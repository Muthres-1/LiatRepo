<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/home/training/contracts/utilities/Curve.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {</span>
   5 |     | <span class='neutral'>  _spacing_,</span>
   6 |     | <span class='neutral'>  getCurveLength,</span>
   7 |     | <span class='neutral'>  setLogPriceCurrent,</span>
   8 |     | <span class='neutral'>  setCurveLength</span>
   9 |     | <span class='neutral'>} from &quot;./Memory.sol&quot;;</span>
  10 |     | <span class='neutral'>import {</span>
  11 |     | <span class='neutral'>  Index,</span>
  12 |     | <span class='neutral'>  zeroIndex,</span>
  13 |     | <span class='neutral'>  oneIndex,</span>
  14 |     | <span class='neutral'>  twoIndex,</span>
  15 |     | <span class='neutral'>  maxCurveIndex</span>
  16 |     | <span class='neutral'>} from &quot;./Index.sol&quot;;</span>
  17 |     | <span class='neutral'>import {PriceLibrary} from &quot;./Price.sol&quot;;</span>
  18 |     | <span class='neutral'>import {</span>
  19 |     | <span class='neutral'>  X59,</span>
  20 |     | <span class='neutral'>  min,</span>
  21 |     | <span class='neutral'>  max,</span>
  22 |     | <span class='neutral'>  zeroX59,</span>
  23 |     | <span class='neutral'>  thirtyTwoX59,</span>
  24 |     | <span class='neutral'>  minLogSpacing</span>
  25 |     | <span class='neutral'>} from &quot;./X59.sol&quot;;</span>
  26 |     | <span class='neutral'>import {</span>
  27 |     | <span class='neutral'>  LogSpacingIsTooSmall,</span>
  28 |     | <span class='neutral'>  BlankIntervalsShouldBeAvoided,</span>
  29 |     | <span class='neutral'>  InvalidCurveArrangement,</span>
  30 |     | <span class='neutral'>  CurveIndexOutOfRange</span>
  31 |     | <span class='neutral'>} from &quot;./Errors.sol&quot;;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>// The curve sequence comprises 64 bit logarithmic prices in the form of</span>
  34 |     | <span class='neutral'>//</span>
  35 |     | <span class='neutral'>//  &#39;(2 ** 59) * (16 + qHistorical)&#39;</span>
  36 |     | <span class='neutral'>//</span>
  37 |     | <span class='neutral'>// where</span>
  38 |     | <span class='neutral'>//</span>
  39 |     | <span class='neutral'>//  &#39;qHistorical := log(pHistorical / pOffset)&#39;.</span>
  40 |     | <span class='neutral'>//</span>
  41 |     | <span class='neutral'>// Hence, each slot of the curve sequence consists of up to four members. The</span>
  42 |     | <span class='neutral'>// curve sequence should have at least two members. The first and the second</span>
  43 |     | <span class='neutral'>// members are &#39;qLower&#39; and &#39;qUpper&#39; (i.e., boundaries of the active liquidity</span>
  44 |     | <span class='neutral'>// interval) with the order depending on the pool&#39;s history. The last member is</span>
  45 |     | <span class='neutral'>// always &#39;qCurrent&#39;. Consider the following curve sequence:</span>
  46 |     | <span class='neutral'>// </span>
  47 |     | <span class='neutral'>//  &#39;q[0], q[1], q[2], ..., q[l - 1]&#39;</span>
  48 |     | <span class='neutral'>//</span>
  49 |     | <span class='neutral'>// where &#39;l&#39; is the number of members. In order for the above sequence to be</span>
  50 |     | <span class='neutral'>// considered valid, we should have:</span>
  51 |     | <span class='neutral'>//</span>
  52 |     | <span class='neutral'>//  &#39;min(q[i - 1], q[i - 2]) &lt; q[i] &lt; max(q[i - 1], q[i - 2])&#39;.</span>
  53 |     | <span class='neutral'>//</span>
  54 |     | <span class='neutral'>// This ordering rule is verified upon initialization of any pool and it is</span>
  55 |     | <span class='neutral'>// preserved by each amendment to the curve sequence.</span>
  56 |     | <span class='neutral'>type Curve is uint256;</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>using PriceLibrary for uint16;</span>
  59 |     | <span class='neutral'>using CurveLibrary for Curve global;</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>library CurveLibrary {</span>
  62 |     | <span class='neutral'>  /// @notice Returns the member of the curve sequence corresponding to the</span>
  63 |     | <span class='neutral'>  /// given index.</span>
  64 |     | <span class='neutral'>  ///</span>
  65 |     | <span class='neutral'>  /// Index out-of-range should be avoided externally.</span>
  66 |     | <span class='unexecuted'>  function member(</span>
  67 |     | <span class='neutral'>    Curve curve,</span>
  68 |     | <span class='neutral'>    Index index</span>
  69 |     | <span class='neutral'>  ) internal pure returns (</span>
  70 |     | <span class='unexecuted'>    X59 q</span>
  71 |     | <span class='neutral'>  ) {</span>
  72 |     | <span class='neutral'>    assembly {</span>
  73 |     | <span class='neutral'>      // Each member of the curve sequence is &#39;64 bits == 8 bytes&#39; which is why</span>
  74 |     | <span class='neutral'>      // we are shifting index by &#39;3&#39; bits (i.e., we are multiplying index by</span>
  75 |     | <span class='neutral'>      // &#39;8 == 2 ** 3&#39;). We load the memory slot whose most significant 64 bits</span>
  76 |     | <span class='neutral'>      // host the member that we are interested in. Then, we shift the content</span>
  77 |     | <span class='neutral'>      // by 192 bits to the right in order to discard the remaining bits.</span>
  78 |     | <span class='neutral'>      //</span>
  79 |     | <span class='neutral'>      //       ----------------------------------------------------</span>
  80 |     | <span class='neutral'>      //       | 64 bit member to be loaded | 192 additional bits |</span>
  81 |     | <span class='neutral'>      //       +---------------------------------------------------</span>
  82 |     | <span class='neutral'>      //       |</span>
  83 |     | <span class='neutral'>      //    pointer == curve + (index &lt;&lt; 3)</span>
  84 |     | <span class='neutral'>      //</span>
  85 |     | <span class='neutral'>      // The addition is safe because index out-of-range is avoided externally.</span>
  86 |     | <span class='unexecuted'>      q := shr(192, mload(add(curve, shl(3, index))))</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'>  }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>  /// @notice Returns the leftmost and rightmost members of the curve sequence.</span>
  91 |     | <span class='neutral'>  function boundaries(</span>
  92 |     | <span class='neutral'>    Curve curve</span>
  93 |     | <span class='neutral'>  ) internal pure returns (</span>
  94 |     | <span class='neutral'>    X59 qLower,</span>
  95 |     | <span class='neutral'>    X59 qUpper</span>
  96 |     | <span class='neutral'>  ) {</span>
  97 |     | <span class='neutral'>    // The first and the second members of the curve sequence are loaded.</span>
  98 |     | <span class='neutral'>    // Index-out-of-range is not possible because the curve sequence has at</span>
  99 |     | <span class='neutral'>    // least two members.</span>
 100 |     | <span class='neutral'>    qLower = curve.member(zeroIndex);</span>
 101 |     | <span class='neutral'>    qUpper = curve.member(oneIndex);</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    // The two boundaries are arranged in order.</span>
 104 |     | <span class='neutral'>    //</span>
 105 |     | <span class='neutral'>    // Signed comparison is valid because both values are nonnegative and </span>
 106 |     | <span class='neutral'>    // do not exceed &#39;2 ** 64&#39; since each one is loaded from 64 bits of memory.</span>
 107 |     | <span class='neutral'>    (qLower, qUpper) = (qUpper &lt;= qLower) ? </span>
 108 |     | <span class='neutral'>                       (qUpper, qLower) : </span>
 109 |     | <span class='neutral'>                       (qLower, qUpper);</span>
 110 |     | <span class='neutral'>  }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>  /// @notice Validates an initial curve provided by the pool creator.</span>
 113 |     | <span class='neutral'>  function validate(</span>
 114 |     | <span class='neutral'>    Curve curve</span>
 115 |     | <span class='neutral'>  ) internal pure returns (</span>
 116 |     | <span class='neutral'>    X59 qLower,</span>
 117 |     | <span class='neutral'>    X59 qUpper</span>
 118 |     | <span class='neutral'>  ) {</span>
 119 |     | <span class='neutral'>    // The first and the second members of the curve sequence to be verified</span>
 120 |     | <span class='neutral'>    // are loaded. The curve sequence is read from an &#39;uint256[]&#39; calldata</span>
 121 |     | <span class='neutral'>    // array, whose length is non-zero due to the custom error</span>
 122 |     | <span class='neutral'>    // &#39;CurveLengthIsZero()&#39;. Hence, index out of range is not possible at this</span>
 123 |     | <span class='neutral'>    // point.</span>
 124 |     | <span class='neutral'>    X59 q0 = curve.member(zeroIndex);</span>
 125 |     | <span class='neutral'>    X59 q1 = curve.member(oneIndex);</span>
 126 |     | <span class='neutral'>    </span>
 127 |     | <span class='neutral'>    // The output of &#39;member&#39; is always non-negative and never exceeds </span>
 128 |     | <span class='neutral'>    // &#39;2 ** 64&#39; (read from 64 bits of memory). Hence, signed comparison is</span>
 129 |     | <span class='neutral'>    // valid.</span>
 130 |     | <span class='neutral'>    (qLower, qUpper) = (q0 &lt;= q1) ? (q0, q1) : (q1, q0);</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    // Underflow is not possible due to the above rearrangement of &#39;qLower&#39; and</span>
 133 |     | <span class='neutral'>    // &#39;qUpper&#39;.</span>
 134 |     | <span class='neutral'>    X59 qSpacing = qUpper - qLower;</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    // This is a one time calculation of &#39;sqrtSpacing&#39; and </span>
 137 |     | <span class='neutral'>    // &#39;sqrtInverseSpacing&#39;. They will be used later for swaps.</span>
 138 |     | <span class='neutral'>    _spacing_.storePrice(qSpacing);</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    // Since both sides are non-negative and less than &#39;2 ** 64&#39;, all three </span>
 141 |     | <span class='neutral'>    // signed comparisons are valid.</span>
 142 |     | <span class='neutral'>    require(qSpacing &gt;= minLogSpacing, LogSpacingIsTooSmall(qSpacing));</span>
 143 |     | <span class='neutral'>    require(</span>
 144 |     | <span class='neutral'>      qLower &gt; qSpacing,</span>
 145 |     | <span class='neutral'>      BlankIntervalsShouldBeAvoided(qLower, qUpper)</span>
 146 |     | <span class='neutral'>    );</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    // Underflow is not possible because &#39;qSpacing&#39; does not exceed &#39;64&#39; bits.</span>
 149 |     | <span class='neutral'>    // Hence, &#39;qSpacing &lt;= (2 ** 64) - 1 &lt; thirtyTwoX59&#39;.</span>
 150 |     | <span class='neutral'>    require(</span>
 151 |     | <span class='neutral'>      qUpper &lt; thirtyTwoX59 - qSpacing,</span>
 152 |     | <span class='neutral'>      BlankIntervalsShouldBeAvoided(qLower, qUpper)</span>
 153 |     | <span class='neutral'>    );</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    Index length = twoIndex;</span>
 156 |     | <span class='neutral'>    while (true) {</span>
 157 |     | <span class='neutral'>      // This may be an out-of-range access which is intentional, because we</span>
 158 |     | <span class='neutral'>      // break before using &#39;q2&#39; if &#39;length&#39; is out of range.</span>
 159 |     | <span class='neutral'>      X59 q2 = curve.member(length);</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>      // During initialization of a pool, the provided &#39;curve&#39; is always</span>
 162 |     | <span class='neutral'>      // followed by at least &#39;64&#39; bits of &#39;0&#39;. Hence, this indicates that we</span>
 163 |     | <span class='neutral'>      // have reached the end of the curve.</span>
 164 |     | <span class='neutral'>      if (q2 == zeroX59) break;</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>      // Here, we are checking the requirement:</span>
 167 |     | <span class='neutral'>      //</span>
 168 |     | <span class='neutral'>      //  &#39;min(q0, q1) &lt; q2 &lt; max(q0, q1)&#39;</span>
 169 |     | <span class='neutral'>      //</span>
 170 |     | <span class='neutral'>      // The output of &#39;member&#39; is always non-negative and never exceeds 64</span>
 171 |     | <span class='neutral'>      // bits (loaded from 64 bits of memory). Hence signed comparisons are</span>
 172 |     | <span class='neutral'>      // valid.</span>
 173 |     | <span class='neutral'>      if ((q2 &lt;= q0) || (q1 &lt;= q2)) {</span>
 174 |     | <span class='neutral'>        if ((q2 &lt;= q1) || (q0 &lt;= q2)) {</span>
 175 |     | <span class='neutral'>          revert InvalidCurveArrangement(q0, q1, q2);</span>
 176 |     | <span class='neutral'>        }</span>
 177 |     | <span class='neutral'>      }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>      // The two most recent members are shifted so that a new member can be</span>
 180 |     | <span class='neutral'>      // loaded as &#39;q2&#39;.</span>
 181 |     | <span class='neutral'>      q0 = q1;</span>
 182 |     | <span class='neutral'>      q1 = q2;</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>      // This addition is safe and never exceeds the &#39;2 ** 256 - 1&#39; limit.</span>
 185 |     | <span class='neutral'>      length = length + oneIndex;</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    // The length of the given curve should not exceed &#39;maxCurveIndex&#39;.</span>
 189 |     | <span class='neutral'>    require(length &lt;= maxCurveIndex, CurveIndexOutOfRange(length));</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    // &#39;q1&#39; is the last valid member of the curve and therefore, it is set in</span>
 192 |     | <span class='neutral'>    // memory as &#39;qCurrent&#39;.</span>
 193 |     | <span class='neutral'>    setLogPriceCurrent(q1);</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    // The &#39;length&#39; of the curve is stored in its appropriate memory location.</span>
 196 |     | <span class='neutral'>    // Due to the above check, this value is less than &#39;2 ** 16&#39; and can be</span>
 197 |     | <span class='neutral'>    // safely stored in the allocated 2 bytes of memory space.</span>
 198 |     | <span class='neutral'>    setCurveLength(length);</span>
 199 |     | <span class='neutral'>  }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>  /// @notice Generates a new curve with two members and stores its memory</span>
 202 |     | <span class='neutral'>  /// pointer in the appropriate memory location.</span>
 203 |     | <span class='neutral'>  ///</span>
 204 |     | <span class='neutral'>  /// &#39;qCurrent&#39; and &#39;qOther&#39; should be positive and smaller than </span>
 205 |     | <span class='neutral'>  /// &#39;thirtyTwoX59&#39;.</span>
 206 |     | <span class='neutral'>  function newCurve(</span>
 207 |     | <span class='neutral'>    Curve curve,</span>
 208 |     | <span class='neutral'>    X59 qCurrent,</span>
 209 |     | <span class='neutral'>    X59 qOther</span>
 210 |     | <span class='neutral'>  ) internal pure {</span>
 211 |     | <span class='neutral'>    assembly {</span>
 212 |     | <span class='neutral'>      mstore(</span>
 213 |     | <span class='neutral'>        curve,</span>
 214 |     | <span class='neutral'>        or(</span>
 215 |     | <span class='neutral'>          // &#39;qOther&#39; is written in the first place.</span>
 216 |     | <span class='neutral'>          shl(192, qOther),</span>
 217 |     | <span class='neutral'>          // &#39;qCurrent&#39; is written in the second place.</span>
 218 |     | <span class='neutral'>          shl(128, qCurrent)</span>
 219 |     | <span class='neutral'>        )</span>
 220 |     | <span class='neutral'>      )</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    // The new length is stored in the allocated memory location.</span>
 224 |     | <span class='neutral'>    setCurveLength(twoIndex);</span>
 225 |     | <span class='neutral'>  }</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='neutral'>  /// @notice Amends the curve by adding a new member.</span>
 228 |     | <span class='neutral'>  /// @param q is the given logarithmic price to be added to the curve</span>
 229 |     | <span class='neutral'>  /// sequence.</span>
 230 |     | <span class='neutral'>  /// &#39;q&#39; must be positive and less than &#39;2 ** 64&#39;.</span>
 231 |     | <span class='neutral'>  function amend(</span>
 232 |     | <span class='neutral'>    Curve curve,</span>
 233 |     | <span class='neutral'>    X59 q</span>
 234 |     | <span class='neutral'>  ) internal pure {</span>
 235 |     | <span class='neutral'>    // The first and second members of the curve are loaded.</span>
 236 |     | <span class='neutral'>    // Index out of range is not possible because the curve has at least two </span>
 237 |     | <span class='neutral'>    // members.</span>
 238 |     | <span class='neutral'>    X59 q0 = curve.member(zeroIndex);</span>
 239 |     | <span class='neutral'>    X59 q1 = curve.member(oneIndex);</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='neutral'>    // If &#39;q&#39; is not within the current active interval, then a new curve</span>
 242 |     | <span class='neutral'>    // sequence is constructed. Signed comparison is valid because &#39;q0&#39;, &#39;q1&#39;,</span>
 243 |     | <span class='neutral'>    // and &#39;q&#39; are nonnegative and do not exceed 64 bits.</span>
 244 |     | <span class='neutral'>    if (q &lt;= min(q0, q1)) {</span>
 245 |     | <span class='neutral'>      newCurve(curve, min(q0, q1), max(q0, q1));</span>
 246 |     | <span class='neutral'>      return;</span>
 247 |     | <span class='neutral'>    }</span>
 248 |     | <span class='neutral'>    if (max(q0, q1) &lt;= q) {</span>
 249 |     | <span class='neutral'>      newCurve(curve, max(q0, q1), min(q0, q1));</span>
 250 |     | <span class='neutral'>      return;</span>
 251 |     | <span class='neutral'>    }</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='neutral'>    // The length of the curve is loaded from the memory.</span>
 254 |     | <span class='neutral'>    Index length = getCurveLength();</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>    // Every member of the curve is exhausted until either the following rule</span>
 257 |     | <span class='neutral'>    // is violated or runs out of members:</span>
 258 |     | <span class='neutral'>    //</span>
 259 |     | <span class='neutral'>    // &#39;min(q[k - 1], q[k - 2]) &lt; q[k] &lt; max(q[k - 1], q[k - 2])&#39;.</span>
 260 |     | <span class='neutral'>    //</span>
 261 |     | <span class='neutral'>    // Then, &#39;q&#39; is written in the corresponding place and the rest of that</span>
 262 |     | <span class='neutral'>    // slot is cleared.</span>
 263 |     | <span class='neutral'>    Index index = oneIndex;</span>
 264 |     | <span class='neutral'>    while (true) {</span>
 265 |     | <span class='neutral'>      // Is &#39;q&#39; between &#39;q0&#39; and &#39;q1&#39;? If so, we proceed forward, otherwise,</span>
 266 |     | <span class='neutral'>      // &#39;q&#39; is written in place of &#39;q1&#39; and the rest of that slot is cleared.</span>
 267 |     | <span class='neutral'>      // Signed comparisons are valid because &#39;q0&#39;, &#39;q1&#39;, and &#39;q&#39; are</span>
 268 |     | <span class='neutral'>      // non-negative and do not exceed 64 bits.</span>
 269 |     | <span class='neutral'>      if ((q0 &lt; q1) ? (q &lt; q1) : (q1 &lt; q)) {</span>
 270 |     | <span class='neutral'>        // This addition is safe and never exceeds the &#39;2 ** 256 - 1&#39; limit.</span>
 271 |     | <span class='neutral'>        index = index + oneIndex;</span>
 272 |     | <span class='neutral'>        q0 = q1;</span>
 273 |     | <span class='neutral'>        if (index &lt; length) {</span>
 274 |     | <span class='neutral'>          // Index out-of-range is not possible due to the above check.</span>
 275 |     | <span class='neutral'>          q1 = curve.member(index);</span>
 276 |     | <span class='neutral'>        } else {</span>
 277 |     | <span class='neutral'>          break;</span>
 278 |     | <span class='neutral'>        }</span>
 279 |     | <span class='neutral'>      } else {</span>
 280 |     | <span class='neutral'>        break;</span>
 281 |     | <span class='neutral'>      }</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>    // &#39;q&#39; is added to the end.</span>
 285 |     | <span class='neutral'>    // This is not an out-of-range addition because one additional slot is</span>
 286 |     | <span class='neutral'>    // always reserved for the amendment of the curve. A maximum of 2</span>
 287 |     | <span class='neutral'>    // amendments occur per swap.</span>
 288 |     | <span class='neutral'>    assembly {</span>
 289 |     | <span class='neutral'>      mstore(add(curve, shl(3, index)), shl(192, q))</span>
 290 |     | <span class='neutral'>    }</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>    // &#39;index + oneIndex&#39; must not exceed &#39;maxIndex&#39;.</span>
 293 |     | <span class='neutral'>    require(index &lt; maxCurveIndex, CurveIndexOutOfRange(index));</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    // Lastly, &#39;curveLength&#39; is updated.</span>
 296 |     | <span class='neutral'>    // Due to the above check, this value is less than &#39;2 ** 16&#39; and can be</span>
 297 |     | <span class='neutral'>    // safely stored in the allocated 2 bytes of memory space.</span>
 298 |     | <span class='neutral'>    setCurveLength(index + oneIndex);</span>
 299 |     | <span class='neutral'>  }</span>
 300 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/Errors.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {Index} from &quot;./Index.sol&quot;;</span>
   5 |     | <span class='neutral'>import {X15} from &quot;./X15.sol&quot;;</span>
   6 |     | <span class='neutral'>import {X47} from &quot;./X47.sol&quot;;</span>
   7 |     | <span class='neutral'>import {X59} from &quot;./X59.sol&quot;;</span>
   8 |     | <span class='neutral'>import {X111} from &quot;./X111.sol&quot;;</span>
   9 |     | <span class='neutral'>import {X127} from &quot;./X127.sol&quot;;</span>
  10 |     | <span class='neutral'>import {X208} from &quot;./X208.sol&quot;;</span>
  11 |     | <span class='neutral'>import {X216} from &quot;./X216.sol&quot;;</span>
  12 |     | <span class='neutral'>import {Tag} from &quot;./Tag.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>/// @notice Thrown in case of overflow when attempting to calculate</span>
  15 |     | <span class='neutral'>/// &#39;(a * b) / denominator&#39;.</span>
  16 |     | <span class='neutral'>error MulDivOverflow(uint256 a, uint256 b, uint256 denominator);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>/// @notice Thrown in case of overflow or underflow when attempting to</span>
  19 |     | <span class='neutral'>/// calculate &#39;a + b&#39;.</span>
  20 |     | <span class='neutral'>error SafeAddFailed(X127 a, X127 b);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>/// @notice Thrown when balance exceeds &#39;type(uint128).max&#39;.</span>
  23 |     | <span class='neutral'>error BalanceOverflow(uint256 balance);</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>/// @notice Thrown when safe cast into an int256 overflows.</span>
  26 |     | <span class='neutral'>error SafeCastOverflow(uint256 value);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>/// @notice Thrown when the given &#39;qSpacing&#39; is less than &#39;minLogSpacing&#39;.</span>
  29 |     | <span class='neutral'>error LogSpacingIsTooSmall(X59 qSpacing);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>/// @notice Thrown when attempting to initialize a curve sequence on blank</span>
  32 |     | <span class='neutral'>/// intervals.</span>
  33 |     | <span class='neutral'>error BlankIntervalsShouldBeAvoided(X59 qLower, X59 qUpper);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>/// @notice Thrown when &#39;curveLength&#39; is zero upon initialization.</span>
  36 |     | <span class='neutral'>error CurveLengthIsZero();</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>/// @notice Each member of the curve sequence should be in-between the</span>
  39 |     | <span class='neutral'>/// preceding two members. Thrown when a given initial curve sequence violates</span>
  40 |     | <span class='neutral'>/// this rule.</span>
  41 |     | <span class='neutral'>error InvalidCurveArrangement(X59 q0, X59 q1, X59 q2);</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>/// @notice Thrown when &#39;curveLength&#39; is out of range.</span>
  44 |     | <span class='neutral'>error CurveIndexOutOfRange(Index length);</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>/// @notice Thrown in case of overflow when attempting to calculate </span>
  47 |     | <span class='neutral'>///</span>
  48 |     | <span class='neutral'>/// &#39;amount := ceiling(</span>
  49 |     | <span class='neutral'>///</span>
  50 |     | <span class='neutral'>///     shares *</span>
  51 |     | <span class='neutral'>///</span>
  52 |     | <span class='neutral'>///     (getZeroForOne() ? sqrtOffset : sqrtInverseOffset) * </span>
  53 |     | <span class='neutral'>///</span>
  54 |     | <span class='neutral'>///      multiplier</span>
  55 |     | <span class='neutral'>///     ------------</span>
  56 |     | <span class='neutral'>///       2 ** 208</span>
  57 |     | <span class='neutral'>///  )&#39;.</span>
  58 |     | <span class='neutral'>error SafeOutOfRangeAmountOverflow(</span>
  59 |     | <span class='neutral'>  X127 sqrtOffsetOrSqrtInverseOffset,</span>
  60 |     | <span class='neutral'>  X208 growthMultiplier,</span>
  61 |     | <span class='neutral'>  int256 shares</span>
  62 |     | <span class='neutral'>);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>/// @notice Thrown in case of overflow when attempting to calculate </span>
  65 |     | <span class='neutral'>///</span>
  66 |     | <span class='neutral'>/// &#39;amount := ceiling(</span>
  67 |     | <span class='neutral'>///</span>
  68 |     | <span class='neutral'>///     (zeroOrOne ? sqrtOffset : sqrtInverseOffset) * </span>
  69 |     | <span class='neutral'>///</span>
  70 |     | <span class='neutral'>///      liquidity      integral</span>
  71 |     | <span class='neutral'>///     ----------- * -------------</span>
  72 |     | <span class='neutral'>///       2 ** 111     outgoingMax</span>
  73 |     | <span class='neutral'>///  )&#39;.</span>
  74 |     | <span class='neutral'>error SafeInRangeAmountOverflow(</span>
  75 |     | <span class='neutral'>  X127 sqrtOffsetOrSqrtInverseOffset,</span>
  76 |     | <span class='neutral'>  X216 integral,</span>
  77 |     | <span class='neutral'>  X111 liquidity,</span>
  78 |     | <span class='neutral'>  X216 outgoingMax,</span>
  79 |     | <span class='neutral'>  uint256 outgoingMaxModularInverse</span>
  80 |     | <span class='neutral'>);</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>/// @notice Thrown when the second horizontal coordinate of a given kernel is</span>
  83 |     | <span class='neutral'>/// &#39;0&#39;. In this case, we have a vertical jump at the origin which limits</span>
  84 |     | <span class='neutral'>/// liquidity growth.</span>
  85 |     | <span class='neutral'>error SecondHorizontalCoordinateIsZero();</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>/// @notice The horizontal coordinates should be monotonically non-decreasing.</span>
  88 |     | <span class='neutral'>error NonMonotonicHorizontalCoordinates(X59 q_i, X59 q_j);</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>/// @notice The vertical coordinates should be monotonically non-decreasing.</span>
  91 |     | <span class='neutral'>error NonMonotonicVerticalCoordinates(X15 c_i, X15 c_j);</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>/// @notice There should not be repetitive points.</span>
  94 |     | <span class='neutral'>error RepetitiveKernelPoints(X15 c_i, X59 q_i);</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>/// @notice Thrown when the horizontal coordinates of a non-vertical and </span>
  97 |     | <span class='neutral'>/// non-horizontal segment are closer than &#39;2 ** 32&#39;.</span>
  98 |     | <span class='neutral'>error SlopeTooHigh(X59 q_i, X59 q_j);</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>/// @notice Thrown when the horizontal coordinates of a given &#39;kernelCompact&#39;</span>
 101 |     | <span class='neutral'>/// exceeds &#39;qSpacing&#39;.</span>
 102 |     | <span class='neutral'>error HorizontalCoordinatesMayNotExceedLogSpacing(X59 q_j, X59 qSpacing);</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>/// @notice There should not be three repetitive horizontal coordinates. A </span>
 105 |     | <span class='neutral'>/// vertical jump (i.e., discontinuity) is permitted and can be constructed</span>
 106 |     | <span class='neutral'>/// via two repetitive horizontal coordinates. However, three repetitive</span>
 107 |     | <span class='neutral'>/// horizontal coordinates are always redundant and should be avoided.</span>
 108 |     | <span class='neutral'>error RepetitiveHorizontalCoordinates(X59 q_i);</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>/// @notice There should not be three repetitive vertical coordinates. A </span>
 111 |     | <span class='neutral'>/// horizontal segment (i.e., constant range) is permitted and can be </span>
 112 |     | <span class='neutral'>/// constructed via two repetitive vertical coordinates. However, three</span>
 113 |     | <span class='neutral'>/// repetitive vertical coordinates are always redundant and should be</span>
 114 |     | <span class='neutral'>/// avoided.</span>
 115 |     | <span class='neutral'>error RepetitiveVerticalCoordinates(X15 c_i);</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>/// @notice Thrown when &#39;kernelLength&#39; is out of range.</span>
 118 |     | <span class='neutral'>error KernelIndexOutOfRange(Index length);</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>/// @notice The last vertical coordinate should be equal to &#39;oneX15&#39;.</span>
 121 |     | <span class='neutral'>error LastVerticalCoordinateMismatch(X15 c_j);</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>/// @notice Thrown when growth exceeds maximum permitted value of &#39;maxGrowth&#39;.</span>
 124 |     | <span class='neutral'>error GrowthOverflow();</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>/// @notice Thrown when accrued growth portion values exceed &#39;2 ** 104 - 1&#39;.</span>
 127 |     | <span class='neutral'>error AccruedGrowthPortionOverflow(X127 accruedValue);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>/// @notice Thrown when given flags are invalid or not consistent with hook.</span>
 130 |     | <span class='neutral'>error InvalidFlags(uint256);</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>/// @notice Thrown when the numerical search for outgoing target fails which </span>
 133 |     | <span class='neutral'>/// should never heappen.</span>
 134 |     | <span class='neutral'>error SearchingForOutgoingTargetFailed();</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>/// @notice Thrown when the numerical search for incoming target fails which</span>
 137 |     | <span class='neutral'>/// should never heappen.</span>
 138 |     | <span class='neutral'>error SearchingForIncomingTargetFailed();</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>/// @notice Thrown when the numerical search for overshoot fails which should</span>
 141 |     | <span class='neutral'>/// never heappen.</span>
 142 |     | <span class='neutral'>error SearchingForOvershootFailed();</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>/// @notice Thrown if attempting to unlock the protocol while already unlocked.</span>
 145 |     | <span class='neutral'>error AlreadyUnlocked(address currentCaller);</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>/// @notice Thrown when any of the following methods are invoked prior to the</span>
 148 |     | <span class='neutral'>/// protocol being unlocked:</span>
 149 |     | <span class='neutral'>///</span>
 150 |     | <span class='neutral'>///   &#39;INofeeswap.clear&#39;</span>
 151 |     | <span class='neutral'>///   &#39;INofeeswap.take&#39;</span>
 152 |     | <span class='neutral'>///   &#39;INofeeswap.settle&#39;</span>
 153 |     | <span class='neutral'>///   &#39;INofeeswap.transferTransientBalanceFrom&#39;</span>
 154 |     | <span class='neutral'>///   &#39;INofeeswap.modifyBalance&#39;</span>
 155 |     | <span class='neutral'>///   &#39;INofeeswap.swap&#39;</span>
 156 |     | <span class='neutral'>///   &#39;INofeeswapDelegatee.modifyPosition&#39;</span>
 157 |     | <span class='neutral'>///   &#39;INofeeswapDelegatee.donate&#39;</span>
 158 |     | <span class='neutral'>///</span>
 159 |     | <span class='neutral'>error ProtocolIsLocked();</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>/// @notice Thrown when attempting to perform the following operations on a </span>
 162 |     | <span class='neutral'>/// pool which is locked:</span>
 163 |     | <span class='neutral'>///</span>
 164 |     | <span class='neutral'>///   &#39;INofeeswap.swap&#39;</span>
 165 |     | <span class='neutral'>///   &#39;INofeeswapDelegatee.modifyPosition&#39;</span>
 166 |     | <span class='neutral'>///   &#39;INofeeswapDelegatee.donate&#39;</span>
 167 |     | <span class='neutral'>///   &#39;INofeeswapDelegatee.modifyKernel&#39;</span>
 168 |     | <span class='neutral'>///   &#39;INofeeswapDelegatee.modifyPoolGrowthPortion&#39;</span>
 169 |     | <span class='neutral'>///   &#39;INofeeswapDelegatee.updateGrowthPortions&#39;</span>
 170 |     | <span class='neutral'>///   &#39;INofeeswapDelegatee.collectPool&#39;</span>
 171 |     | <span class='neutral'>///   &#39;INofeeswapDelegatee.collectProtocol&#39;</span>
 172 |     | <span class='neutral'>///</span>
 173 |     | <span class='neutral'>error PoolIsLocked(uint256 poolId);</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>/// @notice Thrown when the deployment of static parameters fail.</span>
 176 |     | <span class='neutral'>error DeploymentFailed();</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>/// @notice Thrown when the method &#39;redeployStaticParamsAndKernel&#39; is run</span>
 179 |     | <span class='neutral'>/// externally.</span>
 180 |     | <span class='neutral'>error CannotRedeployStaticParamsAndKernelExternally();</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>/// @notice Thrown when attempting to sync protocol&#39;s reserve of native token.</span>
 183 |     | <span class='neutral'>error NativeTokenCannotBeSynced();</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>/// @notice Thrown when the spender allowance for a tag is insufficient.</span>
 186 |     | <span class='neutral'>error InsufficientPermission(address spender, Tag tag);</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>/// @notice Thrown when the total number of shares accross all liquidity</span>
 189 |     | <span class='neutral'>/// intervals exceed &#39;2 ** 127 - 1&#39;.</span>
 190 |     | <span class='neutral'>error SharesGrossOverflow(int256 sharesGross);</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>/// @notice Thrown when attempting to access a pool which does not exist.</span>
 193 |     | <span class='neutral'>error PoolDoesNotExist(uint256 poolId);</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>/// @notice Thrown when the owner balance for a tag is insufficient.</span>
 196 |     | <span class='neutral'>error InsufficientBalance(address owner, Tag tag);</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>/// @notice Throws when Sentinel response is invalid.</span>
 199 |     | <span class='neutral'>error InvalidSentinelResponse(bytes4 response);</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>/// @notice Thrown when the given &#39;zeroForOne&#39; is not in agreement with </span>
 202 |     | <span class='neutral'>/// &#39;logPriceLimitOffsetted&#39;.</span>
 203 |     | <span class='neutral'>error InvalidDirection(X59 current, X59 limit);</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>/// @notice Thrown when attempting to initialize a pool that already exists.</span>
 206 |     | <span class='neutral'>error PoolExists(uint256 poolId);</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>/// @notice Thrown when &#39;log(pOffset)&#39; is not within the range &#39;[-89, +89]&#39;.</span>
 209 |     | <span class='neutral'>error LogOffsetOutOfRange(X59 qOffset);</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>/// @notice Thrown when the given tags are not in the correct order, i.e.,</span>
 212 |     | <span class='neutral'>/// &#39;tag0 &lt; tag1&#39;.</span>
 213 |     | <span class='neutral'>error TagsOutOfOrder(Tag tag0, Tag tag1);</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>/// @notice Thrown when a given growth portion is greater than one.</span>
 216 |     | <span class='neutral'>error InvalidGrowthPortion(X47 poolGrowthPortion);</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>/// @notice Thrown when a given logarithmic price does not belong to the range</span>
 219 |     | <span class='neutral'>/// &#39;[log(pOffset) - 16 + 1 / (2 ** 59), log(pOffset) + 16 - 1 / (2 ** 59)]&#39;.</span>
 220 |     | <span class='neutral'>error LogPriceOutOfRange(X59 logPrice);</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>/// @notice Thrown when attempting to mint/burn a position with zero shares or</span>
 223 |     | <span class='neutral'>/// when the number of shares does not belong to </span>
 224 |     | <span class='neutral'>/// &#39;[- type(int128).max, type(int128).max]&#39;.</span>
 225 |     | <span class='neutral'>error InvalidNumberOfShares(int256 shares);</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='neutral'>/// @notice Thrown when attempting to initialize a pool with &#39;poolId == 0&#39;.</span>
 228 |     | <span class='neutral'>error PoolIdCannotBeZero();</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>/// @notice Thrown when attempting to access protocol operations via an</span>
 231 |     | <span class='neutral'>/// unauthorized address.</span>
 232 |     | <span class='neutral'>error OnlyByProtocol(address attemptingAddress, address protocolAddress);</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>/// @notice Thrown when attempting to access pool operations via an</span>
 235 |     | <span class='neutral'>/// unauthorized address.</span>
 236 |     | <span class='neutral'>error OnlyByPoolOwner(address attemptingAddress, address poolOwnerAddress);</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>/// @notice Thrown when attempting to mint/burn a position with invalid</span>
 239 |     | <span class='neutral'>/// lower bound which is not equal to interval boundaries modulo &#39;qSpacing&#39;.</span>
 240 |     | <span class='neutral'>error LogPriceMinIsNotSpaced(X59 logPriceMin);</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>/// @notice Thrown when attempting to mint/burn a position with invalid</span>
 243 |     | <span class='neutral'>/// upper bound which is not equal to interval boundaries modulo &#39;qSpacing&#39;.</span>
 244 |     | <span class='neutral'>error LogPriceMaxIsNotSpaced(X59 logPriceMax);</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='neutral'>/// @notice Thrown when attempting to mint/burn a position with invalid</span>
 247 |     | <span class='neutral'>/// lower bound which is not greater than &#39;qSpacing&#39;</span>
 248 |     | <span class='neutral'>error LogPriceMinIsInBlankArea(X59 logPriceMin);</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>/// @notice Thrown when attempting to mint/burn a position with invalid</span>
 251 |     | <span class='neutral'>/// lower bound which is not less than &#39;thirtyTwoX59 - qSpacing&#39;.</span>
 252 |     | <span class='neutral'>error LogPriceMaxIsInBlankArea(X59 logPriceMax);</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>/// @notice Thrown when the given logPrices for a position are not in the</span>
 255 |     | <span class='neutral'>/// correct order.</span>
 256 |     | <span class='neutral'>error LogPricesOutOfOrder(X59 logPriceMin, X59 logPriceMax);</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='neutral'>/// @notice Thrown when attempting donate to a pool whose donate flag is not </span>
 259 |     | <span class='neutral'>/// active.</span>
 260 |     | <span class='neutral'>error DonateIsNotAllowed(uint256 poolId);</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>/// @notice Thrown when attempting to perform a donate to an empty interval.</span>
 263 |     | <span class='neutral'>error CannotDonateToEmptyInterval();</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='neutral'>/// @notice Thrown when attempting to change an immutable kernel.</span>
 266 |     | <span class='neutral'>error ImmutableKernel(uint256 poolId);</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>/// @notice Thrown when attempting to change an immutable poolGrowthPortion.</span>
 269 |     | <span class='neutral'>error ImmutablePoolGrowthPortion(uint256 poolId);</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='neutral'>/// @notice Thrown when attempting to make a delegate call to the protocol.</span>
 272 |     | <span class='neutral'>error NoDelegateCall(address context);</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>/// @notice Thrown when transient balances are not cleared.</span>
 275 |     | <span class='neutral'>error OutstandingAmount();</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='neutral'>/// @notice Thrown when attempting to transfer NofeeAssets to address 0.</span>
 278 |     | <span class='neutral'>error CannotTransferToAddressZero();</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>/// @notice Thrown when the amount to be cleared is not equal to the transient</span>
 281 |     | <span class='neutral'>/// balance of &#39;msg.sender&#39;.</span>
 282 |     | <span class='neutral'>error NotEqualToTransientBalance(int256 currentBalance);</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>/// @notice Thrown when the size of &#39;hookData&#39; exceeds &#39;type(uint16).max&#39;.</span>
 285 |     | <span class='neutral'>error HookDataTooLong(uint256 hookDataByteCount);</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='neutral'>/// @notice Thrown when attempting to transfer ownership to address 0.</span>
 288 |     | <span class='neutral'>error AdminCannotBeAddressZero();</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='neutral'>/// @notice Thrown when attempting to settle a tag with nonzero &#39;msg.value&#39;.</span>
 291 |     | <span class='neutral'>error MsgValueIsNonZero(uint256 msgValue);</span>
 292 |     | <span class='neutral'></span>
 293 |     | <span class='neutral'>/// @notice Thrown when attempting to mint a position after burning it in the</span>
 294 |     | <span class='neutral'>/// same transaction.</span>
 295 |     | <span class='neutral'>error CannotMintAfterBurning(uint256 poolId, X59 qMin, X59 qMax);</span>

</code>
<br />

<b>/home/training/contracts/utilities/FullMath.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {MulDivOverflow} from &quot;./Errors.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @title Contains 512-bit multiplication and division functions</span>
   7 |     | <span class='neutral'>/// Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv</span>
   8 |     | <span class='neutral'>/// for several functions in this library.</span>
   9 |     | <span class='unexecuted'>library FullMathLibrary {</span>
  10 |     | <span class='neutral'>  ///                           _____   _____   _____</span>
  11 |     | <span class='neutral'>  /// @notice 512-bit addition &#39;r1 r0 = a1 a0 + b1 b0&#39;.</span>
  12 |     | <span class='neutral'>  /// Overflow should be avoided externally.</span>
  13 |     | <span class='neutral'>  /// @param a0 Least significant 256 bits of the first number.</span>
  14 |     | <span class='neutral'>  /// @param a1 Most significant 256 bits of the first number.</span>
  15 |     | <span class='neutral'>  /// @param b0 Least significant 256 bits of the second number.</span>
  16 |     | <span class='neutral'>  /// @param b1 Most significant 256 bits of the second number.</span>
  17 |     | <span class='neutral'>  /// @return r0 Least significant 256 bits of the addition.</span>
  18 |     | <span class='neutral'>  /// @return r1 Most significant 256 bits of the addition.</span>
  19 |     | <span class='neutral'>  function add512(</span>
  20 |     | <span class='neutral'>    uint256 a0,</span>
  21 |     | <span class='neutral'>    uint256 a1,</span>
  22 |     | <span class='neutral'>    uint256 b0,</span>
  23 |     | <span class='neutral'>    uint256 b1</span>
  24 |     | <span class='neutral'>  ) internal pure returns (</span>
  25 |     | <span class='neutral'>    uint256 r0,</span>
  26 |     | <span class='neutral'>    uint256 r1</span>
  27 |     | <span class='neutral'>  ) {</span>
  28 |     | <span class='neutral'>    //      s0</span>
  29 |     | <span class='neutral'>    //      a1 a0</span>
  30 |     | <span class='neutral'>    // +    b1 b0</span>
  31 |     | <span class='neutral'>    // -----------</span>
  32 |     | <span class='neutral'>    //      r1 r0</span>
  33 |     | <span class='neutral'>    //</span>
  34 |     | <span class='neutral'>    // where &#39;s0 := lt(r0, a0)&#39;.</span>
  35 |     | <span class='neutral'>    assembly {</span>
  36 |     | <span class='neutral'>      r0 := add(a0, b0)</span>
  37 |     | <span class='neutral'>      r1 := add(</span>
  38 |     | <span class='neutral'>        add(a1, b1),</span>
  39 |     | <span class='neutral'>        // &#39;r0 &lt; a0&#39; indicates that the addition &#39;a0 + b0&#39; has overflowed. In</span>
  40 |     | <span class='neutral'>        // this case &#39;1&#39; needs to be added to the most significant 256 bits of</span>
  41 |     | <span class='neutral'>        // the output.</span>
  42 |     | <span class='neutral'>        lt(r0, a0)</span>
  43 |     | <span class='neutral'>      )</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'>  }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>  ///                              _____   _____   _____</span>
  48 |     | <span class='neutral'>  /// @notice 512-bit subtraction &#39;r1 r0 = a1 a0 - b1 b0&#39;.</span>
  49 |     | <span class='neutral'>  /// Underflow should be avoided externally.</span>
  50 |     | <span class='neutral'>  /// @param a0 Least significant 256 bits of the minuend.</span>
  51 |     | <span class='neutral'>  /// @param a1 Most significant 256 bits of the minuend.</span>
  52 |     | <span class='neutral'>  /// @param b0 Least significant 256 bits of the subtrahend.</span>
  53 |     | <span class='neutral'>  /// @param b1 Most significant 256 bits of the subtrahend.</span>
  54 |     | <span class='neutral'>  /// @return r0 Least significant 256 bits of the subtraction.</span>
  55 |     | <span class='neutral'>  /// @return r1 Most significant 256 bits of the subtraction.</span>
  56 |     | <span class='neutral'>  function sub512(</span>
  57 |     | <span class='neutral'>    uint256 a0,</span>
  58 |     | <span class='neutral'>    uint256 a1,</span>
  59 |     | <span class='neutral'>    uint256 b0,</span>
  60 |     | <span class='neutral'>    uint256 b1</span>
  61 |     | <span class='neutral'>  ) internal pure returns (</span>
  62 |     | <span class='neutral'>    uint256 r0,</span>
  63 |     | <span class='neutral'>    uint256 r1</span>
  64 |     | <span class='neutral'>  ) {</span>
  65 |     | <span class='neutral'>    //      a1 a0</span>
  66 |     | <span class='neutral'>    // -    b1 b0</span>
  67 |     | <span class='neutral'>    // -----------</span>
  68 |     | <span class='neutral'>    //      s1 r0</span>
  69 |     | <span class='neutral'>    // -    s0</span>
  70 |     | <span class='neutral'>    // -----------</span>
  71 |     | <span class='neutral'>    //      r1 r0</span>
  72 |     | <span class='neutral'>    //</span>
  73 |     | <span class='neutral'>    // where &#39;s0 := lt(a0, b0)&#39; and &#39;s1 := (a1 - b1) % (2 ** 256)&#39;.</span>
  74 |     | <span class='neutral'>    assembly {</span>
  75 |     | <span class='neutral'>      r0 := sub(a0, b0)</span>
  76 |     | <span class='neutral'>      r1 := sub(</span>
  77 |     | <span class='neutral'>        sub(a1, b1),</span>
  78 |     | <span class='neutral'>        // &#39;a0 &lt; b0&#39; indicates that the subtraction &#39;a0 - b0&#39; has underflowed.</span>
  79 |     | <span class='neutral'>        // In this case &#39;1&#39; needs to be subtracted from the most significant</span>
  80 |     | <span class='neutral'>        // 256 bits of the output.</span>
  81 |     | <span class='neutral'>        lt(a0, b0)</span>
  82 |     | <span class='neutral'>      )</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'>  }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>  ///                           ___________</span>
  87 |     | <span class='neutral'>  /// @notice 512-bit multiply &#39;prod1 prod0 = a * b&#39;.</span>
  88 |     | <span class='neutral'>  /// @param a The multiplicand.</span>
  89 |     | <span class='neutral'>  /// @param b The multiplier.</span>
  90 |     | <span class='neutral'>  /// @return prod0 Least significant 256 bits of the product.</span>
  91 |     | <span class='neutral'>  /// @return prod1 Most significant 256 bits of the product.</span>
  92 | *   | <span class='executed'>  function mul512(</span>
  93 |     | <span class='neutral'>    uint256 a,</span>
  94 |     | <span class='neutral'>    uint256 b</span>
  95 |     | <span class='neutral'>  ) internal pure returns (</span>
  96 | *   | <span class='executed'>    uint256 prod0, </span>
  97 | *   | <span class='executed'>    uint256 prod1</span>
  98 |     | <span class='neutral'>  ) {</span>
  99 | *   | <span class='executed'>    assembly {</span>
 100 |     | <span class='neutral'>      // &#39;mm := a * b - (2 ** 256 - 1) * q&#39;</span>
 101 | *   | <span class='executed'>      let mm := mulmod(a, b, not(0))</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>      // &#39;prod0 := a * b - (2 ** 256) * p&#39;</span>
 104 | *   | <span class='executed'>      prod0 := mul(a, b)</span>
 105 |     | <span class='neutral'></span>
 106 | *   | <span class='executed'>      prod1 := sub(</span>
 107 |     | <span class='neutral'>        // &#39;mm - prod0 == q&#39;.</span>
 108 | *   | <span class='executed'>        sub(mm, prod0),</span>
 109 |     | <span class='neutral'>        //               a * b                 a * b</span>
 110 |     | <span class='neutral'>        // p == floor(----------) &lt;= floor(--------------) == q</span>
 111 |     | <span class='neutral'>        //             2 ** 256             2 ** 256 - 1</span>
 112 |     | <span class='neutral'>        //</span>
 113 |     | <span class='neutral'>        // On the other hand, since</span>
 114 |     | <span class='neutral'>        //</span>
 115 |     | <span class='neutral'>        //      a * b          a * b                  a * b</span>
 116 |     | <span class='neutral'>        // -------------- - ---------- == ----------------------------- &lt; 1</span>
 117 |     | <span class='neutral'>        //  2 ** 256 - 1     2 ** 256      (2 ** 256) * (2 ** 256 - 1)</span>
 118 |     | <span class='neutral'>        //</span>
 119 |     | <span class='neutral'>        // we have &#39;q - p &lt;= 1&#39;.</span>
 120 |     | <span class='neutral'>        //</span>
 121 |     | <span class='neutral'>        // Hence, either &#39;p == q&#39; or &#39;p == q - 1&#39;.</span>
 122 |     | <span class='neutral'>        //</span>
 123 |     | <span class='neutral'>        // If &#39;p == q&#39;, then &#39;mm - prod0 == q &gt;= 0&#39;.</span>
 124 |     | <span class='neutral'>        // If &#39;p == q - 1&#39;, then &#39;prod0 - mm == (2 ** 256) - q &gt; 0&#39;.</span>
 125 |     | <span class='neutral'>        //</span>
 126 |     | <span class='neutral'>        // Since &#39;p == q&#39; and &#39;p == q - 1&#39; are mutually exclusive, we can argue</span>
 127 |     | <span class='neutral'>        // that:</span>
 128 |     | <span class='neutral'>        //</span>
 129 |     | <span class='neutral'>        // &#39;p == q&#39; if and only if &#39;mm &gt;= prod0&#39;.</span>
 130 |     | <span class='neutral'>        // &#39;p == q - 1&#39; if and only if &#39;mm &lt; prod0&#39;.</span>
 131 |     | <span class='neutral'>        //</span>
 132 |     | <span class='neutral'>        // Hence, in the latter case, we should subtract by &#39;1&#39;.</span>
 133 | *   | <span class='executed'>        lt(mm, prod0)</span>
 134 |     | <span class='neutral'>      )</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'>  }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>  /// @notice Calculates (a * b) / denominator when </span>
 139 |     | <span class='neutral'>  /// &#39;a * b &lt; denominator * (denominator - 1)&#39;.</span>
 140 |     | <span class='neutral'>  /// @param a The multiplicand.</span>
 141 |     | <span class='neutral'>  /// @param b The multiplier.</span>
 142 |     | <span class='neutral'>  /// @param denominator The divisor.</span>
 143 |     | <span class='neutral'>  /// @return result &#39;(a * b) / denominator&#39;.</span>
 144 | *   | <span class='executed'>  function cheapMulDiv(</span>
 145 |     | <span class='neutral'>    uint256 a,</span>
 146 |     | <span class='neutral'>    uint256 b,</span>
 147 |     | <span class='neutral'>    uint256 denominator</span>
 148 |     | <span class='neutral'>  ) internal pure returns (</span>
 149 | *   | <span class='executed'>    uint256 result</span>
 150 |     | <span class='neutral'>  ) {</span>
 151 |     | <span class='neutral'>    assembly {</span>
 152 | *   | <span class='executed'>      result := sub(denominator, 1)</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>      // &#39;s := a * b - q * (denominator - 1)&#39;</span>
 155 |     | <span class='neutral'>      // &#39;r := a * b - p * denominator&#39;</span>
 156 |     | <span class='neutral'>      // &#39;s - r == p * denominator == p&#39; [mod (denominator - 1)]</span>
 157 | *   | <span class='executed'>      result := addmod(</span>
 158 | *   | <span class='executed'>        mulmod(a, b, result),</span>
 159 |     | <span class='neutral'>        // This subtraction is safe because </span>
 160 |     | <span class='neutral'>        // &#39;(a * b) % denominator &lt;= denominator - 1&#39;.</span>
 161 | *   | <span class='executed'>        sub(result, mulmod(a, b, denominator)),</span>
 162 | *   | <span class='executed'>        result</span>
 163 |     | <span class='neutral'>      )</span>
 164 |     | <span class='neutral'>      // Notice that &#39;result &lt;= denominator - 1&#39; and because of the input</span>
 165 |     | <span class='neutral'>      // requirement, we have &#39;p = (a * b) / denominator &lt;= denominator - 1&#39;.</span>
 166 |     | <span class='neutral'>      // Hence, &#39;result == s - r == p&#39;.</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'>  }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>  /// @notice Calculates the modular inverse of an odd number modulo &#39;2 ** 256&#39;</span>
 171 |     | <span class='neutral'>  /// Input should be odd.</span>
 172 |     | <span class='neutral'>  /// @param value The number whose modular inverse to be calculated.</span>
 173 |     | <span class='neutral'>  /// @return inverse A 256-bit inverse satisfying</span>
 174 |     | <span class='neutral'>  /// &#39;value * inverse == 1&#39; [mod 2 ** 256].</span>
 175 | *   | <span class='executed'>  function modularInverse(</span>
 176 |     | <span class='neutral'>    uint256 value</span>
 177 |     | <span class='neutral'>  ) internal pure returns (</span>
 178 | *   | <span class='executed'>    uint256 inverse</span>
 179 |     | <span class='neutral'>  ) {</span>
 180 |     | <span class='neutral'>    unchecked {</span>
 181 |     | <span class='neutral'>      // Compute the inverse by starting with a seed that is correct for four</span>
 182 |     | <span class='neutral'>      // bits. That is, &#39;value * inverse = 1&#39; [mod 2 ** 4].</span>
 183 | *   | <span class='executed'>      inverse = 3 * value ^ 2;</span>
 184 |     | <span class='neutral'>      // Now use Newton-Raphson iterations to improve the precision. Thanks to</span>
 185 |     | <span class='neutral'>      // Hensel&#39;s lifting lemma, this also works in modular arithmetic,</span>
 186 |     | <span class='neutral'>      // doubling the correct bits in each step.</span>
 187 | *   | <span class='executed'>      inverse *= 2 - value * inverse;</span>
 188 | *   | <span class='executed'>      inverse *= 2 - value * inverse;</span>
 189 | *   | <span class='executed'>      inverse *= 2 - value * inverse;</span>
 190 | *   | <span class='executed'>      inverse *= 2 - value * inverse;</span>
 191 | *   | <span class='executed'>      inverse *= 2 - value * inverse;</span>
 192 | *   | <span class='executed'>      inverse *= 2 - value * inverse;</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'>  }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>  ///                          ________</span>
 197 |     | <span class='neutral'>  /// @notice 768-bit multiply q2 q1 q0 = a * b * c</span>
 198 |     | <span class='neutral'>  /// @param a The multiplicand.</span>
 199 |     | <span class='neutral'>  /// @param b The first multiplier.</span>
 200 |     | <span class='neutral'>  /// @param c The second multiplier.</span>
 201 |     | <span class='neutral'>  /// @return q0 Least significant 256 bits of the product.</span>
 202 |     | <span class='neutral'>  /// @return q1 Middle 256 bits of the product.</span>
 203 |     | <span class='neutral'>  /// @return q2 Most significant 256 bits of the product.</span>
 204 |     | <span class='neutral'>  function mul768(</span>
 205 |     | <span class='neutral'>    uint256 a,</span>
 206 |     | <span class='neutral'>    uint256 b,</span>
 207 |     | <span class='neutral'>    uint256 c</span>
 208 |     | <span class='neutral'>  ) internal pure returns (</span>
 209 |     | <span class='neutral'>    uint256 q0,</span>
 210 |     | <span class='neutral'>    uint256 q1,</span>
 211 |     | <span class='neutral'>    uint256 q2</span>
 212 |     | <span class='neutral'>  ) {</span>
 213 |     | <span class='neutral'>    //          a</span>
 214 |     | <span class='neutral'>    // x        b</span>
 215 |     | <span class='neutral'>    // -----------</span>
 216 |     | <span class='neutral'>    //      q1 q0</span>
 217 |     | <span class='neutral'>    // x        c</span>
 218 |     | <span class='neutral'>    // -----------</span>
 219 |     | <span class='neutral'>    //   ss </span>
 220 |     | <span class='neutral'>    //      mm q0</span>
 221 |     | <span class='neutral'>    // + q2 q1  0</span>
 222 |     | <span class='neutral'>    // -----------</span>
 223 |     | <span class='neutral'>    //   q2 q1 q0</span>
 224 |     | <span class='neutral'>    //</span>
 225 |     | <span class='neutral'>    uint256 mm;</span>
 226 |     | <span class='neutral'>    (q0, q1) = mul512(a, b);</span>
 227 |     | <span class='neutral'>    (q1, q2) = mul512(q1, c);</span>
 228 |     | <span class='neutral'>    (q0, mm) = mul512(q0, c);</span>
 229 |     | <span class='neutral'>    assembly {</span>
 230 |     | <span class='neutral'>      q1 := add(q1, mm)</span>
 231 |     | <span class='neutral'>      // &#39;q1 &lt; mm&#39; indicates that the above addition has overflowed (i.e.,</span>
 232 |     | <span class='neutral'>      // &#39;ss == 1&#39;) and hence, &#39;1&#39; needs to be added to the most significant</span>
 233 |     | <span class='neutral'>      // 256 bits of the product.</span>
 234 |     | <span class='neutral'>      q2 := add(q2, lt(q1, mm))</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'>  }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>  /// @notice Calculates </span>
 239 |     | <span class='neutral'>  ///</span>
 240 |     | <span class='neutral'>  ///         a * b * c</span>
 241 |     | <span class='neutral'>  /// &#39;min(----------------, 2 ** 216 - 1)&#39;</span>
 242 |     | <span class='neutral'>  ///       d * (2 ** 143)</span>
 243 |     | <span class='neutral'>  ///</span>
 244 |     | <span class='neutral'>  /// with full precision when &#39;a * b * c != 0&#39;.</span>
 245 |     | <span class='neutral'>  /// @param a The multiplicand.</span>
 246 |     | <span class='neutral'>  /// @param b The first multiplier.</span>
 247 |     | <span class='neutral'>  /// @param c The second multiplier.</span>
 248 |     | <span class='neutral'>  /// @param d The denominator.</span>
 249 |     | <span class='neutral'>  /// @param roundUp Whether to round up the result.</span>
 250 |     | <span class='neutral'>  /// @return result The output value &#39;(a * b * c) / (d * (2 ** 143))&#39; which is</span>
 251 |     | <span class='neutral'>  /// capped by &#39;2 ** 216 - 1&#39;.</span>
 252 |     | <span class='neutral'>  function mulDiv(</span>
 253 |     | <span class='neutral'>    uint256 a,</span>
 254 |     | <span class='neutral'>    uint256 b,</span>
 255 |     | <span class='neutral'>    uint256 c,</span>
 256 |     | <span class='neutral'>    uint256 d,</span>
 257 |     | <span class='neutral'>    bool roundUp</span>
 258 |     | <span class='neutral'>  ) internal pure returns (</span>
 259 |     | <span class='neutral'>    uint256 result</span>
 260 |     | <span class='neutral'>  ) {</span>
 261 |     | <span class='neutral'>    unchecked {</span>
 262 |     | <span class='neutral'>      // ________</span>
 263 |     | <span class='neutral'>      // q2 q1 q0 = a * b * c</span>
 264 |     | <span class='neutral'>      (uint256 q0, uint256 q1, uint256 q2) = mul768(a, b, c);</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>      // If &#39;q2 &gt;= (1 &lt;&lt; 103)&#39;, then the output is greater than or equal to</span>
 267 |     | <span class='neutral'>      //</span>
 268 |     | <span class='neutral'>      //  (2 ** 103) * (2 ** 256) * (2 ** 256)</span>
 269 |     | <span class='neutral'>      // -------------------------------------- == 2 ** 216</span>
 270 |     | <span class='neutral'>      //        (2 ** 256) * (2 ** 143)</span>
 271 |     | <span class='neutral'>      //</span>
 272 |     | <span class='neutral'>      // In this case, &#39;2 ** 216 - 1&#39; should be returned.</span>
 273 |     | <span class='neutral'>      if (q2 &gt;= (1 &lt;&lt; 103)) return ((1 &lt;&lt; 216) - 1);</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='neutral'>      // Divide the numerator by &#39;2 ** 143&#39;</span>
 276 |     | <span class='neutral'>      (q2, q1) = (</span>
 277 |     | <span class='neutral'>        (q2 &lt;&lt; 113) | (q1 &gt;&gt; 143),</span>
 278 |     | <span class='neutral'>        (q1 &lt;&lt; 113) | (q0 &gt;&gt; 143)</span>
 279 |     | <span class='neutral'>      );</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='neutral'>      // Calculating the remainder of the numerator modulo &#39;d&#39;.</span>
 282 |     | <span class='neutral'>      uint256 r;</span>
 283 |     | <span class='neutral'>      assembly {</span>
 284 |     | <span class='neutral'>        r := addmod(</span>
 285 |     | <span class='neutral'>          addmod(q1, q2, d), // (q1 + q2) % d</span>
 286 |     | <span class='neutral'>          mulmod(q2, not(0), d), // (q2 * (2 ** 256 - 1)) % d</span>
 287 |     | <span class='neutral'>          d</span>
 288 |     | <span class='neutral'>        ) // (q1 + q2 * (2 ** 256)) % d</span>
 289 |     | <span class='neutral'>      }</span>
 290 |     | <span class='neutral'>      </span>
 291 |     | <span class='neutral'>      //                         _____</span>
 292 |     | <span class='neutral'>      // &#39;r&#39; is subtracted from &#39;q2 q1&#39;.</span>
 293 |     | <span class='neutral'>      assembly {</span>
 294 |     | <span class='neutral'>        // &#39;q1 &lt; r&#39; indicates that the subtraction &#39;q1 - r&#39; underflows.</span>
 295 |     | <span class='neutral'>        // In this case &#39;1&#39; needs to be subtracted from q2.</span>
 296 |     | <span class='neutral'>        q2 := sub(q2, lt(q1, r))</span>
 297 |     | <span class='neutral'>        q1 := sub(q1, r)</span>
 298 |     | <span class='neutral'>      }</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='neutral'>      // Determines whether to return &#39;2 ** 216 - 1&#39;.</span>
 301 |     | <span class='neutral'>      //                _____</span>
 302 |     | <span class='neutral'>      // Check whether &#39;q2 q1 &gt;= (2 ** 256) * d&#39;.</span>
 303 |     | <span class='neutral'>      if (q2 &gt;= d) return ((1 &lt;&lt; 216) - 1);</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>      // &#39;d&#39; is factored into an odd part and a power of two. </span>
 306 |     | <span class='neutral'>      // Then, the numerator is divided by the power of two.</span>
 307 |     | <span class='neutral'>      {</span>
 308 |     | <span class='neutral'>        // This is the largest power of two that &#39;d&#39; is divisible by.</span>
 309 |     | <span class='neutral'>        uint256 twos = (0 - d) &amp; d;</span>
 310 |     | <span class='neutral'>        assembly {</span>
 311 |     | <span class='neutral'>          // Dividing &#39;d&#39; by &#39;twos&#39;.</span>
 312 |     | <span class='neutral'>          d := div(d, twos)</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>          //           _____</span>
 315 |     | <span class='neutral'>          // Dividing &#39;q2 q1&#39; by &#39;twos&#39; and storing the least significant &#39;256&#39;</span>
 316 |     | <span class='neutral'>          // bits in &#39;q1&#39;.</span>
 317 |     | <span class='neutral'>          q1 := or(</span>
 318 |     | <span class='neutral'>            div(q1, twos), // &#39;q1 / (2 ** k)&#39;</span>
 319 |     | <span class='neutral'>            mul(</span>
 320 |     | <span class='neutral'>              q2,</span>
 321 |     | <span class='neutral'>              add(</span>
 322 |     | <span class='neutral'>                div(</span>
 323 |     | <span class='neutral'>                  sub(0, twos), // &#39;2 ** 256 - 2 ** k&#39;</span>
 324 |     | <span class='neutral'>                  twos // &#39;2 ** k&#39;</span>
 325 |     | <span class='neutral'>                ), // &#39;2 ** (256 - k) - 1&#39;</span>
 326 |     | <span class='neutral'>                1</span>
 327 |     | <span class='neutral'>              ) // &#39;(2 ** (256 - k)) % (2 ** 256)&#39;</span>
 328 |     | <span class='neutral'>            ) // &#39;(q2 * (2 ** (256 - k))) % (2 ** 256)&#39;</span>
 329 |     | <span class='neutral'>          ) // &#39;(q2 * (2 ** (256 - k)) + q1 / (2 ** k)) % (2 ** 256)&#39;</span>
 330 |     | <span class='neutral'>        }</span>
 331 |     | <span class='neutral'>      }</span>
 332 |     | <span class='neutral'></span>
 333 |     | <span class='neutral'>      // The result can now be calculated precisely using modular inverse.</span>
 334 |     | <span class='neutral'>      // Let &#39;di := modularInverse(d)&#39;.</span>
 335 |     | <span class='neutral'>      //</span>
 336 |     | <span class='neutral'>      //  _____</span>
 337 |     | <span class='neutral'>      // &#39;q2 q1 == d * result&#39;</span>
 338 |     | <span class='neutral'>      // &#39;(2 ** 256) * q2 + q1 == d * result&#39;</span>
 339 |     | <span class='neutral'>      // &#39;di * (2 ** 256) * q2 + di * q1 == di * d * result&#39;</span>
 340 |     | <span class='neutral'>      // &#39;di * (2 ** 256) * q2 + di * q1 == ((2 ** 256) * k + 1) * result&#39;</span>
 341 |     | <span class='neutral'>      // &#39;di * q1 == result&#39; [mod 2 ** 256]</span>
 342 |     | <span class='neutral'>      result = modularInverse(d) * q1;</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='neutral'>      // If either of the remainders are positive, then the result should be</span>
 345 |     | <span class='neutral'>      // rounded up.</span>
 346 |     | <span class='neutral'>      if (roundUp) {</span>
 347 |     | <span class='neutral'>        if ((q0 &amp; 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) &gt; 0 || r &gt; 0) {</span>
 348 |     | <span class='neutral'>          ++result;</span>
 349 |     | <span class='neutral'>        }</span>
 350 |     | <span class='neutral'>      }</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='neutral'>      // Determines whether to return &#39;2 ** 216 - 1&#39;.</span>
 353 |     | <span class='neutral'>      if (result &gt;= (1 &lt;&lt; 216)) return ((1 &lt;&lt; 216) - 1);</span>
 354 |     | <span class='neutral'>    }</span>
 355 |     | <span class='neutral'>  }</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>  /// @notice Calculates</span>
 358 |     | <span class='neutral'>  ///</span>
 359 |     | <span class='neutral'>  ///      a * b * c</span>
 360 |     | <span class='neutral'>  /// &#39;----------------&#39;</span>
 361 |     | <span class='neutral'>  ///   d * (2 ** 111)</span>
 362 |     | <span class='neutral'>  ///</span>
 363 |     | <span class='neutral'>  /// with full precision. Overflows if the result exceeds &#39;type(int256).max&#39;.</span>
 364 |     | <span class='neutral'>  /// &#39;e&#39; must be the modular inverse of &#39;d / (2 ** k)&#39; where &#39;k&#39; is the</span>
 365 |     | <span class='neutral'>  /// largest power of two within &#39;d&#39;.</span>
 366 |     | <span class='neutral'>  /// We should have &#39;a * b * c != 0&#39; and &#39;d != 0&#39;.</span>
 367 |     | <span class='neutral'>  /// @param a The multiplicand.</span>
 368 |     | <span class='neutral'>  /// @param b The first multiplier.</span>
 369 |     | <span class='neutral'>  /// @param c The second multiplier.</span>
 370 |     | <span class='neutral'>  /// @param d The denominator.</span>
 371 |     | <span class='neutral'>  /// @param e Modular inverse of the odd part of the denominator.</span>
 372 |     | <span class='neutral'>  /// @param roundUp Whether to round up the result.</span>
 373 |     | <span class='neutral'>  /// @return result The output value &#39;(a * b * c) / (d * (2 ** 111))&#39; if there</span>
 374 |     | <span class='neutral'>  /// is no overflow.</span>
 375 |     | <span class='neutral'>  /// @return overflow Whether the result overflows.</span>
 376 |     | <span class='neutral'>  function mulDiv(</span>
 377 |     | <span class='neutral'>    uint256 a,</span>
 378 |     | <span class='neutral'>    uint256 b,</span>
 379 |     | <span class='neutral'>    uint256 c,</span>
 380 |     | <span class='neutral'>    uint256 d,</span>
 381 |     | <span class='neutral'>    uint256 e,</span>
 382 |     | <span class='neutral'>    bool roundUp</span>
 383 |     | <span class='neutral'>  ) internal pure returns (</span>
 384 |     | <span class='neutral'>    uint256 result,</span>
 385 |     | <span class='neutral'>    bool overflow</span>
 386 |     | <span class='neutral'>  ) {</span>
 387 |     | <span class='neutral'>    unchecked {</span>
 388 |     | <span class='neutral'>      // ________</span>
 389 |     | <span class='neutral'>      // q2 q1 q0 = a * b * c</span>
 390 |     | <span class='neutral'>      (uint256 q0, uint256 q1, uint256 q2) = mul768(a, b, c);</span>
 391 |     | <span class='neutral'></span>
 392 |     | <span class='neutral'>      // If &#39;q2 &gt;= (1 &lt;&lt; 111)&#39;, then the output is greater than or equal to</span>
 393 |     | <span class='neutral'>      //</span>
 394 |     | <span class='neutral'>      //  (2 ** 111) * (2 ** 256) * (2 ** 256)</span>
 395 |     | <span class='neutral'>      // -------------------------------------- == 2 ** 256</span>
 396 |     | <span class='neutral'>      //        (2 ** 256) * (2 ** 111)</span>
 397 |     | <span class='neutral'>      //</span>
 398 |     | <span class='neutral'>      // In this case, we return overflow.</span>
 399 |     | <span class='neutral'>      if (q2 &gt;= (1 &lt;&lt; 111)) return (0, true);</span>
 400 |     | <span class='neutral'></span>
 401 |     | <span class='neutral'>      // Divide the numerator by &#39;2 ** 111&#39;</span>
 402 |     | <span class='neutral'>      (q2, q1) = (</span>
 403 |     | <span class='neutral'>        (q2 &lt;&lt; 145) | (q1 &gt;&gt; 111),</span>
 404 |     | <span class='neutral'>        (q1 &lt;&lt; 145) | (q0 &gt;&gt; 111)</span>
 405 |     | <span class='neutral'>      );</span>
 406 |     | <span class='neutral'></span>
 407 |     | <span class='neutral'>      // Calculating the remainder of the numerator modulo &#39;d&#39;.</span>
 408 |     | <span class='neutral'>      uint256 r;</span>
 409 |     | <span class='neutral'>      assembly {</span>
 410 |     | <span class='neutral'>        r := addmod(</span>
 411 |     | <span class='neutral'>          addmod(q1, q2, d), // (q1 + q2) % d</span>
 412 |     | <span class='neutral'>          mulmod(q2, not(0), d), // (q2 * (2 ** 256 - 1)) % d</span>
 413 |     | <span class='neutral'>          d</span>
 414 |     | <span class='neutral'>        ) // (q1 + q2 * (2 ** 256)) % d</span>
 415 |     | <span class='neutral'>      }</span>
 416 |     | <span class='neutral'></span>
 417 |     | <span class='neutral'>      //                         _____</span>
 418 |     | <span class='neutral'>      // &#39;r&#39; is subtracted from &#39;q2 q1&#39;.</span>
 419 |     | <span class='neutral'>      assembly {</span>
 420 |     | <span class='neutral'>        // &#39;q1 &lt; r&#39; indicates that the subtraction &#39;q1 - r&#39; underflowes.</span>
 421 |     | <span class='neutral'>        // In this case &#39;1&#39; needs to be subtracted from q2.</span>
 422 |     | <span class='neutral'>        q2 := sub(q2, lt(q1, r))</span>
 423 |     | <span class='neutral'>        q1 := sub(q1, r)</span>
 424 |     | <span class='neutral'>      }</span>
 425 |     | <span class='neutral'></span>
 426 |     | <span class='neutral'>      // Determines whether to return overflow.</span>
 427 |     | <span class='neutral'>      // The following equality is satisfied if and only if</span>
 428 |     | <span class='neutral'>      //</span>
 429 |     | <span class='neutral'>      //      a * b * c</span>
 430 |     | <span class='neutral'>      // &#39;---------------- &gt;= (2 ** 256)&#39;</span>
 431 |     | <span class='neutral'>      //   d * (2 ** 111)</span>
 432 |     | <span class='neutral'>      //</span>
 433 |     | <span class='neutral'>      if (q2 &gt;= d) return (0, true);</span>
 434 |     | <span class='neutral'></span>
 435 |     | <span class='neutral'>      // &#39;d&#39; is factored into an odd part and a power of two and the numerator</span>
 436 |     | <span class='neutral'>      // is divided by the power of two.</span>
 437 |     | <span class='neutral'>      d = (0 - d) &amp; d;</span>
 438 |     | <span class='neutral'>      assembly {</span>
 439 |     | <span class='neutral'>        q1 := or(</span>
 440 |     | <span class='neutral'>          div(q1, d), // q1 / (2 ** k)</span>
 441 |     | <span class='neutral'>          mul(</span>
 442 |     | <span class='neutral'>            q2,</span>
 443 |     | <span class='neutral'>            add(</span>
 444 |     | <span class='neutral'>              div(</span>
 445 |     | <span class='neutral'>                sub(0, d), // &#39;2 ** 256 - 2 ** k&#39;</span>
 446 |     | <span class='neutral'>                d // &#39;2 ** k&#39;</span>
 447 |     | <span class='neutral'>              ), // &#39;2 ** (256 - k) - 1&#39;</span>
 448 |     | <span class='neutral'>              1</span>
 449 |     | <span class='neutral'>            ) // &#39;(2 ** (256 - k)) % (2 ** 256)&#39;</span>
 450 |     | <span class='neutral'>          ) // &#39;(q2 * (2 ** (256 - k))) % (2 ** 256)&#39;</span>
 451 |     | <span class='neutral'>        ) // &#39;(q2 * (2 ** (256 - k)) + q1 / (2 ** k)) % (2 ** 256)&#39;</span>
 452 |     | <span class='neutral'>      }</span>
 453 |     | <span class='neutral'></span>
 454 |     | <span class='neutral'>      // The result can now be calculated precisely using &#39;e&#39;.</span>
 455 |     | <span class='neutral'>      //  _____</span>
 456 |     | <span class='neutral'>      // &#39;q2 q1 == d * result&#39;</span>
 457 |     | <span class='neutral'>      // &#39;(2 ** 256) * q2 + q1 == d * result&#39;</span>
 458 |     | <span class='neutral'>      // &#39;e * (2 ** 256) * q2 + e * q1 == e * d * result&#39;</span>
 459 |     | <span class='neutral'>      // &#39;e * (2 ** 256) * q2 + e * q1 == ((2 ** 256) * k + 1) * result&#39;</span>
 460 |     | <span class='neutral'>      // &#39;e * q1 == result&#39; [mod 2 ** 256]</span>
 461 |     | <span class='neutral'>      result = e * q1;</span>
 462 |     | <span class='neutral'></span>
 463 |     | <span class='neutral'>      // If either of the remainders are positive, then the result should be</span>
 464 |     | <span class='neutral'>      // rounded up.</span>
 465 |     | <span class='neutral'>      if (roundUp) {</span>
 466 |     | <span class='neutral'>        if ((q0 &amp; 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFF) &gt; 0 || r &gt; 0) {</span>
 467 |     | <span class='neutral'>          ++result;</span>
 468 |     | <span class='neutral'>        }</span>
 469 |     | <span class='neutral'>      }</span>
 470 |     | <span class='neutral'></span>
 471 |     | <span class='neutral'>      // Determines whether to overflow.</span>
 472 |     | <span class='neutral'>      if (result &gt;= (1 &lt;&lt; 255)) return (0, true);</span>
 473 |     | <span class='neutral'>    }</span>
 474 |     | <span class='neutral'>  }</span>
 475 |     | <span class='neutral'></span>
 476 |     | <span class='neutral'>  /// @notice Calculates floor((a * b) / denominator) with full precision.</span>
 477 |     | <span class='neutral'>  /// Overflow should be avoided externally.</span>
 478 |     | <span class='neutral'>  /// @param a The multiplicand</span>
 479 |     | <span class='neutral'>  /// @param b The multiplier</span>
 480 |     | <span class='neutral'>  /// @param denominator The divisor</span>
 481 |     | <span class='neutral'>  /// @return result The 256-bit result</span>
 482 | *   | <span class='executed'>  function mulDiv(</span>
 483 |     | <span class='neutral'>    uint256 a,</span>
 484 |     | <span class='neutral'>    uint256 b,</span>
 485 |     | <span class='neutral'>    uint256 denominator</span>
 486 |     | <span class='neutral'>  ) internal pure returns (</span>
 487 | *   | <span class='executed'>    uint256 result</span>
 488 |     | <span class='neutral'>  ) {</span>
 489 |     | <span class='neutral'>    unchecked {</span>
 490 |     | <span class='neutral'>      //                   ___________</span>
 491 |     | <span class='neutral'>      // 512-bit multiply &#39;prod1 prod0 = a * b&#39;</span>
 492 |     | <span class='neutral'>      // Compute the product mod 2**256 and mod 2 ** 256 - 1</span>
 493 |     | <span class='neutral'>      // then use the Chinese Remainder Theorem to reconstruct</span>
 494 |     | <span class='neutral'>      // the 512 bit result. The result is stored in two 256</span>
 495 |     | <span class='neutral'>      // variables such that product = prod1 * (2 ** 256) + prod0</span>
 496 | *   | <span class='executed'>      (uint256 prod0, uint256 prod1) = mul512(a, b);</span>
 497 |     | <span class='neutral'></span>
 498 |     | <span class='neutral'>      // Short circuit 256 by 256 division</span>
 499 |     | <span class='neutral'>      // This saves gas when a * b is small, at the cost of making the</span>
 500 |     | <span class='neutral'>      // large case a bit more expensive. Depending on your use case you</span>
 501 |     | <span class='neutral'>      // may want to remove this short circuit and always go through the</span>
 502 |     | <span class='neutral'>      // 512 bit path.</span>
 503 | *   | <span class='executed'>      if (prod1 == 0) {</span>
 504 |     | <span class='neutral'>        assembly {</span>
 505 | *   | <span class='executed'>          result := div(prod0, denominator)</span>
 506 |     | <span class='neutral'>        }</span>
 507 | *   | <span class='executed'>        return result;</span>
 508 |     | <span class='neutral'>      }</span>
 509 |     | <span class='neutral'>      </span>
 510 |     | <span class='neutral'>      ///////////////////////////////////////////////</span>
 511 |     | <span class='neutral'>      // 512 by 256 division.</span>
 512 |     | <span class='neutral'>      ///////////////////////////////////////////////</span>
 513 |     | <span class='neutral'></span>
 514 |     | <span class='neutral'>      //                                                        ___________</span>
 515 |     | <span class='neutral'>      // Make division exact by subtracting the remainder from &#39;prod1 prod0&#39;</span>
 516 |     | <span class='neutral'>      // Compute remainder using mulmod</span>
 517 |     | <span class='neutral'>      // Note mulmod(_, _, 0) == 0</span>
 518 | *   | <span class='executed'>      uint256 remainder;</span>
 519 |     | <span class='neutral'>      assembly {</span>
 520 | *   | <span class='executed'>        remainder := mulmod(a, b, denominator)</span>
 521 |     | <span class='neutral'>      }</span>
 522 |     | <span class='neutral'></span>
 523 |     | <span class='neutral'>      // Subtract 256 bit number from 512 bit number</span>
 524 |     | <span class='neutral'>      assembly {</span>
 525 | *   | <span class='executed'>        prod1 := sub(prod1, gt(remainder, prod0))</span>
 526 | *   | <span class='executed'>        prod0 := sub(prod0, remainder)</span>
 527 |     | <span class='neutral'>      }</span>
 528 |     | <span class='neutral'>      </span>
 529 |     | <span class='neutral'>      // Factor powers of two out of denominator</span>
 530 |     | <span class='neutral'>      // Compute largest power of two-divisor of denominator.</span>
 531 |     | <span class='neutral'>      // Always &gt;= 1 unless the denominator is zero, then twos is zero.</span>
 532 | *   | <span class='executed'>      uint256 twos = (0 - denominator) &amp; denominator;</span>
 533 |     | <span class='neutral'>      // Divide denominator by power of two</span>
 534 |     | <span class='neutral'>      assembly {</span>
 535 | *   | <span class='executed'>        denominator := div(denominator, twos)</span>
 536 |     | <span class='neutral'>      }</span>
 537 |     | <span class='neutral'>      </span>
 538 |     | <span class='neutral'>      //         ___________</span>
 539 |     | <span class='neutral'>      // Divide &#39;prod1 prod0&#39; by the factors of two</span>
 540 |     | <span class='neutral'>      assembly {</span>
 541 | *   | <span class='executed'>        prod0 := div(prod0, twos)</span>
 542 |     | <span class='neutral'>      }</span>
 543 |     | <span class='neutral'>      // Shift in bits from prod1 into prod0. For this we need</span>
 544 |     | <span class='neutral'>      // to flip `twos` such that it is 2**256 / twos.</span>
 545 |     | <span class='neutral'>      // If twos is zero, then it becomes one</span>
 546 |     | <span class='neutral'>      assembly {</span>
 547 | *   | <span class='executed'>        twos := add(div(sub(0, twos), twos), 1)</span>
 548 |     | <span class='neutral'>      }</span>
 549 | *   | <span class='executed'>      prod0 |= prod1 * twos;</span>
 550 |     | <span class='neutral'>      </span>
 551 |     | <span class='neutral'>      // Invert denominator mod 2**256</span>
 552 |     | <span class='neutral'>      // Now that denominator is an odd number, it has an inverse</span>
 553 |     | <span class='neutral'>      // modulo 2**256 such that denominator * inv = 1 mod 2**256.</span>
 554 |     | <span class='neutral'>      // Compute the inverse by starting with a seed that is correct</span>
 555 |     | <span class='neutral'>      // correct for four bits. That is, denominator * inv = 1 mod 2**4</span>
 556 |     | <span class='neutral'>      // If denominator is zero the inverse starts with 2</span>
 557 |     | <span class='neutral'>      // Now use Newton-Raphson iteration to improve the precision.</span>
 558 |     | <span class='neutral'>      // Thanks to Hensel&#39;s lifting lemma, this also works in modular</span>
 559 |     | <span class='neutral'>      // arithmetic, doubling the correct bits in each step.</span>
 560 | *   | <span class='executed'>      uint256 inv = modularInverse(denominator);</span>
 561 |     | <span class='neutral'>      // If denominator is zero, inv is now 128</span>
 562 |     | <span class='neutral'>      </span>
 563 |     | <span class='neutral'>      // Because the division is now exact we can divide by multiplying</span>
 564 |     | <span class='neutral'>      // with the modular inverse of the denominator. This will give us the</span>
 565 |     | <span class='neutral'>      // correct result modulo 2**256. Since the preconditions guarantee</span>
 566 |     | <span class='neutral'>      // that the outcome is less than 2**256, this is the final result.</span>
 567 |     | <span class='neutral'>      // We don&#39;t need to compute the high bits of the result and prod1</span>
 568 |     | <span class='neutral'>      // is no longer required.</span>
 569 | *   | <span class='executed'>      result = prod0 * inv;</span>
 570 | *   | <span class='executed'>      return result;</span>
 571 |     | <span class='neutral'>    }</span>
 572 |     | <span class='neutral'>  }</span>
 573 |     | <span class='neutral'></span>
 574 |     | <span class='neutral'>  /// @notice Calculates ceiling((a * b) / denominator) with full precision.</span>
 575 |     | <span class='neutral'>  /// Overflow should be avoided externally.</span>
 576 |     | <span class='neutral'>  /// @param a The multiplicand</span>
 577 |     | <span class='neutral'>  /// @param b The multiplier</span>
 578 |     | <span class='neutral'>  /// @param denominator The divisor</span>
 579 |     | <span class='neutral'>  /// @return result The 256-bit result</span>
 580 |     | <span class='neutral'>  function mulDivRoundUp(</span>
 581 |     | <span class='neutral'>    uint256 a,</span>
 582 |     | <span class='neutral'>    uint256 b,</span>
 583 |     | <span class='neutral'>    uint256 denominator</span>
 584 |     | <span class='neutral'>  ) internal pure returns (uint256 result) {</span>
 585 |     | <span class='neutral'>    result = mulDiv(a, b, denominator);</span>
 586 |     | <span class='neutral'>    // The result is incremented if &#39;a * b&#39; is not divisible by &#39;denominator&#39;.</span>
 587 |     | <span class='neutral'>    assembly {</span>
 588 |     | <span class='neutral'>      result := add(result, gt(mulmod(a, b, denominator), 0))</span>
 589 |     | <span class='neutral'>    }</span>
 590 |     | <span class='neutral'>  }</span>
 591 |     | <span class='neutral'></span>
 592 |     | <span class='neutral'>  /// @notice Calculates floor((a * b) / denominator) with full precision.</span>
 593 |     | <span class='neutral'>  /// Throws in case of overflow.</span>
 594 |     | <span class='neutral'>  /// @param a The multiplicand</span>
 595 |     | <span class='neutral'>  /// @param b The multiplier</span>
 596 |     | <span class='neutral'>  /// @param denominator The divisor</span>
 597 |     | <span class='neutral'>  /// @return result The 256-bit result</span>
 598 |     | <span class='neutral'>  function safeMulDiv(</span>
 599 |     | <span class='neutral'>    uint256 a,</span>
 600 |     | <span class='neutral'>    uint256 b,</span>
 601 |     | <span class='neutral'>    uint256 denominator</span>
 602 |     | <span class='neutral'>  ) internal pure returns (uint256 result) {</span>
 603 |     | <span class='neutral'>    (, uint256 prod1) = mul512(a, b);</span>
 604 |     | <span class='neutral'>    require(prod1 &lt; denominator, MulDivOverflow(a, b, denominator));</span>
 605 |     | <span class='neutral'>    result = mulDiv(a, b, denominator);</span>
 606 |     | <span class='neutral'>  }</span>
 607 |     | <span class='neutral'></span>
 608 |     | <span class='neutral'>  /// @notice Calculates ceiling((a * b) / denominator) with full precision.</span>
 609 |     | <span class='neutral'>  /// Throws in case of overflow.</span>
 610 |     | <span class='neutral'>  /// @param a The multiplicand</span>
 611 |     | <span class='neutral'>  /// @param b The multiplier</span>
 612 |     | <span class='neutral'>  /// @param denominator The divisor</span>
 613 |     | <span class='neutral'>  /// @return result The 256-bit result</span>
 614 |     | <span class='neutral'>  function safeMulDivRoundUp(</span>
 615 |     | <span class='neutral'>    uint256 a,</span>
 616 |     | <span class='neutral'>    uint256 b,</span>
 617 |     | <span class='neutral'>    uint256 denominator</span>
 618 |     | <span class='neutral'>  ) internal pure returns (uint256 result) {</span>
 619 |     | <span class='neutral'>    // The result is incremented if &#39;a * b&#39; is not divisible by &#39;denominator&#39;.</span>
 620 |     | <span class='neutral'>    assembly {</span>
 621 |     | <span class='neutral'>      result := gt(mulmod(a, b, denominator), 0)</span>
 622 |     | <span class='neutral'>    }</span>
 623 |     | <span class='neutral'>    result += safeMulDiv(a, b, denominator);</span>
 624 |     | <span class='neutral'>  }</span>
 625 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/Index.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// Type index is used to enumerate members of the curve and kernel.</span>
   5 |     | <span class='neutral'>type Index is uint256;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='unexecuted'>Index constant zeroIndex = Index.wrap(0);</span>
   8 |     | <span class='unexecuted'>Index constant oneIndex = Index.wrap(1);</span>
   9 |     | <span class='unexecuted'>Index constant twoIndex = Index.wrap(2);</span>
  10 |     | <span class='neutral'>Index constant threeIndex = Index.wrap(3);</span>
  11 |     | <span class='neutral'>Index constant maxCurveIndex = Index.wrap(type(uint16).max);</span>
  12 |     | <span class='neutral'>Index constant maxKernelIndex = Index.wrap(1020);</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>using {equals as ==, notEquals as !=} for Index global;</span>
  15 |     | <span class='neutral'>using {lessThan as &lt;, greaterThan as &gt;} for Index global;</span>
  16 |     | <span class='neutral'>using {lessThanOrEqualTo as &lt;=, greaterThanOrEqualTo as &gt;=} for Index global;</span>
  17 |     | <span class='neutral'>using {add as +, sub as -} for Index global;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>function equals(</span>
  20 |     | <span class='neutral'>  Index value0,</span>
  21 |     | <span class='neutral'>  Index value1</span>
  22 |     | <span class='neutral'>) pure returns (</span>
  23 |     | <span class='neutral'>  bool result</span>
  24 |     | <span class='neutral'>) {</span>
  25 |     | <span class='neutral'>  assembly {</span>
  26 |     | <span class='neutral'>    result := eq(value0, value1)</span>
  27 |     | <span class='neutral'>  }</span>
  28 |     | <span class='neutral'>}</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>function notEquals(</span>
  31 |     | <span class='neutral'>  Index value0,</span>
  32 |     | <span class='neutral'>  Index value1</span>
  33 |     | <span class='neutral'>) pure returns (</span>
  34 |     | <span class='neutral'>  bool result</span>
  35 |     | <span class='neutral'>) {</span>
  36 |     | <span class='neutral'>  return !(value0 == value1);</span>
  37 |     | <span class='neutral'>}</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>function lessThan(</span>
  40 |     | <span class='neutral'>  Index value0,</span>
  41 |     | <span class='neutral'>  Index value1</span>
  42 |     | <span class='neutral'>) pure returns (</span>
  43 |     | <span class='unexecuted'>  bool result</span>
  44 |     | <span class='neutral'>) {</span>
  45 |     | <span class='neutral'>  assembly {</span>
  46 |     | <span class='unexecuted'>    result := lt(value0, value1)</span>
  47 |     | <span class='neutral'>  }</span>
  48 |     | <span class='neutral'>}</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='unexecuted'>function greaterThan(</span>
  51 |     | <span class='neutral'>  Index value0,</span>
  52 |     | <span class='neutral'>  Index value1</span>
  53 |     | <span class='neutral'>) pure returns (</span>
  54 |     | <span class='unexecuted'>  bool result</span>
  55 |     | <span class='neutral'>) {</span>
  56 |     | <span class='neutral'>  assembly {</span>
  57 |     | <span class='unexecuted'>    result := gt(value0, value1)</span>
  58 |     | <span class='neutral'>  }</span>
  59 |     | <span class='neutral'>}</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>function lessThanOrEqualTo(</span>
  62 |     | <span class='neutral'>  Index value0,</span>
  63 |     | <span class='neutral'>  Index value1</span>
  64 |     | <span class='neutral'>) pure returns (</span>
  65 |     | <span class='neutral'>  bool result</span>
  66 |     | <span class='neutral'>) {</span>
  67 |     | <span class='neutral'>  return !(value0 &gt; value1);</span>
  68 |     | <span class='neutral'>}</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>function greaterThanOrEqualTo(</span>
  71 |     | <span class='neutral'>  Index value0,</span>
  72 |     | <span class='neutral'>  Index value1</span>
  73 |     | <span class='neutral'>) pure returns (</span>
  74 |     | <span class='unexecuted'>  bool result</span>
  75 |     | <span class='neutral'>) {</span>
  76 |     | <span class='unexecuted'>  return !(value0 &lt; value1);</span>
  77 |     | <span class='neutral'>}</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>// Overflow should be avoided externally.</span>
  80 |     | <span class='unexecuted'>function add(</span>
  81 |     | <span class='neutral'>  Index value0,</span>
  82 |     | <span class='neutral'>  Index value1</span>
  83 |     | <span class='neutral'>) pure returns (</span>
  84 |     | <span class='unexecuted'>  Index result</span>
  85 |     | <span class='neutral'>) {</span>
  86 |     | <span class='neutral'>  assembly {</span>
  87 |     | <span class='unexecuted'>    result := add(value0, value1)</span>
  88 |     | <span class='neutral'>  }</span>
  89 |     | <span class='neutral'>}</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>// Underflow should be avoided externally.</span>
  92 |     | <span class='unexecuted'>function sub(</span>
  93 |     | <span class='neutral'>  Index value0,</span>
  94 |     | <span class='neutral'>  Index value1</span>
  95 |     | <span class='neutral'>) pure returns (</span>
  96 |     | <span class='unexecuted'>  Index result</span>
  97 |     | <span class='neutral'>) {</span>
  98 |     | <span class='neutral'>  assembly {</span>
  99 |     | <span class='unexecuted'>    result := sub(value0, value1)</span>
 100 |     | <span class='neutral'>  }</span>
 101 |     | <span class='neutral'>}</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>function min(</span>
 104 |     | <span class='neutral'>  Index value0,</span>
 105 |     | <span class='neutral'>  Index value1</span>
 106 |     | <span class='neutral'>) pure returns (</span>
 107 |     | <span class='neutral'>  Index result</span>
 108 |     | <span class='neutral'>) {</span>
 109 |     | <span class='neutral'>  return (value0 &lt; value1) ? value0 : value1;</span>
 110 |     | <span class='neutral'>}</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>function max(</span>
 113 |     | <span class='neutral'>  Index value0,</span>
 114 |     | <span class='neutral'>  Index value1</span>
 115 |     | <span class='neutral'>) pure returns (</span>
 116 |     | <span class='neutral'>  Index result</span>
 117 |     | <span class='neutral'>) {</span>
 118 |     | <span class='neutral'>  return (value0 &lt; value1) ? value1 : value0;</span>
 119 |     | <span class='neutral'>}</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>library IndexLibrary {</span>
 122 |     | <span class='neutral'>  /// @notice Returns the current 16-bit index of the curve or kernel under </span>
 123 |     | <span class='neutral'>  /// exploration given the corresponding pointer.</span>
 124 |     | <span class='neutral'>  ///</span>
 125 |     | <span class='neutral'>  /// &#39;pointer&#39; should be a constant value.</span>
 126 |     | <span class='neutral'>  function getIndex(</span>
 127 |     | <span class='neutral'>    uint256 pointer</span>
 128 |     | <span class='neutral'>  ) internal pure returns (</span>
 129 |     | <span class='neutral'>    Index value</span>
 130 |     | <span class='neutral'>  ) {</span>
 131 |     | <span class='neutral'>    assembly {</span>
 132 |     | <span class='neutral'>      // First, the memory slot whose most significant 16 bits host the index</span>
 133 |     | <span class='neutral'>      // is loaded and then the least significant 240 bits are discarded.</span>
 134 |     | <span class='neutral'>      value := shr(240, mload(pointer))</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'>  }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>  /// @notice Increases a 16-bit index stored in memory by one, given a </span>
 139 |     | <span class='neutral'>  /// pointer. The new value for the index is then returned.</span>
 140 |     | <span class='neutral'>  /// Overflow should be avoided externally.</span>
 141 |     | <span class='neutral'>  ///</span>
 142 |     | <span class='neutral'>  /// &#39;pointer&#39; should be a constant value.</span>
 143 |     | <span class='neutral'>  function incrementIndex(</span>
 144 |     | <span class='neutral'>    uint256 pointer</span>
 145 |     | <span class='neutral'>  ) internal pure returns (</span>
 146 |     | <span class='neutral'>    Index value</span>
 147 |     | <span class='neutral'>  ) {</span>
 148 |     | <span class='neutral'>    assembly {</span>
 149 |     | <span class='neutral'>      // Index is the most significant 16 bit. Hence, to increment it we need</span>
 150 |     | <span class='neutral'>      // to add the slot by &#39;2 ** 240&#39;.</span>
 151 |     | <span class='neutral'>      value := add(mload(pointer), shl(240, 1))</span>
 152 |     | <span class='neutral'>      mstore(pointer, value)</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>      // Then, the least significant 240 bits are discarded and the resulting</span>
 155 |     | <span class='neutral'>      // value is returned.</span>
 156 |     | <span class='neutral'>      value := shr(240, value)</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'>  }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>  /// @notice Decreases a 16-bit index stored in memory by one, given a </span>
 161 |     | <span class='neutral'>  /// pointer. The new value for the index is then returned.</span>
 162 |     | <span class='neutral'>  /// Underflow should be avoided externally.</span>
 163 |     | <span class='neutral'>  ///</span>
 164 |     | <span class='neutral'>  /// &#39;pointer&#39; should be a constant value.</span>
 165 |     | <span class='neutral'>  function decrementIndex(</span>
 166 |     | <span class='neutral'>    uint256 pointer</span>
 167 |     | <span class='neutral'>  ) internal pure returns (</span>
 168 |     | <span class='neutral'>    Index value</span>
 169 |     | <span class='neutral'>  ) {</span>
 170 |     | <span class='neutral'>    assembly {</span>
 171 |     | <span class='neutral'>      // Index is the most significant 16 bit. Hence, to decrement it we need</span>
 172 |     | <span class='neutral'>      // to subtract the slot by &#39;2 ** 240&#39;.</span>
 173 |     | <span class='neutral'>      value := sub(mload(pointer), shl(240, 1))</span>
 174 |     | <span class='neutral'>      mstore(pointer, value)</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>      // Then, the least significant 240 bits are discarded and the resulting</span>
 177 |     | <span class='neutral'>      // value is returned.</span>
 178 |     | <span class='neutral'>      value := shr(240, value)</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'>  }</span>
 181 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/Integral.sol</b>
<code>
    1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
    2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>import {zeroX15, X15} from &quot;./X15.sol&quot;;</span>
    5 |     | <span class='neutral'>import {twoX59, X59} from &quot;./X59.sol&quot;;</span>
    6 |     | <span class='neutral'>import {X74} from &quot;./X74.sol&quot;;</span>
    7 |     | <span class='neutral'>import {zeroX216, X216} from &quot;./X216.sol&quot;;</span>
    8 |     | <span class='neutral'>import {PriceLibrary} from &quot;./Price.sol&quot;;</span>
    9 |     | <span class='neutral'></span>
   10 |     | <span class='neutral'>// (2 ** 240) * exp(-8)</span>
   11 |     | <span class='neutral'>uint256 constant EXP_INV_8_X240 = </span>
   12 | *   | <span class='executed'>  0x00000015FC21041027ACBBFCD46780FEE71EAD23FBCB7F4A81E58767EF801A32;</span>
   13 |     | <span class='neutral'></span>
   14 |     | <span class='unexecuted'>library IntegralLibrary {</span>
   15 |     | <span class='neutral'>  using PriceLibrary for uint256;</span>
   16 |     | <span class='neutral'></span>
   17 |     | <span class='neutral'>  /// @notice Let &#39;l&#39; and &#39;u&#39; denote the logarithmic prices whose offset binary</span>
   18 |     | <span class='neutral'>  /// &#39;X59&#39; representation is stored in the pointers &#39;price0&#39; and &#39;price1&#39;,</span>
   19 |     | <span class='neutral'>  /// respectively. In other words, define:</span>
   20 |     | <span class='neutral'>  ///</span>
   21 |     | <span class='neutral'>  ///               price0.log()                         price1.log()</span>
   22 |     | <span class='neutral'>  ///  l := - 16 + --------------    and    u := - 16 + --------------</span>
   23 |     | <span class='neutral'>  ///                 2 ** 59                              2 ** 59</span>
   24 |     | <span class='neutral'>  /// -------------------------------------------------------------------------</span>
   25 |     | <span class='neutral'>  /// If &#39;left == false&#39; this function transforms the given integral</span>
   26 |     | <span class='neutral'>  ///</span>
   27 |     | <span class='neutral'>  ///             / u</span>
   28 |     | <span class='neutral'>  ///            |      -h/2</span>
   29 |     | <span class='neutral'>  ///  input :=  |     e     f(h - l) dh</span>
   30 |     | <span class='neutral'>  ///            |</span>
   31 |     | <span class='neutral'>  ///           / l</span>
   32 |     | <span class='neutral'>  ///</span>
   33 |     | <span class='neutral'>  /// to the following:</span>
   34 |     | <span class='neutral'>  ///</span>
   35 |     | <span class='neutral'>  ///     / u                                     / u</span>
   36 |     | <span class='neutral'>  ///    |      +h/2                 +(l + u)/2  |      -h/2</span>
   37 |     | <span class='neutral'>  ///    |     e     f(u - h) dh == e            |     e     f(h - l) dh ==</span>
   38 |     | <span class='neutral'>  ///    |                                       |</span>
   39 |     | <span class='neutral'>  ///   / l                                     / l</span>
   40 |     | <span class='neutral'>  ///</span>
   41 |     | <span class='neutral'>  ///  exp(+ l / 2) * exp(+ u / 2) * input ==</span>
   42 |     | <span class='neutral'>  ///</span>
   43 |     | <span class='neutral'>  ///  (2**216) * exp(-8+l/2) * (2**216) * exp(-8+u/2) * input</span>
   44 |     | <span class='neutral'>  /// --------------------------------------------------------- == </span>
   45 |     | <span class='neutral'>  ///                     (2 ** 432) * exp(-16)</span>
   46 |     | <span class='neutral'>  ///</span>
   47 |     | <span class='neutral'>  ///  (2**216) * exp(-16+(l+16)/2) * (2**216) * exp(-16+(u+16)/2) * input</span>
   48 |     | <span class='neutral'>  /// --------------------------------------------------------------------- == </span>
   49 |     | <span class='neutral'>  ///                       (2 ** 432) * exp(-16)</span>
   50 |     | <span class='neutral'>  ///</span>
   51 |     | <span class='neutral'>  ///  price0.sqrt(true) * price1.sqrt(true) * input</span>
   52 |     | <span class='neutral'>  /// -----------------------------------------------</span>
   53 |     | <span class='neutral'>  ///             (2 ** 432) * exp(-16)</span>
   54 |     | <span class='neutral'>  ///</span>
   55 |     | <span class='neutral'>  /// -------------------------------------------------------------------------</span>
   56 |     | <span class='neutral'>  /// If &#39;left == true&#39; the integral</span>
   57 |     | <span class='neutral'>  ///</span>
   58 |     | <span class='neutral'>  ///             / u</span>
   59 |     | <span class='neutral'>  ///            |      +h/2</span>
   60 |     | <span class='neutral'>  ///  input :=  |     e     f(u - h) dh</span>
   61 |     | <span class='neutral'>  ///            |</span>
   62 |     | <span class='neutral'>  ///           / l</span>
   63 |     | <span class='neutral'>  ///</span>
   64 |     | <span class='neutral'>  /// is transformed to </span>
   65 |     | <span class='neutral'>  ///</span>
   66 |     | <span class='neutral'>  ///     / u                                     / u</span>
   67 |     | <span class='neutral'>  ///    |      -h/2                 -(l + u)/2  |      +h/2</span>
   68 |     | <span class='neutral'>  ///    |     e     f(h - l) dh == e            |     e     f(u - h) dh == </span>
   69 |     | <span class='neutral'>  ///    |                                       |</span>
   70 |     | <span class='neutral'>  ///   / l                                     / l</span>
   71 |     | <span class='neutral'>  ///</span>
   72 |     | <span class='neutral'>  ///  exp(- l / 2) * exp(- u / 2) * input ==</span>
   73 |     | <span class='neutral'>  ///</span>
   74 |     | <span class='neutral'>  ///  (2**216) * exp(-8-l/2) * (2**216) * exp(-8-u/2) * input</span>
   75 |     | <span class='neutral'>  /// --------------------------------------------------------- == </span>
   76 |     | <span class='neutral'>  ///                     (2 ** 432) * exp(-16)</span>
   77 |     | <span class='neutral'>  ///</span>
   78 |     | <span class='neutral'>  ///  (2**216) * exp(-(l+16)/2) * (2**216) * exp(-(u+16)/2) * input</span>
   79 |     | <span class='neutral'>  /// --------------------------------------------------------------- == </span>
   80 |     | <span class='neutral'>  ///                      (2 ** 432) * exp(-16)</span>
   81 |     | <span class='neutral'>  ///</span>
   82 |     | <span class='neutral'>  ///  price0.sqrt(false) * price1.sqrt(false) * input</span>
   83 |     | <span class='neutral'>  /// -------------------------------------------------</span>
   84 |     | <span class='neutral'>  ///              (2 ** 432) * exp(-16)</span>
   85 |     | <span class='neutral'>  ///</span>
   86 |     | <span class='neutral'>  /// -------------------------------------------------------------------------</span>
   87 |     | <span class='neutral'>  /// The following approximation is used:</span>
   88 |     | <span class='neutral'>  ///</span>
   89 |     | <span class='neutral'>  ///            1                   b * c * d</span>
   90 |     | <span class='neutral'>  /// ----------------------- ~ --------------------</span>
   91 |     | <span class='neutral'>  ///  (2 ** 432) * exp(-16)     (2 ** 256 - 1) * a</span>
   92 |     | <span class='neutral'>  ///</span>
   93 |     | <span class='neutral'>  /// where</span>
   94 |     | <span class='neutral'>  ///</span>
   95 |     | <span class='neutral'>  /// &#39;a == 0x5BC2A24E50A66D39C35A9132C33F2FC50A1B99389D5455E78A7CF7EF8894E4CD&#39;</span>
   96 |     | <span class='neutral'>  /// &#39;b == 0x4BC3287B&#39;, &#39;c == 0xCEF6AE8685&#39;, &#39;d == 0xCB21E499&#39;.</span>
   97 |     | <span class='neutral'>  ///</span>
   98 |     | <span class='neutral'>  /// &#39;integralInput&#39; should be non-negative and less than &#39;oneX216&#39;.</span>
   99 | *   | <span class='executed'>  function shift(</span>
  100 |     | <span class='neutral'>    X216 integralInput,</span>
  101 |     | <span class='neutral'>    uint256 price0,</span>
  102 |     | <span class='neutral'>    uint256 price1,</span>
  103 |     | <span class='neutral'>    bool left</span>
  104 |     | <span class='neutral'>  ) internal pure returns (</span>
  105 | *   | <span class='executed'>    X216 shiftedIntegral</span>
  106 |     | <span class='neutral'>  ) {</span>
  107 |     | <span class='neutral'>    // This boolean determines whether &#39;sqrt&#39; or &#39;sqrtInverse&#39; is returned by</span>
  108 |     | <span class='neutral'>    // &#39;PriceLibrary&#39;.</span>
  109 | *   | <span class='executed'>    bool right = !left;</span>
  110 | *   | <span class='executed'>    X216 p0 = price0.sqrt(right);</span>
  111 | *   | <span class='executed'>    X216 p1 = price1.sqrt(right);</span>
  112 |     | <span class='neutral'>    assembly {</span>
  113 |     | <span class='neutral'>      // All three multiplications are safe because &#39;integralInput&#39;, &#39;p0&#39; and</span>
  114 |     | <span class='neutral'>      // &#39;p1&#39; are read from 216 bits of memory and the outputs fit within 256</span>
  115 |     | <span class='neutral'>      // bits.</span>
  116 | *   | <span class='executed'>      integralInput := mul(0x4BC3287B, integralInput) // b * integralInput</span>
  117 | *   | <span class='executed'>      p0 := mul(0xCEF6AE8685, p0) // c * price0.sqrt(right)</span>
  118 | *   | <span class='executed'>      p1 := mul(0xCB21E499, p1) // d * price1.sqrt(right)</span>
  119 |     | <span class='neutral'></span>
  120 |     | <span class='neutral'>      // Next, we calculate</span>
  121 |     | <span class='neutral'>      // &#39;p0 * p1 / a == c * d * price0.sqrt(right) * price1.sqrt(right) / a&#39;.</span>
  122 |     | <span class='neutral'>      // Let &#39;s := p0 * p1 - (2 ** 256) * q&#39;.</span>
  123 |     | <span class='neutral'>      // Let &#39;r := p0 * p1 - a * p&#39;.</span>
  124 |     | <span class='neutral'>      // Then &#39;s - r == a * p&#39; [mod 2 ** 256]</span>
  125 |     | <span class='neutral'>      //</span>
  126 |     | <span class='neutral'>      // The output does not exceed 249 bits because both &#39;price0.sqrt(right)&#39;</span>
  127 |     | <span class='neutral'>      // and &#39;price1.sqrt(right)&#39; are less than &#39;oneX216&#39; and:</span>
  128 |     | <span class='neutral'>      // &#39;c * d * (1 &lt;&lt; 216) * (1 &lt;&lt; 216) / a &lt; 2 ** 249&#39;.</span>
  129 | *   | <span class='executed'>      shiftedIntegral := mul(</span>
  130 |     | <span class='neutral'>        // s - r</span>
  131 | *   | <span class='executed'>        sub(</span>
  132 |     | <span class='neutral'>          // s</span>
  133 | *   | <span class='executed'>          mul(p0, p1),</span>
  134 |     | <span class='neutral'>          // r</span>
  135 | *   | <span class='executed'>          mulmod(</span>
  136 | *   | <span class='executed'>            p0,</span>
  137 | *   | <span class='executed'>            p1,</span>
  138 |     | <span class='neutral'>            // a</span>
  139 | *   | <span class='executed'>            0x5BC2A24E50A66D39C35A9132C33F2FC50A1B99389D5455E78A7CF7EF8894E4CD</span>
  140 |     | <span class='neutral'>          )</span>
  141 |     | <span class='neutral'>        ),</span>
  142 |     | <span class='neutral'>        // modularInverse(a, 2 ** 256)</span>
  143 | *   | <span class='executed'>        0x7082326D62B7EF4D06861F13C21DD192C8044B19A121205B7DC63C2642B5A805</span>
  144 |     | <span class='neutral'>      )</span>
  145 |     | <span class='neutral'></span>
  146 |     | <span class='neutral'>      // Multiplication by &#39;integralInput / (2 ** 256 - 1)&#39;</span>
  147 | *   | <span class='executed'>      shiftedIntegral := sub(</span>
  148 |     | <span class='neutral'>        // r == x * y - (2 ** 256 - 1) * q</span>
  149 | *   | <span class='executed'>        mulmod(shiftedIntegral, integralInput, not(0)),</span>
  150 |     | <span class='neutral'>        // s == x * y - (2 ** 256) * p</span>
  151 | *   | <span class='executed'>        mul(shiftedIntegral, integralInput)</span>
  152 |     | <span class='neutral'>      )</span>
  153 |     | <span class='neutral'>    }</span>
  154 | *   | <span class='executed'>    return shiftedIntegral;</span>
  155 |     | <span class='neutral'>  }</span>
  156 |     | <span class='neutral'></span>
  157 |     | <span class='neutral'>  /// @notice Returns an integral value given its memory pointer.</span>
  158 |     | <span class='neutral'>  /// Notice that due to an &#39;exp(-8) / 2&#39; factor, integral values are always</span>
  159 |     | <span class='neutral'>  /// less than &#39;oneX216&#39;. This is because:</span>
  160 |     | <span class='neutral'>  ///</span>
  161 |     | <span class='neutral'>  ///               / +16                         / +16</span>
  162 |     | <span class='neutral'>  ///   exp(-8)    |      +h/2        exp(-8)    |      -h/2</span>
  163 |     | <span class='neutral'>  ///  --------- x |     e     dh == --------- x |     e     dh &lt; 1</span>
  164 |     | <span class='neutral'>  ///      2       |                     2       |</span>
  165 |     | <span class='neutral'>  ///             / -16                         / -16</span>
  166 |     | <span class='neutral'>  ///</span>
  167 | *   | <span class='executed'>  function integral(</span>
  168 |     | <span class='neutral'>    uint256 pointer</span>
  169 |     | <span class='neutral'>  ) internal pure returns (</span>
  170 | *   | <span class='executed'>    X216 value</span>
  171 |     | <span class='neutral'>  ) {</span>
  172 |     | <span class='neutral'>    assembly {</span>
  173 |     | <span class='neutral'>      // The slot whose most significant 160 bits host the integral value is</span>
  174 |     | <span class='neutral'>      // loaded and then the least significant 40 bits are discarded via a 40</span>
  175 |     | <span class='neutral'>      // bit shift to the right.</span>
  176 | *   | <span class='executed'>      value := shr(40, mload(pointer))</span>
  177 |     | <span class='neutral'>    }</span>
  178 |     | <span class='neutral'>  }</span>
  179 |     | <span class='neutral'></span>
  180 |     | <span class='neutral'>  /// @notice Writes an integral value in a memory pointer.</span>
  181 |     | <span class='neutral'>  /// &#39;pointer&#39; should not be less than &#39;32&#39;.</span>
  182 |     | <span class='neutral'>  /// &#39;integralValue&#39; should be less than &#39;oneX216&#39;.</span>
  183 | *   | <span class='executed'>  function setIntegral(</span>
  184 |     | <span class='neutral'>    uint256 pointer,</span>
  185 |     | <span class='neutral'>    X216 integralValue</span>
  186 |     | <span class='neutral'>  ) internal pure {</span>
  187 | *   | <span class='executed'>    assembly {</span>
  188 |     | <span class='neutral'>      // The preceding slot is cached so that it can be restored after we place</span>
  189 |     | <span class='neutral'>      // the integral value in the appropriate memory location.</span>
  190 |     | <span class='neutral'>      // The subtraction is safe because of the input requirement on &#39;pointer&#39;.</span>
  191 | *   | <span class='executed'>      let precedingPointer := sub(pointer, 32)</span>
  192 | *   | <span class='executed'>      let precedingSlot := mload(precedingPointer)</span>
  193 |     | <span class='neutral'></span>
  194 |     | <span class='neutral'>      // We move 5 bytes backward (40 bits) to point to the slot whose least</span>
  195 |     | <span class='neutral'>      // significant 216 bits are supposed to host &#39;integralValue&#39;.</span>
  196 |     | <span class='neutral'>      // &#39;216 - 256&#39; bits == &#39;-40&#39; bits == &#39;-5&#39; bytes.</span>
  197 | *   | <span class='executed'>      mstore(sub(pointer, 5), integralValue)</span>
  198 |     | <span class='neutral'></span>
  199 |     | <span class='neutral'>      // The preceding slot is restored.</span>
  200 | *   | <span class='executed'>      mstore(precedingPointer, precedingSlot)</span>
  201 |     | <span class='neutral'>    }</span>
  202 |     | <span class='neutral'>  }</span>
  203 |     | <span class='neutral'></span>
  204 |     | <span class='neutral'>  /// @notice Adds a given increment to an integral stored in the given memory </span>
  205 |     | <span class='neutral'>  /// pointer.</span>
  206 |     | <span class='neutral'>  /// Overflow should be avoided externally.</span>
  207 | *   | <span class='executed'>  function incrementIntegral(</span>
  208 |     | <span class='neutral'>    uint256 pointer,</span>
  209 |     | <span class='neutral'>    X216 increment</span>
  210 |     | <span class='neutral'>  ) internal pure {</span>
  211 |     | <span class='neutral'>    assembly {</span>
  212 |     | <span class='neutral'>      // The increment is shifted to the left by 40 bits to be added to the</span>
  213 |     | <span class='neutral'>      // integral value in memory. In other words, the following slot is</span>
  214 |     | <span class='neutral'>      // loaded:</span>
  215 |     | <span class='neutral'>      //</span>
  216 |     | <span class='neutral'>      //   +-------------------+----------------------------------------------+</span>
  217 |     | <span class='neutral'>      //   | 216 bit integral  | 40 additional bits that should remain intact |</span>
  218 |     | <span class='neutral'>      //   +-------------------+----------------------------------------------+</span>
  219 |     | <span class='neutral'>      //   |</span>
  220 |     | <span class='neutral'>      // pointer</span>
  221 |     | <span class='neutral'>      //</span>
  222 |     | <span class='neutral'>      // and added to:</span>
  223 |     | <span class='neutral'>      //</span>
  224 |     | <span class='neutral'>      //   +-------------------+----------------------------------------------+</span>
  225 |     | <span class='neutral'>      //   | 216 bit increment |          40 additional zero bits             |</span>
  226 |     | <span class='neutral'>      //   +-------------------+----------------------------------------------+</span>
  227 |     | <span class='neutral'>      //</span>
  228 |     | <span class='neutral'>      // The result is then stored in memory using the same pointer.</span>
  229 |     | <span class='neutral'>      // The addition is safe because overflow is handled externally.</span>
  230 | *   | <span class='executed'>      mstore(pointer, add(mload(pointer), shl(40, increment)))</span>
  231 |     | <span class='neutral'>    }</span>
  232 |     | <span class='neutral'>  }</span>
  233 |     | <span class='neutral'></span>
  234 |     | <span class='neutral'>  /// @notice Subtracts a given decrement from an integral stored in the given</span>
  235 |     | <span class='neutral'>  /// memory pointer.</span>
  236 |     | <span class='neutral'>  /// Underflow should be avoided externally.</span>
  237 | *   | <span class='executed'>  function decrementIntegral(</span>
  238 |     | <span class='neutral'>    uint256 pointer,</span>
  239 |     | <span class='neutral'>    X216 decrement</span>
  240 |     | <span class='neutral'>  ) internal pure {</span>
  241 |     | <span class='neutral'>    assembly {</span>
  242 |     | <span class='neutral'>      // The decrement is shifted to the left by 40 bits to be subtracted from</span>
  243 |     | <span class='neutral'>      // the integral value in memory. In other words, the following slot is</span>
  244 |     | <span class='neutral'>      // loaded:</span>
  245 |     | <span class='neutral'>      //</span>
  246 |     | <span class='neutral'>      //   --------------------------------------------------------------------</span>
  247 |     | <span class='neutral'>      //   | 216 bit integral  | 40 additional bits that should remain intact |</span>
  248 |     | <span class='neutral'>      //   +-------------------------------------------------------------------</span>
  249 |     | <span class='neutral'>      //   |</span>
  250 |     | <span class='neutral'>      // pointer</span>
  251 |     | <span class='neutral'>      //</span>
  252 |     | <span class='neutral'>      // and the following value is subtracted from the loaded slot:</span>
  253 |     | <span class='neutral'>      //</span>
  254 |     | <span class='neutral'>      //   --------------------------------------------------------------------</span>
  255 |     | <span class='neutral'>      //   | 216 bit increment |          40 additional zero bits             |</span>
  256 |     | <span class='neutral'>      //   --------------------------------------------------------------------</span>
  257 |     | <span class='neutral'>      //</span>
  258 |     | <span class='neutral'>      // The result is then stored in memory using the same pointer.</span>
  259 |     | <span class='neutral'>      // The subtraction is safe because underflow is handled externally.</span>
  260 | *   | <span class='executed'>      mstore(pointer, sub(mload(pointer), shl(40, decrement)))</span>
  261 |     | <span class='neutral'>    }</span>
  262 |     | <span class='neutral'>  }</span>
  263 |     | <span class='neutral'></span>
  264 |     | <span class='neutral'>  /// @notice Let &#39;q&#39; denote the logarithmic price whose offset binary &#39;X59&#39;</span>
  265 |     | <span class='neutral'>  /// representation is stored in the pointer &#39;targetPrice&#39;. In other words,</span>
  266 |     | <span class='neutral'>  /// define:</span>
  267 |     | <span class='neutral'>  ///</span>
  268 |     | <span class='neutral'>  ///               targetPrice.log()</span>
  269 |     | <span class='neutral'>  ///  q := - 16 + -------------------</span>
  270 |     | <span class='neutral'>  ///                   2 ** 59</span>
  271 |     | <span class='neutral'>  ///</span>
  272 |     | <span class='neutral'>  /// Additionally, let &#39;(b0, c0)&#39; and &#39;(b1, c1)&#39; represent the segment</span>
  273 |     | <span class='neutral'>  /// coordinates to be loaded from the memory via the pointers</span>
  274 |     | <span class='neutral'>  /// &#39;coordinates0 := segmentCoordinates&#39; and</span>
  275 |     | <span class='neutral'>  /// &#39;coordinates1 := segmentCoordinates + 64&#39;, respectively. More precisely:</span>
  276 |     | <span class='neutral'>  ///</span>
  277 |     | <span class='neutral'>  ///                coordinates0.log()           coordinates0.height()</span>
  278 |     | <span class='neutral'>  ///  b0 := - 16 + --------------------,  c0 := -----------------------</span>
  279 |     | <span class='neutral'>  ///                     2 ** 59                        2 ** 15</span>
  280 |     | <span class='neutral'>  ///</span>
  281 |     | <span class='neutral'>  ///                coordinates1.log()           coordinates1.height()</span>
  282 |     | <span class='neutral'>  ///  b1 := - 16 + --------------------,  c1 := -----------------------</span>
  283 |     | <span class='neutral'>  ///                     2 ** 59                        2 ** 15</span>
  284 |     | <span class='neutral'>  ///</span>
  285 |     | <span class='neutral'>  /// -------------------------------------------------------------------------</span>
  286 |     | <span class='neutral'>  /// This function evaluates the following and returns the resulting</span>
  287 |     | <span class='neutral'>  /// value in &#39;X216&#39; representation:</span>
  288 |     | <span class='neutral'>  ///</span>
  289 |     | <span class='neutral'>  ///                                      c1 - c0</span>
  290 |     | <span class='neutral'>  ///  (2 ** 216) * (exp(-8) / 2) * (c0 + --------- (q - b0))</span>
  291 |     | <span class='neutral'>  ///                                      b1 - b0</span>
  292 |     | <span class='neutral'>  ///</span>
  293 |     | <span class='neutral'>  /// We should have: &#39;c0 &lt;= c1 &lt;= oneX15&#39;.</span>
  294 |     | <span class='neutral'>  /// We should have: &#39;min(b0, b1) &lt;= q &lt;= max(b0, b1) &lt; thirtyTwoX59&#39;.</span>
  295 |     | <span class='neutral'>  /// We should have: &#39;b0 != b1&#39;.</span>
  296 | *   | <span class='executed'>  function evaluate(</span>
  297 |     | <span class='neutral'>    uint256 segmentCoordinates,</span>
  298 |     | <span class='neutral'>    uint256 targetPrice</span>
  299 |     | <span class='neutral'>  ) internal pure returns (</span>
  300 | *   | <span class='executed'>    X216 value</span>
  301 |     | <span class='neutral'>  ) {</span>
  302 |     | <span class='neutral'>    // Loads the segment coordinates from the memory. &#39;(b0, c0)&#39; are loaded</span>
  303 |     | <span class='neutral'>    // using &#39;pointer = segmentCoordinates&#39; and &#39;(b1, c1)&#39; are loaded using</span>
  304 |     | <span class='neutral'>    // &#39;pointer = segmentCoordinates + 64&#39;.</span>
  305 | *   | <span class='executed'>    (X59 b0, X59 b1, X15 c0, X15 c1) = segmentCoordinates.segment();</span>
  306 |     | <span class='neutral'></span>
  307 |     | <span class='neutral'>    // In this case, because of the input requirement &#39;c0 &lt;= c1&#39;, we have </span>
  308 |     | <span class='neutral'>    // &#39;c0 == c1 == zeroX15&#39; and the output should be &#39;zeroX216&#39;.</span>
  309 | *   | <span class='executed'>    if (c1 == zeroX15) return value;</span>
  310 |     | <span class='neutral'></span>
  311 |     | <span class='neutral'>    // If &#39;c1 == c0&#39;, we multiply &#39;c0&#39; by &#39;exp(-8) / 2&#39; and return.</span>
  312 |     | <span class='neutral'>    // The multiplication is safe because &#39;c0&#39; is a 16 bit (read from memory) </span>
  313 |     | <span class='neutral'>    // non-negative value and &#39;EXP_INV_8_X240&#39; is 229 bits.</span>
  314 | *   | <span class='executed'>    if (c1 == c0) {</span>
  315 |     | <span class='neutral'>      assembly {</span>
  316 |     | <span class='neutral'>        // The last &#39;40&#39; bits are discarded because</span>
  317 |     | <span class='neutral'>        // &#39;216 - 240 - 15 - 1 == - 40&#39;, where &#39;216&#39; appears because the output</span>
  318 |     | <span class='neutral'>        // should follow the &#39;X216&#39; representation, &#39;240&#39; cancels the </span>
  319 |     | <span class='neutral'>        // &#39;1 &lt;&lt; 240&#39; factor in &#39;EXP_INV_8_X240&#39;, &#39;15&#39; cancels the &#39;X15&#39;</span>
  320 |     | <span class='neutral'>        // representation of &#39;c0&#39;, and &#39;1&#39; accounts for the denominator of</span>
  321 |     | <span class='neutral'>        // &#39;exp(-8) / 2&#39;.</span>
  322 | *   | <span class='executed'>        value := shr(40, mul(c0, EXP_INV_8_X240))</span>
  323 |     | <span class='neutral'>      }</span>
  324 | *   | <span class='executed'>      return value;</span>
  325 |     | <span class='neutral'>    }</span>
  326 |     | <span class='neutral'></span>
  327 |     | <span class='neutral'>    // If &#39;b1 == q&#39;, the solution is equal to:</span>
  328 |     | <span class='neutral'>    //</span>
  329 |     | <span class='neutral'>    //                                      c1 - c0</span>
  330 |     | <span class='neutral'>    //  (2 ** 216) * (exp(-8) / 2) * (c0 + --------- (b1 - b0)) ==</span>
  331 |     | <span class='neutral'>    //                                      b1 - b0</span>
  332 |     | <span class='neutral'>    //</span>
  333 |     | <span class='neutral'>    //  (2 ** 216) * (exp(-8) / 2) * c1</span>
  334 |     | <span class='neutral'>    //</span>
  335 |     | <span class='neutral'>    // Hence, we just multiply &#39;c1&#39; by &#39;exp(-8) / 2&#39; and return.</span>
  336 |     | <span class='neutral'>    // The multiplication is safe because &#39;c1&#39; is a 16 bit (read from memory) </span>
  337 |     | <span class='neutral'>    // non-negative value and &#39;EXP_INV_8_X240&#39; is 229 bits.</span>
  338 | *   | <span class='executed'>    if (b1 == targetPrice.log()) {</span>
  339 |     | <span class='neutral'>      assembly {</span>
  340 |     | <span class='neutral'>        // As argued above, the last &#39;40&#39; bits are discarded because</span>
  341 |     | <span class='neutral'>        // &#39;216 - 240 - 15 - 1 == - 40&#39;, where &#39;216&#39; appears because the output</span>
  342 |     | <span class='neutral'>        // should follow the &#39;X216&#39; representation, &#39;240&#39; cancels the </span>
  343 |     | <span class='neutral'>        // &#39;1 &lt;&lt; 240&#39; factor in &#39;EXP_INV_8_X240&#39;, &#39;15&#39; cancels the &#39;X15&#39;</span>
  344 |     | <span class='neutral'>        // representation of &#39;c1&#39;, and &#39;1&#39; accounts for the denominator of</span>
  345 |     | <span class='neutral'>        // &#39;exp(-8) / 2&#39;.</span>
  346 | *   | <span class='executed'>        value := shr(40, mul(c1, EXP_INV_8_X240))</span>
  347 |     | <span class='neutral'>      }</span>
  348 | *   | <span class='executed'>      return value;</span>
  349 |     | <span class='neutral'>    }</span>
  350 |     | <span class='neutral'></span>
  351 |     | <span class='neutral'>    // If &#39;b1 &lt; b0&#39;, the subtraction &#39;b0 - b1&#39; is safe and the subtraction</span>
  352 |     | <span class='neutral'>    // &#39;b0 - targetPrice.log()&#39; is also safe due to the input requirement:</span>
  353 |     | <span class='neutral'>    // &#39;q &lt;= max(b0, b1)&#39;.</span>
  354 |     | <span class='neutral'>    //</span>
  355 |     | <span class='neutral'>    // If &#39;b1 &gt;= b0&#39;, the subtraction &#39;b1 - b0&#39; is safe and the subtraction</span>
  356 |     | <span class='neutral'>    // &#39;targetPrice.log() - b0&#39; is also safe due to the input requirement:</span>
  357 |     | <span class='neutral'>    // &#39;min(b0, b1) &lt;= q&#39;.</span>
  358 |     | <span class='neutral'>    //</span>
  359 |     | <span class='neutral'>    // The subtraction &#39;c1 - c0&#39; is safe because of the input requirement</span>
  360 |     | <span class='neutral'>    // &#39;c0 &lt;= c1&#39;. The multiplication is also safe because &#39;|q - b0|&#39; and</span>
  361 |     | <span class='neutral'>    // &#39;c1 - c0&#39; are both non-negative and occupy up to &#39;64&#39; and &#39;16&#39; bits,</span>
  362 |     | <span class='neutral'>    // respectively.</span>
  363 |     | <span class='neutral'>    //</span>
  364 |     | <span class='neutral'>    // The signed comparison of &#39;b0&#39; and &#39;b1&#39; is valid because both are 64 bit</span>
  365 |     | <span class='neutral'>    // (read from memory) non-negative values.</span>
  366 | *   | <span class='executed'>    (X59 db, X74 numerator) = (b1 &lt; b0) ? </span>
  367 | *   | <span class='executed'>      (b0 - b1, (b0 - targetPrice.log()).times(c1 - c0)) : </span>
  368 | *   | <span class='executed'>      (b1 - b0, (targetPrice.log() - b0).times(c1 - c0));</span>
  369 |     | <span class='neutral'></span>
  370 |     | <span class='neutral'>    // Next, we calculate </span>
  371 |     | <span class='neutral'>    // &#39;(exp(-8) / 2) * (c0 + |q - b0| * (c1 - c0) / db)&#39;</span>
  372 |     | <span class='neutral'>    // where &#39;db = |b1 - b0|&#39;.</span>
  373 | *   | <span class='executed'>    assembly {</span>
  374 |     | <span class='neutral'>      // The 320 bit product &#39;EXP_INV_8_X240 * numerator&#39; is calculated first, </span>
  375 |     | <span class='neutral'>      // where &#39;numerator = |q - b0| * (c1 - c0)&#39;.</span>
  376 |     | <span class='neutral'></span>
  377 |     | <span class='neutral'>      // The least significant 192-bits of the product </span>
  378 |     | <span class='neutral'>      // &#39;EXP_INV_8_X240 * numerator&#39;. This multiplication is in &#39;X314&#39;</span>
  379 |     | <span class='neutral'>      // representation because &#39;240 + 74 == 314&#39;.</span>
  380 | *   | <span class='executed'>      let lsbitsX314 := mulmod(EXP_INV_8_X240, numerator, shl(192, 1))</span>
  381 |     | <span class='neutral'></span>
  382 |     | <span class='neutral'>      // The most significant 128-bits of the product </span>
  383 |     | <span class='neutral'>      // &#39;EXP_INV_8_X240 * numerator&#39;.</span>
  384 |     | <span class='neutral'>      // &#39;r == EXP_INV_8_X240 * numerator - (2 ** 192 - 1) * q&#39;</span>
  385 |     | <span class='neutral'>      // &#39;lsbitsX314 == EXP_INV_8_X240 * numerator - (2 ** 192) * p&#39;</span>
  386 |     | <span class='neutral'>      // &#39;r - lsbitsX314 == p&#39; [mod 2 ** 192 - 1]</span>
  387 | *   | <span class='executed'>      let msbitsX314 := addmod(</span>
  388 |     | <span class='neutral'>        // r</span>
  389 | *   | <span class='executed'>        mulmod(EXP_INV_8_X240, numerator, sub(shl(192, 1), 1)),</span>
  390 |     | <span class='neutral'>        // 0 - lsbitsX314 [mod 2 ** 192 - 1]</span>
  391 |     | <span class='neutral'>        // The subtraction is safe because &#39;lsbitsX314&#39; does not exceed 192</span>
  392 |     | <span class='neutral'>        // bits.</span>
  393 | *   | <span class='executed'>        sub(sub(shl(192, 1), 1), lsbitsX314),</span>
  394 | *   | <span class='executed'>        sub(shl(192, 1), 1)</span>
  395 |     | <span class='neutral'>      )</span>
  396 |     | <span class='neutral'></span>
  397 |     | <span class='neutral'>      // Here, we perform the division by &#39;db&#39; via the simple long division</span>
  398 |     | <span class='neutral'>      // algorithm, i.e., &#39;(2 ** 192) * msbitsX314 + lsbitsX314&#39; divided by</span>
  399 |     | <span class='neutral'>      // &#39;db&#39; becomes:</span>
  400 |     | <span class='neutral'>      //</span>
  401 |     | <span class='neutral'>      //                 q1X255         q0X255</span>
  402 |     | <span class='neutral'>      //      ---------------------------------</span>
  403 |     | <span class='neutral'>      // db   |      msbitsX314     lsbitsX314</span>
  404 |     | <span class='neutral'>      //      |</span>
  405 |     | <span class='neutral'>      //            q1X255 * db </span>
  406 |     | <span class='neutral'>      //        -------------------------------</span>
  407 |     | <span class='neutral'>      //        msbitsX314 % db     lsbitsX314</span>
  408 |     | <span class='neutral'>      //</span>
  409 |     | <span class='neutral'>      //                           q0X255 * db</span>
  410 |     | <span class='neutral'>      //        -------------------------------</span>
  411 |     | <span class='neutral'>      //                                     r</span>
  412 |     | <span class='neutral'>      //</span>
  413 |     | <span class='neutral'>      // where </span>
  414 |     | <span class='neutral'>      // &#39;r := (msbitsX314 * (2 ** 192) + lsbitsX314) % db&#39;</span>
  415 |     | <span class='neutral'>      // &#39;q1X255 := msbitsX314 / db&#39;</span>
  416 |     | <span class='neutral'>      // &#39;q0X255 := ((msbits % db) * (2 ** 192) + lsbitsX314) / db&#39;</span>
  417 | *   | <span class='executed'>      let quotientX255 := add(</span>
  418 |     | <span class='neutral'>        // First, we calculate &#39;q1X255 &lt;&lt; 192&#39; which the more significant part</span>
  419 |     | <span class='neutral'>        // of the quotient.</span>
  420 |     | <span class='neutral'>        //</span>
  421 |     | <span class='neutral'>        // The division &#39;msbitsX314 / db&#39; is safe because &#39;db != 0&#39; due to an</span>
  422 |     | <span class='neutral'>        // input requirement.</span>
  423 |     | <span class='neutral'>        //</span>
  424 |     | <span class='neutral'>        // The 192-bit shift does not overflow because &#39;|q - b0| &lt;= db&#39; and</span>
  425 |     | <span class='neutral'>        // therefore:</span>
  426 |     | <span class='neutral'>        // </span>
  427 |     | <span class='neutral'>        // &#39;msbitsX314 / db =</span>
  428 |     | <span class='neutral'>        //  ((EXP_INV_8_X240 * |q - b0| * (c1 - c0)) &gt;&gt; 192) / db &lt;= </span>
  429 |     | <span class='neutral'>        //  ((EXP_INV_8_X240 * db * (c1 - c0)) &gt;&gt; 192) / db == </span>
  430 |     | <span class='neutral'>        //  ((EXP_INV_8_X240 * (c1 - c0)) &gt;&gt; 192) &lt;</span>
  431 |     | <span class='neutral'>        //  (2 ** (229 + 16)) &gt;&gt; 192 == 2 ** 53&#39;</span>
  432 |     | <span class='neutral'>        //</span>
  433 |     | <span class='neutral'>        // Hence, &#39;msbitsX314 / db&#39; does not exceed &#39;53&#39; bits.</span>
  434 | *   | <span class='executed'>        shl(192, div(msbitsX314, db)),</span>
  435 |     | <span class='neutral'>        // Then, we calculate &#39;q0X255&#39; which the least significant 192 bits of</span>
  436 |     | <span class='neutral'>        // the quotientX255.</span>
  437 |     | <span class='neutral'>        //</span>
  438 |     | <span class='neutral'>        // The division by &#39;db&#39; is safe because &#39;db != 0&#39; due to an input</span>
  439 |     | <span class='neutral'>        // requirement.</span>
  440 | *   | <span class='executed'>        div(</span>
  441 |     | <span class='neutral'>          // The addition is safe because &#39;lsbitsX314&#39; and &#39;db&#39; do not exceed</span>
  442 |     | <span class='neutral'>          // &#39;192&#39; and &#39;64 &#39;bits, respectively.</span>
  443 | *   | <span class='executed'>          add(</span>
  444 |     | <span class='neutral'>            // The shift does not overflow because </span>
  445 |     | <span class='neutral'>            // &#39;msbitsX314 % db &lt; db &lt; 2 ** 64&#39;.</span>
  446 | *   | <span class='executed'>            shl(192, mod(msbitsX314, db)),</span>
  447 | *   | <span class='executed'>            lsbitsX314</span>
  448 |     | <span class='neutral'>          ),</span>
  449 | *   | <span class='executed'>          db</span>
  450 |     | <span class='neutral'>        )</span>
  451 |     | <span class='neutral'>      )</span>
  452 |     | <span class='neutral'></span>
  453 |     | <span class='neutral'>      // Lastly, we need to add &#39;(exp(-8) / 2) * c0&#39;.</span>
  454 |     | <span class='neutral'>      //</span>
  455 |     | <span class='neutral'>      // This addition is also safe because:</span>
  456 |     | <span class='neutral'>      //</span>
  457 |     | <span class='neutral'>      //        c1 - c0                    c1 - c0</span>
  458 |     | <span class='neutral'>      //  c0 + --------- (q - b0) &lt;= c0 + --------- (b1 - b0) &lt;= c1</span>
  459 |     | <span class='neutral'>      //        b1 - b0                    b1 - b0</span>
  460 |     | <span class='neutral'>      //</span>
  461 |     | <span class='neutral'>      // Hence the output of &#39;add&#39; is bounded by &#39;mul(c1, EXP_INV_8_X240)&#39;</span>
  462 |     | <span class='neutral'>      // which does not overflow because &#39;c1 &lt;= oneX15&#39; and &#39;EXP_INV_8_X240&#39;</span>
  463 |     | <span class='neutral'>      // has 229 bits.</span>
  464 |     | <span class='neutral'>      //</span>
  465 |     | <span class='neutral'>      // As argued above, the last &#39;40&#39; bits are discarded because</span>
  466 |     | <span class='neutral'>      // &#39;216 - 240 - 15 - 1 == - 40&#39;, where &#39;216&#39; appears because the output</span>
  467 |     | <span class='neutral'>      // should follow the &#39;X216&#39; representation, &#39;240&#39; cancels the </span>
  468 |     | <span class='neutral'>      // &#39;1 &lt;&lt; 240&#39; factor in &#39;EXP_INV_8_X240&#39;, &#39;15&#39; cancels the &#39;X15&#39;</span>
  469 |     | <span class='neutral'>      // representation of &#39;c0&#39; and &#39;c1&#39;, and &#39;1&#39; accounts for the denominator</span>
  470 |     | <span class='neutral'>      // of &#39;exp(-8) / 2&#39;.</span>
  471 | *   | <span class='executed'>      value := shr(40, add(mul(c0, EXP_INV_8_X240), quotientX255))</span>
  472 |     | <span class='neutral'>    }</span>
  473 |     | <span class='neutral'>  }</span>
  474 |     | <span class='neutral'></span>
  475 |     | <span class='neutral'>  /// @notice Let &#39;f&#39; and &#39;t&#39; denote the logPrice values whose offset binary</span>
  476 |     | <span class='neutral'>  /// &#39;X59&#39; representation is stored in the pointers &#39;from&#39; and &#39;to&#39;,</span>
  477 |     | <span class='neutral'>  /// respectively. In other words, define:</span>
  478 |     | <span class='neutral'>  ///</span>
  479 |     | <span class='neutral'>  ///               from.log()                          to.log()</span>
  480 |     | <span class='neutral'>  ///  f := - 16 + ------------    and    t := - 16 + ------------</span>
  481 |     | <span class='neutral'>  ///                2 ** 59                            2 ** 59</span>
  482 |     | <span class='neutral'>  ///</span>
  483 |     | <span class='neutral'>  /// Additionally, let &#39;(b0, c0)&#39; and &#39;(b1, c1)&#39; represent the segment</span>
  484 |     | <span class='neutral'>  /// coordinates to be loaded from the memory via the pointers</span>
  485 |     | <span class='neutral'>  /// &#39;coordinates0&#39; and &#39;coordinates1 := coordinates0 + 64&#39;, respectively.</span>
  486 |     | <span class='neutral'>  /// More precisely:</span>
  487 |     | <span class='neutral'>  ///</span>
  488 |     | <span class='neutral'>  ///               coordinates0.log()           coordinates0.height()</span>
  489 |     | <span class='neutral'>  /// b0 := - 16 + --------------------,  c0 := -----------------------</span>
  490 |     | <span class='neutral'>  ///                    2 ** 59                        2 ** 15</span>
  491 |     | <span class='neutral'>  ///</span>
  492 |     | <span class='neutral'>  ///               coordinates1.log()           coordinates1.height()</span>
  493 |     | <span class='neutral'>  /// b1 := - 16 + --------------------,  c1 := -----------------------</span>
  494 |     | <span class='neutral'>  ///                    2 ** 59                        2 ** 15</span>
  495 |     | <span class='neutral'>  ///</span>
  496 |     | <span class='neutral'>  /// -------------------------------------------------------------------------</span>
  497 |     | <span class='neutral'>  /// If &#39;f &lt; t&#39; this function calculates:</span>
  498 |     | <span class='neutral'>  ///</span>
  499 |     | <span class='neutral'>  ///                                / t</span>
  500 |     | <span class='neutral'>  ///                               |     -h/2         c1 - c0</span>
  501 |     | <span class='neutral'>  ///  (2 ** 216) * (exp(-8) / 2) * |    e      (c0 + --------- (h - b0)) dh</span>
  502 |     | <span class='neutral'>  ///                               |                  b1 - b0</span>
  503 |     | <span class='neutral'>  ///                              / f</span>
  504 |     | <span class='neutral'>  ///</span>
  505 |     | <span class='neutral'>  /// In this case, the following closed-form formula is used:</span>
  506 |     | <span class='neutral'>  ///</span>
  507 |     | <span class='neutral'>  ///  (2 ** 216) * exp(-8) * (</span>
  508 |     | <span class='neutral'>  ///                                          c1 - c0</span>
  509 |     | <span class='neutral'>  ///    c0 * (exp(- f / 2) - exp(- t / 2)) + --------- * </span>
  510 |     | <span class='neutral'>  ///                                          b1 - b0</span>
  511 |     | <span class='neutral'>  ///</span>
  512 |     | <span class='neutral'>  ///    ((f - b0 + 2) * exp(- f / 2) - (t - b0 + 2) * exp(- t / 2))</span>
  513 |     | <span class='neutral'>  ///  )</span>
  514 |     | <span class='neutral'>  ///</span>
  515 |     | <span class='neutral'>  ///  == c0 * ((2 ** 216) * exp(- 8 - f / 2) - (2 ** 216) * exp(- 8 - t / 2))</span>
  516 |     | <span class='neutral'>  ///</span>
  517 |     | <span class='neutral'>  ///       c1 - c0</span>
  518 |     | <span class='neutral'>  ///    + --------- * ((f - b0 + 2) * (2 ** 216) * exp(- 8 - f / 2) - </span>
  519 |     | <span class='neutral'>  ///       b1 - b0</span>
  520 |     | <span class='neutral'>  ///                   (t - b0 + 2) * (2 ** 216) * exp(- 8 - t / 2))</span>
  521 |     | <span class='neutral'>  ///</span>
  522 |     | <span class='neutral'>  ///  == c0 * (from.sqrt(false) - to.sqrt(false))</span>
  523 |     | <span class='neutral'>  ///</span>
  524 |     | <span class='neutral'>  ///       c1 - c0</span>
  525 |     | <span class='neutral'>  ///    + --------- * ((f - b0 + 2) * from.sqrt(false) - </span>
  526 |     | <span class='neutral'>  ///       b1 - b0</span>
  527 |     | <span class='neutral'>  ///                   (t - b0 + 2) * to.sqrt(false))</span>
  528 |     | <span class='neutral'>  ///</span>
  529 |     | <span class='neutral'>  /// -------------------------------------------------------------------------</span>
  530 |     | <span class='neutral'>  /// If &#39;t &lt; f&#39; this function calculates:</span>
  531 |     | <span class='neutral'>  ///</span>
  532 |     | <span class='neutral'>  ///                                / f</span>
  533 |     | <span class='neutral'>  ///                               |     +h/2         c1 - c0</span>
  534 |     | <span class='neutral'>  ///  (2 ** 216) * (exp(-8) / 2) * |    e      (c0 + --------- (b0 - h)) dh</span>
  535 |     | <span class='neutral'>  ///                               |                  b0 - b1</span>
  536 |     | <span class='neutral'>  ///                              / t</span>
  537 |     | <span class='neutral'>  ///</span>
  538 |     | <span class='neutral'>  /// In this case, the following closed-form formula is used:</span>
  539 |     | <span class='neutral'>  ///</span>
  540 |     | <span class='neutral'>  ///  (2 ** 216) * exp(-8) * (</span>
  541 |     | <span class='neutral'>  ///                                          c1 - c0</span>
  542 |     | <span class='neutral'>  ///    c0 * (exp(+ f / 2) - exp(+ t / 2)) + --------- * </span>
  543 |     | <span class='neutral'>  ///                                          b0 - b1</span>
  544 |     | <span class='neutral'>  ///</span>
  545 |     | <span class='neutral'>  ///    ((b0 - f + 2) * exp(+ f / 2) - (b0 - t + 2) * exp(+ t / 2))</span>
  546 |     | <span class='neutral'>  ///  )</span>
  547 |     | <span class='neutral'>  ///</span>
  548 |     | <span class='neutral'>  ///  == c0 * ((2 ** 216) * exp(- 8 + f / 2) - (2 ** 216) * exp(- 8 + t / 2))</span>
  549 |     | <span class='neutral'>  ///</span>
  550 |     | <span class='neutral'>  ///       c1 - c0</span>
  551 |     | <span class='neutral'>  ///    + --------- * ((b0 - f + 2) * (2 ** 216) * exp(- 8 + f / 2) - </span>
  552 |     | <span class='neutral'>  ///       b0 - b1</span>
  553 |     | <span class='neutral'>  ///                   (b0 - t + 2) * (2 ** 216) * exp(- 8 + t / 2))</span>
  554 |     | <span class='neutral'>  ///</span>
  555 |     | <span class='neutral'>  ///  == c0 * (from.sqrt(true) - to.sqrt(true))</span>
  556 |     | <span class='neutral'>  ///</span>
  557 |     | <span class='neutral'>  ///       c1 - c0</span>
  558 |     | <span class='neutral'>  ///    + --------- * ((b0 - f + 2) * from.sqrt(true) - </span>
  559 |     | <span class='neutral'>  ///       b0 - b1</span>
  560 |     | <span class='neutral'>  ///                   (b0 - t + 2) * to.sqrt(true))</span>
  561 |     | <span class='neutral'>  ///</span>
  562 |     | <span class='neutral'>  /// -------------------------------------------------------------------------</span>
  563 |     | <span class='neutral'>  /// We should have: &#39;c0 &lt;= c1 &lt;= oneX15&#39;.</span>
  564 |     | <span class='neutral'>  ///</span>
  565 |     | <span class='neutral'>  /// If &#39;t &lt; f&#39; then we should have: &#39;b1 &lt;= t &lt; f &lt;= b0 &lt; thirtyTwoX59&#39;</span>
  566 |     | <span class='neutral'>  ///</span>
  567 |     | <span class='neutral'>  /// If &#39;f &lt; t&#39; then we should have: &#39;b0 &lt;= f &lt; t &lt;= b1 &lt; thirtyTwoX59&#39;</span>
  568 |     | <span class='neutral'>  ///</span>
  569 | *   | <span class='executed'>  function outgoing(</span>
  570 |     | <span class='neutral'>    uint256 coordinate0,</span>
  571 |     | <span class='neutral'>    uint256 from,</span>
  572 |     | <span class='neutral'>    uint256 to</span>
  573 |     | <span class='neutral'>  ) internal pure returns (</span>
  574 | *   | <span class='executed'>    X216 result</span>
  575 |     | <span class='neutral'>  ) {</span>
  576 |     | <span class='neutral'>    // The following values will be defined and loaded from the memory.</span>
  577 | *   | <span class='executed'>    X15 c0;</span>
  578 | *   | <span class='executed'>    X216 sqrtFrom;</span>
  579 | *   | <span class='executed'>    X216 sqrtTo;</span>
  580 | *   | <span class='executed'>    X59 db;</span>
  581 | *   | <span class='executed'>    X74 from_times_dc;</span>
  582 | *   | <span class='executed'>    X74 to_times_dc;</span>
  583 | *   | <span class='executed'>    {</span>
  584 |     | <span class='neutral'>      // First, we load the two integral boundaries.</span>
  585 | *   | <span class='executed'>      X59 logFrom = from.log();</span>
  586 | *   | <span class='executed'>      X59 logTo = to.log();</span>
  587 |     | <span class='neutral'></span>
  588 |     | <span class='neutral'>      // The special case of &#39;logFrom == logTo&#39; is handled here. In this case</span>
  589 |     | <span class='neutral'>      // the result is equal to &#39;zeroX216&#39;.</span>
  590 | *   | <span class='executed'>      if (logFrom == logTo) return zeroX216;</span>
  591 |     | <span class='neutral'></span>
  592 |     | <span class='neutral'>      // The pointer to the second price is derived.</span>
  593 | *   | <span class='executed'>      uint256 coordinate1;</span>
  594 |     | <span class='neutral'>      unchecked {</span>
  595 | *   | <span class='executed'>        coordinate1 = coordinate0 + 64;</span>
  596 |     | <span class='neutral'>      }</span>
  597 |     | <span class='neutral'></span>
  598 |     | <span class='neutral'>      // &#39;c0&#39; is loaded from the memory.</span>
  599 | *   | <span class='executed'>      c0 = coordinate0.height();</span>
  600 |     | <span class='neutral'></span>
  601 |     | <span class='neutral'>      // &#39;c1&#39; is loaded from the memory and temporarily placed in &#39;dc&#39;.</span>
  602 | *   | <span class='executed'>      X15 dc = coordinate1.height();</span>
  603 |     | <span class='neutral'></span>
  604 |     | <span class='neutral'>      // In this case, because of the input requirement &#39;c0 &lt;= c1&#39;, we have </span>
  605 |     | <span class='neutral'>      // &#39;c0 == c1 == zeroX15&#39; and the output should be &#39;zeroX216&#39;.</span>
  606 | *   | <span class='executed'>      if (dc == zeroX15) return zeroX216;</span>
  607 |     | <span class='neutral'></span>
  608 |     | <span class='neutral'>      // &#39;dc&#39; represents the vertical length of the segment that characterizes</span>
  609 |     | <span class='neutral'>      // the function that we are integrating. The subtraction is safe due to</span>
  610 |     | <span class='neutral'>      // the input requirement &#39;c0 &lt;= c1&#39;.</span>
  611 | *   | <span class='executed'>      dc = dc - c0;</span>
  612 |     | <span class='neutral'></span>
  613 |     | <span class='neutral'>      // As explained above, depending on the value of &#39;left&#39;, we either use</span>
  614 |     | <span class='neutral'>      // &#39;(from.sqrt(false), to.sqrt(false))&#39; or</span>
  615 |     | <span class='neutral'>      // &#39;(from.sqrt(true), to.sqrt(true))&#39;.</span>
  616 | *   | <span class='executed'>      bool left = logTo &lt; logFrom;</span>
  617 | *   | <span class='executed'>      sqrtFrom = from.sqrt(left);</span>
  618 | *   | <span class='executed'>      sqrtTo = to.sqrt(left);</span>
  619 |     | <span class='neutral'></span>
  620 |     | <span class='neutral'>      // If &#39;c1 == c0&#39; we simply return</span>
  621 |     | <span class='neutral'>      // &#39;c0 * (from.sqrt(false) - to.sqrt(false)) / (2 ** 15)&#39;</span>
  622 |     | <span class='neutral'>      // for &#39;left == false&#39; or </span>
  623 |     | <span class='neutral'>      // &#39;c0 * (from.sqrt(true) - to.sqrt(true)) / (2 ** 15)&#39;</span>
  624 |     | <span class='neutral'>      // for &#39;left == true&#39;.</span>
  625 |     | <span class='neutral'>      //</span>
  626 |     | <span class='neutral'>      // The subtraction is safe, because if &#39;f &lt;= t&#39; then</span>
  627 |     | <span class='neutral'>      // &#39;left == false&#39; and we have &#39;exp(- 8 - t / 2) &lt;= exp(-8 - f / 2)&#39;</span>
  628 |     | <span class='neutral'>      // which concludes &#39;to.sqrt(left) &lt;= from.sqrt(left)&#39;.</span>
  629 |     | <span class='neutral'>      //</span>
  630 |     | <span class='neutral'>      // On the other hand, if &#39;t &lt; f&#39; then &#39;left == true&#39; and we have</span>
  631 |     | <span class='neutral'>      // &#39;exp(- 8 + t / 2) &lt; exp(- 8 + f / 2)&#39; which concludes</span>
  632 |     | <span class='neutral'>      // &#39;to.sqrt(left) &lt; from.sqrt(left)&#39;.</span>
  633 |     | <span class='neutral'>      //</span>
  634 |     | <span class='neutral'>      // The multiplication is safe because &#39;c0&#39; and &#39;sqrtFrom - sqrtTo&#39; are</span>
  635 |     | <span class='neutral'>      // nonnegative values which do not exceed &#39;16&#39; and &#39;216&#39; bits, </span>
  636 |     | <span class='neutral'>      // respectively.</span>
  637 |     | <span class='neutral'>      //</span>
  638 |     | <span class='neutral'>      // We shift the result by 15 bits to the right to cancel the &#39;X15&#39;</span>
  639 |     | <span class='neutral'>      // representation of &#39;c0&#39;.</span>
  640 | *   | <span class='executed'>      if (dc == zeroX15) {</span>
  641 |     | <span class='neutral'>        assembly {</span>
  642 | *   | <span class='executed'>          result := shr(15, mul(c0, sub(sqrtFrom, sqrtTo)))</span>
  643 |     | <span class='neutral'>        }</span>
  644 | *   | <span class='executed'>        return result;</span>
  645 |     | <span class='neutral'>      }</span>
  646 |     | <span class='neutral'></span>
  647 |     | <span class='neutral'>      // &#39;b0&#39; is loaded from memory and temporarily placed in &#39;db&#39;.</span>
  648 | *   | <span class='executed'>      db = coordinate0.log();</span>
  649 |     | <span class='neutral'></span>
  650 |     | <span class='neutral'>      // Next, if &#39;left == true&#39;, we calculate </span>
  651 |     | <span class='neutral'>      // &#39;(b0 - logFrom + 2) * dc&#39; and &#39;(b0 - logTo + 2) * dc&#39;. </span>
  652 |     | <span class='neutral'>      // If &#39;left == false&#39;, we calculate </span>
  653 |     | <span class='neutral'>      // &#39;(logFrom - b0 + 2) * dc&#39; and &#39;(logTo - b0 + 2) * dc&#39;.</span>
  654 |     | <span class='neutral'>      //</span>
  655 |     | <span class='neutral'>      // The subtractions are safe due to the input requirements. Because if</span>
  656 |     | <span class='neutral'>      // &#39;left == false&#39;, we have &#39;b0 &lt;= logFrom&#39; and &#39;b0 &lt;= logTo&#39;.</span>
  657 |     | <span class='neutral'>      // Additionally, if &#39;left == true&#39;, we have &#39;logFrom &lt;= b0&#39; and</span>
  658 |     | <span class='neutral'>      // &#39;logTo &lt;= b0&#39;.</span>
  659 |     | <span class='neutral'>      //</span>
  660 |     | <span class='neutral'>      // The additions with &#39;twoX59&#39; are safe, because in all cases the two</span>
  661 |     | <span class='neutral'>      // terms that are being added are less than &#39;2 ** 64&#39;.</span>
  662 |     | <span class='neutral'>      //</span>
  663 |     | <span class='neutral'>      // The multiplications are safe, because in all cases the inputs are</span>
  664 |     | <span class='neutral'>      // non-negative and the output does not exceed 81 bits.</span>
  665 | *   | <span class='executed'>      (from_times_dc, to_times_dc) = left ? </span>
  666 | *   | <span class='executed'>        ((db - logFrom + twoX59).times(dc), (db - logTo + twoX59).times(dc)) : </span>
  667 | *   | <span class='executed'>        ((logFrom - db + twoX59).times(dc), (logTo - db + twoX59).times(dc));</span>
  668 |     | <span class='neutral'>      </span>
  669 |     | <span class='neutral'>      // &#39;db&#39; represents the horizontal length of the segment that</span>
  670 |     | <span class='neutral'>      // characterizes the function that we are integrating. The subtractions</span>
  671 |     | <span class='neutral'>      // are safe due to the input requirements. Because if &#39;left == false&#39;,</span>
  672 |     | <span class='neutral'>      // we have &#39;b0 &lt;= b1&#39; and if &#39;left == true&#39;, we have &#39;b0 &gt;= b1&#39;.</span>
  673 | *   | <span class='executed'>      db = left ? db - coordinate1.log() : coordinate1.log() - db;</span>
  674 |     | <span class='neutral'>    }</span>
  675 |     | <span class='neutral'></span>
  676 | *   | <span class='executed'>    assembly {</span>
  677 |     | <span class='neutral'>      // The least significant 192-bits of the product </span>
  678 |     | <span class='neutral'>      // &#39;from_times_dc * sqrtFrom&#39; which is in &#39;X290&#39; representation because</span>
  679 |     | <span class='neutral'>      // &#39;from_times_dc&#39; is &#39;X74&#39; and &#39;sqrtFrom&#39; is &#39;X216&#39;.</span>
  680 | *   | <span class='executed'>      let lsbits0X290 := mulmod(from_times_dc, sqrtFrom, shl(192, 1))</span>
  681 |     | <span class='neutral'></span>
  682 |     | <span class='neutral'>      // The least significant 192-bits of the product </span>
  683 |     | <span class='neutral'>      // &#39;to_times_dc * sqrtTo&#39; which is in &#39;X290&#39; representation because</span>
  684 |     | <span class='neutral'>      // &#39;to_times_dc&#39; is &#39;X74&#39; and &#39;sqrtTo&#39; is &#39;X216&#39;.</span>
  685 | *   | <span class='executed'>      let lsbits1X290 := mulmod(to_times_dc, sqrtTo, shl(192, 1))</span>
  686 |     | <span class='neutral'></span>
  687 |     | <span class='neutral'>      // Next, we calculate </span>
  688 |     | <span class='neutral'>      // &#39;sqrtFrom * from_times_dc - sqrtTo * to_times_dc&#39;.</span>
  689 |     | <span class='neutral'>      //</span>
  690 |     | <span class='neutral'>      // Next, we are going to prove that the subtraction is safe:</span>
  691 |     | <span class='neutral'>      //</span>
  692 |     | <span class='neutral'>      // If &#39;f &lt; t&#39;, We are calculating</span>
  693 |     | <span class='neutral'>      //</span>
  694 |     | <span class='neutral'>      // y := ((f - b0 + 2) * exp(- f / 2) - (t - b0 + 2) * exp(- t / 2)) * dc</span>
  695 |     | <span class='neutral'>      //</span>
  696 |     | <span class='neutral'>      // In this case, because &#39;(q + 2) * exp(-q / 2)&#39; is a decreasing function</span>
  697 |     | <span class='neutral'>      // within the interval &#39;(0, +oo)&#39;, the expression</span>
  698 |     | <span class='neutral'>      // </span>
  699 |     | <span class='neutral'>      // (f - b0 + 2) * exp(-(f - b0) / 2) - (t - b0 + 2) * exp(-(t - b0) / 2)</span>
  700 |     | <span class='neutral'>      //</span>
  701 |     | <span class='neutral'>      // is non-negative which concludes that &#39;y&#39; is also non-negative. Hence,</span>
  702 |     | <span class='neutral'>      // the subtraction is safe.</span>
  703 |     | <span class='neutral'>      //</span>
  704 |     | <span class='neutral'>      // If &#39;t &lt; f&#39;, We are calculating</span>
  705 |     | <span class='neutral'>      //</span>
  706 |     | <span class='neutral'>      // y := ((b0 - f + 2) * exp(+ f / 2) - (b0 - t + 2) * exp(+ t / 2)) * dc</span>
  707 |     | <span class='neutral'>      //</span>
  708 |     | <span class='neutral'>      // In this case, because &#39;(q + 2) * exp(-q / 2)&#39; is a decreasing function</span>
  709 |     | <span class='neutral'>      // within the interval &#39;(0, +oo)&#39;, the expression</span>
  710 |     | <span class='neutral'>      // </span>
  711 |     | <span class='neutral'>      // (b0 - f + 2) * exp(-(b0 - f) / 2) - (b0 - t + 2) * exp(-(b0 - t) / 2)</span>
  712 |     | <span class='neutral'>      //</span>
  713 |     | <span class='neutral'>      // is non-negative which concludes that &#39;y&#39; is also non-negative. Hence,</span>
  714 |     | <span class='neutral'>      // the subtraction is safe.</span>
  715 |     | <span class='neutral'></span>
  716 |     | <span class='neutral'>      // The least significant 192-bits of </span>
  717 |     | <span class='neutral'>      // &#39;sqrtFrom * from_times_dc - sqrtTo * to_times_dc&#39; which may underflow</span>
  718 |     | <span class='neutral'>      // in which case &#39;1&#39; will be subtracted from &#39;msbitsX290&#39;.</span>
  719 |     | <span class='neutral'>      // The subtraction is safe because &#39;lsbits1X290&#39; is less than &#39;1 &lt;&lt; 192&#39;.</span>
  720 | *   | <span class='executed'>      let lsbitsX290 := addmod(</span>
  721 | *   | <span class='executed'>        lsbits0X290,</span>
  722 | *   | <span class='executed'>        sub(shl(192, 1), lsbits1X290),</span>
  723 | *   | <span class='executed'>        shl(192, 1)</span>
  724 |     | <span class='neutral'>      )</span>
  725 |     | <span class='neutral'></span>
  726 |     | <span class='neutral'>      // The most significant 128-bits of </span>
  727 |     | <span class='neutral'>      // &#39;sqrtFrom * from_times_dc - sqrtTo * to_times_dc&#39;</span>
  728 | *   | <span class='executed'>      let msbitsX290 := sub(</span>
  729 |     | <span class='neutral'>        // &#39;x == to_times_dc * sqrtTo - (2 ** 192) * a&#39;</span>
  730 |     | <span class='neutral'>        // &#39;y == from_times_dc * sqrtFrom - (2 ** 192 - 1) * b&#39;</span>
  731 |     | <span class='neutral'>        // &#39;z == from_times_dc * sqrtFrom - (2 ** 192) * c&#39;</span>
  732 |     | <span class='neutral'>        // &#39;w == to_times_dc * sqrtTo - (2 ** 192 - 1) * d&#39;</span>
  733 |     | <span class='neutral'>        //</span>
  734 |     | <span class='neutral'>        // &#39;x + y - z - w == b - d&#39; [mod 2 ** 192]</span>
  735 | *   | <span class='executed'>        sub(</span>
  736 | *   | <span class='executed'>          add(</span>
  737 | *   | <span class='executed'>            lsbits1X290,</span>
  738 | *   | <span class='executed'>            mulmod(from_times_dc, sqrtFrom, sub(shl(192, 1), 1))</span>
  739 |     | <span class='neutral'>          ),</span>
  740 | *   | <span class='executed'>          add(</span>
  741 | *   | <span class='executed'>            lsbits0X290,</span>
  742 | *   | <span class='executed'>            mulmod(to_times_dc, sqrtTo, sub(shl(192, 1), 1))</span>
  743 |     | <span class='neutral'>          )</span>
  744 |     | <span class='neutral'>        ),</span>
  745 |     | <span class='neutral'>        // &#39;lsbits0X290 &lt; lsbits1X290&#39; indicates that &#39;lsbits&#39; has underflowed.</span>
  746 |     | <span class='neutral'>        // In this case, we need to subtract &#39;msbitsX290&#39; by &#39;1&#39;.</span>
  747 | *   | <span class='executed'>        lt(lsbits0X290, lsbits1X290)</span>
  748 |     | <span class='neutral'>      )</span>
  749 |     | <span class='neutral'></span>
  750 |     | <span class='neutral'>      // Next, we calculate:</span>
  751 |     | <span class='neutral'>      //</span>
  752 |     | <span class='neutral'>      // &#39;(from_times_dc * sqrtFrom - to_times_dc * sqrtTo) / db&#39;</span>
  753 |     | <span class='neutral'>      //</span>
  754 |     | <span class='neutral'>      // Here, we perform the division by &#39;db&#39; via the simple long division</span>
  755 |     | <span class='neutral'>      //                   _____________________</span>
  756 |     | <span class='neutral'>      // algorithm, i.e., &#39;msbitsX290 lsbitsX290&#39; divided by &#39;db&#39; becomes:</span>
  757 |     | <span class='neutral'>      //</span>
  758 |     | <span class='neutral'>      //                 q1X231           q0X231</span>
  759 |     | <span class='neutral'>      //      -----------------------------------</span>
  760 |     | <span class='neutral'>      // db   |      msbitsX290       lsbitsX290</span>
  761 |     | <span class='neutral'>      //      |</span>
  762 |     | <span class='neutral'>      //            q1X231 * db </span>
  763 |     | <span class='neutral'>      //        ---------------------------------</span>
  764 |     | <span class='neutral'>      //        msbitsX290 % db       lsbitsX290</span>
  765 |     | <span class='neutral'>      //</span>
  766 |     | <span class='neutral'>      //                             q0X231 * db</span>
  767 |     | <span class='neutral'>      //        ---------------------------------</span>
  768 |     | <span class='neutral'>      //                                       r</span>
  769 |     | <span class='neutral'>      //</span>
  770 |     | <span class='neutral'>      // where</span>
  771 |     | <span class='neutral'>      // &#39;r := (msbitsX290 * (2 ** 192) + lsbitsX290) % db&#39;</span>
  772 |     | <span class='neutral'>      // &#39;q1X231 := msbitsX290 / db&#39;</span>
  773 |     | <span class='neutral'>      // &#39;q0X231 := ((msbitsX290 % db) * (2 ** 192) + lsbitsX290) / db&#39;</span>
  774 |     | <span class='neutral'>      //</span>
  775 |     | <span class='neutral'>      // Next, we will prove that &#39;msbitsX290 / db &lt; 2 ** 50&#39; which will be</span>
  776 |     | <span class='neutral'>      // useful later. If &#39;f &lt; t&#39; (the other side can be argued similarly), we</span>
  777 |     | <span class='neutral'>      // have:</span>
  778 |     | <span class='neutral'>      //</span>
  779 |     | <span class='neutral'>      //  (2 ** 192) * msbitsX290 + lsbitsX290</span>
  780 |     | <span class='neutral'>      // -------------------------------------- ==</span>
  781 |     | <span class='neutral'>      //      (2 ** (290 - 59)) * (b1 - b0)</span>
  782 |     | <span class='neutral'>      //</span>
  783 |     | <span class='neutral'>      //   (2 ** 192) * msbitsX290 + lsbitsX290</span>
  784 |     | <span class='neutral'>      //  --------------------------------------</span>
  785 |     | <span class='neutral'>      //                2 ** 290</span>
  786 |     | <span class='neutral'>      // ---------------------------------------- ==</span>
  787 |     | <span class='neutral'>      //                b1 - b0</span>
  788 |     | <span class='neutral'>      //               ---------</span>
  789 |     | <span class='neutral'>      //                2 ** 59</span>
  790 |     | <span class='neutral'>      //</span>
  791 |     | <span class='neutral'>      //  ((f - b0 + 2) * exp(- f / 2) - (t - b0 + 2) * exp(- t / 2)) * dc</span>
  792 |     | <span class='neutral'>      // ------------------------------------------------------------------ &lt;=</span>
  793 |     | <span class='neutral'>      //                              b1 - b0</span>
  794 |     | <span class='neutral'>      //</span>
  795 |     | <span class='neutral'>      //  ((f - b0 + 2) * exp(- f / 2) - (t - b0 + 2) * exp(- t / 2)) * dc</span>
  796 |     | <span class='neutral'>      // ------------------------------------------------------------------ ==</span>
  797 |     | <span class='neutral'>      //                               t - f</span>
  798 |     | <span class='neutral'>      //</span>
  799 |     | <span class='neutral'>      //  g(t - b0) - g(f - b0)</span>
  800 |     | <span class='neutral'>      // ----------------------- * exp(- b0 / 2) * dc ==</span>
  801 |     | <span class='neutral'>      //   (t - b0) - (f - b0)</span>
  802 |     | <span class='neutral'>      //</span>
  803 |     | <span class='neutral'>      //  g&#39;(z) * exp(- b0 / 2) * dc &lt;= exp(-1) * exp(- b0 / 2) * dc &lt; </span>
  804 |     | <span class='neutral'>      //  exp(7) &lt; 2 ** 11</span>
  805 |     | <span class='neutral'>      //</span>
  806 |     | <span class='neutral'>      // where &#39;g(q) := - (q + 2) * exp(-q / 2)&#39; and &#39;z&#39; is some arbitrary </span>
  807 |     | <span class='neutral'>      // point within the interval &#39;(0, +oo)&#39; whose existence is guaranteed</span>
  808 |     | <span class='neutral'>      // thanks to the mean value theorem.</span>
  809 |     | <span class='neutral'>      //</span>
  810 |     | <span class='neutral'>      // Due to the above argument, we have &#39;msbitsX290 / db &lt;= 2 ** 50&#39;.</span>
  811 | *   | <span class='executed'>      let quotientX231 := add(</span>
  812 |     | <span class='neutral'>        // First, we calculate &#39;q1X231 &lt;&lt; 192&#39; which the more significant part</span>
  813 |     | <span class='neutral'>        // of the quotientX231.</span>
  814 |     | <span class='neutral'>        //</span>
  815 |     | <span class='neutral'>        // The division &#39;msbits / db&#39; is safe because &#39;db != 0&#39; due to an input</span>
  816 |     | <span class='neutral'>        // requirement.</span>
  817 |     | <span class='neutral'>        //</span>
  818 |     | <span class='neutral'>        // The 192 bit shift to the left is safe because we have proven that</span>
  819 |     | <span class='neutral'>        // &#39;msbitsX290 / db &lt;= 2 ** 50&#39;.</span>
  820 | *   | <span class='executed'>        shl(192, div(msbitsX290, db)),</span>
  821 |     | <span class='neutral'>        // Then, we calculate &#39;q0X231&#39; which is the least significant 192 bits</span>
  822 |     | <span class='neutral'>        // of &#39;quotientX231&#39;.</span>
  823 |     | <span class='neutral'>        //</span>
  824 |     | <span class='neutral'>        // The division by &#39;db&#39; is safe because &#39;db != 0&#39; due to an input</span>
  825 |     | <span class='neutral'>        // requirement.</span>
  826 | *   | <span class='executed'>        div(</span>
  827 | *   | <span class='executed'>          add(</span>
  828 |     | <span class='neutral'>            // The shift does not overflow because </span>
  829 |     | <span class='neutral'>            // &#39;msbitsX290 % db &lt; db &lt; 2 ** 64&#39;.</span>
  830 | *   | <span class='executed'>            shl(192, mod(msbitsX290, db)),</span>
  831 | *   | <span class='executed'>            lsbitsX290</span>
  832 |     | <span class='neutral'>          ),</span>
  833 | *   | <span class='executed'>          db</span>
  834 |     | <span class='neutral'>        )</span>
  835 |     | <span class='neutral'>      )</span>
  836 |     | <span class='neutral'></span>
  837 |     | <span class='neutral'>      // Lastly, the following value is calculated:</span>
  838 |     | <span class='neutral'>      //</span>
  839 |     | <span class='neutral'>      // &#39;c0 * (from.sqrt(left) - to.sqrt(left)) + quotient&#39;</span>
  840 |     | <span class='neutral'>      //</span>
  841 |     | <span class='neutral'>      // The addition does not overflow and does not exceed &#39;216&#39; bits because</span>
  842 |     | <span class='neutral'>      // the output integral is equal to:</span>
  843 |     | <span class='neutral'>      //</span>
  844 |     | <span class='neutral'>      //                                / t</span>
  845 |     | <span class='neutral'>      //                               |     -h/2         c1 - c0</span>
  846 |     | <span class='neutral'>      //  (2 ** 216) * (exp(-8) / 2) * |    e      (c0 + --------- (h - b0)) dh</span>
  847 |     | <span class='neutral'>      //                               |                  b1 - b0</span>
  848 |     | <span class='neutral'>      //                              / f</span>
  849 |     | <span class='neutral'>      //</span>
  850 |     | <span class='neutral'>      //                                   / 16</span>
  851 |     | <span class='neutral'>      //                                  |     -h/2</span>
  852 |     | <span class='neutral'>      //  &lt;= (2 ** 216) * (exp(-8) / 2) * |    e      dh &lt; (2 ** 216) - 1</span>
  853 |     | <span class='neutral'>      //                                  |</span>
  854 |     | <span class='neutral'>      //                                 / -16</span>
  855 |     | <span class='neutral'>      //</span>
  856 |     | <span class='neutral'>      // The subtraction is safe, because if &#39;f &lt;= t&#39; then</span>
  857 |     | <span class='neutral'>      // &#39;left == false&#39; and we have &#39;exp(- 8 - t / 2) &lt;= exp(-8 - f / 2)&#39;</span>
  858 |     | <span class='neutral'>      // which concludes &#39;to.sqrt(left) &lt;= from.sqrt(left)&#39;</span>
  859 |     | <span class='neutral'>      //</span>
  860 |     | <span class='neutral'>      // On the other hand, if &#39;t &lt; f&#39; then &#39;left == true&#39; and we have</span>
  861 |     | <span class='neutral'>      // &#39;exp(- 8 + t / 2) &lt; exp(- 8 + f / 2)&#39; which concludes</span>
  862 |     | <span class='neutral'>      // &#39;to.sqrt(left) &lt; from.sqrt(left)&#39;.</span>
  863 |     | <span class='neutral'>      //</span>
  864 |     | <span class='neutral'>      // The multiplication is safe because &#39;c0&#39; and &#39;sqrtFrom - sqrtTo&#39; are</span>
  865 |     | <span class='neutral'>      // nonnegative values which do not exceed &#39;16&#39; and &#39;216&#39; bits, </span>
  866 |     | <span class='neutral'>      // respectively.</span>
  867 |     | <span class='neutral'>      //</span>
  868 |     | <span class='neutral'>      // We shift the result by 15 bits to the right to cancel the &#39;X15&#39;</span>
  869 |     | <span class='neutral'>      // representation of &#39;c0&#39; and &#39;dc&#39;.</span>
  870 | *   | <span class='executed'>      result := shr(15, add(mul(c0, sub(sqrtFrom, sqrtTo)), quotientX231))</span>
  871 |     | <span class='neutral'>    }</span>
  872 |     | <span class='neutral'>  }</span>
  873 |     | <span class='neutral'></span>
  874 |     | <span class='neutral'>  /// @notice Let &#39;f&#39; and &#39;t&#39; denote the logPrice values whose offset binary</span>
  875 |     | <span class='neutral'>  /// &#39;X59&#39; representation is stored in the pointers &#39;from&#39; and &#39;to&#39;,</span>
  876 |     | <span class='neutral'>  /// respectively. In other words, define:</span>
  877 |     | <span class='neutral'>  ///</span>
  878 |     | <span class='neutral'>  ///               from.log()                          to.log()</span>
  879 |     | <span class='neutral'>  ///  f := - 16 + ------------    and    t := - 16 + ------------</span>
  880 |     | <span class='neutral'>  ///                2 ** 59                            2 ** 59</span>
  881 |     | <span class='neutral'>  ///</span>
  882 |     | <span class='neutral'>  /// Let &#39;(b0, c0)&#39; and &#39;(b1, c1)&#39; represent the segment coordinates to be</span>
  883 |     | <span class='neutral'>  /// loaded from the memory using &#39;coordinate0&#39; and &#39;coordinate0 + 64&#39;,</span>
  884 |     | <span class='neutral'>  /// respectively.</span>
  885 |     | <span class='neutral'>  ///</span>
  886 |     | <span class='neutral'>  /// Additionally, let &#39;(b0, c0)&#39; and &#39;(b1, c1)&#39; represent the segment</span>
  887 |     | <span class='neutral'>  /// coordinates to be loaded from the memory via the pointers</span>
  888 |     | <span class='neutral'>  /// &#39;coordinates0&#39; and &#39;coordinates1 := coordinates0 + 64&#39;, respectively.</span>
  889 |     | <span class='neutral'>  /// More precisely:</span>
  890 |     | <span class='neutral'>  ///</span>
  891 |     | <span class='neutral'>  ///               coordinates0.log()           coordinates0.height()</span>
  892 |     | <span class='neutral'>  /// b0 := - 16 + --------------------,  c0 := -----------------------</span>
  893 |     | <span class='neutral'>  ///                    2 ** 59                        2 ** 15</span>
  894 |     | <span class='neutral'>  ///</span>
  895 |     | <span class='neutral'>  ///               coordinates1.log()           coordinates1.height()</span>
  896 |     | <span class='neutral'>  /// b1 := - 16 + --------------------,  c1 := -----------------------</span>
  897 |     | <span class='neutral'>  ///                    2 ** 59                        2 ** 15</span>
  898 |     | <span class='neutral'>  ///</span>
  899 |     | <span class='neutral'>  /// -------------------------------------------------------------------------</span>
  900 |     | <span class='neutral'>  /// If &#39;f &lt; t&#39; this function calculates:</span>
  901 |     | <span class='neutral'>  ///</span>
  902 |     | <span class='neutral'>  ///                                / t</span>
  903 |     | <span class='neutral'>  ///                               |     +h/2         c1 - c0</span>
  904 |     | <span class='neutral'>  ///  (2 ** 216) * (exp(-8) / 2) * |    e      (c0 + --------- (h - b0)) dh</span>
  905 |     | <span class='neutral'>  ///                               |                  b1 - b0</span>
  906 |     | <span class='neutral'>  ///                              / f</span>
  907 |     | <span class='neutral'>  ///</span>
  908 |     | <span class='neutral'>  /// In this case, the following closed-form formula is used:</span>
  909 |     | <span class='neutral'>  ///</span>
  910 |     | <span class='neutral'>  ///  (2 ** 216) * exp(-8) * (</span>
  911 |     | <span class='neutral'>  ///                                          c1 - c0</span>
  912 |     | <span class='neutral'>  ///    c1 * (exp(+ t / 2) - exp(+ f / 2)) - --------- * </span>
  913 |     | <span class='neutral'>  ///                                          b1 - b0</span>
  914 |     | <span class='neutral'>  ///</span>
  915 |     | <span class='neutral'>  ///    ((b1 - t + 2) * exp(+ t / 2) - (b1 - f + 2) * exp(+ f / 2))</span>
  916 |     | <span class='neutral'>  ///  )</span>
  917 |     | <span class='neutral'>  ///</span>
  918 |     | <span class='neutral'>  ///  == c1 * ((2 ** 216) * exp(- 8 + t / 2) - (2 ** 216) * exp(- 8 + f / 2))</span>
  919 |     | <span class='neutral'>  ///</span>
  920 |     | <span class='neutral'>  ///       c1 - c0</span>
  921 |     | <span class='neutral'>  ///    - --------- * ((b1 - t + 2) * (2 ** 216) * exp(- 8 + t / 2) - </span>
  922 |     | <span class='neutral'>  ///       b1 - b0</span>
  923 |     | <span class='neutral'>  ///                   (b1 - f + 2) * (2 ** 216) * exp(- 8 + f / 2))</span>
  924 |     | <span class='neutral'>  ///</span>
  925 |     | <span class='neutral'>  ///  == c1 * (to.sqrt(true) - from.sqrt(true))</span>
  926 |     | <span class='neutral'>  ///</span>
  927 |     | <span class='neutral'>  ///       c1 - c0</span>
  928 |     | <span class='neutral'>  ///    - --------- * ((b1 - t + 2) * to.sqrt(true) - </span>
  929 |     | <span class='neutral'>  ///       b1 - b0</span>
  930 |     | <span class='neutral'>  ///                   (b1 - f + 2) * from.sqrt(true))</span>
  931 |     | <span class='neutral'>  ///</span>
  932 |     | <span class='neutral'>  /// -------------------------------------------------------------------------</span>
  933 |     | <span class='neutral'>  /// If &#39;t &lt; f&#39; this function calculates:</span>
  934 |     | <span class='neutral'>  ///</span>
  935 |     | <span class='neutral'>  ///                                / f</span>
  936 |     | <span class='neutral'>  ///                               |     -h/2         c1 - c0</span>
  937 |     | <span class='neutral'>  ///  (2 ** 216) * (exp(-8) / 2) * |    e      (c0 + --------- (b0 - h)) dh</span>
  938 |     | <span class='neutral'>  ///                               |                  b0 - b1</span>
  939 |     | <span class='neutral'>  ///                              / t</span>
  940 |     | <span class='neutral'>  ///</span>
  941 |     | <span class='neutral'>  /// In this case, the following closed-form formula is used:</span>
  942 |     | <span class='neutral'>  ///</span>
  943 |     | <span class='neutral'>  ///  (2 ** 216) * exp(-8) * (</span>
  944 |     | <span class='neutral'>  ///                                          c1 - c0</span>
  945 |     | <span class='neutral'>  ///    c1 * (exp(- t / 2) - exp(- f / 2)) - --------- * </span>
  946 |     | <span class='neutral'>  ///                                          b0 - b1</span>
  947 |     | <span class='neutral'>  ///</span>
  948 |     | <span class='neutral'>  ///    ((t - b1 + 2) * exp(- t / 2) - (f - b1 + 2) * exp(- f / 2))</span>
  949 |     | <span class='neutral'>  ///  )</span>
  950 |     | <span class='neutral'>  ///</span>
  951 |     | <span class='neutral'>  ///  == c1 * ((2 ** 216) * exp(- 8 - t / 2) - (2 ** 216) * exp(- 8 - f / 2))</span>
  952 |     | <span class='neutral'>  ///</span>
  953 |     | <span class='neutral'>  ///       c1 - c0</span>
  954 |     | <span class='neutral'>  ///    - --------- * ((t - b1 + 2) * (2 ** 216) * exp(- 8 - t / 2) - </span>
  955 |     | <span class='neutral'>  ///       b0 - b1</span>
  956 |     | <span class='neutral'>  ///                   (f - b1 + 2) * (2 ** 216) * exp(- 8 - f / 2))</span>
  957 |     | <span class='neutral'>  ///</span>
  958 |     | <span class='neutral'>  ///  == c1 * (to.sqrt(false) - from.sqrt(false))</span>
  959 |     | <span class='neutral'>  ///</span>
  960 |     | <span class='neutral'>  ///       c1 - c0</span>
  961 |     | <span class='neutral'>  ///    - --------- * ((t - b1 + 2) * to.sqrt(false) - </span>
  962 |     | <span class='neutral'>  ///       b0 - b1</span>
  963 |     | <span class='neutral'>  ///                   (f - b1 + 2) * from.sqrt(false))</span>
  964 |     | <span class='neutral'>  ///</span>
  965 |     | <span class='neutral'>  /// -------------------------------------------------------------------------</span>
  966 |     | <span class='neutral'>  /// We should have: &#39;c0 &lt;= c1 &lt;= oneX15&#39;.</span>
  967 |     | <span class='neutral'>  ///</span>
  968 |     | <span class='neutral'>  /// If &#39;t &lt; f&#39; then we should have: &#39;b1 &lt;= t &lt; f &lt;= b0 &lt; thirtyTwoX59&#39;</span>
  969 |     | <span class='neutral'>  ///</span>
  970 |     | <span class='neutral'>  /// If &#39;f &lt; t&#39; then we should have: &#39;b0 &lt;= f &lt; t &lt;= b1 &lt; thirtyTwoX59&#39;</span>
  971 |     | <span class='neutral'>  ///</span>
  972 | *   | <span class='executed'>  function incoming(</span>
  973 |     | <span class='neutral'>    uint256 coordinate0,</span>
  974 |     | <span class='neutral'>    uint256 from,</span>
  975 |     | <span class='neutral'>    uint256 to</span>
  976 |     | <span class='neutral'>  ) internal pure returns (</span>
  977 | *   | <span class='executed'>    X216 result</span>
  978 |     | <span class='neutral'>  ) {</span>
  979 |     | <span class='neutral'>    // The following values will be defined and loaded from the memory.</span>
  980 | *   | <span class='executed'>    X15 c1;</span>
  981 | *   | <span class='executed'>    X216 sqrtFrom;</span>
  982 | *   | <span class='executed'>    X216 sqrtTo;</span>
  983 | *   | <span class='executed'>    X59 db;</span>
  984 | *   | <span class='executed'>    X74 from_times_dc;</span>
  985 | *   | <span class='executed'>    X74 to_times_dc;</span>
  986 | *   | <span class='executed'>    {</span>
  987 |     | <span class='neutral'>      // First, we load the integral boundaries.</span>
  988 | *   | <span class='executed'>      X59 logFrom = from.log();</span>
  989 | *   | <span class='executed'>      X59 logTo = to.log();</span>
  990 |     | <span class='neutral'></span>
  991 |     | <span class='neutral'>      // The special case of &#39;logFrom == logTo&#39; is handled here. In this case</span>
  992 |     | <span class='neutral'>      // the result is equal to &#39;zeroX216&#39;.</span>
  993 | *   | <span class='executed'>      if (logFrom == logTo) return zeroX216;</span>
  994 |     | <span class='neutral'></span>
  995 | *   | <span class='executed'>      {</span>
  996 |     | <span class='neutral'>        // The pointer to the second price is derived.</span>
  997 | *   | <span class='executed'>        uint256 coordinate1;</span>
  998 |     | <span class='neutral'>        unchecked {</span>
  999 | *   | <span class='executed'>          coordinate1 = coordinate0 + 64;</span>
 1000 |     | <span class='neutral'>        }</span>
 1001 |     | <span class='neutral'></span>
 1002 |     | <span class='neutral'>        // &#39;c1&#39; is loaded from the memory.</span>
 1003 | *   | <span class='executed'>        c1 = coordinate1.height();</span>
 1004 |     | <span class='neutral'></span>
 1005 |     | <span class='neutral'>        // In this case, because of the input requirement &#39;c0 &lt;= c1&#39;, we have </span>
 1006 |     | <span class='neutral'>        // &#39;c0 == c1 == zeroX15&#39; and the output should be &#39;zeroX216&#39;.</span>
 1007 | *   | <span class='executed'>        if (c1 == zeroX15) return result;</span>
 1008 |     | <span class='neutral'></span>
 1009 |     | <span class='neutral'>        // &#39;b1&#39; is loaded from the memory and temporarily placed in &#39;db&#39;.</span>
 1010 | *   | <span class='executed'>        db = coordinate1.log();</span>
 1011 |     | <span class='neutral'>      }</span>
 1012 |     | <span class='neutral'></span>
 1013 |     | <span class='neutral'>      // As explained above, depending on the value of &#39;left&#39;, we either use</span>
 1014 |     | <span class='neutral'>      // &#39;(from.sqrt(false), to.sqrt(false))&#39; or</span>
 1015 |     | <span class='neutral'>      // &#39;(from.sqrt(true), to.sqrt(true))&#39;.</span>
 1016 | *   | <span class='executed'>      bool left = logTo &lt; logFrom;</span>
 1017 | *   | <span class='executed'>      sqrtFrom = from.sqrt(!left);</span>
 1018 | *   | <span class='executed'>      sqrtTo = to.sqrt(!left);</span>
 1019 |     | <span class='neutral'></span>
 1020 | *   | <span class='executed'>      {</span>
 1021 |     | <span class='neutral'>        // &#39;c0&#39; is loaded from the memory and temporarily placed in &#39;dc&#39;.</span>
 1022 | *   | <span class='executed'>        X15 dc = coordinate0.height();</span>
 1023 |     | <span class='neutral'></span>
 1024 |     | <span class='neutral'>        // If &#39;c1 == c0&#39; we simply return</span>
 1025 |     | <span class='neutral'>        // &#39;c1 * (to.sqrt(true) - from.sqrt(true)) / (2 ** 15)&#39;</span>
 1026 |     | <span class='neutral'>        // for &#39;left == false&#39; or </span>
 1027 |     | <span class='neutral'>        // &#39;c1 * (to.sqrt(false) - from.sqrt(false)) / (2 ** 15)&#39;</span>
 1028 |     | <span class='neutral'>        // for &#39;left == true&#39;.</span>
 1029 |     | <span class='neutral'>        //</span>
 1030 |     | <span class='neutral'>        // The subtraction is safe, because if &#39;f &lt;= t&#39; then</span>
 1031 |     | <span class='neutral'>        // &#39;left == false&#39; and we have &#39;exp(- 8 + f / 2) &lt;= exp(-8 + t / 2)&#39;</span>
 1032 |     | <span class='neutral'>        // which concludes &#39;from.sqrt(!left) &lt;= to.sqrt(!left)&#39;</span>
 1033 |     | <span class='neutral'>        //</span>
 1034 |     | <span class='neutral'>        // On the other hand, if &#39;t &lt; f&#39; then &#39;left == true&#39; and we have</span>
 1035 |     | <span class='neutral'>        // &#39;exp(- 8 - f / 2) &lt; exp(- 8 - t / 2)&#39; which concludes</span>
 1036 |     | <span class='neutral'>        // &#39;from.sqrt(!left) &lt; to.sqrt(!left)&#39;.</span>
 1037 |     | <span class='neutral'>        //</span>
 1038 |     | <span class='neutral'>        // The multiplication is safe because &#39;c1&#39; and &#39;sqrtTo - sqrtFrom&#39; are</span>
 1039 |     | <span class='neutral'>        // nonnegative values which do not exceed &#39;16&#39; and &#39;216&#39; bits, </span>
 1040 |     | <span class='neutral'>        // respectively.</span>
 1041 |     | <span class='neutral'>        //</span>
 1042 |     | <span class='neutral'>        // We shift the result by 15 bits to the right to cancel the &#39;X15&#39;</span>
 1043 |     | <span class='neutral'>        // representation of &#39;c1&#39;.</span>
 1044 | *   | <span class='executed'>        if (c1 == dc) {</span>
 1045 |     | <span class='neutral'>          assembly {</span>
 1046 | *   | <span class='executed'>            result := shr(15, mul(c1, sub(sqrtTo, sqrtFrom)))</span>
 1047 |     | <span class='neutral'>          }</span>
 1048 | *   | <span class='executed'>          return result;</span>
 1049 |     | <span class='neutral'>        }</span>
 1050 |     | <span class='neutral'></span>
 1051 |     | <span class='neutral'>        // &#39;dc&#39; represents the vertical length of the segment that</span>
 1052 |     | <span class='neutral'>        // characterizes the function that we are integrating. The subtraction</span>
 1053 |     | <span class='neutral'>        // is safe due to the input requirement &#39;c0 &lt;= c1&#39;.</span>
 1054 | *   | <span class='executed'>        dc = c1 - dc;</span>
 1055 |     | <span class='neutral'></span>
 1056 |     | <span class='neutral'>        // Next, if &#39;left == true&#39;, we calculate </span>
 1057 |     | <span class='neutral'>        // &#39;(logFrom - b1 + 2) * dc&#39; and &#39;(logTo - b1 + 2) * dc&#39;. </span>
 1058 |     | <span class='neutral'>        // If &#39;left == false&#39;, we calculate </span>
 1059 |     | <span class='neutral'>        // &#39;(b1 - logFrom + 2) * dc&#39; and &#39;(b1 - logTo + 2) * dc&#39;.</span>
 1060 |     | <span class='neutral'>        //</span>
 1061 |     | <span class='neutral'>        // The subtractions are safe due to the input requirements. Because if</span>
 1062 |     | <span class='neutral'>        // &#39;left == false&#39;, we have &#39;logFrom &lt;= b1&#39; and &#39;logTo &lt;= b1&#39;.</span>
 1063 |     | <span class='neutral'>        // Additionally, if &#39;left == true&#39;, we have &#39;b1 &lt;= logFrom&#39; and</span>
 1064 |     | <span class='neutral'>        // &#39;b1 &lt;= logTo&#39;.</span>
 1065 |     | <span class='neutral'>        //</span>
 1066 |     | <span class='neutral'>        // The additions with &#39;twoX59&#39; are safe, because in all cases the two</span>
 1067 |     | <span class='neutral'>        // terms that are being added are less than &#39;2 ** 64&#39;.</span>
 1068 |     | <span class='neutral'>        //</span>
 1069 |     | <span class='neutral'>        // The multiplications are safe, because in all cases the inputs are</span>
 1070 |     | <span class='neutral'>        // non-negative and the output does not exceed 81 bits.</span>
 1071 | *   | <span class='executed'>        (from_times_dc, to_times_dc) = left ? (</span>
 1072 | *   | <span class='executed'>          (logFrom - db + twoX59).times(dc),</span>
 1073 | *   | <span class='executed'>          (logTo - db + twoX59).times(dc)</span>
 1074 |     | <span class='neutral'>        ) : (</span>
 1075 | *   | <span class='executed'>          (db - logFrom + twoX59).times(dc),</span>
 1076 | *   | <span class='executed'>          (db - logTo + twoX59).times(dc)</span>
 1077 |     | <span class='neutral'>        );</span>
 1078 |     | <span class='neutral'>      }</span>
 1079 |     | <span class='neutral'></span>
 1080 |     | <span class='neutral'>      // &#39;db&#39; represents the horizontal length of the segment that</span>
 1081 |     | <span class='neutral'>      // characterizes the function that we are integrating. The subtractions</span>
 1082 |     | <span class='neutral'>      // are safe due to the input requirements. Because if &#39;left == false&#39;,</span>
 1083 |     | <span class='neutral'>      // we have &#39;b0 &lt;= b1&#39; and if &#39;left == true&#39;, we have &#39;b0 &gt;= b1&#39;.</span>
 1084 | *   | <span class='executed'>      db = left ? coordinate0.log() - db : db - coordinate0.log();</span>
 1085 |     | <span class='neutral'>    }</span>
 1086 |     | <span class='neutral'></span>
 1087 | *   | <span class='executed'>    assembly {</span>
 1088 |     | <span class='neutral'>      // The least significant 192-bits of the product </span>
 1089 |     | <span class='neutral'>      // &#39;from_times_dc * sqrtFrom&#39; which is in &#39;X290&#39; representation because</span>
 1090 |     | <span class='neutral'>      // &#39;from_times_dc&#39; is &#39;X74&#39; and &#39;sqrtFrom&#39; is &#39;X216&#39;.</span>
 1091 | *   | <span class='executed'>      let lsbits0X290 := mulmod(from_times_dc, sqrtFrom, shl(192, 1))</span>
 1092 |     | <span class='neutral'></span>
 1093 |     | <span class='neutral'>      // The least significant 192-bits of the product </span>
 1094 |     | <span class='neutral'>      // &#39;to_times_dc * sqrtTo&#39; which is in &#39;X290&#39; representation because</span>
 1095 |     | <span class='neutral'>      // &#39;to_times_dc&#39; is &#39;X74&#39; and &#39;sqrtTo&#39; is &#39;X216&#39;.</span>
 1096 | *   | <span class='executed'>      let lsbits1X290 := mulmod(to_times_dc, sqrtTo, shl(192, 1))</span>
 1097 |     | <span class='neutral'></span>
 1098 |     | <span class='neutral'>      // Next, we calculate </span>
 1099 |     | <span class='neutral'>      // &#39;sqrtTo * to_times_dc - sqrtFrom * from_times_dc&#39;.</span>
 1100 |     | <span class='neutral'>      //</span>
 1101 |     | <span class='neutral'>      // Next, we are going to prove that the subtraction is safe:</span>
 1102 |     | <span class='neutral'>      //</span>
 1103 |     | <span class='neutral'>      // If &#39;f &lt; t&#39;, We are calculating</span>
 1104 |     | <span class='neutral'>      //</span>
 1105 |     | <span class='neutral'>      // y := ((b1 - t + 2) * exp(+ t / 2) - (b1 - f + 2) * exp(+ f / 2)) * dc</span>
 1106 |     | <span class='neutral'>      //</span>
 1107 |     | <span class='neutral'>      // In this case, because &#39;(q + 2) * exp(-q / 2)&#39; is a decreasing function</span>
 1108 |     | <span class='neutral'>      // within the interval &#39;(0, +oo)&#39;, the expression</span>
 1109 |     | <span class='neutral'>      // </span>
 1110 |     | <span class='neutral'>      // (b1 - t + 2) * exp(-(b1 - t) / 2) - (b1 - f + 2) * exp(-(b1 - f) / 2)</span>
 1111 |     | <span class='neutral'>      //</span>
 1112 |     | <span class='neutral'>      // is non-negative which concludes that &#39;y&#39; is also non-negative. Hence,</span>
 1113 |     | <span class='neutral'>      // the subtraction is safe.</span>
 1114 |     | <span class='neutral'>      //</span>
 1115 |     | <span class='neutral'>      // If &#39;t &lt; f&#39;, We are calculating</span>
 1116 |     | <span class='neutral'>      //</span>
 1117 |     | <span class='neutral'>      // y := ((t - b1 + 2) * exp(- t / 2) - (f - b1 + 2) * exp(- f / 2)) * dc</span>
 1118 |     | <span class='neutral'>      //</span>
 1119 |     | <span class='neutral'>      // In this case, because &#39;(q + 2) * exp(-q / 2)&#39; is a decreasing function</span>
 1120 |     | <span class='neutral'>      // within the interval &#39;(0, +oo)&#39;, the expression</span>
 1121 |     | <span class='neutral'>      // </span>
 1122 |     | <span class='neutral'>      // (t - b1 + 2) * exp(-(t - b1) / 2) - (f - b1 + 2) * exp(-(f - b1) / 2)</span>
 1123 |     | <span class='neutral'>      //</span>
 1124 |     | <span class='neutral'>      // is non-negative which concludes that &#39;y&#39; is also non-negative. Hence,</span>
 1125 |     | <span class='neutral'>      // the subtraction is safe.</span>
 1126 |     | <span class='neutral'></span>
 1127 |     | <span class='neutral'>      // The least significant 192-bits of </span>
 1128 |     | <span class='neutral'>      // &#39;sqrtTo * to_times_dc - sqrtFrom * from_times_dc&#39; which may underflow</span>
 1129 |     | <span class='neutral'>      // in which case &#39;1&#39; will be subtracted from &#39;msbitsX290&#39;.</span>
 1130 |     | <span class='neutral'>      // The subtraction is safe because &#39;lsbits0X290&#39; is less than &#39;1 &lt;&lt; 192&#39;.</span>
 1131 | *   | <span class='executed'>      let lsbitsX290 := addmod(</span>
 1132 | *   | <span class='executed'>        lsbits1X290,</span>
 1133 | *   | <span class='executed'>        sub(shl(192, 1), lsbits0X290),</span>
 1134 | *   | <span class='executed'>        shl(192, 1)</span>
 1135 |     | <span class='neutral'>      )</span>
 1136 |     | <span class='neutral'></span>
 1137 |     | <span class='neutral'>      // The most significant 128-bits of </span>
 1138 |     | <span class='neutral'>      // &#39;sqrtTo * to_times_dc - sqrtFrom * from_times_dc&#39;.</span>
 1139 | *   | <span class='executed'>      let msbitsX290 := sub(</span>
 1140 |     | <span class='neutral'>        // &#39;x == from_times_dc * sqrtFrom - (2 ** 192) * a&#39;</span>
 1141 |     | <span class='neutral'>        // &#39;y == to_times_dc * sqrtTo - (2 ** 192 - 1) * b&#39;</span>
 1142 |     | <span class='neutral'>        // &#39;z == to_times_dc * sqrtTo - (2 ** 192) * c&#39;</span>
 1143 |     | <span class='neutral'>        // &#39;w == from_times_dc * sqrtFrom - (2 ** 192 - 1) * d&#39;</span>
 1144 |     | <span class='neutral'>        //</span>
 1145 |     | <span class='neutral'>        // &#39;x + y - z - w == b - d (mod 2 ** 192)&#39;</span>
 1146 | *   | <span class='executed'>        sub(</span>
 1147 | *   | <span class='executed'>          add(</span>
 1148 | *   | <span class='executed'>            lsbits0X290,</span>
 1149 | *   | <span class='executed'>            mulmod(to_times_dc, sqrtTo, sub(shl(192, 1), 1))</span>
 1150 |     | <span class='neutral'>          ),</span>
 1151 | *   | <span class='executed'>          add(</span>
 1152 | *   | <span class='executed'>            lsbits1X290,</span>
 1153 | *   | <span class='executed'>            mulmod(from_times_dc, sqrtFrom, sub(shl(192, 1), 1))</span>
 1154 |     | <span class='neutral'>          )</span>
 1155 |     | <span class='neutral'>        ),</span>
 1156 |     | <span class='neutral'>        // &#39;lsbits1X290 &lt; lsbits0X290&#39; indicates that &#39;lsbits&#39; has underflowed.</span>
 1157 |     | <span class='neutral'>        // In this case, we need to subtract &#39;msbitsX290&#39; by &#39;1&#39;.</span>
 1158 | *   | <span class='executed'>        lt(lsbits1X290, lsbits0X290)</span>
 1159 |     | <span class='neutral'>      )</span>
 1160 |     | <span class='neutral'></span>
 1161 |     | <span class='neutral'>      // Next, we calculate:</span>
 1162 |     | <span class='neutral'>      //</span>
 1163 |     | <span class='neutral'>      // &#39;(sqrtTo * to_times_dc - sqrtFrom * from_times_dc) / db&#39;</span>
 1164 |     | <span class='neutral'>      //</span>
 1165 |     | <span class='neutral'>      // Here, we perform the division by &#39;db&#39; via the simple long division</span>
 1166 |     | <span class='neutral'>      //                   _____________________</span>
 1167 |     | <span class='neutral'>      // algorithm, i.e., &#39;msbitsX290 lsbitsX290&#39; divided by &#39;db&#39; becomes:</span>
 1168 |     | <span class='neutral'>      //</span>
 1169 |     | <span class='neutral'>      //                 q1X231           q0X231</span>
 1170 |     | <span class='neutral'>      //      -----------------------------------</span>
 1171 |     | <span class='neutral'>      // db   |      msbitsX290       lsbitsX290</span>
 1172 |     | <span class='neutral'>      //      |</span>
 1173 |     | <span class='neutral'>      //            q1X231 * db </span>
 1174 |     | <span class='neutral'>      //        ---------------------------------</span>
 1175 |     | <span class='neutral'>      //        msbitsX290 % db       lsbitsX290</span>
 1176 |     | <span class='neutral'>      //</span>
 1177 |     | <span class='neutral'>      //                             q0X231 * db</span>
 1178 |     | <span class='neutral'>      //        ---------------------------------</span>
 1179 |     | <span class='neutral'>      //                                       r</span>
 1180 |     | <span class='neutral'>      //</span>
 1181 |     | <span class='neutral'>      // where</span>
 1182 |     | <span class='neutral'>      // &#39;r := (msbitsX290 * (2 ** 192) + lsbitsX290) % db&#39;</span>
 1183 |     | <span class='neutral'>      // &#39;q1X231 := msbitsX290 / db&#39;</span>
 1184 |     | <span class='neutral'>      // &#39;q0X231 := ((msbitsX290 % db) * (2 ** 192) + lsbitsX290) / db&#39;</span>
 1185 |     | <span class='neutral'>      //</span>
 1186 |     | <span class='neutral'>      // Next, we will prove that &#39;msbitsX290 / db &lt; 2 ** 50&#39; which will be</span>
 1187 |     | <span class='neutral'>      // useful later. If &#39;f &lt; t&#39; (the other side can be argued similarly), we</span>
 1188 |     | <span class='neutral'>      // have:</span>
 1189 |     | <span class='neutral'>      //</span>
 1190 |     | <span class='neutral'>      //  (2 ** 192) * msbitsX290 + lsbitsX290</span>
 1191 |     | <span class='neutral'>      // -------------------------------------- ==</span>
 1192 |     | <span class='neutral'>      //      (2 ** (290 - 59)) * (b1 - b0)</span>
 1193 |     | <span class='neutral'>      //</span>
 1194 |     | <span class='neutral'>      //   (2 ** 192) * msbitsX290 + lsbitsX290</span>
 1195 |     | <span class='neutral'>      //  --------------------------------------</span>
 1196 |     | <span class='neutral'>      //                2 ** 290</span>
 1197 |     | <span class='neutral'>      // ---------------------------------------- ==</span>
 1198 |     | <span class='neutral'>      //                b1 - b0</span>
 1199 |     | <span class='neutral'>      //               ---------</span>
 1200 |     | <span class='neutral'>      //                2 ** 59</span>
 1201 |     | <span class='neutral'>      //</span>
 1202 |     | <span class='neutral'>      //  ((b1 - t + 2) * exp(+ t / 2) - (b1 - f + 2) * exp(+ f / 2)) * dc</span>
 1203 |     | <span class='neutral'>      // ------------------------------------------------------------------ &lt;=</span>
 1204 |     | <span class='neutral'>      //                              b1 - b0</span>
 1205 |     | <span class='neutral'>      //</span>
 1206 |     | <span class='neutral'>      //  ((b1 - t + 2) * exp(+ t / 2) - (b1 - f + 2) * exp(+ f / 2)) * dc</span>
 1207 |     | <span class='neutral'>      // ------------------------------------------------------------------ ==</span>
 1208 |     | <span class='neutral'>      //                               t - f</span>
 1209 |     | <span class='neutral'>      //</span>
 1210 |     | <span class='neutral'>      //  g(b1 - t) - g(b1 - f)</span>
 1211 |     | <span class='neutral'>      // ----------------------- * exp(+ b1 / 2) * dc ==</span>
 1212 |     | <span class='neutral'>      //   (b1 - t) - (b1 - f)</span>
 1213 |     | <span class='neutral'>      //</span>
 1214 |     | <span class='neutral'>      //  g&#39;(z) * exp(+ b1 / 2) * dc &lt;= exp(-1) * exp(8) * dc &lt; exp(7)</span>
 1215 |     | <span class='neutral'>      //  &lt; 2 ** 11</span>
 1216 |     | <span class='neutral'>      //</span>
 1217 |     | <span class='neutral'>      // where &#39;g(q) := - (q + 2) * exp(-q / 2)&#39; and &#39;z&#39; is some arbitrary </span>
 1218 |     | <span class='neutral'>      // point within the interval &#39;(0, +oo)&#39; whose existence is guaranteed</span>
 1219 |     | <span class='neutral'>      // thanks to the mean value theorem.</span>
 1220 |     | <span class='neutral'>      //</span>
 1221 |     | <span class='neutral'>      // Due to the above argument, we have &#39;msbitsX290 / db &lt;= 2 ** 50&#39;.</span>
 1222 | *   | <span class='executed'>      let quotientX231 := add(</span>
 1223 |     | <span class='neutral'>        // First, we calculate &#39;q1X231 &lt;&lt; 192&#39; which the more significant part</span>
 1224 |     | <span class='neutral'>        // of the quotientX231.</span>
 1225 |     | <span class='neutral'>        //</span>
 1226 |     | <span class='neutral'>        // The division &#39;msbits / db&#39; is safe because &#39;db != 0&#39; due to an input</span>
 1227 |     | <span class='neutral'>        // requirement.</span>
 1228 |     | <span class='neutral'>        //</span>
 1229 |     | <span class='neutral'>        // The 192 bit shift to the left is safe because we have proven that</span>
 1230 |     | <span class='neutral'>        // &#39;msbitsX290 / db &lt;= 2 ** 50&#39;.</span>
 1231 | *   | <span class='executed'>        shl(192, div(msbitsX290, db)),</span>
 1232 |     | <span class='neutral'>        // Then, we calculate &#39;q0X231&#39; which is the least significant 192 bits</span>
 1233 |     | <span class='neutral'>        // of &#39;quotientX231&#39;.</span>
 1234 |     | <span class='neutral'>        //</span>
 1235 |     | <span class='neutral'>        // The division by &#39;db&#39; is safe because &#39;db != 0&#39; due to an input</span>
 1236 |     | <span class='neutral'>        // requirement.</span>
 1237 | *   | <span class='executed'>        div(</span>
 1238 | *   | <span class='executed'>          add(</span>
 1239 |     | <span class='neutral'>            // The shift does not overflow because </span>
 1240 |     | <span class='neutral'>            // &#39;msbitsX290 % db &lt; db &lt; 2 ** 64&#39;.</span>
 1241 | *   | <span class='executed'>            shl(192, mod(msbitsX290, db)),</span>
 1242 | *   | <span class='executed'>            lsbitsX290</span>
 1243 |     | <span class='neutral'>          ),</span>
 1244 | *   | <span class='executed'>          db</span>
 1245 |     | <span class='neutral'>        )</span>
 1246 |     | <span class='neutral'>      )</span>
 1247 |     | <span class='neutral'></span>
 1248 |     | <span class='neutral'>      // Lastly, the following value is calculated:</span>
 1249 |     | <span class='neutral'>      //</span>
 1250 |     | <span class='neutral'>      // &#39;c1 * (to.sqrt(!left) - from.sqrt(!left)) - quotient&#39;</span>
 1251 |     | <span class='neutral'>      //</span>
 1252 |     | <span class='neutral'>      // The inner subtraction is safe, because if &#39;f &lt;= t&#39; then</span>
 1253 |     | <span class='neutral'>      // &#39;left == false&#39; and we have &#39;exp(- 8 + f / 2) &lt;= exp(- 8 + t / 2)&#39;</span>
 1254 |     | <span class='neutral'>      // which concludes &#39;from.sqrt(!left) &lt;= to.sqrt(!left)&#39;</span>
 1255 |     | <span class='neutral'>      //</span>
 1256 |     | <span class='neutral'>      // On the other hand, if &#39;t &lt; f&#39; then &#39;left == true&#39; and we have</span>
 1257 |     | <span class='neutral'>      // &#39;exp(- 8 - f / 2) &lt; exp(- 8 - t / 2)&#39; which concludes</span>
 1258 |     | <span class='neutral'>      // &#39;from.sqrt(!left) &lt; to.sqrt(!left)&#39;.</span>
 1259 |     | <span class='neutral'>      //</span>
 1260 |     | <span class='neutral'>      // The multiplication is safe because &#39;c1&#39; and &#39;sqrtTo - sqrtFrom&#39; are</span>
 1261 |     | <span class='neutral'>      // nonnegative values which do not exceed &#39;16&#39; and &#39;216&#39; bits, </span>
 1262 |     | <span class='neutral'>      // respectively.</span>
 1263 |     | <span class='neutral'>      //</span>
 1264 |     | <span class='neutral'>      // The outer subtraction is safe because the output integral is</span>
 1265 |     | <span class='neutral'>      // non-negative. Underflow due to rounding error is also impossible</span>
 1266 |     | <span class='neutral'>      // because the lowest possible value for an incoming integral</span>
 1267 |     | <span class='neutral'>      // corresponds to </span>
 1268 |     | <span class='neutral'>      //</span>
 1269 |     | <span class='neutral'>      // &#39;c0 := 0&#39;</span>
 1270 |     | <span class='neutral'>      // &#39;c1 := 1 / (2 ** 15)&#39;</span>
 1271 |     | <span class='neutral'>      // &#39;b0 := - 16 + 1 / (2 ** 59)&#39;</span>
 1272 |     | <span class='neutral'>      // &#39;b1 := + 16 - 1 / (2 ** 59)&#39;</span>
 1273 |     | <span class='neutral'>      // &#39;f := - 16 + 1 / (2 ** 59)&#39;</span>
 1274 |     | <span class='neutral'>      // &#39;t := - 16 + 2 / (2 ** 59)&#39;</span>
 1275 |     | <span class='neutral'>      //</span>
 1276 |     | <span class='neutral'>      // leading to</span>
 1277 |     | <span class='neutral'>      //                               / t</span>
 1278 |     | <span class='neutral'>      //                              |     +h/2         c1 - c0</span>
 1279 |     | <span class='neutral'>      // (2 ** 216) * (exp(-8) / 2) * |    e      (c0 + --------- (h - b0)) dh</span>
 1280 |     | <span class='neutral'>      //                              |                  b1 - b0</span>
 1281 |     | <span class='neutral'>      //                             / f</span>
 1282 |     | <span class='neutral'>      //</span>
 1283 |     | <span class='neutral'>      // ~= 8502917395809738</span>
 1284 |     | <span class='neutral'>      //</span>
 1285 |     | <span class='neutral'>      // which does not underflow.</span>
 1286 |     | <span class='neutral'>      //</span>
 1287 |     | <span class='neutral'>      // We shift the result by 15 bits to the right to cancel the &#39;X15&#39;</span>
 1288 |     | <span class='neutral'>      // representation of &#39;c1&#39; and &#39;dc&#39;.</span>
 1289 | *   | <span class='executed'>      result := shr(15, sub(mul(c1, sub(sqrtTo, sqrtFrom)), quotientX231))</span>
 1290 |     | <span class='neutral'>    }</span>
 1291 |     | <span class='neutral'>  }</span>
 1292 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/Interval.sol</b>
<code>
    1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
    2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>import {</span>
    5 |     | <span class='neutral'>  _current_,</span>
    6 |     | <span class='neutral'>  _origin_,</span>
    7 |     | <span class='neutral'>  _begin_,</span>
    8 |     | <span class='neutral'>  _end_,</span>
    9 |     | <span class='neutral'>  _target_,</span>
   10 |     | <span class='neutral'>  _overshoot_,</span>
   11 |     | <span class='neutral'>  _total0_,</span>
   12 |     | <span class='neutral'>  _total1_,</span>
   13 |     | <span class='neutral'>  _forward0_,</span>
   14 |     | <span class='neutral'>  _forward1_,</span>
   15 |     | <span class='neutral'>  _indexKernelTotal_,</span>
   16 |     | <span class='neutral'>  _indexKernelForward_,</span>
   17 |     | <span class='neutral'>  _indexCurve_,</span>
   18 |     | <span class='neutral'>  _currentToTarget_,</span>
   19 |     | <span class='neutral'>  _incomingCurrentToTarget_,</span>
   20 |     | <span class='neutral'>  _originToOvershoot_,</span>
   21 |     | <span class='neutral'>  _currentToOrigin_,</span>
   22 |     | <span class='neutral'>  _targetToOvershoot_,</span>
   23 |     | <span class='neutral'>  _currentToOvershoot_,</span>
   24 |     | <span class='neutral'>  _interval_,</span>
   25 |     | <span class='neutral'>  _spacing_,</span>
   26 |     | <span class='neutral'>  _endOfInterval_,</span>
   27 |     | <span class='neutral'>  getCurve,</span>
   28 |     | <span class='neutral'>  getLogPriceLimitOffsetted,</span>
   29 |     | <span class='neutral'>  getCurveLength,</span>
   30 |     | <span class='neutral'>  getKernel,</span>
   31 |     | <span class='neutral'>  getDirection,</span>
   32 |     | <span class='neutral'>  getIntegralLimit,</span>
   33 |     | <span class='neutral'>  getZeroForOne,</span>
   34 |     | <span class='neutral'>  getExactInput,</span>
   35 |     | <span class='neutral'>  getLogPriceLimitOffsettedWithinInterval,</span>
   36 |     | <span class='neutral'>  getLogPriceCurrent,</span>
   37 |     | <span class='neutral'>  setZeroForOne,</span>
   38 |     | <span class='neutral'>  setCurveLength,</span>
   39 |     | <span class='neutral'>  setOutgoingMax,</span>
   40 |     | <span class='neutral'>  setOutgoingMaxModularInverse,</span>
   41 |     | <span class='neutral'>  setIncomingMax,</span>
   42 |     | <span class='neutral'>  setCurve,</span>
   43 |     | <span class='neutral'>  setLogPriceLimitOffsetted,</span>
   44 |     | <span class='neutral'>  setIntegralLimit,</span>
   45 |     | <span class='neutral'>  setIndexCurve,</span>
   46 |     | <span class='neutral'>  setDirection,</span>
   47 |     | <span class='neutral'>  setLogPriceLimitOffsettedWithinInterval,</span>
   48 |     | <span class='neutral'>  setIntegral0,</span>
   49 |     | <span class='neutral'>  setIntegral1</span>
   50 |     | <span class='neutral'>} from &quot;./Memory.sol&quot;;</span>
   51 |     | <span class='neutral'>import {Index, zeroIndex, oneIndex, IndexLibrary} from &quot;./Index.sol&quot;;</span>
   52 |     | <span class='neutral'>import {X15} from &quot;./X15.sol&quot;;</span>
   53 |     | <span class='neutral'>import {X59, min, max, zeroX59, twoX59, epsilonX59} from &quot;./X59.sol&quot;;</span>
   54 |     | <span class='neutral'>import {X74} from &quot;./X74.sol&quot;;</span>
   55 |     | <span class='neutral'>import {</span>
   56 |     | <span class='neutral'>  X216,</span>
   57 |     | <span class='neutral'>  min,</span>
   58 |     | <span class='neutral'>  max,</span>
   59 |     | <span class='neutral'>  zeroX216,</span>
   60 |     | <span class='neutral'>  oneX216,</span>
   61 |     | <span class='neutral'>  epsilonX216,</span>
   62 |     | <span class='neutral'>  expInverse8X216</span>
   63 |     | <span class='neutral'>} from &quot;./X216.sol&quot;;</span>
   64 |     | <span class='neutral'>import {FullMathLibrary} from &quot;./FullMath.sol&quot;;</span>
   65 |     | <span class='neutral'>import {Curve} from &quot;./Curve.sol&quot;;</span>
   66 |     | <span class='neutral'>import {Kernel} from &quot;./Kernel.sol&quot;;</span>
   67 |     | <span class='neutral'>import {IntegralLibrary} from &quot;./Integral.sol&quot;;</span>
   68 |     | <span class='neutral'>import {PriceLibrary} from &quot;./Price.sol&quot;;</span>
   69 |     | <span class='neutral'>import {</span>
   70 |     | <span class='neutral'>  SearchingForOutgoingTargetFailed,</span>
   71 |     | <span class='neutral'>  SearchingForIncomingTargetFailed,</span>
   72 |     | <span class='neutral'>  SearchingForOvershootFailed</span>
   73 |     | <span class='neutral'>} from &quot;./Errors.sol&quot;;</span>
   74 |     | <span class='neutral'></span>
   75 |     | <span class='neutral'>using PriceLibrary for uint16;</span>
   76 |     | <span class='neutral'>using IndexLibrary for uint16;</span>
   77 |     | <span class='neutral'>using IntegralLibrary for uint16;</span>
   78 |     | <span class='neutral'>using IntegralLibrary for X216;</span>
   79 |     | <span class='neutral'></span>
   80 |     | <span class='neutral'>/// @notice In order to perform a swap within the current active liquidity</span>
   81 |     | <span class='neutral'>/// interval, the following parameters should be set in memory:</span>
   82 |     | <span class='neutral'>///</span>
   83 |     | <span class='neutral'>/// - &#39;logPriceLimitOffsettedWithinInterval&#39;</span>
   84 |     | <span class='neutral'>/// - &#39;indexCurve&#39;</span>
   85 |     | <span class='neutral'>/// - &#39;direction&#39;</span>
   86 |     | <span class='neutral'>/// - &#39;current&#39;</span>
   87 |     | <span class='neutral'>/// - &#39;origin&#39;</span>
   88 |     | <span class='neutral'>/// - &#39;begin&#39;</span>
   89 |     | <span class='neutral'>/// - &#39;end&#39;</span>
   90 |     | <span class='neutral'>/// - &#39;target&#39;</span>
   91 |     | <span class='neutral'>/// - &#39;total0&#39;</span>
   92 |     | <span class='neutral'>/// - &#39;total1&#39;</span>
   93 |     | <span class='neutral'>///</span>
   94 |     | <span class='neutral'>/// where the description of each parameter is given in &#39;Memory.sol&#39;. This</span>
   95 |     | <span class='neutral'>/// function initiates the &#39;swapWithin&#39; method of &#39;Swap.sol&#39; by setting the</span>
   96 |     | <span class='neutral'>/// above parameters.</span>
   97 |     | <span class='neutral'>function initiateInterval() pure {</span>
   98 |     | <span class='neutral'>  // We first load the memory pointer for the curve sequence from the memory.</span>
   99 |     | <span class='neutral'>  Curve curve = getCurve();</span>
  100 |     | <span class='neutral'></span>
  101 |     | <span class='neutral'>  // The value set as &#39;logPriceLimitOffsetted&#39; may be outside of the current</span>
  102 |     | <span class='neutral'>  // active liquidity interval. In such cases, we first need to perform a swap</span>
  103 |     | <span class='neutral'>  // towards the current interval boundary and then we transition to a new</span>
  104 |     | <span class='neutral'>  // interval. In order to perform the former step, &#39;logPriceLimitOffsetted&#39;</span>
  105 |     | <span class='neutral'>  // needs to be capped by the boundaries of the current active liquidity</span>
  106 |     | <span class='neutral'>  // interval.</span>
  107 |     | <span class='neutral'>  {</span>
  108 |     | <span class='neutral'>    // To this end, the first two members of the curve sequence are loaded. As</span>
  109 |     | <span class='neutral'>    // explained in &#39;Curve.sol&#39;, the first two members are the boundaries of</span>
  110 |     | <span class='neutral'>    // the current active liquidity interval.</span>
  111 |     | <span class='neutral'>    (X59 qLower, X59 qUpper) = curve.boundaries();</span>
  112 |     | <span class='neutral'></span>
  113 |     | <span class='neutral'>    // Signed comparison is valid here because:</span>
  114 |     | <span class='neutral'>    //</span>
  115 |     | <span class='neutral'>    // &#39;0 &lt; qLower &lt; 2 ** 64&#39;,</span>
  116 |     | <span class='neutral'>    // &#39;0 &lt; qUpper &lt; 2 ** 64&#39;,</span>
  117 |     | <span class='neutral'>    // &#39;0 &lt; getLogPriceLimitOffsetted() &lt; 2 ** 64&#39;.</span>
  118 |     | <span class='neutral'>    //</span>
  119 |     | <span class='neutral'>    // Each of the above values are offsetted logarithmic prices that occupy</span>
  120 |     | <span class='neutral'>    // exactly &#39;64&#39; bits in memory.</span>
  121 |     | <span class='neutral'>    //</span>
  122 |     | <span class='neutral'>    // The resulting value is also between &#39;0&#39; and &#39;2 ** 64&#39; and can be safely</span>
  123 |     | <span class='neutral'>    // stored within the allocated &#39;64&#39; bits of memory.</span>
  124 |     | <span class='neutral'>    setLogPriceLimitOffsettedWithinInterval(</span>
  125 |     | <span class='neutral'>      min(max(qLower, getLogPriceLimitOffsetted()), qUpper)</span>
  126 |     | <span class='neutral'>    );</span>
  127 |     | <span class='neutral'>  }</span>
  128 |     | <span class='neutral'></span>
  129 |     | <span class='neutral'>  // As explained in &#39;Curve.sol&#39;, the length of the curve sequence is always</span>
  130 |     | <span class='neutral'>  // greater than or equal to &#39;2&#39;. Hence, subtraction is safe here.</span>
  131 |     | <span class='neutral'>  Index indexCurve = getCurveLength() - oneIndex;</span>
  132 |     | <span class='neutral'></span>
  133 |     | <span class='neutral'>  // When performing a swap within the current active liquidity interval, we</span>
  134 |     | <span class='neutral'>  // explore members of the curve sequence by starting from the last member.</span>
  135 |     | <span class='neutral'>  // Hence, the initial index should point to the last member, which is how</span>
  136 |     | <span class='neutral'>  // &#39;indexCurve&#39; is chosen. The very first execution of the method</span>
  137 |     | <span class='neutral'>  // &#39;movePhase()&#39; reduces &#39;indexCurve&#39; to &#39;getCurveLength() - twoIndex&#39; which</span>
  138 |     | <span class='neutral'>  // refers to the very first phase of &#39;w(.)&#39; to be explored.</span>
  139 |     | <span class='neutral'>  //</span>
  140 |     | <span class='neutral'>  // The value of &#39;indexCurve&#39; is less than &#39;getCurveLength()&#39; and therefore</span>
  141 |     | <span class='neutral'>  // does not exceed &#39;2&#39; bytes. Hence, it can be safely stored in the allocated</span>
  142 |     | <span class='neutral'>  // 2 bytes of memory.</span>
  143 |     | <span class='neutral'>  setIndexCurve(indexCurve);</span>
  144 |     | <span class='neutral'></span>
  145 |     | <span class='neutral'>  // Index out of range is not possible because &#39;indexCurve&#39; refers to the last</span>
  146 |     | <span class='neutral'>  // member of the curve which is the current offsetted logarithmic price as</span>
  147 |     | <span class='neutral'>  // explained in &#39;Curve.sol&#39;.</span>
  148 |     | <span class='neutral'>  X59 current = curve.member(indexCurve);</span>
  149 |     | <span class='neutral'></span>
  150 |     | <span class='neutral'>  // As explained in &#39;Memory.sol&#39;, the curve sequence leads to a function</span>
  151 |     | <span class='neutral'>  // &#39;w : [qLower, qUpper] -&gt; [0, qSpacing]&#39; which is composed of &#39;phases&#39;. For</span>
  152 |     | <span class='neutral'>  // example, let &#39;qLower, qUpper, qCurrent&#39; represent the curve sequence.</span>
  153 |     | <span class='neutral'>  // Then, &#39;w(q)&#39; can be plotted as follows:</span>
  154 |     | <span class='neutral'>  //</span>
  155 |     | <span class='neutral'>  //          ^</span>
  156 |     | <span class='neutral'>  //  spacing |\</span>
  157 |     | <span class='neutral'>  //          | \</span>
  158 |     | <span class='neutral'>  //          |  \</span>
  159 |     | <span class='neutral'>  //          |   \</span>
  160 |     | <span class='neutral'>  //          |    \</span>
  161 |     | <span class='neutral'>  //          |     \</span>
  162 |     | <span class='neutral'>  //          |      \</span>
  163 |     | <span class='neutral'>  //          |               /</span>
  164 |     | <span class='neutral'>  //          |              /</span>
  165 |     | <span class='neutral'>  //          |             /</span>
  166 |     | <span class='neutral'>  //          |            /</span>
  167 |     | <span class='neutral'>  //          |           /</span>
  168 |     | <span class='neutral'>  //          |          /</span>
  169 |     | <span class='neutral'>  //          |         /</span>
  170 |     | <span class='neutral'>  //          |        /</span>
  171 |     | <span class='neutral'>  //        0 +-------+--------+</span>
  172 |     | <span class='neutral'>  //       qLower  qCurrent  qUpper</span>
  173 |     | <span class='neutral'>  //</span>
  174 |     | <span class='neutral'>  // See &#39;Memory.sol&#39; for the precise definition of &#39;w(q)&#39;. In general, the</span>
  175 |     | <span class='neutral'>  // very first &#39;phase&#39; to be explored corresponds to the segment in between</span>
  176 |     | <span class='neutral'>  // &#39;curve.member(getCurveLength() - oneIndex)&#39; and </span>
  177 |     | <span class='neutral'>  // &#39;curve.member(getCurveLength() - twoIndex)&#39;. In this example, the first</span>
  178 |     | <span class='neutral'>  // phase is within &#39;(qCurrent, qUpper)&#39;.</span>
  179 |     | <span class='neutral'>  //</span>
  180 |     | <span class='neutral'>  // Here, the direction of the initial &#39;phase&#39; to be explored is determined</span>
  181 |     | <span class='neutral'>  // and its opposite is set in memory. If</span>
  182 |     | <span class='neutral'>  // &#39;(2 ** 59) * (16 + qCurrent) &lt; curve.member(indexCurve - oneIndex)&#39;, then</span>
  183 |     | <span class='neutral'>  // the direction is towards &#39;+oo&#39; and we should store &#39;true&#39;. Alternatively</span>
  184 |     | <span class='neutral'>  // if &#39;(2 ** 59) * (16 + qCurrent) &gt; curve.member(indexCurve - oneIndex)&#39;,</span>
  185 |     | <span class='neutral'>  // then the direction is towards &#39;-oo&#39; and we should store &#39;false&#39;. Notice</span>
  186 |     | <span class='neutral'>  // that members of the curve sequence may never be equal. Lastly, we store</span>
  187 |     | <span class='neutral'>  // the opposite so that after the first execution of &#39;movePhase()&#39; the</span>
  188 |     | <span class='neutral'>  // direction is corrected. As explained in &#39;Memory.sol&#39; regardless of the</span>
  189 |     | <span class='neutral'>  // value for &#39;zeroForOne&#39; (i.e., whether the swap is towards &#39;+oo&#39; or &#39;-oo&#39;),</span>
  190 |     | <span class='neutral'>  // we flip the direction flag every time that we move to a new &#39;phase&#39;,</span>
  191 |     | <span class='neutral'>  // because consecutive phases have opposite directions. In the above example,</span>
  192 |     | <span class='neutral'>  // the direction of the very first &#39;phase&#39; within &#39;(qCurrent, qUpper)&#39; is</span>
  193 |     | <span class='neutral'>  // towards &#39;+oo&#39; and the direction of the second &#39;phase&#39; within</span>
  194 |     | <span class='neutral'>  // &#39;(qLower, qCurrent)&#39; is towards &#39;-oo&#39;, i.e., &#39;false&#39; and &#39;true&#39;,</span>
  195 |     | <span class='neutral'>  // respectively. We store the opposite of the direction for the first</span>
  196 |     | <span class='neutral'>  // &#39;phase&#39;, so that the first run of the function &#39;movePhase()&#39; would change</span>
  197 |     | <span class='neutral'>  // the direction to the intended value.</span>
  198 |     | <span class='neutral'>  //</span>
  199 |     | <span class='neutral'>  // Subtraction is safe because the length of the curve is always greater than</span>
  200 |     | <span class='neutral'>  // or equal to &#39;2&#39; and hence,</span>
  201 |     | <span class='neutral'>  // &#39;indexCurve - oneIndex == getCurveLength() - twoIndex &gt;= zeroIndex&#39;.</span>
  202 |     | <span class='neutral'>  //</span>
  203 |     | <span class='neutral'>  // Signed comparison is valid here because both sides are members of curve</span>
  204 |     | <span class='neutral'>  // that are nonnegative and less than &#39;2 ** 64&#39;.</span>
  205 |     | <span class='neutral'>  setDirection(current &lt; curve.member(indexCurve - oneIndex));</span>
  206 |     | <span class='neutral'></span>
  207 |     | <span class='neutral'>  // Next, the values &#39;(2 ** 216) * exp(- 8 - qCurrent / 2)&#39; and</span>
  208 |     | <span class='neutral'>  // &#39;(2 ** 216) * exp(- 8 + qCurrent / 2)&#39; are determined and stored in memory</span>
  209 |     | <span class='neutral'>  // along with &#39;(2 ** 59) * (16 + qCurrent)&#39;. The resulting values are then</span>
  210 |     | <span class='neutral'>  // copied as initial points for &#39;qOrigin&#39;, &#39;qBegin&#39;, &#39;qEnd&#39;, &#39;qTarget&#39;,</span>
  211 |     | <span class='neutral'>  // &#39;qTotal0&#39;, and &#39;qTotal1&#39;.</span>
  212 |     | <span class='neutral'>  //</span>
  213 |     | <span class='neutral'>  // The requirements of store price are satisfied because &#39;qCurrent&#39; is a </span>
  214 |     | <span class='neutral'>  // member of the curve sequence and may never exceed &#39;64&#39; bits. Additionally,</span>
  215 |     | <span class='neutral'>  // the value for all of the pointers below is a constant greater than &#39;32&#39;.</span>
  216 |     | <span class='neutral'>  //</span>
  217 |     | <span class='neutral'>  // The definition for the content of each memory pointer is given in</span>
  218 |     | <span class='neutral'>  // &#39;Memory.sol&#39;.</span>
  219 |     | <span class='neutral'>  _current_.storePrice(current);</span>
  220 |     | <span class='neutral'>  _origin_.copyPrice(_current_);</span>
  221 |     | <span class='neutral'>  _begin_.copyPrice(_current_);</span>
  222 |     | <span class='neutral'>  _end_.copyPrice(_current_);</span>
  223 |     | <span class='neutral'>  _target_.copyPrice(_current_);</span>
  224 |     | <span class='neutral'>  // Notice that according to &#39;PriceLibrary&#39; one can copy the content of a</span>
  225 |     | <span class='neutral'>  // price pointer to a price with height which is what we are doing here.</span>
  226 |     | <span class='neutral'>  _total0_.copyPrice(_current_);</span>
  227 |     | <span class='neutral'>  _total1_.copyPrice(_current_);</span>
  228 |     | <span class='neutral'>}</span>
  229 |     | <span class='neutral'></span>
  230 |     | <span class='neutral'>/// @notice Increments &#39;indexKernelTotal&#39; and substitutes &#39;total0&#39; with</span>
  231 |     | <span class='neutral'>/// &#39;total1&#39;. Lastly, loads a new breakpoint from the kernel and stores its</span>
  232 |     | <span class='neutral'>/// resultant with &#39;qOrigin&#39; into the price pointer &#39;_total1_&#39;.</span>
  233 |     | <span class='neutral'>///</span>
  234 |     | <span class='neutral'>/// ---------------------------------------------------------------------------</span>
  235 |     | <span class='neutral'>///</span>
  236 |     | <span class='neutral'>/// Overflow of &#39;indexKernelTotal&#39; and index out of range should be avoided</span>
  237 |     | <span class='neutral'>/// externally.</span>
  238 |     | <span class='neutral'>function moveBreakpointTotal() pure {</span>
  239 |     | <span class='neutral'>  // A swap can be interpreted as a price movement. The precise value for</span>
  240 |     | <span class='neutral'>  // &#39;qTarget&#39; may be determined from &#39;logPriceLimit&#39; or we may need to</span>
  241 |     | <span class='neutral'>  // determine that based on &#39;amountSpecified&#39;. We also need to keep track of</span>
  242 |     | <span class='neutral'>  // the outgoing and incoming amounts as we move from the &#39;qCurrent&#39; to</span>
  243 |     | <span class='neutral'>  // &#39;qTarget&#39;. As explained in &#39;Memory.sol&#39;, in the definitions for &#39;amount0&#39;</span>
  244 |     | <span class='neutral'>  // and &#39;amount1&#39;, if &#39;zeroForOne == false&#39;, the outgoing and incoming amounts</span>
  245 |     | <span class='neutral'>  // are proportional to:</span>
  246 |     | <span class='neutral'>  //</span>
  247 |     | <span class='neutral'>  //                           - 8     / qTarget</span>
  248 |     | <span class='neutral'>  //    currentToTarget      e        |    - h / 2</span>
  249 |     | <span class='neutral'>  //  &#39;----------------- := ------- * |  e         k(w(h)) dh&#39;.</span>
  250 |     | <span class='neutral'>  //       2 ** 216            2      |</span>
  251 |     | <span class='neutral'>  //                                 / qCurrent</span>
  252 |     | <span class='neutral'>  //</span>
  253 |     | <span class='neutral'>  //                                   - 8     / qTarget</span>
  254 |     | <span class='neutral'>  //    incomingCurrentToTarget      e        |    + h / 2</span>
  255 |     | <span class='neutral'>  //  &#39;------------------------- := ------- * |  e         k(w(h)) dh&#39;,</span>
  256 |     | <span class='neutral'>  //           2 ** 216                2      |</span>
  257 |     | <span class='neutral'>  //                                         / qCurrent</span>
  258 |     | <span class='neutral'>  //</span>
  259 |     | <span class='neutral'>  // and if &#39;zeroForOne == true&#39;, the outgoing and incoming amounts are</span>
  260 |     | <span class='neutral'>  // proportional to:</span>
  261 |     | <span class='neutral'>  //</span>
  262 |     | <span class='neutral'>  //                           - 8     / qCurrent</span>
  263 |     | <span class='neutral'>  //    currentToTarget      e        |    + h / 2</span>
  264 |     | <span class='neutral'>  //  &#39;----------------- := ------- * |  e         k(w(h)) dh&#39;,</span>
  265 |     | <span class='neutral'>  //       2 ** 216            2      |</span>
  266 |     | <span class='neutral'>  //                                 / qTarget</span>
  267 |     | <span class='neutral'>  //</span>
  268 |     | <span class='neutral'>  //                                   - 8     / qCurrent</span>
  269 |     | <span class='neutral'>  //    incomingCurrentToTarget      e        |    - h / 2</span>
  270 |     | <span class='neutral'>  //  &#39;------------------------- := ------- * |  e         k(w(h)) dh&#39;.</span>
  271 |     | <span class='neutral'>  //            2 ** 216               2      |</span>
  272 |     | <span class='neutral'>  //                                         / qTarget</span>
  273 |     | <span class='neutral'>  //</span>
  274 |     | <span class='neutral'>  // Hence, in order to keep track of the outgoing and incoming amounts, we</span>
  275 |     | <span class='neutral'>  // need to keep track of the two integrals, &#39;currentToTarget&#39; and </span>
  276 |     | <span class='neutral'>  // &#39;incomingCurrentToTarget&#39;. Remember that both functions &#39;k&#39; and &#39;w&#39; are</span>
  277 |     | <span class='neutral'>  // piecewise linear. As a result, &#39;k(w(h))&#39; is also piecewise linear. In</span>
  278 |     | <span class='neutral'>  // order to keep track of the integrals, we proceed from &#39;qCurrent&#39; to</span>
  279 |     | <span class='neutral'>  // &#39;qTarget&#39; piece by piece. At each step, we take the outgoing and incoming</span>
  280 |     | <span class='neutral'>  // integrals of the piece under exploration using &#39;IntegralLibrary&#39; and</span>
  281 |     | <span class='neutral'>  // increment the total integrals &#39;currentToTarget&#39; and</span>
  282 |     | <span class='neutral'>  // &#39;incomingCurrentToTarget&#39; with the resulting values.</span>
  283 |     | <span class='neutral'>  // </span>
  284 |     | <span class='neutral'>  // To this end, we need to keep track of the pieces for both &#39;w&#39; and &#39;k&#39;.</span>
  285 |     | <span class='neutral'>  // As explained in &#39;Memory.sol&#39;, each piece of the function &#39;w&#39; is regarded</span>
  286 |     | <span class='neutral'>  // as a &#39;phase&#39; and the current phase under exploration can be characterized</span>
  287 |     | <span class='neutral'>  // by the following three members of the curve sequence:</span>
  288 |     | <span class='neutral'>  //</span>
  289 |     | <span class='neutral'>  //  - &#39;qEnd := q[indexCurve]&#39;,</span>
  290 |     | <span class='neutral'>  //</span>
  291 |     | <span class='neutral'>  //  - &#39;qOrigin := q[indexCurve + 1]&#39;,</span>
  292 |     | <span class='neutral'>  //</span>
  293 |     | <span class='neutral'>  //  - &#39;q[indexCurve + 2]&#39;,</span>
  294 |     | <span class='neutral'>  //</span>
  295 |     | <span class='neutral'>  // where the out of range member &#39;q[curveLength]&#39; is assigned the same value</span>
  296 |     | <span class='neutral'>  // as the last member &#39;q[curveLength - 1]&#39;.</span>
  297 |     | <span class='neutral'>  //</span>
  298 |     | <span class='neutral'>  // &#39;q[indexCurve + 2]&#39; is where the &#39;phase&#39; starts. &#39;qEnd&#39; is where the phase</span>
  299 |     | <span class='neutral'>  // ends. If &#39;q[indexCurve + 2] &lt; qEnd&#39; then the &#39;phase&#39; under exploration in</span>
  300 |     | <span class='neutral'>  // the diagram of &#39;w(.)&#39; corresponds to a segment whose extension intersects</span>
  301 |     | <span class='neutral'>  // with the horizontal axis at &#39;qOrigin&#39; with the angle &#39;+45&#39; degrees. In</span>
  302 |     | <span class='neutral'>  // this case, &#39;getDirection() == false&#39; and &#39;w(h) := h - qOrigin&#39;. If</span>
  303 |     | <span class='neutral'>  // &#39;qBegin &gt; qEnd&#39; then the &#39;phase&#39; under exploration in the diagram of</span>
  304 |     | <span class='neutral'>  // &#39;w(.)&#39; corresponds to a segment whose extension intersects with the</span>
  305 |     | <span class='neutral'>  // horizontal axis at &#39;qOrigin&#39; with the angle &#39;+135&#39; degrees. In this case,</span>
  306 |     | <span class='neutral'>  // &#39;w(h) := qOrigin - h&#39; and &#39;getDirection() == true&#39;.</span>
  307 |     | <span class='neutral'>  //</span>
  308 |     | <span class='neutral'>  // As we move from &#39;qCurrent&#39; towards the destination of the swap, we may</span>
  309 |     | <span class='neutral'>  // need to move from one &#39;phase&#39; to the next. Let</span>
  310 |     | <span class='neutral'>  // &#39;(qEnd, qOrigin, q[indexCurve + 2])&#39; represent the current &#39;phase&#39; under</span>
  311 |     | <span class='neutral'>  // exploration. If &#39;q[indexCurve + 2] &lt; qEnd&#39; (&#39;getDirection() == false&#39;),</span>
  312 |     | <span class='neutral'>  // then we have</span>
  313 |     | <span class='neutral'>  //</span>
  314 |     | <span class='neutral'>  //  &#39;k(w(h)) == k(h - qOrigin)&#39; for every &#39;q[indexCurve + 2] &lt; h &lt; qEnd&#39;.</span>
  315 |     | <span class='neutral'>  //</span>
  316 |     | <span class='neutral'>  // If &#39;qEnd &lt; q[indexCurve + 2]&#39; (&#39;getDirection() == true&#39;), then we have</span>
  317 |     | <span class='neutral'>  //</span>
  318 |     | <span class='neutral'>  //  &#39;k(w(h)) == k(qOrigin - h)&#39; for every &#39;qEnd &lt; h &lt; q[indexCurve + 2]&#39;.</span>
  319 |     | <span class='neutral'>  //</span>
  320 |     | <span class='neutral'>  // But &#39;k : [0, qSpacing] -&gt; [0, 1]&#39; is also piecewise linear. Now that we</span>
  321 |     | <span class='neutral'>  // fixed one phase of the function &#39;w&#39; and everything is with respect to the</span>
  322 |     | <span class='neutral'>  // function &#39;k&#39;, we need to account for every piece of &#39;k&#39; within </span>
  323 |     | <span class='neutral'>  //</span>
  324 |     | <span class='neutral'>  //  &#39;(q[indexCurve + 2] - qOrigin, qEnd - qOrigin)&#39;</span>
  325 |     | <span class='neutral'>  //</span>
  326 |     | <span class='neutral'>  // or</span>
  327 |     | <span class='neutral'>  //</span>
  328 |     | <span class='neutral'>  //  &#39;(qEnd - qOrigin, q[indexCurve + 2] - qOrigin)&#39;,</span>
  329 |     | <span class='neutral'>  //</span>
  330 |     | <span class='neutral'>  // depending on the direction. &#39;indexKernelTotal&#39; is the index that we use</span>
  331 |     | <span class='neutral'>  // for this purpose. At first, it is equal to &#39;zeroIndex&#39; and it is</span>
  332 |     | <span class='neutral'>  // incremented by &#39;oneIndex&#39; every time that this function is called.</span>
  333 |     | <span class='neutral'>  //</span>
  334 |     | <span class='neutral'>  // Let</span>
  335 |     | <span class='neutral'>  //</span>
  336 |     | <span class='neutral'>  //  &#39;b0 := b[indexKernelTotal]&#39;,</span>
  337 |     | <span class='neutral'>  //  &#39;c0 := c[indexKernelTotal]&#39;,</span>
  338 |     | <span class='neutral'>  //</span>
  339 |     | <span class='neutral'>  // represent the horizontal and vertical coordinates of the kernel breakpoint</span>
  340 |     | <span class='neutral'>  // corresponding to &#39;indexKernelTotal&#39;, respectively (prior to it being</span>
  341 |     | <span class='neutral'>  // incremented). Let</span>
  342 |     | <span class='neutral'>  //</span>
  343 |     | <span class='neutral'>  //  &#39;b1 := b[indexKernelTotal + oneIndex]&#39;,</span>
  344 |     | <span class='neutral'>  //  &#39;c1 := c[indexKernelTotal + oneIndex]&#39;,</span>
  345 |     | <span class='neutral'>  //</span>
  346 |     | <span class='neutral'>  // represent the vertical and horizontal coordinates of the kernel breakpoint</span>
  347 |     | <span class='neutral'>  // corresponding to &#39;indexKernelTotal + oneIndex&#39;.</span>
  348 |     | <span class='neutral'>  // </span>
  349 |     | <span class='neutral'>  // If &#39;q[indexCurve + 2] &lt; qEnd&#39;, then we want to integrate</span>
  350 |     | <span class='neutral'>  //</span>
  351 |     | <span class='neutral'>  //  &#39;exp(- h / 2) * k(h - qOrigin)&#39;</span>
  352 |     | <span class='neutral'>  //</span>
  353 |     | <span class='neutral'>  // and</span>
  354 |     | <span class='neutral'>  //</span>
  355 |     | <span class='neutral'>  //  &#39;exp(+ h / 2) * k(h - qOrigin)&#39;</span>
  356 |     | <span class='neutral'>  //</span>
  357 |     | <span class='neutral'>  // between the two breakpoints characterized by &#39;indexKernelTotal&#39; and</span>
  358 |     | <span class='neutral'>  // &#39;indexKernelTotal + oneIndex&#39;. If &#39;qEnd &lt; q[indexCurve + 2]&#39;, then we want</span>
  359 |     | <span class='neutral'>  // to integrate</span>
  360 |     | <span class='neutral'>  //</span>
  361 |     | <span class='neutral'>  //  &#39;exp(- h / 2) * k(qOrigin - h)&#39;</span>
  362 |     | <span class='neutral'>  //</span>
  363 |     | <span class='neutral'>  // and</span>
  364 |     | <span class='neutral'>  //</span>
  365 |     | <span class='neutral'>  //  &#39;exp(+ h / 2) * k(qOrigin - h)&#39;</span>
  366 |     | <span class='neutral'>  //</span>
  367 |     | <span class='neutral'>  // between the two breakpoints characterized by &#39;indexKernelTotal&#39; and</span>
  368 |     | <span class='neutral'>  // &#39;indexKernelTotal + oneIndex&#39;.</span>
  369 |     | <span class='neutral'>  //</span>
  370 |     | <span class='neutral'>  // To that end, the first step is to shift the two breakpoints by &#39;qOrigin&#39;.</span>
  371 |     | <span class='neutral'>  // The memory spaces &#39;total0&#39; and &#39;total1&#39; keep track of these shifted</span>
  372 |     | <span class='neutral'>  // breakpoints. In other words, &#39;total0&#39; and &#39;total1&#39; are the breakpoints for</span>
  373 |     | <span class='neutral'>  // &#39;k(h - qOrigin)&#39; or &#39;k(qOrigin - h)&#39;, depending on the direction.</span>
  374 |     | <span class='neutral'>  //</span>
  375 |     | <span class='neutral'>  // As explained in &#39;Memory.sol&#39;, each one of &#39;total0&#39; and &#39;total1&#39; are prices</span>
  376 |     | <span class='neutral'>  // with height and each one occupies &#39;64&#39; bytes in memory via the layout</span>
  377 |     | <span class='neutral'>  // explained in &#39;Price.sol&#39;.</span>
  378 |     | <span class='neutral'>  //</span>
  379 |     | <span class='neutral'>  // If &#39;q[indexCurve + 2] &lt; qEnd&#39;, we have:</span>
  380 |     | <span class='neutral'>  // </span>
  381 |     | <span class='neutral'>  //  &#39;_total0_.height() := (2 ** 15) * c0&#39;</span>
  382 |     | <span class='neutral'>  //  &#39;_total1_.height() := (2 ** 15) * c1&#39;</span>
  383 |     | <span class='neutral'>  //  &#39;_total0_.log() := (2 ** 59) * (16 + qOrigin + b0)&#39;</span>
  384 |     | <span class='neutral'>  //  &#39;_total1_.log() := (2 ** 59) * (16 + qOrigin + b1)&#39;</span>
  385 |     | <span class='neutral'>  // </span>
  386 |     | <span class='neutral'>  // If &#39;qEnd &lt; q[indexCurve + 2]&#39;, we have:</span>
  387 |     | <span class='neutral'>  //</span>
  388 |     | <span class='neutral'>  //  &#39;_total0_.height() := (2 ** 15) * c0&#39;</span>
  389 |     | <span class='neutral'>  //  &#39;_total1_.height() := (2 ** 15) * c1&#39;</span>
  390 |     | <span class='neutral'>  //  &#39;_total0_.log() := (2 ** 59) * (16 + qOrigin - b0)&#39;</span>
  391 |     | <span class='neutral'>  //  &#39;_total1_.log() := (2 ** 59) * (16 + qOrigin - b1)&#39;</span>
  392 |     | <span class='neutral'>  //</span>
  393 |     | <span class='neutral'>  // The values for &#39;_total0_.sqrt(false)&#39;, &#39;_total1_.sqrt(false)&#39;,</span>
  394 |     | <span class='neutral'>  // &#39;_total0_.sqrt(true)&#39;, and &#39;_total1_.sqrt(true)&#39; are calculated</span>
  395 |     | <span class='neutral'>  // accordingly to mirror the above logarithmic values.</span>
  396 |     | <span class='neutral'>  //</span>
  397 |     | <span class='neutral'>  // Now, in order to move from one pair of breakpoints to the next we first</span>
  398 |     | <span class='neutral'>  // replace the &#39;64&#39; bytes of &#39;total0&#39; with the &#39;64&#39; bytes of &#39;total1&#39; so that</span>
  399 |     | <span class='neutral'>  // &#39;total1&#39; can be used for the next shifted price to be calculated.</span>
  400 |     | <span class='neutral'>  _total0_.copyPriceWithHeight(_total1_);</span>
  401 |     | <span class='neutral'></span>
  402 |     | <span class='neutral'>  // Then, we calculate the new content of &#39;total1&#39; as described above using</span>
  403 |     | <span class='neutral'>  // the function &#39;impose&#39; from &#39;KernelLibrary&#39;.</span>
  404 |     | <span class='neutral'>  //</span>
  405 |     | <span class='neutral'>  // Index out of range for &#39;indexKernelTotal&#39; is avoided externally.</span>
  406 |     | <span class='neutral'>  //</span>
  407 |     | <span class='neutral'>  // Next, we are going to prove that:</span>
  408 |     | <span class='neutral'>  //</span>
  409 |     | <span class='neutral'>  //  &#39;0 &lt; (2 ** 59) * (16 + qOrigin + b1) &lt; 2 ** 64&#39;,</span>
  410 |     | <span class='neutral'>  //  &#39;0 &lt; (2 ** 59) * (16 + qOrigin - b1) &lt; 2 ** 64&#39;,</span>
  411 |     | <span class='neutral'>  //</span>
  412 |     | <span class='neutral'>  // as required by &#39;impose&#39; in &#39;Kernel.sol&#39;.</span>
  413 |     | <span class='neutral'>  //</span>
  414 |     | <span class='neutral'>  // Let &#39;pLower&#39; and &#39;pUpper&#39; denote the minimum and maximum price in the</span>
  415 |     | <span class='neutral'>  // active liquidity interval, respectively and define</span>
  416 |     | <span class='neutral'>  //</span>
  417 |     | <span class='neutral'>  //  &#39;qLower := log(pLower / pOffset)&#39;,</span>
  418 |     | <span class='neutral'>  //  &#39;qUpper := log(pUpper / pOffset)&#39;.</span>
  419 |     | <span class='neutral'>  //</span>
  420 |     | <span class='neutral'>  // Let &#39;qSpacing := qUpper - qLower&#39; denote the length of every liquidity</span>
  421 |     | <span class='neutral'>  // interval. Upon initializing a pool, the given curve sequence is validated</span>
  422 |     | <span class='neutral'>  // by the method &#39;validate&#39; in &#39;Curve.sol&#39;.</span>
  423 |     | <span class='neutral'>  //</span>
  424 |     | <span class='neutral'>  // When validating the curve sequence, the custom</span>
  425 |     | <span class='neutral'>  // error &#39;BlankIntervalsShouldBeAvoided&#39; ensures that &#39;16 + qLower&#39; is</span>
  426 |     | <span class='neutral'>  // greater than &#39;qSpacing&#39; and &#39;16 + qUpper&#39; is smaller than &#39;32 - qSpacing&#39;.</span>
  427 |     | <span class='neutral'>  // As a result, every member &#39;q&#39; of the initial curve sequence</span>
  428 |     | <span class='neutral'>  // satisfies:</span>
  429 |     | <span class='neutral'>  // </span>
  430 |     | <span class='neutral'>  //  &#39;qSpacing &lt; 16 + q &lt; 32 - qSpacing&#39;</span>
  431 |     | <span class='neutral'>  // </span>
  432 |     | <span class='neutral'>  // In addition, the method &#39;setSwapParams&#39; in &#39;Swap.sol&#39; ensures that</span>
  433 |     | <span class='neutral'>  // &#39;qTarget&#39; for every swap is also bounded by both</span>
  434 |     | <span class='neutral'>  // &#39;qSpacing + 1 / (2 ** 59)&#39; and &#39;32 - 1 / (2 ** 59) - qSpacing&#39;.</span>
  435 |     | <span class='neutral'>  // This ensures that the above inequality is always satisfied for every</span>
  436 |     | <span class='neutral'>  // member of the curve and not only the initial curve.</span>
  437 |     | <span class='neutral'>  //</span>
  438 |     | <span class='neutral'>  // Now, since &#39;qOrigin&#39; is a member of the curve sequence, we also have:</span>
  439 |     | <span class='neutral'>  //</span>
  440 |     | <span class='neutral'>  //  &#39;qSpacing &lt; 16 + qOrigin &lt; 32 - qSpacing&#39;</span>
  441 |     | <span class='neutral'>  //</span>
  442 |     | <span class='neutral'>  // Hence,</span>
  443 |     | <span class='neutral'>  //</span>
  444 |     | <span class='neutral'>  //  &#39;0 &lt; (2 ** 59) * (16 + qOrigin) &lt;= (2 ** 59) * (16 + qOrigin + b1)</span>
  445 |     | <span class='neutral'>  //     &lt; (2 ** 59) * (32 - qSpacing + b1) &lt;= (2 ** 59) * 32 == 2 ** 64&#39;</span>
  446 |     | <span class='neutral'>  //</span>
  447 |     | <span class='neutral'>  // where &#39;0 &lt; (2 ** 59) * (16 + qOrigin)&#39; is because &#39;qOrigin&#39; is a member of</span>
  448 |     | <span class='neutral'>  // the curve and &#39;b1 &lt;= qSpacing&#39; is concluded from the custom error</span>
  449 |     | <span class='neutral'>  // &#39;HorizontalCoordinatesMayNotExceedLogSpacing&#39; when validating kernel in</span>
  450 |     | <span class='neutral'>  // &#39;KernelCompact.sol&#39;.</span>
  451 |     | <span class='neutral'>  //</span>
  452 |     | <span class='neutral'>  // Additionally,</span>
  453 |     | <span class='neutral'>  //</span>
  454 |     | <span class='neutral'>  //  &#39;2 ** 64 &gt;  (2 ** 59) * (16 + qOrigin)</span>
  455 |     | <span class='neutral'>  //           &gt;= (2 ** 59) * (16 + qOrigin - b1)</span>
  456 |     | <span class='neutral'>  //           &gt;  (2 ** 59) * (qSpacing - b1) &gt;= 0&#39;</span>
  457 |     | <span class='neutral'>  //</span>
  458 |     | <span class='neutral'>  // where &#39;(2 ** 59) * (16 + qOrigin) &lt; 2 ** 64&#39; is because &#39;qOrigin&#39; is a</span>
  459 |     | <span class='neutral'>  // member of the curve and &#39;b1 &lt;= qSpacing&#39; is concluded from the custom</span>
  460 |     | <span class='neutral'>  // error &#39;HorizontalCoordinatesMayNotExceedLogSpacing&#39; when validating kernel</span>
  461 |     | <span class='neutral'>  // in &#39;KernelCompact.sol&#39;.</span>
  462 |     | <span class='neutral'>  //</span>
  463 |     | <span class='neutral'>  // Lastly, &#39;_total1_&#39; is a fixed value greater than &#39;34&#39;.</span>
  464 |     | <span class='neutral'>  //</span>
  465 |     | <span class='neutral'>  // Therefore, the input requirements of &#39;impose&#39; are satisfied.</span>
  466 |     | <span class='neutral'>  getKernel().impose(</span>
  467 |     | <span class='neutral'>    // The resulting values are stored using the pointer &#39;_total1_&#39;.</span>
  468 |     | <span class='neutral'>    _total1_,</span>
  469 |     | <span class='neutral'>    // &#39;qOrigin&#39; is used as the base price for the shift.</span>
  470 |     | <span class='neutral'>    _origin_,</span>
  471 |     | <span class='neutral'>    // The incremented index is safely stored in the allocated 2 bytes of</span>
  472 |     | <span class='neutral'>    // memory because overflow of &#39;indexKernelTotal&#39; is avoided externally.</span>
  473 |     | <span class='neutral'>    _indexKernelTotal_.incrementIndex(),</span>
  474 |     | <span class='neutral'>    // Since the phase is fixed, the current direction is used for this shift.</span>
  475 |     | <span class='neutral'>    getDirection()</span>
  476 |     | <span class='neutral'>  );</span>
  477 |     | <span class='neutral'>}</span>
  478 |     | <span class='neutral'></span>
  479 |     | <span class='neutral'>/// @notice Increments &#39;indexKernelForward&#39; and substitutes &#39;forward0&#39; with</span>
  480 |     | <span class='neutral'>/// &#39;forward1&#39;. Lastly, loads a new breakpoint from the kernel and stores its</span>
  481 |     | <span class='neutral'>/// resultant with &#39;qTarget&#39; into the memory space &#39;forward1&#39;.</span>
  482 |     | <span class='neutral'>///</span>
  483 |     | <span class='neutral'>/// ---------------------------------------------------------------------------</span>
  484 |     | <span class='neutral'>///</span>
  485 |     | <span class='neutral'>/// Overflow of &#39;indexKernelForward&#39; and index out of range should be avoided</span>
  486 |     | <span class='neutral'>/// externally.</span>
  487 |     | <span class='neutral'>function moveBreakpointForward() pure {</span>
  488 |     | <span class='neutral'>  // In order to perform a swap within the active liquidity interval, we first</span>
  489 |     | <span class='neutral'>  // determine &#39;qTarget&#39; as well as the outgoing and incoming amounts. After</span>
  490 |     | <span class='neutral'>  // this step, we need to construct a new curve sequence in preparation for</span>
  491 |     | <span class='neutral'>  // the next swap. To that end, we amend the curve sequence. The process of</span>
  492 |     | <span class='neutral'>  // amending is explained in &#39;Curve.sol&#39;. Each amendment involves potentially</span>
  493 |     | <span class='neutral'>  // disposing a number of members from the end of the curve sequence and then</span>
  494 |     | <span class='neutral'>  // adding a new member to the end.</span>
  495 |     | <span class='neutral'>  //</span>
  496 |     | <span class='neutral'>  // As explained in &#39;Memory.sol&#39;, in the definition of &#39;overshoot&#39;, each swap</span>
  497 |     | <span class='neutral'>  // involves a maximum of two amendments. We first amend the curve sequence</span>
  498 |     | <span class='neutral'>  // with &#39;qOvershoot&#39;. Then, we amend the resulting curve sequence with</span>
  499 |     | <span class='neutral'>  // &#39;qTarget&#39; so that the last member becomes &#39;qTarget&#39;. The purpose of</span>
  500 |     | <span class='neutral'>  // amending with &#39;qOvershoot&#39; is to ensure that the conservation of reserves</span>
  501 |     | <span class='neutral'>  // is maintained. In other words, we want to have:</span>
  502 |     | <span class='neutral'>  // </span>
  503 |     | <span class='neutral'>  //  &#39;totalReserveOfTag0Before == totalReserveOfTag0After&#39;,</span>
  504 |     | <span class='neutral'>  //  &#39;totalReserveOfTag1Before == totalReserveOfTag1After&#39;.</span>
  505 |     | <span class='neutral'>  //</span>
  506 |     | <span class='neutral'>  // In order to satisfy the two equations above, we need two variables. One is</span>
  507 |     | <span class='neutral'>  // &#39;growth&#39;, which increases with every swap. But since we have two</span>
  508 |     | <span class='neutral'>  // equations, we need another degree of freedom in the choice for the new</span>
  509 |     | <span class='neutral'>  // curve sequence. This is why we resort to the notion of &#39;overshoot&#39;. The</span>
  510 |     | <span class='neutral'>  // reason behind &#39;overshoot&#39; is further explained in &#39;Memory.sol&#39;.</span>
  511 |     | <span class='neutral'>  //</span>
  512 |     | <span class='neutral'>  // Consider the new curve sequence which is amended by both &#39;qOvershoot&#39; and</span>
  513 |     | <span class='neutral'>  // then &#39;qTarget&#39;. Construct &#39;wAmended&#39; accordingly using the formula given</span>
  514 |     | <span class='neutral'>  // in &#39;Memory.sol&#39;. By canceling the first variable &#39;growth&#39;, the search for</span>
  515 |     | <span class='neutral'>  // &#39;qOvershoot&#39; boils down to solving the following equation:</span>
  516 |     | <span class='neutral'>  //</span>
  517 |     | <span class='neutral'>  //      / qTarget                         / qUpper</span>
  518 |     | <span class='neutral'>  //     |   + h/2                         |   - h/2</span>
  519 |     | <span class='neutral'>  //     |  e      k(wAmended(h)) dh       |  e      k(wAmended(h)) dh</span>
  520 |     | <span class='neutral'>  //     |                                 |</span>
  521 |     | <span class='neutral'>  //    / qLower                          / qTarget</span>
  522 |     | <span class='neutral'>  //  &#39;------------------------------ == ------------------------------&#39;.</span>
  523 |     | <span class='neutral'>  //         / qTarget                         / qUpper</span>
  524 |     | <span class='neutral'>  //        |    + h/2                        |    - h/2</span>
  525 |     | <span class='neutral'>  //        |  e       k(w(h)) dh             |  e       k(w(h)) dh</span>
  526 |     | <span class='neutral'>  //        |                                 |</span>
  527 |     | <span class='neutral'>  //       / qLower                          / qTarget</span>
  528 |     | <span class='neutral'>  //</span>
  529 |     | <span class='neutral'>  // For simplicity, consider the case &#39;zeroForOne == false&#39;. In this case,</span>
  530 |     | <span class='neutral'>  //</span>
  531 |     | <span class='neutral'>  //                     /  k(w(h))            if  qOvershoot &lt; h &lt; qUpper</span>
  532 |     | <span class='neutral'>  //  &#39;k(wAmended(h)) = |   k(h - qTarget)     if  qTarget &lt; h &lt; qOvershoot &#39;</span>
  533 |     | <span class='neutral'>  //                    |   k(qOvershoot - h)  if  qOrigin &lt; h &lt; qTarget</span>
  534 |     | <span class='neutral'>  //                     \  k(w(h))            if  qLower &lt; h &lt; qOrigin</span>
  535 |     | <span class='neutral'>  //</span>
  536 |     | <span class='neutral'>  // which means that</span>
  537 |     | <span class='neutral'>  //</span>
  538 |     | <span class='neutral'>  //     / qUpper</span>
  539 |     | <span class='neutral'>  //    |   - h / 2</span>
  540 |     | <span class='neutral'>  //  &#39; |  e        k(wAmended(h)) dh ==</span>
  541 |     | <span class='neutral'>  //    |</span>
  542 |     | <span class='neutral'>  //   / qTarget</span>
  543 |     | <span class='neutral'>  //</span>
  544 |     | <span class='neutral'>  //     / qOvershoot                    / qUpper</span>
  545 |     | <span class='neutral'>  //    |   - h / 2                     |   - h / 2</span>
  546 |     | <span class='neutral'>  //    |  e        k(h - qTarget) dh + |  e        k(w(h)) dh &#39;.</span>
  547 |     | <span class='neutral'>  //    |                               |</span>
  548 |     | <span class='neutral'>  //   / qTarget                       / qOvershoot</span>
  549 |     | <span class='neutral'>  //</span>
  550 |     | <span class='neutral'>  // Hence, we need to integrate &#39;exp(-h / 2) * k(h - qTarget)&#39; from &#39;qTarget&#39;</span>
  551 |     | <span class='neutral'>  // to &#39;qOvershoot&#39;.</span>
  552 |     | <span class='neutral'>  // </span>
  553 |     | <span class='neutral'>  // Remember that at this stage, &#39;qOvershoot&#39; is still an unknown value which</span>
  554 |     | <span class='neutral'>  // will be determined via numerical search. More precisely, after &#39;qTarget&#39;</span>
  555 |     | <span class='neutral'>  // is determined, we keep moving forward in the same direction until we find</span>
  556 |     | <span class='neutral'>  // the precise value for &#39;qOvershoot&#39;. But as we move forward, we need to</span>
  557 |     | <span class='neutral'>  // keep track of the integral</span>
  558 |     | <span class='neutral'>  //</span>
  559 |     | <span class='neutral'>  //     / qOvershoot</span>
  560 |     | <span class='neutral'>  //    |   - h / 2</span>
  561 |     | <span class='neutral'>  //  &#39; |  e        k(h - qTarget) dh</span>
  562 |     | <span class='neutral'>  //    |</span>
  563 |     | <span class='neutral'>  //   / qTarget</span>
  564 |     | <span class='neutral'>  //</span>
  565 |     | <span class='neutral'>  // To this end, we enumerate pieces of &#39;k&#39; one by one and</span>
  566 |     | <span class='neutral'>  // &#39;indexKernelForward&#39; is the index that we use for this purpose. At first,</span>
  567 |     | <span class='neutral'>  // before the start of the search for &#39;qOvershoot&#39;, this index is equal to</span>
  568 |     | <span class='neutral'>  // &#39;zeroIndex&#39; and it is incremented by &#39;oneIndex&#39; everytime that the present</span>
  569 |     | <span class='neutral'>  // function is called.</span>
  570 |     | <span class='neutral'>  //</span>
  571 |     | <span class='neutral'>  // Let</span>
  572 |     | <span class='neutral'>  //</span>
  573 |     | <span class='neutral'>  //  &#39;b0 := b[indexKernelForward]&#39;,</span>
  574 |     | <span class='neutral'>  //  &#39;c0 := c[indexKernelForward]&#39;,</span>
  575 |     | <span class='neutral'>  //</span>
  576 |     | <span class='neutral'>  // represent the horizontal and vertical coordinates of the kernel breakpoint</span>
  577 |     | <span class='neutral'>  // corresponding to &#39;indexKernelForward&#39;, respectively (prior to it being</span>
  578 |     | <span class='neutral'>  // incremented). Let</span>
  579 |     | <span class='neutral'>  //</span>
  580 |     | <span class='neutral'>  //  &#39;b1 := b[indexKernelForward + oneIndex]&#39;,</span>
  581 |     | <span class='neutral'>  //  &#39;c1 := c[indexKernelForward + oneIndex]&#39;,</span>
  582 |     | <span class='neutral'>  //</span>
  583 |     | <span class='neutral'>  // represent the vertical and horizontal coordinates of the kernel breakpoint</span>
  584 |     | <span class='neutral'>  // corresponding to &#39;indexKernelForward + oneIndex&#39;.</span>
  585 |     | <span class='neutral'>  // </span>
  586 |     | <span class='neutral'>  // If &#39;zeroForOne == false&#39;, then we want to integrate </span>
  587 |     | <span class='neutral'>  //</span>
  588 |     | <span class='neutral'>  //  &#39;exp(- h / 2) * k(h - qTarget)&#39;</span>
  589 |     | <span class='neutral'>  //</span>
  590 |     | <span class='neutral'>  // between the two breakpoints that are characterized by &#39;indexKernelForward&#39;</span>
  591 |     | <span class='neutral'>  // and &#39;indexKernelForward + oneIndex&#39;. If &#39;zeroForOne == true&#39;, then we want</span>
  592 |     | <span class='neutral'>  // to integrate</span>
  593 |     | <span class='neutral'>  //</span>
  594 |     | <span class='neutral'>  //  &#39;exp(+ h / 2) * k(qTarget - h)&#39;</span>
  595 |     | <span class='neutral'>  //</span>
  596 |     | <span class='neutral'>  // between the two breakpoints characterized by &#39;indexKernelForward&#39; and</span>
  597 |     | <span class='neutral'>  // &#39;indexKernelForward + oneIndex&#39;.</span>
  598 |     | <span class='neutral'>  //</span>
  599 |     | <span class='neutral'>  // To that end, the first step is to shift the two breakpoints by &#39;qTarget&#39;.</span>
  600 |     | <span class='neutral'>  // The memory spaces &#39;forward0&#39; and &#39;forward1&#39; keep track of these shifted</span>
  601 |     | <span class='neutral'>  // breakpoints. In other words, &#39;forward0&#39; and &#39;forward1&#39; are the breakpoints</span>
  602 |     | <span class='neutral'>  // for &#39;k(h - qTarget)&#39; or &#39;k(qTarget - h)&#39;, depending on &#39;zeroForOne&#39;.</span>
  603 |     | <span class='neutral'>  //</span>
  604 |     | <span class='neutral'>  // As explained in &#39;Memory.sol&#39;, each one of &#39;forward0&#39; and &#39;forward1&#39; are</span>
  605 |     | <span class='neutral'>  // prices with height and each one occupies &#39;64&#39; bytes in memory via the</span>
  606 |     | <span class='neutral'>  // layout explained in &#39;Price.sol&#39;.</span>
  607 |     | <span class='neutral'>  //</span>
  608 |     | <span class='neutral'>  // If &#39;zeroForOne == false&#39;, we have:</span>
  609 |     | <span class='neutral'>  // </span>
  610 |     | <span class='neutral'>  //  &#39;_forward0_.height() := (2 ** 15) * c0&#39;</span>
  611 |     | <span class='neutral'>  //  &#39;_forward1_.height() := (2 ** 15) * c1&#39;</span>
  612 |     | <span class='neutral'>  //  &#39;_forward0_.log() := (2 ** 59) * (16 + qTarget + b0)&#39;</span>
  613 |     | <span class='neutral'>  //  &#39;_forward1_.log() := (2 ** 59) * (16 + qTarget + b1)&#39;</span>
  614 |     | <span class='neutral'>  // </span>
  615 |     | <span class='neutral'>  // If &#39;zeroForOne == true&#39;, we have:</span>
  616 |     | <span class='neutral'>  //</span>
  617 |     | <span class='neutral'>  //  &#39;_forward0_.height() := (2 ** 15) * c0&#39;</span>
  618 |     | <span class='neutral'>  //  &#39;_forward1_.height() := (2 ** 15) * c1&#39;</span>
  619 |     | <span class='neutral'>  //  &#39;_forward0_.log() := (2 ** 59) * (16 + qTarget - b0)&#39;</span>
  620 |     | <span class='neutral'>  //  &#39;_forward1_.log() := (2 ** 59) * (16 + qTarget - b1)&#39;</span>
  621 |     | <span class='neutral'>  //</span>
  622 |     | <span class='neutral'>  // The values for &#39;forward0.sqrt(false)&#39;, &#39;forward1.sqrt(false)&#39;,</span>
  623 |     | <span class='neutral'>  // &#39;forward0.sqrt(true)&#39;, and &#39;forward1.sqrt(true)&#39; are calculated</span>
  624 |     | <span class='neutral'>  // accordingly to mirror the above logarithmic prices.</span>
  625 |     | <span class='neutral'>  //</span>
  626 |     | <span class='neutral'>  // Now, in order to move from one pair of breakpoints to the next we first</span>
  627 |     | <span class='neutral'>  // replace the &#39;64&#39; bytes of &#39;forward0&#39; with the &#39;64&#39; bytes of &#39;forward1&#39; so</span>
  628 |     | <span class='neutral'>  // that &#39;forward1&#39; can be used for the next shifted price to be calculated.</span>
  629 |     | <span class='neutral'>  _forward0_.copyPriceWithHeight(_forward1_);</span>
  630 |     | <span class='neutral'></span>
  631 |     | <span class='neutral'>  // Then we calculate the new value for &#39;forward1&#39; as described above using</span>
  632 |     | <span class='neutral'>  // the function &#39;impose&#39; from &#39;KernelLibrary&#39;.</span>
  633 |     | <span class='neutral'>  //</span>
  634 |     | <span class='neutral'>  // Index out of range for &#39;indexKernelForward&#39; is avoided externally.</span>
  635 |     | <span class='neutral'>  //</span>
  636 |     | <span class='neutral'>  // Next, we are going to prove that:</span>
  637 |     | <span class='neutral'>  //</span>
  638 |     | <span class='neutral'>  //  &#39;0 &lt; (2 ** 59) * (16 + qTarget - b1) &lt; 2 ** 64&#39;</span>
  639 |     | <span class='neutral'>  //  &#39;0 &lt; (2 ** 59) * (16 + qTarget + b1) &lt; 2 ** 64&#39;</span>
  640 |     | <span class='neutral'>  //</span>
  641 |     | <span class='neutral'>  // as required by &#39;impose&#39; in &#39;Kernel.sol&#39; for cases &#39;left == false&#39; and</span>
  642 |     | <span class='neutral'>  // &#39;left == true&#39;, respectively.</span>
  643 |     | <span class='neutral'>  //</span>
  644 |     | <span class='neutral'>  // Let &#39;pLower&#39; and &#39;pUpper&#39; denote the minimum and maximum price in the</span>
  645 |     | <span class='neutral'>  // active liquidity interval, respectively and define</span>
  646 |     | <span class='neutral'>  //</span>
  647 |     | <span class='neutral'>  //  &#39;qLower := log(pLower / pOffset)&#39;,</span>
  648 |     | <span class='neutral'>  //  &#39;qUpper := log(pUpper / pOffset)&#39;.</span>
  649 |     | <span class='neutral'>  //</span>
  650 |     | <span class='neutral'>  // Let &#39;qSpacing := qUpper - qLower&#39; denote the length of every liquidity</span>
  651 |     | <span class='neutral'>  // interval. Upon initializing a pool, the given curve sequence is validated</span>
  652 |     | <span class='neutral'>  // by the method &#39;validate&#39; in &#39;Curve.sol&#39;. When validating the curve</span>
  653 |     | <span class='neutral'>  // sequence, the custom error &#39;BlankIntervalsShouldBeAvoided&#39; ensures that</span>
  654 |     | <span class='neutral'>  // &#39;16 + qLower&#39; is greater than &#39;qSpacing&#39; and &#39;16 + qUpper&#39; is smaller than</span>
  655 |     | <span class='neutral'>  // &#39;32 - qSpacing&#39;. As a result, every member &#39;q&#39; of the initial curve</span>
  656 |     | <span class='neutral'>  // sequence satisfies:</span>
  657 |     | <span class='neutral'>  // </span>
  658 |     | <span class='neutral'>  //  &#39;qSpacing &lt; 16 + q &lt; 32 - qSpacing&#39;</span>
  659 |     | <span class='neutral'>  // </span>
  660 |     | <span class='neutral'>  // In addition, the method &#39;setSwapParams&#39; in &#39;Swap.sol&#39; ensures that</span>
  661 |     | <span class='neutral'>  // &#39;qTarget&#39; for every swap is also bounded by both</span>
  662 |     | <span class='neutral'>  // &#39;qSpacing + 1 / (2 ** 59)&#39; and &#39;32 - 1 / (2 ** 59) - qSpacing&#39;.</span>
  663 |     | <span class='neutral'>  // This ensures that the above inequality is always satisfied for every</span>
  664 |     | <span class='neutral'>  // member of the curve and not only the initial curve.</span>
  665 |     | <span class='neutral'>  //</span>
  666 |     | <span class='neutral'>  // Remember that &#39;logPriceLimitOffsettedWithinInterval&#39; is capped by both</span>
  667 |     | <span class='neutral'>  // &#39;qLower&#39; and &#39;qUpper&#39; in &#39;initiateInterval&#39;. Hence, if</span>
  668 |     | <span class='neutral'>  // &#39;zeroForOne == false&#39;:</span>
  669 |     | <span class='neutral'>  //</span>
  670 |     | <span class='neutral'>  //  &#39;qLower &lt;= qCurrent &lt;= qTarget &lt;= qLimit &lt;= qUpper&#39;</span>
  671 |     | <span class='neutral'>  //</span>
  672 |     | <span class='neutral'>  // and if &#39;zeroForOne == true&#39;:</span>
  673 |     | <span class='neutral'>  //</span>
  674 |     | <span class='neutral'>  //  &#39;qLower &lt;= qLimit &lt;= qTarget &lt;= qCurrent &lt;= qUpper&#39;</span>
  675 |     | <span class='neutral'>  //</span>
  676 |     | <span class='neutral'>  // which means that in both cases:</span>
  677 |     | <span class='neutral'>  //</span>
  678 |     | <span class='neutral'>  //  &#39;qSpacing &lt; 16 + qLower &lt;= 16 + qTarget &lt;= 16 + qUpper &lt; 32 - qSpacing&#39;.</span>
  679 |     | <span class='neutral'>  //</span>
  680 |     | <span class='neutral'>  // Put simply, since at this stage we are swapping within the current active</span>
  681 |     | <span class='neutral'>  // interval, then the target belongs to the current active interval.</span>
  682 |     | <span class='neutral'>  //</span>
  683 |     | <span class='neutral'>  // Hence,</span>
  684 |     | <span class='neutral'>  //</span>
  685 |     | <span class='neutral'>  //  &#39;0 &lt;  (2 ** 59) * (16 + qLower)</span>
  686 |     | <span class='neutral'>  //     &lt;= (2 ** 59) * (16 + qTarget)</span>
  687 |     | <span class='neutral'>  //     &lt;= (2 ** 59) * (16 + qTarget + b1)</span>
  688 |     | <span class='neutral'>  //     &lt;  (2 ** 59) * (32 - qSpacing + b1)</span>
  689 |     | <span class='neutral'>  //     &lt;= (2 ** 59) * 32 == 2 ** 64&#39;</span>
  690 |     | <span class='neutral'>  //</span>
  691 |     | <span class='neutral'>  // where &#39;0 &lt; (2 ** 59) * (16 + qLower)&#39; is because &#39;qLower&#39; is a member of</span>
  692 |     | <span class='neutral'>  // the curve sequence and &#39;b1 &lt;= qSpacing&#39; is concluded from the custom error</span>
  693 |     | <span class='neutral'>  // &#39;HorizontalCoordinatesMayNotExceedLogSpacing&#39; when validating kernel in</span>
  694 |     | <span class='neutral'>  // &#39;KernelCompact.sol&#39;.</span>
  695 |     | <span class='neutral'>  //</span>
  696 |     | <span class='neutral'>  // Additionally,</span>
  697 |     | <span class='neutral'>  //</span>
  698 |     | <span class='neutral'>  //  &#39;2 ** 64 &gt;  (2 ** 59) * (16 + qUpper)</span>
  699 |     | <span class='neutral'>  //           &gt;= (2 ** 59) * (16 + qTarget)</span>
  700 |     | <span class='neutral'>  //           &gt;= (2 ** 59) * (16 + qTarget - b1)</span>
  701 |     | <span class='neutral'>  //           &gt;  (2 ** 59) * (qSpacing - b1) &gt;= 0&#39;</span>
  702 |     | <span class='neutral'>  //</span>
  703 |     | <span class='neutral'>  // where &#39;(2 ** 59) * (16 + qUpper) &lt; 2 ** 64&#39; is because &#39;qUpper&#39; is a</span>
  704 |     | <span class='neutral'>  // member of the curve sequence and &#39;b1 &lt;= qSpacing&#39; is concluded from the</span>
  705 |     | <span class='neutral'>  // custom error &#39;HorizontalCoordinatesMayNotExceedLogSpacing&#39; when validating</span>
  706 |     | <span class='neutral'>  // kernel in &#39;KernelCompact.sol&#39;.</span>
  707 |     | <span class='neutral'>  //</span>
  708 |     | <span class='neutral'>  // Lastly, &#39;_forward1_&#39; is a fixed value greater than &#39;34&#39;.</span>
  709 |     | <span class='neutral'>  //</span>
  710 |     | <span class='neutral'>  // Therefore, the input requirements of &#39;impose&#39; are satisfied.</span>
  711 |     | <span class='neutral'>  getKernel().impose(</span>
  712 |     | <span class='neutral'>    // The resulting values are stored using the pointer &#39;_forward1_&#39;.</span>
  713 |     | <span class='neutral'>    _forward1_,</span>
  714 |     | <span class='neutral'>    // &#39;target&#39; is used as the base price for the shift.</span>
  715 |     | <span class='neutral'>    _target_,</span>
  716 |     | <span class='neutral'>    // The incremented index is safely stored in the allocated 2 bytes of</span>
  717 |     | <span class='neutral'>    // memory because overflow of &#39;indexKernelForward&#39; is avoided externally.</span>
  718 |     | <span class='neutral'>    _indexKernelForward_.incrementIndex(),</span>
  719 |     | <span class='neutral'>    // In other words, if &#39;getZeroForOne() == false&#39;, we have</span>
  720 |     | <span class='neutral'>    // &#39;qTarget &lt;= qOvershoot&#39; and we keep track of the breakpoints for</span>
  721 |     | <span class='neutral'>    // &#39;k(h - qTarget)&#39;. If &#39;getZeroForOne() == true&#39;, we have</span>
  722 |     | <span class='neutral'>    // &#39;qOvershoot &lt;= qTarget&#39; and we keep track of the breakpoints for</span>
  723 |     | <span class='neutral'>    // &#39;k(qTarget - h)&#39;. Hence, the direction of the shift should be aligned</span>
  724 |     | <span class='neutral'>    // with &#39;getZeroForOne()&#39;.</span>
  725 |     | <span class='neutral'>    getZeroForOne()</span>
  726 |     | <span class='neutral'>  );</span>
  727 |     | <span class='neutral'>}</span>
  728 |     | <span class='neutral'></span>
  729 |     | <span class='neutral'>/// @notice This function transitions from one &#39;phase&#39; of the curve sequence to</span>
  730 |     | <span class='neutral'>/// the next one.</span>
  731 |     | <span class='neutral'>///</span>
  732 |     | <span class='neutral'>/// To this end, &#39;direction&#39; is flipped. &#39;indexCurve&#39; is decremented. &#39;begin&#39;</span>
  733 |     | <span class='neutral'>/// is replaced with &#39;origin&#39;. &#39;origin&#39; is replaced with &#39;end&#39;. A new member of</span>
  734 |     | <span class='neutral'>/// the curve sequence is loaded using the decremented index and is stored in</span>
  735 |     | <span class='neutral'>/// &#39;end&#39;. Lastly, &#39;total0&#39; and &#39;total1&#39; are recalculated based on the new</span>
  736 |     | <span class='neutral'>/// &#39;origin&#39;.</span>
  737 |     | <span class='neutral'>///</span>
  738 |     | <span class='neutral'>/// ---------------------------------------------------------------------------</span>
  739 |     | <span class='neutral'>///</span>
  740 |     | <span class='neutral'>/// Underflow of &#39;indexCurve&#39; should be avoided externally.</span>
  741 |     | <span class='neutral'>///</span>
  742 |     | <span class='neutral'>/// Underflow and index out of range for &#39;indexKernelTotal - oneIndex&#39; should</span>
  743 |     | <span class='neutral'>/// be avoided externally.</span>
  744 |     | <span class='neutral'>///</span>
  745 |     | <span class='neutral'>/// Index out of range for &#39;indexKernelTotal&#39; should be avoided externally.</span>
  746 |     | <span class='neutral'>function movePhase() pure returns (bool direction) {</span>
  747 |     | <span class='neutral'>  // As explained in &#39;Memory.sol&#39; and earlier in this script, a swap within the</span>
  748 |     | <span class='neutral'>  // active liquidity interval can be seen as a movement in price from</span>
  749 |     | <span class='neutral'>  // &#39;qCurrent&#39; to &#39;qTarget&#39;. In order to determine the outgoing and incoming</span>
  750 |     | <span class='neutral'>  // amounts for a swap, we need to integrate a number of piecewise functions</span>
  751 |     | <span class='neutral'>  // from &#39;qCurrent&#39; to &#39;qTarget&#39;.</span>
  752 |     | <span class='neutral'>  //</span>
  753 |     | <span class='neutral'>  // One of these functions is &#39;w(.)&#39; whose pieces need to be examined one by</span>
  754 |     | <span class='neutral'>  // one. &#39;w(.)&#39; is constructed from the curve sequence as explained in</span>
  755 |     | <span class='neutral'>  // &#39;Memory.sol&#39;. Every piece of the function &#39;w(.)&#39; is regarded as a &#39;phase&#39;.</span>
  756 |     | <span class='neutral'>  // As explained above, a &#39;phase&#39; corresponds to three consecutive members of</span>
  757 |     | <span class='neutral'>  // the curve sequence:</span>
  758 |     | <span class='neutral'>  //</span>
  759 |     | <span class='neutral'>  //  - &#39;qEnd := q[indexCurve]&#39;,</span>
  760 |     | <span class='neutral'>  //</span>
  761 |     | <span class='neutral'>  //  - &#39;qOrigin := q[indexCurve + 1]&#39;,</span>
  762 |     | <span class='neutral'>  //</span>
  763 |     | <span class='neutral'>  //  - &#39;q[indexCurve + 2]&#39;.</span>
  764 |     | <span class='neutral'>  //</span>
  765 |     | <span class='neutral'>  // where the out of range member &#39;q[curveLength]&#39; is assigned the same value</span>
  766 |     | <span class='neutral'>  // as the last member &#39;q[curveLength - 1]&#39;.</span>
  767 |     | <span class='neutral'>  //</span>
  768 |     | <span class='neutral'>  // If &#39;q[indexCurve + 2] &lt; qEnd&#39;, we have</span>
  769 |     | <span class='neutral'>  //</span>
  770 |     | <span class='neutral'>  //  &#39;w(q) == q - qOrigin&#39; for every &#39;q[indexCurve + 2] &lt; q &lt; qEnd&#39;.</span>
  771 |     | <span class='neutral'>  //</span>
  772 |     | <span class='neutral'>  // If &#39;qEnd &lt; q[indexCurve + 2]&#39;, we have</span>
  773 |     | <span class='neutral'>  //</span>
  774 |     | <span class='neutral'>  //  &#39;w(q) == qOrigin - q&#39; for every &#39;qEnd &lt; q &lt; q[indexCurve + 2]&#39;.</span>
  775 |     | <span class='neutral'>  //</span>
  776 |     | <span class='neutral'>  // Initially, (i.e., for the very first &#39;phase&#39;) we have:</span>
  777 |     | <span class='neutral'>  //</span>
  778 |     | <span class='neutral'>  //  - &#39;indexCurve == curveLength - 2&#39;,</span>
  779 |     | <span class='neutral'>  //</span>
  780 |     | <span class='neutral'>  //  - &#39;qEnd := q[indexCurve] == q[curveLength - 2]&#39;,</span>
  781 |     | <span class='neutral'>  //</span>
  782 |     | <span class='neutral'>  //  - &#39;qOrigin := q[indexCurve + 1] == q[curveLength - 1]&#39;,</span>
  783 |     | <span class='neutral'>  //</span>
  784 |     | <span class='neutral'>  //  - &#39;q[indexCurve + 2] := q[curveLength] == q[curveLength - 1]&#39;.</span>
  785 |     | <span class='neutral'>  //</span>
  786 |     | <span class='neutral'>  // Then, with each call to the present function, &#39;indexCurve&#39; is decremented</span>
  787 |     | <span class='neutral'>  // and the following three members of the curve sequence are used to</span>
  788 |     | <span class='neutral'>  // characterize the current phase:</span>
  789 |     | <span class='neutral'>  //</span>
  790 |     | <span class='neutral'>  //  - &#39;qEnd := q[indexCurve]&#39;,</span>
  791 |     | <span class='neutral'>  //</span>
  792 |     | <span class='neutral'>  //  - &#39;qOrigin := q[indexCurve + 1]&#39;,</span>
  793 |     | <span class='neutral'>  //</span>
  794 |     | <span class='neutral'>  //  - &#39;q[indexCurve + 2]&#39;.</span>
  795 |     | <span class='neutral'>  //</span>
  796 |     | <span class='neutral'>  // Hence, in order to move from a &#39;phase&#39; to the next one, we need to copy</span>
  797 |     | <span class='neutral'>  // the content of &#39;origin&#39; to &#39;begin&#39;, then copy the content of &#39;end&#39; to</span>
  798 |     | <span class='neutral'>  // &#39;origin&#39;, and lastly, we need to load a new member from the curve sequence</span>
  799 |     | <span class='neutral'>  // corresponding to the decremented index.</span>
  800 |     | <span class='neutral'>  //</span>
  801 |     | <span class='neutral'>  // Index out of range for &#39;indexCurve&#39; is avoided externally.</span>
  802 |     | <span class='neutral'>  //</span>
  803 |     | <span class='neutral'>  // The requirements of &#39;storePrice&#39; are satisfied because &#39;_end_&#39; is a</span>
  804 |     | <span class='neutral'>  // constant greater than &#39;32&#39; and</span>
  805 |     | <span class='neutral'>  // &#39;getCurve().member(_indexCurve_.decrementIndex())&#39; is a member of the</span>
  806 |     | <span class='neutral'>  // curve which is positive and less than &#39;2 ** 64&#39;.</span>
  807 |     | <span class='neutral'>  _begin_.copyPrice(_origin_);</span>
  808 |     | <span class='neutral'>  _origin_.copyPrice(_end_);</span>
  809 |     | <span class='neutral'>  _end_.storePrice(getCurve().member(_indexCurve_.decrementIndex()));</span>
  810 |     | <span class='neutral'></span>
  811 |     | <span class='neutral'>  // Next, we need to flip the direction flag. Let the triplet</span>
  812 |     | <span class='neutral'>  //</span>
  813 |     | <span class='neutral'>  //  &#39;q[indexCurve + 1]&#39;, &#39;q[indexCurve + 2]&#39;, &#39;q[indexCurve + 3]&#39;</span>
  814 |     | <span class='neutral'>  //</span>
  815 |     | <span class='neutral'>  // represent the &#39;phase&#39; prior to the above update and let</span>
  816 |     | <span class='neutral'>  //</span>
  817 |     | <span class='neutral'>  //  &#39;q[indexCurve]&#39;, &#39;q[indexCurve + 1]&#39;, &#39;q[indexCurve + 2]&#39;</span>
  818 |     | <span class='neutral'>  //</span>
  819 |     | <span class='neutral'>  // represent the new &#39;phase&#39;.</span>
  820 |     | <span class='neutral'>  //</span>
  821 |     | <span class='neutral'>  // Remember that the curve sequence is constructed in such a way that every</span>
  822 |     | <span class='neutral'>  // member is in between the preceding two members. As explained in</span>
  823 |     | <span class='neutral'>  // &#39;Curve.sol&#39;, this ordering rule is always preserved with every amendment</span>
  824 |     | <span class='neutral'>  // of the curve sequence. Hence, we have:</span>
  825 |     | <span class='neutral'>  //</span>
  826 |     | <span class='neutral'>  //  &#39;min(q[indexCurve + 1], q[indexCurve + 2]) &lt;</span>
  827 |     | <span class='neutral'>  //</span>
  828 |     | <span class='neutral'>  //   q[indexCurve + 3] &lt;</span>
  829 |     | <span class='neutral'>  //</span>
  830 |     | <span class='neutral'>  //   max(q[indexCurve + 1], q[indexCurve + 2])&#39;</span>
  831 |     | <span class='neutral'>  //</span>
  832 |     | <span class='neutral'>  // and</span>
  833 |     | <span class='neutral'>  //</span>
  834 |     | <span class='neutral'>  //  &#39;min(q[indexCurve], q[indexCurve + 1]) &lt; </span>
  835 |     | <span class='neutral'>  //</span>
  836 |     | <span class='neutral'>  //   q[indexCurve + 2] &lt; </span>
  837 |     | <span class='neutral'>  //</span>
  838 |     | <span class='neutral'>  //   max(q[indexCurve], q[indexCurve + 1])&#39;.</span>
  839 |     | <span class='neutral'>  //</span>
  840 |     | <span class='neutral'>  // Now, consider the following two possibilities:</span>
  841 |     | <span class='neutral'>  //</span>
  842 |     | <span class='neutral'>  //  - If</span>
  843 |     | <span class='neutral'>  //</span>
  844 |     | <span class='neutral'>  //      &#39;q[indexCurve] &lt; q[indexCurve + 1]&#39;,</span>
  845 |     | <span class='neutral'>  //</span>
  846 |     | <span class='neutral'>  //    then the second inequality boils down to</span>
  847 |     | <span class='neutral'>  //</span>
  848 |     | <span class='neutral'>  //      &#39;q[indexCurve] &lt; q[indexCurve + 2] &lt; q[indexCurve + 1]&#39;,</span>
  849 |     | <span class='neutral'>  //</span>
  850 |     | <span class='neutral'>  //    and, consequently, the first inequality boils do</span>
  851 |     | <span class='neutral'>  //</span>
  852 |     | <span class='neutral'>  //      &#39;q[indexCurve + 2] &lt; q[indexCurve + 3] &lt; q[indexCurve + 1]&#39;.</span>
  853 |     | <span class='neutral'>  //</span>
  854 |     | <span class='neutral'>  //    Hence, we have</span>
  855 |     | <span class='neutral'>  //</span>
  856 |     | <span class='neutral'>  //      &#39;q[indexCurve] &lt; q[indexCurve + 2]&#39;,</span>
  857 |     | <span class='neutral'>  //      &#39;q[indexCurve + 3] &lt; q[indexCurve + 1]&#39;,</span>
  858 |     | <span class='neutral'>  //</span>
  859 |     | <span class='neutral'>  //    and therefore, the old phase and the new phase have opposite</span>
  860 |     | <span class='neutral'>  //    directions.</span>
  861 |     | <span class='neutral'>  //</span>
  862 |     | <span class='neutral'>  //  - If</span>
  863 |     | <span class='neutral'>  //</span>
  864 |     | <span class='neutral'>  //      &#39;q[indexCurve + 1] &lt; q[indexCurve]&#39;,</span>
  865 |     | <span class='neutral'>  //</span>
  866 |     | <span class='neutral'>  //    then the second inequality boils down to</span>
  867 |     | <span class='neutral'>  //</span>
  868 |     | <span class='neutral'>  //      &#39;q[indexCurve + 1] &lt; q[indexCurve + 2] &lt; q[indexCurve]&#39;,</span>
  869 |     | <span class='neutral'>  //</span>
  870 |     | <span class='neutral'>  //    and, consequently, the first inequality boils do</span>
  871 |     | <span class='neutral'>  //</span>
  872 |     | <span class='neutral'>  //      &#39;q[indexCurve + 1] &lt; q[indexCurve + 3] &lt; q[indexCurve + 2]&#39;.</span>
  873 |     | <span class='neutral'>  //</span>
  874 |     | <span class='neutral'>  //    Hence, we have</span>
  875 |     | <span class='neutral'>  //</span>
  876 |     | <span class='neutral'>  //      &#39;q[indexCurve + 2] &lt; q[indexCurve]&#39;,</span>
  877 |     | <span class='neutral'>  //      &#39;q[indexCurve + 1] &lt; q[indexCurve + 3]&#39;,</span>
  878 |     | <span class='neutral'>  //</span>
  879 |     | <span class='neutral'>  //    and therefore, in this case, the old phase and the new phase have</span>
  880 |     | <span class='neutral'>  //    opposite directions as well.</span>
  881 |     | <span class='neutral'>  //</span>
  882 |     | <span class='neutral'>  // So, in both cases as we transition to a new &#39;phase&#39;, the direction should</span>
  883 |     | <span class='neutral'>  // be flipped. The resulting boolean is stored in memory and it is also</span>
  884 |     | <span class='neutral'>  // cached to be given as output and to be used later in the present function.</span>
  885 |     | <span class='neutral'>  setDirection(direction = !getDirection());</span>
  886 |     | <span class='neutral'></span>
  887 |     | <span class='neutral'>  // Fetch the memory pointer for the kernel from the memory.</span>
  888 |     | <span class='neutral'>  Kernel kernel = getKernel();</span>
  889 |     | <span class='neutral'>  Index indexKernelTotal = _indexKernelTotal_.getIndex();</span>
  890 |     | <span class='neutral'></span>
  891 |     | <span class='neutral'>  // Let &#39;b0&#39; and &#39;b1&#39; represent the horizontal coordinates of the kernel</span>
  892 |     | <span class='neutral'>  // breakpoint corresponding to &#39;indexKernelTotal - oneIndex&#39; and</span>
  893 |     | <span class='neutral'>  // &#39;indexKernelTotal&#39;, respectively.</span>
  894 |     | <span class='neutral'>  //</span>
  895 |     | <span class='neutral'>  // Remember that if &#39;direction == false&#39;, we have:</span>
  896 |     | <span class='neutral'>  // </span>
  897 |     | <span class='neutral'>  //  &#39;_total0_.log() := (2 ** 59) * (16 + qOrigin + b0)&#39;,</span>
  898 |     | <span class='neutral'>  //  &#39;_total1_.log() := (2 ** 59) * (16 + qOrigin + b1)&#39;,</span>
  899 |     | <span class='neutral'>  // </span>
  900 |     | <span class='neutral'>  // and if &#39;direction == true&#39;, we have:</span>
  901 |     | <span class='neutral'>  //</span>
  902 |     | <span class='neutral'>  //  &#39;_total0_.log() := (2 ** 59) * (16 + qOrigin - b0)&#39;,</span>
  903 |     | <span class='neutral'>  //  &#39;_total1_.log() := (2 ** 59) * (16 + qOrigin - b1)&#39;.</span>
  904 |     | <span class='neutral'>  //</span>
  905 |     | <span class='neutral'>  // Since the &#39;direction&#39; and &#39;qOrigin&#39; have been revised, we need to</span>
  906 |     | <span class='neutral'>  // recalculate the content of both &#39;total0&#39; and &#39;total1&#39; using the function</span>
  907 |     | <span class='neutral'>  // &#39;impose&#39; from the &#39;KernelLibrary&#39;.</span>
  908 |     | <span class='neutral'>  //</span>
  909 |     | <span class='neutral'>  // Index out of range for &#39;indexKernelTotal&#39; is avoided externally.</span>
  910 |     | <span class='neutral'>  //</span>
  911 |     | <span class='neutral'>  // The subtraction &#39;indexKernelTotal - oneIndex&#39; is safe because underflow is</span>
  912 |     | <span class='neutral'>  // avoided externally.</span>
  913 |     | <span class='neutral'>  //</span>
  914 |     | <span class='neutral'>  // As explained in &#39;moveBreakpointTotal&#39; we should also prove that:</span>
  915 |     | <span class='neutral'>  //</span>
  916 |     | <span class='neutral'>  //  &#39;0 &lt; (2 ** 59) * (16 + qOrigin - b0) &lt; 2 ** 64&#39;</span>
  917 |     | <span class='neutral'>  //  &#39;0 &lt; (2 ** 59) * (16 + qOrigin + b0) &lt; 2 ** 64&#39;</span>
  918 |     | <span class='neutral'>  //  &#39;0 &lt; (2 ** 59) * (16 + qOrigin - b1) &lt; 2 ** 64&#39;</span>
  919 |     | <span class='neutral'>  //  &#39;0 &lt; (2 ** 59) * (16 + qOrigin + b1) &lt; 2 ** 64&#39;</span>
  920 |     | <span class='neutral'>  //</span>
  921 |     | <span class='neutral'>  // as required by &#39;impose&#39; in &#39;Kernel.sol&#39;.</span>
  922 |     | <span class='neutral'>  //</span>
  923 |     | <span class='neutral'>  // Let &#39;pLower&#39; and &#39;pUpper&#39; denote the minimum and maximum price in the</span>
  924 |     | <span class='neutral'>  // active liquidity interval, respectively and define</span>
  925 |     | <span class='neutral'>  //</span>
  926 |     | <span class='neutral'>  //  &#39;qLower := log(pLower / pOffset)&#39;,</span>
  927 |     | <span class='neutral'>  //  &#39;qUpper := log(pUpper / pOffset)&#39;.</span>
  928 |     | <span class='neutral'>  //</span>
  929 |     | <span class='neutral'>  // Let &#39;qSpacing := qUpper - qLower&#39; denote the length of every liquidity</span>
  930 |     | <span class='neutral'>  // interval. Upon initializing a pool, the given curve sequence is validated</span>
  931 |     | <span class='neutral'>  // by the method &#39;validate&#39; in &#39;Curve.sol&#39;. When validating the curve</span>
  932 |     | <span class='neutral'>  // sequence, the custom error &#39;BlankIntervalsShouldBeAvoided&#39; ensures that</span>
  933 |     | <span class='neutral'>  // &#39;16 + qLower&#39; is greater than &#39;qSpacing&#39; and &#39;16 + qUpper&#39; is smaller than</span>
  934 |     | <span class='neutral'>  // &#39;32 - qSpacing&#39;. As a result, every member &#39;q&#39; of the initial curve</span>
  935 |     | <span class='neutral'>  // sequence satisfies:</span>
  936 |     | <span class='neutral'>  // </span>
  937 |     | <span class='neutral'>  //  &#39;qSpacing &lt; 16 + q &lt; 32 - qSpacing&#39;.</span>
  938 |     | <span class='neutral'>  // </span>
  939 |     | <span class='neutral'>  // In addition, the method &#39;setSwapParams&#39; in &#39;Swap.sol&#39; ensures that</span>
  940 |     | <span class='neutral'>  // &#39;qTarget&#39; for every swap is also bounded by both</span>
  941 |     | <span class='neutral'>  // &#39;qSpacing + 1 / (2 ** 59)&#39; and &#39;32 - 1 / (2 ** 59) - qSpacing&#39;.</span>
  942 |     | <span class='neutral'>  // This ensures that the above inequality is always satisfied for every</span>
  943 |     | <span class='neutral'>  // member of the curve and not only the initial curve.</span>
  944 |     | <span class='neutral'>  //</span>
  945 |     | <span class='neutral'>  // Now, since &#39;qOrigin&#39; is a member of the curve sequence, we also have:</span>
  946 |     | <span class='neutral'>  //</span>
  947 |     | <span class='neutral'>  //  &#39;qSpacing &lt; 16 + qOrigin &lt; 32 - qSpacing&#39;.</span>
  948 |     | <span class='neutral'>  //</span>
  949 |     | <span class='neutral'>  // Hence,</span>
  950 |     | <span class='neutral'>  //</span>
  951 |     | <span class='neutral'>  //  &#39;0 &lt; (2 ** 59) * (16 + qOrigin) &lt;= (2 ** 59) * (16 + qOrigin + b0)</span>
  952 |     | <span class='neutral'>  //     &lt; (2 ** 59) * (32 - qSpacing + b0) &lt;= (2 ** 59) * 32 == 2 ** 64&#39;,</span>
  953 |     | <span class='neutral'>  //</span>
  954 |     | <span class='neutral'>  //  &#39;0 &lt; (2 ** 59) * (16 + qOrigin) &lt;= (2 ** 59) * (16 + qOrigin + b1)</span>
  955 |     | <span class='neutral'>  //     &lt; (2 ** 59) * (32 - qSpacing + b1) &lt;= (2 ** 59) * 32 == 2 ** 64&#39;,</span>
  956 |     | <span class='neutral'>  //</span>
  957 |     | <span class='neutral'>  // where &#39;0 &lt; (2 ** 59) * (16 + qOrigin)&#39; is because &#39;qOrigin&#39; is a member of</span>
  958 |     | <span class='neutral'>  // the curve and &#39;b0 &lt;= qSpacing&#39; and &#39;b1 &lt;= qSpacing&#39; are concluded from the</span>
  959 |     | <span class='neutral'>  // custom error &#39;HorizontalCoordinatesMayNotExceedLogSpacing&#39; when validating</span>
  960 |     | <span class='neutral'>  // kernel in &#39;KernelCompact.sol&#39;.</span>
  961 |     | <span class='neutral'>  //</span>
  962 |     | <span class='neutral'>  // Additionally,</span>
  963 |     | <span class='neutral'>  //</span>
  964 |     | <span class='neutral'>  //  &#39;2 ** 64 &gt;  (2 ** 59) * (16 + qOrigin)</span>
  965 |     | <span class='neutral'>  //           &gt;= (2 ** 59) * (16 + qOrigin - b0) </span>
  966 |     | <span class='neutral'>  //           &gt;  (2 ** 59) * (qSpacing - b0)</span>
  967 |     | <span class='neutral'>  //           &gt;= 0&#39;</span>
  968 |     | <span class='neutral'>  //</span>
  969 |     | <span class='neutral'>  //  &#39;2 ** 64 &gt;  (2 ** 59) * (16 + qOrigin)</span>
  970 |     | <span class='neutral'>  //           &gt;= (2 ** 59) * (16 + qOrigin - b1)</span>
  971 |     | <span class='neutral'>  //           &gt;  (2 ** 59) * (qSpacing - b1)</span>
  972 |     | <span class='neutral'>  //           &gt;= 0&#39;</span>
  973 |     | <span class='neutral'>  //</span>
  974 |     | <span class='neutral'>  // where &#39;(2 ** 59) * (16 + qOrigin) &lt; 2 ** 64&#39; is because &#39;qOrigin&#39; is a</span>
  975 |     | <span class='neutral'>  // member of the curve sequence and &#39;b0 &lt;= qSpacing&#39; and &#39;b1 &lt;= qSpacing&#39;</span>
  976 |     | <span class='neutral'>  // are concluded from the custom error</span>
  977 |     | <span class='neutral'>  // &#39;HorizontalCoordinatesMayNotExceedLogSpacing&#39; when validating kernel in</span>
  978 |     | <span class='neutral'>  // &#39;KernelCompact.sol&#39;.</span>
  979 |     | <span class='neutral'>  //</span>
  980 |     | <span class='neutral'>  // Lastly, both &#39;_total0_&#39; and &#39;_total1_&#39; are fixed values greater than &#39;34&#39;.</span>
  981 |     | <span class='neutral'>  //</span>
  982 |     | <span class='neutral'>  // Therefore, in both cases, the input requirements of &#39;impose&#39; are</span>
  983 |     | <span class='neutral'>  // satisfied.</span>
  984 |     | <span class='neutral'>  kernel.impose(</span>
  985 |     | <span class='neutral'>    // The resulting values are stored using the pointer &#39;_total0_&#39;.</span>
  986 |     | <span class='neutral'>    _total0_,</span>
  987 |     | <span class='neutral'>    // The new value for &#39;qOrigin&#39; is used as the base price for the shift.</span>
  988 |     | <span class='neutral'>    _origin_,</span>
  989 |     | <span class='neutral'>    // &#39;total0&#39; corresponds to the kernel breakpoint</span>
  990 |     | <span class='neutral'>    // &#39;indexKernelTotal - oneIndex&#39;.</span>
  991 |     | <span class='neutral'>    indexKernelTotal - oneIndex,</span>
  992 |     | <span class='neutral'>    // The flipped direction is used for this shift.</span>
  993 |     | <span class='neutral'>    direction</span>
  994 |     | <span class='neutral'>  );</span>
  995 |     | <span class='neutral'>  kernel.impose(</span>
  996 |     | <span class='neutral'>    // The resulting values are stored using the pointer &#39;_total1_&#39;.</span>
  997 |     | <span class='neutral'>    _total1_,</span>
  998 |     | <span class='neutral'>    // The new value for &#39;qOrigin&#39; is used as the base price for the shift.</span>
  999 |     | <span class='neutral'>    _origin_,</span>
 1000 |     | <span class='neutral'>    // &#39;total1&#39; corresponds to the kernel breakpoint &#39;indexKernelTotal&#39;.</span>
 1001 |     | <span class='neutral'>    indexKernelTotal,</span>
 1002 |     | <span class='neutral'>    // The flipped direction is used for this shift.</span>
 1003 |     | <span class='neutral'>    direction</span>
 1004 |     | <span class='neutral'>  );</span>
 1005 |     | <span class='neutral'>}</span>
 1006 |     | <span class='neutral'></span>
 1007 |     | <span class='neutral'>/// @notice If &#39;left == false&#39; this function increments &#39;qOvershoot&#39; by</span>
 1008 |     | <span class='neutral'>/// &#39;1 / (2 ** 59)&#39;. If &#39;left == true&#39; this function decrements &#39;qOvershoot&#39;</span>
 1009 |     | <span class='neutral'>/// by &#39;1 / (2 ** 59)&#39;.</span>
 1010 |     | <span class='neutral'>///</span>
 1011 |     | <span class='neutral'>/// Let &#39;q&#39; denote an arbitrary member of the curve sequence with index &#39;i&#39;.</span>
 1012 |     | <span class='neutral'>/// Then, &#39;curve.member(i)&#39; is a positive value read from 64 bits of memory.</span>
 1013 |     | <span class='neutral'>/// Hence,</span>
 1014 |     | <span class='neutral'>///</span>
 1015 |     | <span class='neutral'>///  &#39;1 &lt;= curve.member(indexLower) &lt;= (2 ** 64) - 1&#39;</span>
 1016 |     | <span class='neutral'>///</span>
 1017 |     | <span class='neutral'>///  &#39;1 &lt;= (2 ** 59) * (16 + q) &lt;= (2 ** 64) - 1&#39;</span>
 1018 |     | <span class='neutral'>///</span>
 1019 |     | <span class='neutral'>///  &#39;1 / (2 ** 59) &lt;= 16 + q &lt;= 32 - 1 / (2 ** 59)&#39;</span>
 1020 |     | <span class='neutral'>///</span>
 1021 |     | <span class='neutral'>///  &#39;- 16 + 1 / (2 ** 59) &lt;= q &lt;= + 16 - 1 / (2 ** 59)&#39;</span>
 1022 |     | <span class='neutral'>///</span>
 1023 |     | <span class='neutral'>/// The above inequality will be used to prove the safety of operations in this</span>
 1024 |     | <span class='neutral'>/// function.</span>
 1025 |     | <span class='neutral'>///</span>
 1026 |     | <span class='neutral'>/// ---------------------------------------------------------------------------</span>
 1027 |     | <span class='neutral'>///</span>
 1028 |     | <span class='neutral'>/// If &#39;left == false&#39; then &#39;qOvershoot + 1 / (2 ** 59) &lt;= qUpper&#39; should be</span>
 1029 |     | <span class='neutral'>/// enforced externally.</span>
 1030 |     | <span class='neutral'>///</span>
 1031 |     | <span class='neutral'>/// If &#39;left == true&#39; then &#39;qLower &lt;= qOvershoot - 1 / (2 ** 59)&#39; should be</span>
 1032 |     | <span class='neutral'>/// enforced externally.</span>
 1033 |     | <span class='neutral'>function moveOvershootByEpsilon(</span>
 1034 |     | <span class='neutral'>  bool left</span>
 1035 |     | <span class='neutral'>) pure {</span>
 1036 |     | <span class='neutral'>  // &#39;_overshoot_&#39; is a constant which is greater than &#39;32&#39;.</span>
 1037 |     | <span class='neutral'>  //</span>
 1038 |     | <span class='neutral'>  // In both cases, we will argue that</span>
 1039 |     | <span class='neutral'>  //</span>
 1040 |     | <span class='neutral'>  //  - the resulting value for &#39;(2 ** 59) * (16 + qOvershoot)&#39; is nonnegative</span>
 1041 |     | <span class='neutral'>  //    and less than &#39;2 ** 64&#39;, and</span>
 1042 |     | <span class='neutral'>  //</span>
 1043 |     | <span class='neutral'>  //  - both square root values are nonnegative and less than &#39;one216&#39;.</span>
 1044 |     | <span class='neutral'>  //</span>
 1045 |     | <span class='neutral'>  // Hence, the requirements of &#39;storePrice&#39; are satisfied.</span>
 1046 |     | <span class='neutral'>  left ? _overshoot_.storePrice(</span>
 1047 |     | <span class='neutral'>    // The subtraction is safe, because in this case, we have</span>
 1048 |     | <span class='neutral'>    //</span>
 1049 |     | <span class='neutral'>    //  &#39;0 &lt;  (2 ** 59) * (16 + qLower)</span>
 1050 |     | <span class='neutral'>    //     &lt;= (2 ** 59) * (16 + qOvershoot - 1 / (2 ** 59))</span>
 1051 |     | <span class='neutral'>    //</span>
 1052 |     | <span class='neutral'>    // where the first inequality is because &#39;qLower&#39; is a member of the curve</span>
 1053 |     | <span class='neutral'>    // sequence and the second inequality is enforced externally.</span>
 1054 |     | <span class='neutral'>    //</span>
 1055 |     | <span class='neutral'>    // Additionally, because</span>
 1056 |     | <span class='neutral'>    //</span>
 1057 |     | <span class='neutral'>    //  &#39;_overshoot_.log() == (2 ** 59) * (16 + qOvershoot)&#39;</span>
 1058 |     | <span class='neutral'>    //</span>
 1059 |     | <span class='neutral'>    // is read from 64 bits of memory,</span>
 1060 |     | <span class='neutral'>    //</span>
 1061 |     | <span class='neutral'>    //  &#39;_overshoot_.log() - epsilonX59 == </span>
 1062 |     | <span class='neutral'>    //   (2 ** 59) * (16 + qOvershoot - 1 / (2 ** 59))&#39;</span>
 1063 |     | <span class='neutral'>    //</span>
 1064 |     | <span class='neutral'>    // can be safely stored in 64 bits of memory as well.</span>
 1065 |     | <span class='neutral'>    _overshoot_.log() - epsilonX59,</span>
 1066 |     | <span class='neutral'>    // Here, we calculate:</span>
 1067 |     | <span class='neutral'>    //</span>
 1068 |     | <span class='neutral'>    //  &#39;(2 ** 216) * exp(- 8 - qOvershoot / 2 + 1 / (2 ** 60)) ==</span>
 1069 |     | <span class='neutral'>    //   (2 ** 216) * exp(- 8 - qOvershoot / 2) * exp(1 / (2 ** 60)) ==</span>
 1070 |     | <span class='neutral'>    //   _overshoot_.sqrt(false) * exp(1 / (2 ** 60))&#39;</span>
 1071 |     | <span class='neutral'>    //</span>
 1072 |     | <span class='neutral'>    // &#39;_overshoot_.sqrt(false)&#39; is a nonnegative value which is read from 216</span>
 1073 |     | <span class='neutral'>    // bits of memory. Additionally, since</span>
 1074 |     | <span class='neutral'>    // &#39;qLower &lt;= qOvershoot - 1 / (2 ** 59)&#39; is enforced externally, we have:</span>
 1075 |     | <span class='neutral'>    //</span>
 1076 |     | <span class='neutral'>    //  &#39;(2 ** 216) * exp(- 8 - qOvershoot / 2 + 1 / (2 ** 60)) ==</span>
 1077 |     | <span class='neutral'>    //   (2 ** 216) * exp(- (16 + qOvershoot - 1 / (2 ** 59)) / 2) &lt;=</span>
 1078 |     | <span class='neutral'>    //   (2 ** 216) * exp(- (16 + qLower) / 2) &lt;=</span>
 1079 |     | <span class='neutral'>    //   (2 ** 216) * exp(- 1 / (2 ** 60))&#39;</span>
 1080 |     | <span class='neutral'>    //</span>
 1081 |     | <span class='neutral'>    // which means, that</span>
 1082 |     | <span class='neutral'>    //</span>
 1083 |     | <span class='neutral'>    //  &#39;(2 ** 216) * exp(- 8 - qOvershoot / 2 + 1 / (2 ** 60))&#39;</span>
 1084 |     | <span class='neutral'>    //</span>
 1085 |     | <span class='neutral'>    // does not exceed 216 bits and overflow of</span>
 1086 |     | <span class='neutral'>    // &#39;_overshoot_.sqrt(false).multiplyByExpEpsilon()&#39; is impossible.</span>
 1087 |     | <span class='neutral'>    //</span>
 1088 |     | <span class='neutral'>    // Hence, the requirements of &#39;multiplyByExpEpsilon&#39; are satisfied.</span>
 1089 |     | <span class='neutral'>    _overshoot_.sqrt(false).multiplyByExpEpsilon(),</span>
 1090 |     | <span class='neutral'>    // Here, we calculate:</span>
 1091 |     | <span class='neutral'>    //</span>
 1092 |     | <span class='neutral'>    //  &#39;(2 ** 216) * exp(- 8 + qOvershoot / 2 - 1 / (2 ** 60)) ==</span>
 1093 |     | <span class='neutral'>    //   (2 ** 216) * exp(- 8 + qOvershoot / 2) / exp(1 / (2 ** 60)) ==</span>
 1094 |     | <span class='neutral'>    //   _overshoot_.sqrt(true) / exp(1 / (2 ** 60))&#39;</span>
 1095 |     | <span class='neutral'>    //</span>
 1096 |     | <span class='neutral'>    // Since &#39;_overshoot_.sqrt(true)&#39; is a nonnegative value which is read</span>
 1097 |     | <span class='neutral'>    // from 216 bits of memory, the requirement of &#39;divideByExpEpsilon&#39; is</span>
 1098 |     | <span class='neutral'>    // satisfied.</span>
 1099 |     | <span class='neutral'>    _overshoot_.sqrt(true).divideByExpEpsilon()</span>
 1100 |     | <span class='neutral'>  ) : _overshoot_.storePrice(</span>
 1101 |     | <span class='neutral'>    // The addition is safe, because in this case, we have</span>
 1102 |     | <span class='neutral'>    //</span>
 1103 |     | <span class='neutral'>    //  &#39;(2 ** 59) * (16 + qOvershoot + 1 / (2 ** 59)) &lt;=</span>
 1104 |     | <span class='neutral'>    //   (2 ** 59) * (16 + qUpper) &lt; 2 ** 64</span>
 1105 |     | <span class='neutral'>    //</span>
 1106 |     | <span class='neutral'>    // where the first inequality is enforced externally and the second</span>
 1107 |     | <span class='neutral'>    // inequality is because &#39;qUpper&#39; is a member of the curve sequence.</span>
 1108 |     | <span class='neutral'>    //</span>
 1109 |     | <span class='neutral'>    // Additionally, due to the above argument,</span>
 1110 |     | <span class='neutral'>    // &#39;(2 ** 59) * (16 + qOvershoot + 1 / (2 ** 59))&#39; fits within 64 bits and</span>
 1111 |     | <span class='neutral'>    // can be safely stored in 64 bits of memory.</span>
 1112 |     | <span class='neutral'>    _overshoot_.log() + epsilonX59,</span>
 1113 |     | <span class='neutral'>    // Here, we calculate:</span>
 1114 |     | <span class='neutral'>    //</span>
 1115 |     | <span class='neutral'>    //  &#39;(2 ** 216) * exp(- 8 - qOvershoot / 2 - 1 / (2 ** 60)) ==</span>
 1116 |     | <span class='neutral'>    //   (2 ** 216) * exp(- 8 - qOvershoot / 2) / exp(1 / (2 ** 60)) ==</span>
 1117 |     | <span class='neutral'>    //   _overshoot_.sqrt(false) / exp(1 / (2 ** 60))&#39;</span>
 1118 |     | <span class='neutral'>    //</span>
 1119 |     | <span class='neutral'>    // Since &#39;_overshoot_.sqrt(false)&#39; is a nonnegative value which is read</span>
 1120 |     | <span class='neutral'>    // from 216 bits of memory, the requirement of &#39;divideByExpEpsilon&#39; is</span>
 1121 |     | <span class='neutral'>    // satisfied.</span>
 1122 |     | <span class='neutral'>    _overshoot_.sqrt(false).divideByExpEpsilon(),</span>
 1123 |     | <span class='neutral'>    // Here, we calculate:</span>
 1124 |     | <span class='neutral'>    //</span>
 1125 |     | <span class='neutral'>    //  &#39;(2 ** 216) * exp(- 8 + qOvershoot / 2 + 1 / (2 ** 60)) ==</span>
 1126 |     | <span class='neutral'>    //   (2 ** 216) * exp(- 8 + qOvershoot / 2) * exp(1 / (2 ** 60)) ==</span>
 1127 |     | <span class='neutral'>    //   _overshoot_.sqrt(true) * exp(1 / (2 ** 60))&#39;</span>
 1128 |     | <span class='neutral'>    //</span>
 1129 |     | <span class='neutral'>    // &#39;_overshoot_.sqrt(true)&#39; is a nonnegative value which is read from 216</span>
 1130 |     | <span class='neutral'>    // bits of memory. Additionally, since</span>
 1131 |     | <span class='neutral'>    // &#39;qOvershoot + 1 / (2 ** 59) &lt;= qUpper&#39; is enforced externally, we have:</span>
 1132 |     | <span class='neutral'>    //</span>
 1133 |     | <span class='neutral'>    //  &#39;(2 ** 216) * exp(- 8 + qOvershoot / 2 + 1 / (2 ** 60)) &lt;=</span>
 1134 |     | <span class='neutral'>    //   (2 ** 216) * exp(- (16 - qOvershoot - 1 / (2 ** 59)) / 2) &lt;=</span>
 1135 |     | <span class='neutral'>    //   (2 ** 216) * exp(- (16 - qUpper) / 2) &lt;=</span>
 1136 |     | <span class='neutral'>    //   (2 ** 216) * exp(- 1 / (2 ** 60)) &lt; oneX216&#39;</span>
 1137 |     | <span class='neutral'>    //</span>
 1138 |     | <span class='neutral'>    // which means, that</span>
 1139 |     | <span class='neutral'>    //</span>
 1140 |     | <span class='neutral'>    //  &#39;(2 ** 216) * exp(- 8 + qOvershoot / 2 + 1 / (2 ** 60))&#39;</span>
 1141 |     | <span class='neutral'>    //</span>
 1142 |     | <span class='neutral'>    // does not exceed 216 bits and overflow of</span>
 1143 |     | <span class='neutral'>    // &#39;_overshoot_.sqrt(true).multiplyByExpEpsilon()&#39; is impossible.</span>
 1144 |     | <span class='neutral'>    //</span>
 1145 |     | <span class='neutral'>    // Hence, the requirements of &#39;multiplyByExpEpsilon&#39; are satisfied.</span>
 1146 |     | <span class='neutral'>    _overshoot_.sqrt(true).multiplyByExpEpsilon()</span>
 1147 |     | <span class='neutral'>  );</span>
 1148 |     | <span class='neutral'>}</span>
 1149 |     | <span class='neutral'></span>
 1150 |     | <span class='neutral'>/// @notice For the case &#39;exactInput == false&#39;, i.e., when the specified amount</span>
 1151 |     | <span class='neutral'>/// is outgoing, this function performs a Halley search to determine &#39;qTarget&#39;</span>
 1152 |     | <span class='neutral'>/// based on &#39;integralLimit&#39;. As explained in &#39;Memory.sol&#39;, &#39;integralLimit&#39; is</span>
 1153 |     | <span class='neutral'>/// is derived from &#39;amountSpecified&#39;.</span>
 1154 |     | <span class='neutral'>///</span>
 1155 |     | <span class='neutral'>/// Let</span>
 1156 |     | <span class='neutral'>///</span>
 1157 |     | <span class='neutral'>///  &#39;cTotal0 := c[indexKernelTotal - 1]&#39;,</span>
 1158 |     | <span class='neutral'>///  &#39;cTotal1 := c[indexKernelTotal]&#39;,</span>
 1159 |     | <span class='neutral'>///</span>
 1160 |     | <span class='neutral'>/// represent the vertical coordinates of the kernel breakpoints corresponding</span>
 1161 |     | <span class='neutral'>/// to &#39;indexKernelTotal - 1&#39; and &#39;indexKernelTotal&#39;, respectively. As</span>
 1162 |     | <span class='neutral'>/// explained in &#39;Memory.sol&#39;, the memory spaces that are pointed to by</span>
 1163 |     | <span class='neutral'>/// &#39;_total0_&#39; and &#39;_total1_&#39; host the following vertical coordinates:</span>
 1164 |     | <span class='neutral'>///</span>
 1165 |     | <span class='neutral'>///  &#39;_total0_.height() := (2 ** 15) * cTotal0&#39;,</span>
 1166 |     | <span class='neutral'>///  &#39;_total1_.height() := (2 ** 15) * cTotal1&#39;.</span>
 1167 |     | <span class='neutral'>///</span>
 1168 |     | <span class='neutral'>/// Additionally, if &#39;getDirection() == false&#39;, define</span>
 1169 |     | <span class='neutral'>///</span>
 1170 |     | <span class='neutral'>///  &#39;qTotal0 := qOrigin + b[indexKernelTotal - 1]&#39;,</span>
 1171 |     | <span class='neutral'>///  &#39;qTotal1 := qOrigin + b[indexKernelTotal]&#39;,</span>
 1172 |     | <span class='neutral'>///</span>
 1173 |     | <span class='neutral'>/// and if &#39;getDirection() == true&#39;, define</span>
 1174 |     | <span class='neutral'>///</span>
 1175 |     | <span class='neutral'>///  &#39;qTotal0 := qOrigin - b[indexKernelTotal - 1]&#39;,</span>
 1176 |     | <span class='neutral'>///  &#39;qTotal1 := qOrigin - b[indexKernelTotal]&#39;,</span>
 1177 |     | <span class='neutral'>///</span>
 1178 |     | <span class='neutral'>/// as the shifted horizontal coordinates of the kernel breakpoint</span>
 1179 |     | <span class='neutral'>/// corresponding to &#39;indexKernelTotal - 1&#39; and &#39;indexKernelTotal&#39;,</span>
 1180 |     | <span class='neutral'>/// respectively. Hence, the memory spaces that are pointed to by &#39;_total0_&#39;</span>
 1181 |     | <span class='neutral'>/// and &#39;_total1_&#39; host the following horizontal coordinates as well:</span>
 1182 |     | <span class='neutral'>/// </span>
 1183 |     | <span class='neutral'>///  &#39;_total0_.log() := (2 ** 59) * (16 + qTotal0)&#39;,</span>
 1184 |     | <span class='neutral'>///  &#39;_total1_.log() := (2 ** 59) * (16 + qTotal1)&#39;,</span>
 1185 |     | <span class='neutral'>/// </span>
 1186 |     | <span class='neutral'>/// Let &#39;qBegin&#39; and &#39;qCurrent&#39; represent the offsetted logarithmic prices that</span>
 1187 |     | <span class='neutral'>/// are hosted by the memory pointers &#39;_begin_&#39; and &#39;_current_&#39;, i.e.,</span>
 1188 |     | <span class='neutral'>///</span>
 1189 |     | <span class='neutral'>///  &#39;_begin_.log() == (2 ** 59) * (16 + qBegin)&#39;,</span>
 1190 |     | <span class='neutral'>///  &#39;_current_.log() == (2 ** 59) * (16 + qCurrent)&#39;.</span>
 1191 |     | <span class='neutral'>///</span>
 1192 |     | <span class='neutral'>/// At this stage, &#39;qTarget&#39; is not yet determined. Hence, if </span>
 1193 |     | <span class='neutral'>/// &#39;getZeroForOne() == false&#39;, we have:</span>
 1194 |     | <span class='neutral'>///</span>
 1195 |     | <span class='neutral'>///                           - 8     / qBegin</span>
 1196 |     | <span class='neutral'>///    currentToTarget      e        |    - h / 2</span>
 1197 |     | <span class='neutral'>///  &#39;----------------- := ------- * |  e         k(w(h)) dh&#39;</span>
 1198 |     | <span class='neutral'>///       2 ** 216            2      |</span>
 1199 |     | <span class='neutral'>///                                 / qCurrent</span>
 1200 |     | <span class='neutral'>///</span>
 1201 |     | <span class='neutral'>/// and we want to determine &#39;qTarget&#39; based on the following equation:</span>
 1202 |     | <span class='neutral'>///</span>
 1203 |     | <span class='neutral'>///                              - 8     / qTarget</span>
 1204 |     | <span class='neutral'>///    getIntegralLimit()      e        |    - h / 2</span>
 1205 |     | <span class='neutral'>///  &#39;-------------------- == ------- * |  e         k(w(h)) dh&#39;,</span>
 1206 |     | <span class='neutral'>///         2 ** 216             2      |</span>
 1207 |     | <span class='neutral'>///                                    / qCurrent</span>
 1208 |     | <span class='neutral'>///</span>
 1209 |     | <span class='neutral'>/// which is equivalent to</span>
 1210 |     | <span class='neutral'>///</span>
 1211 |     | <span class='neutral'>///    getIntegralLimit() - currentToTarget</span>
 1212 |     | <span class='neutral'>///  &#39;-------------------------------------- == </span>
 1213 |     | <span class='neutral'>///                  2 ** 216</span>
 1214 |     | <span class='neutral'>///</span>
 1215 |     | <span class='neutral'>///      - 8     / qTarget</span>
 1216 |     | <span class='neutral'>///    e        |    - h / 2</span>
 1217 |     | <span class='neutral'>///   ------- * |  e         k(w(h)) dh == </span>
 1218 |     | <span class='neutral'>///      2      |</span>
 1219 |     | <span class='neutral'>///            / qBegin</span>
 1220 |     | <span class='neutral'>///</span>
 1221 |     | <span class='neutral'>///      - 8     / qTarget</span>
 1222 |     | <span class='neutral'>///    e        |    - h / 2             cTotal1 - cTotal0</span>
 1223 |     | <span class='neutral'>///   ------- * |  e         (cTotal0 + ------------------- (h - qTotal0)) dh&#39;.</span>
 1224 |     | <span class='neutral'>///      2      |                        qTotal1 - qTotal0</span>
 1225 |     | <span class='neutral'>///            / qBegin</span>
 1226 |     | <span class='neutral'>///</span>
 1227 |     | <span class='neutral'>/// Hence, we define</span>
 1228 |     | <span class='neutral'>///</span>
 1229 |     | <span class='neutral'>///  &#39;outgoingLimit := getIntegralLimit() - currentToTarget&#39;.</span>
 1230 |     | <span class='neutral'>///</span>
 1231 |     | <span class='neutral'>/// and solve</span>
 1232 |     | <span class='neutral'>///</span>
 1233 |     | <span class='neutral'>///      - 8     / qBegin + x</span>
 1234 |     | <span class='neutral'>///    e        |   - h / 2             cTotal1 - cTotal0</span>
 1235 |     | <span class='neutral'>///  &#39;------- * |  e        (cTotal0 + ------------------- (h - qTotal0)) dh</span>
 1236 |     | <span class='neutral'>///      2      |                       qTotal1 - qTotal0</span>
 1237 |     | <span class='neutral'>///            / qBegin</span>
 1238 |     | <span class='neutral'>///</span>
 1239 |     | <span class='neutral'>///       outgoingLimit</span>
 1240 |     | <span class='neutral'>///   == ---------------&#39;</span>
 1241 |     | <span class='neutral'>///         2 ** 216</span>
 1242 |     | <span class='neutral'>///</span>
 1243 |     | <span class='neutral'>/// with respect to &#39;x&#39; and then we store</span>
 1244 |     | <span class='neutral'>///</span>
 1245 |     | <span class='neutral'>///  &#39;qTarget := qBegin + x&#39;.</span>
 1246 |     | <span class='neutral'>///</span>
 1247 |     | <span class='neutral'>/// in the memory spaces that are pointed to by &#39;_target_&#39; and &#39;_overshoot_&#39;.</span>
 1248 |     | <span class='neutral'>///</span>
 1249 |     | <span class='neutral'>/// Similarly, if &#39;getZeroForOne() == true&#39;, we solve the equation:</span>
 1250 |     | <span class='neutral'>///</span>
 1251 |     | <span class='neutral'>///      - 8     / qBegin</span>
 1252 |     | <span class='neutral'>///    e        |   + h / 2             cTotal1 - cTotal0</span>
 1253 |     | <span class='neutral'>///  &#39;------- * |  e        (cTotal0 + ------------------- (qTotal0 - h)) dh</span>
 1254 |     | <span class='neutral'>///      2      |                       qTotal0 - qTotal1</span>
 1255 |     | <span class='neutral'>///            / qBegin - x</span>
 1256 |     | <span class='neutral'>///</span>
 1257 |     | <span class='neutral'>///       outgoingLimit</span>
 1258 |     | <span class='neutral'>///   == ---------------&#39;</span>
 1259 |     | <span class='neutral'>///         2 ** 216</span>
 1260 |     | <span class='neutral'>///</span>
 1261 |     | <span class='neutral'>/// with respect to &#39;x&#39; and then we store:</span>
 1262 |     | <span class='neutral'>///</span>
 1263 |     | <span class='neutral'>///  &#39;qTarget := qBegin - x&#39;.</span>
 1264 |     | <span class='neutral'>///</span>
 1265 |     | <span class='neutral'>/// in the memory spaces that are pointed to by &#39;_target_&#39; and &#39;_overshoot_&#39;.</span>
 1266 |     | <span class='neutral'>///</span>
 1267 |     | <span class='neutral'>/// For simplicity, consider the first case of &#39;getZeroForOne() == false&#39;,</span>
 1268 |     | <span class='neutral'>/// since the second case &#39;getZeroForOne() == true&#39; can be argued similarly.</span>
 1269 |     | <span class='neutral'>/// Define:</span>
 1270 |     | <span class='neutral'>///</span>
 1271 |     | <span class='neutral'>///  &#39;q2 := 2 * (cTotal1 - cTotal0)&#39;</span>
 1272 |     | <span class='neutral'>///</span>
 1273 |     | <span class='neutral'>///  &#39;q1 := cTotal1 * (2 - qTotal0 + qBegin) - </span>
 1274 |     | <span class='neutral'>///         cTotal0 * (2 - qTotal1 + qBegin)&#39;</span>
 1275 |     | <span class='neutral'>///</span>
 1276 |     | <span class='neutral'>///  &#39;q0 := 2 * </span>
 1277 |     | <span class='neutral'>///</span>
 1278 |     | <span class='neutral'>///                                      outgoingLimit</span>
 1279 |     | <span class='neutral'>///         (q1 - (qTotal1 - qTotal0) * --------------- * exp(+ qBegin / 2))&#39;</span>
 1280 |     | <span class='neutral'>///                                         2 ** 216</span>
 1281 |     | <span class='neutral'>///</span>
 1282 |     | <span class='neutral'>/// Then the equation can be cast as &#39;f(x) == 0&#39; where</span>
 1283 |     | <span class='neutral'>///</span>
 1284 |     | <span class='neutral'>///  &#39;      f(x) == + ((cTotal1 - cTotal0) * x + q1) * exp(- x / 2) - q0 / 2&#39;</span>
 1285 |     | <span class='neutral'>///</span>
 1286 |     | <span class='neutral'>///      d f(x)</span>
 1287 |     | <span class='neutral'>///  &#39;  -------- == - ((cTotal1 - cTotal0) * x + q1 - q2) * exp(- x / 2) / 2&#39;</span>
 1288 |     | <span class='neutral'>///       d x</span>
 1289 |     | <span class='neutral'>///</span>
 1290 |     | <span class='neutral'>///                                                                 - x / 2</span>
 1291 |     | <span class='neutral'>///    d^2 f(x)                                                   e</span>
 1292 |     | <span class='neutral'>///  &#39;---------- == + ((cTotal1 - cTotal0) * x + q1 - q2 - q2) * -----------&#39;</span>
 1293 |     | <span class='neutral'>///     d x^2                                                         4</span>
 1294 |     | <span class='neutral'>///</span>
 1295 |     | <span class='neutral'>/// Define:</span>
 1296 |     | <span class='neutral'>///</span>
 1297 |     | <span class='neutral'>///  &#39;g(x) == (cTotal1 - cTotal0) * x + q1 - q2&#39;</span>
 1298 |     | <span class='neutral'>///</span>
 1299 |     | <span class='neutral'>///  &#39;h(x) == (cTotal1 - cTotal0) * x + q1 - (q0 / 2) * exp(+ x / 2)&#39;</span>
 1300 |     | <span class='neutral'>///</span>
 1301 |     | <span class='neutral'>/// To solve our equation, we perform the following Halley&#39;s search:</span>
 1302 |     | <span class='neutral'>///</span>
 1303 |     | <span class='neutral'>///  &#39;x = x + </span>
 1304 |     | <span class='neutral'>///                             4 * (h(x) / g(x))</span>
 1305 |     | <span class='neutral'>///   ----------------------------------------------------------------------&#39;</span>
 1306 |     | <span class='neutral'>///    2 - (h(x) / g(x)) + 2 * (h(x) / g(x)) * ((cTotal1 - cTotal0) / g(x))</span>
 1307 |     | <span class='neutral'>///</span>
 1308 |     | <span class='neutral'>/// --------------------------------------------------------------------------- </span>
 1309 |     | <span class='neutral'>///</span>
 1310 |     | <span class='neutral'>/// Underflow of &#39;getIntegralLimit() - _currentToTarget_.integral()&#39; should be</span>
 1311 |     | <span class='neutral'>/// avoided externally.</span>
 1312 |     | <span class='neutral'>///</span>
 1313 |     | <span class='neutral'>/// We should have &#39;getDirection() == getZeroForOne()&#39;.</span>
 1314 |     | <span class='neutral'>///</span>
 1315 |     | <span class='neutral'>/// @return exactAmount Whether the search is performed.</span>
 1316 |     | <span class='neutral'>///</span>
 1317 |     | <span class='neutral'>/// Let &#39;qTarget&#39; represent the existing value stored in the memory space which</span>
 1318 |     | <span class='neutral'>/// is pointed to by &#39;_target_&#39; (prior to calling this function). As explained</span>
 1319 |     | <span class='neutral'>/// in &#39;Memory.sol&#39;, we have:</span>
 1320 |     | <span class='neutral'>///</span>
 1321 |     | <span class='neutral'>///   &#39;qTarget := (</span>
 1322 |     | <span class='neutral'>///                 getDirection() == getZeroForOne()</span>
 1323 |     | <span class='neutral'>///               ) ? (</span>
 1324 |     | <span class='neutral'>///                 getDirection() ? </span>
 1325 |     | <span class='neutral'>///                 max(max(qEnd, qTotal1), qLimitWithinInterval) : </span>
 1326 |     | <span class='neutral'>///                 min(min(qEnd, qTotal1), qLimitWithinInterval)</span>
 1327 |     | <span class='neutral'>///               ) : (</span>
 1328 |     | <span class='neutral'>///                 getDirection() ? </span>
 1329 |     | <span class='neutral'>///                 max(qEnd, qTotal1) : </span>
 1330 |     | <span class='neutral'>///                 min(qEnd, qTotal1)</span>
 1331 |     | <span class='neutral'>///               )&#39;,</span>
 1332 |     | <span class='neutral'>///</span>
 1333 |     | <span class='neutral'>/// Additionally, because of the input requirement</span>
 1334 |     | <span class='neutral'>///</span>
 1335 |     | <span class='neutral'>///   &#39;getDirection() == getZeroForOne()&#39;,</span>
 1336 |     | <span class='neutral'>///</span>
 1337 |     | <span class='neutral'>/// the above equation is equivalent to:</span>
 1338 |     | <span class='neutral'>///</span>
 1339 |     | <span class='neutral'>///   &#39;qTarget := getDirection() ? </span>
 1340 |     | <span class='neutral'>///               max(max(qEnd, qTotal1), qLimitWithinInterval) : </span>
 1341 |     | <span class='neutral'>///               min(min(qEnd, qTotal1), qLimitWithinInterval)&#39;.</span>
 1342 |     | <span class='neutral'>///</span>
 1343 |     | <span class='neutral'>/// If &#39;getZeroForOne() == false&#39;, then the current &#39;qTarget&#39; is an upper bound</span>
 1344 |     | <span class='neutral'>/// for the unknown value &#39;qBegin + x&#39; and the numerical search for &#39;x&#39; is</span>
 1345 |     | <span class='neutral'>/// performed within the range &#39;0&#39; to &#39;qTarget - qBegin&#39;. In this case, we</span>
 1346 |     | <span class='neutral'>/// first need to check the following inequality:</span>
 1347 |     | <span class='neutral'>///</span>
 1348 |     | <span class='neutral'>///      - 8     / qTarget</span>
 1349 |     | <span class='neutral'>///    e        |   - h / 2             cTotal1 - cTotal0</span>
 1350 |     | <span class='neutral'>///  &#39;------- * |  e        (cTotal0 + ------------------- (h - qTotal0)) dh</span>
 1351 |     | <span class='neutral'>///      2      |                       qTotal1 - qTotal0</span>
 1352 |     | <span class='neutral'>///            / qBegin</span>
 1353 |     | <span class='neutral'>///</span>
 1354 |     | <span class='neutral'>///      outgoingLimit</span>
 1355 |     | <span class='neutral'>///   &lt; ---------------&#39;.</span>
 1356 |     | <span class='neutral'>///        2 ** 216</span>
 1357 |     | <span class='neutral'>///</span>
 1358 |     | <span class='neutral'>/// If satisfied, then the outgoing integral across the entire range does not</span>
 1359 |     | <span class='neutral'>/// reach &#39;outgoingLimit / (2 ** 216)&#39;, which means that there is no solution.</span>
 1360 |     | <span class='neutral'>/// In this case, we simply return the value for the above integral in &#39;X216&#39;</span>
 1361 |     | <span class='neutral'>/// representation along with &#39;exactAmount == false&#39;.</span>
 1362 |     | <span class='neutral'>///</span>
 1363 |     | <span class='neutral'>/// Similarly, if &#39;getZeroForOne == true&#39;, then &#39;qTarget&#39; is a lower bound for</span>
 1364 |     | <span class='neutral'>/// the unknown value &#39;qTarget == qBegin - x&#39; and the numerical search for &#39;x&#39;</span>
 1365 |     | <span class='neutral'>/// is performed within the range &#39;0&#39; to &#39;qBegin - qTarget&#39;. In this case,</span>
 1366 |     | <span class='neutral'>/// we first need to check the following inequality:</span>
 1367 |     | <span class='neutral'>///</span>
 1368 |     | <span class='neutral'>///      - 8     / qBegin</span>
 1369 |     | <span class='neutral'>///    e        |   + h / 2             cTotal1 - cTotal0</span>
 1370 |     | <span class='neutral'>///  &#39;------- * |  e        (cTotal0 + ------------------- (qTotal0 - h)) dh</span>
 1371 |     | <span class='neutral'>///      2      |                       qTotal0 - qTotal1</span>
 1372 |     | <span class='neutral'>///            / qTarget</span>
 1373 |     | <span class='neutral'>///</span>
 1374 |     | <span class='neutral'>///      outgoingLimit</span>
 1375 |     | <span class='neutral'>///   &lt; ---------------&#39;.</span>
 1376 |     | <span class='neutral'>///        2 ** 216</span>
 1377 |     | <span class='neutral'>///</span>
 1378 |     | <span class='neutral'>/// If satisfied, then the outgoing integral across the entire range does not</span>
 1379 |     | <span class='neutral'>/// reach &#39;outgoingLimit / (2 ** 216)&#39;, which means that there is no solution.</span>
 1380 |     | <span class='neutral'>/// In this case, we simply return the value for the above integral in &#39;X216&#39;</span>
 1381 |     | <span class='neutral'>/// representation along with &#39;exactAmount == false&#39;.</span>
 1382 |     | <span class='neutral'>///</span>
 1383 |     | <span class='neutral'>/// @return outgoing Integral increment to be added to</span>
 1384 |     | <span class='neutral'>/// &#39;currentToTarget / (2 ** 216)&#39;, i.e.,</span>
 1385 |     | <span class='neutral'>///</span>
 1386 |     | <span class='neutral'>///      - 8     / qTarget</span>
 1387 |     | <span class='neutral'>///    e        |   - h / 2             cTotal1 - cTotal0</span>
 1388 |     | <span class='neutral'>///  &#39;------- * |  e        (cTotal0 + ------------------- (h - qTotal0)) dh&#39;</span>
 1389 |     | <span class='neutral'>///      2      |                       qTotal1 - qTotal0</span>
 1390 |     | <span class='neutral'>///            / qBegin</span>
 1391 |     | <span class='neutral'>///</span>
 1392 |     | <span class='neutral'>/// if &#39;getZeroForOne() == false&#39; and</span>
 1393 |     | <span class='neutral'>///</span>
 1394 |     | <span class='neutral'>///      - 8     / qBegin</span>
 1395 |     | <span class='neutral'>///    e        |   + h / 2             cTotal1 - cTotal0</span>
 1396 |     | <span class='neutral'>///  &#39;------- * |  e        (cTotal0 + ------------------- (qTotal0 - h)) dh&#39;</span>
 1397 |     | <span class='neutral'>///      2      |                       qTotal0 - qTotal1</span>
 1398 |     | <span class='neutral'>///            / qTarget</span>
 1399 |     | <span class='neutral'>///</span>
 1400 |     | <span class='neutral'>/// if &#39;getZeroForOne() == true&#39;.</span>
 1401 |     | <span class='neutral'>///</span>
 1402 |     | <span class='neutral'>/// If &#39;exactAmount == false&#39;, this value is equal to the outgoing integral</span>
 1403 |     | <span class='neutral'>/// across the entire search range and if the search is performed, this value</span>
 1404 |     | <span class='neutral'>/// is equal to the left hand side of the equation that we are solving.</span>
 1405 |     | <span class='neutral'>function searchOutgoingTarget() pure returns (</span>
 1406 |     | <span class='neutral'>  bool exactAmount,</span>
 1407 |     | <span class='neutral'>  X216 outgoing</span>
 1408 |     | <span class='neutral'>) {</span>
 1409 |     | <span class='neutral'>  // First, we subtract &#39;currentToTarget&#39; from &#39;getIntegralLimit()&#39; in order to</span>
 1410 |     | <span class='neutral'>  // get &#39;outgoingLimit&#39;.</span>
 1411 |     | <span class='neutral'>  //</span>
 1412 |     | <span class='neutral'>  // Subtraction is safe because underflow is handled externally.</span>
 1413 |     | <span class='neutral'>  X216 outgoingLimit = getIntegralLimit() - _currentToTarget_.integral();</span>
 1414 |     | <span class='neutral'></span>
 1415 |     | <span class='neutral'>  // The next step is to see if the integral taken across the entire search</span>
 1416 |     | <span class='neutral'>  // range between &#39;qBegin&#39; and &#39;qTarget&#39; exceeds &#39;outgoingLimit&#39; or not. If it</span>
 1417 |     | <span class='neutral'>  // does not, then we simply stop the search and return the resulting integral</span>
 1418 |     | <span class='neutral'>  // along with &#39;exactAmount == false&#39;.</span>
 1419 |     | <span class='neutral'>  //</span>
 1420 |     | <span class='neutral'>  // As defined in &#39;Memory.sol&#39;, we have</span>
 1421 |     | <span class='neutral'>  //</span>
 1422 |     | <span class='neutral'>  //  &#39;qBegin := getDirection() ? </span>
 1423 |     | <span class='neutral'>  //             min(q[indexCurve + 2], qTotal0) : </span>
 1424 |     | <span class='neutral'>  //             max(q[indexCurve + 2], qTotal0)&#39;,</span>
 1425 |     | <span class='neutral'>  //</span>
 1426 |     | <span class='neutral'>  //  &#39;qTarget := (</span>
 1427 |     | <span class='neutral'>  //                getDirection() == getZeroForOne()</span>
 1428 |     | <span class='neutral'>  //              ) ? (</span>
 1429 |     | <span class='neutral'>  //                getDirection() ? </span>
 1430 |     | <span class='neutral'>  //                max(max(qEnd, qTotal1), qLimitWithinInterval) : </span>
 1431 |     | <span class='neutral'>  //                min(min(qEnd, qTotal1), qLimitWithinInterval)</span>
 1432 |     | <span class='neutral'>  //              ) : (</span>
 1433 |     | <span class='neutral'>  //                getDirection() ? </span>
 1434 |     | <span class='neutral'>  //                max(qEnd, qTotal1) : </span>
 1435 |     | <span class='neutral'>  //                min(qEnd, qTotal1)</span>
 1436 |     | <span class='neutral'>  //              )</span>
 1437 |     | <span class='neutral'>  //           == getDirection() ? </span>
 1438 |     | <span class='neutral'>  //              max(max(qEnd, qTotal1), qLimitWithinInterval) : </span>
 1439 |     | <span class='neutral'>  //              min(min(qEnd, qTotal1), qLimitWithinInterval)</span>
 1440 |     | <span class='neutral'>  //</span>
 1441 |     | <span class='neutral'>  // which implies that if &#39;getDirection() == false&#39;, then</span>
 1442 |     | <span class='neutral'>  //</span>
 1443 |     | <span class='neutral'>  //  &#39;qTotal0 &lt;= qBegin &lt;= qTarget &lt;= qTotal1&#39;.</span>
 1444 |     | <span class='neutral'>  //</span>
 1445 |     | <span class='neutral'>  // and if &#39;getDirection() == true&#39;, then</span>
 1446 |     | <span class='neutral'>  //</span>
 1447 |     | <span class='neutral'>  //  &#39;qTotal1 &lt;= qTarget &lt;= qBegin &lt;= qTotal0&#39;.</span>
 1448 |     | <span class='neutral'>  //</span>
 1449 |     | <span class='neutral'>  // Additionally, since the vertical coordinates of kernel are monotonic, we</span>
 1450 |     | <span class='neutral'>  // have &#39;cTotal0 &lt;= cTotal1&#39; and the input requirements of &#39;outgoing&#39; are</span>
 1451 |     | <span class='neutral'>  // satisfied.</span>
 1452 |     | <span class='neutral'>  outgoing = _total0_.outgoing(_begin_, _target_);</span>
 1453 |     | <span class='neutral'>  // Signed comparison is valid because:</span>
 1454 |     | <span class='neutral'>  //</span>
 1455 |     | <span class='neutral'>  //  - the output of &#39;outgoing&#39; is always a nonnegative value which is less</span>
 1456 |     | <span class='neutral'>  //    than &#39;oneX216&#39;.</span>
 1457 |     | <span class='neutral'>  //</span>
 1458 |     | <span class='neutral'>  //  - &#39;outgoingLimit &lt;= getIntegralLimit() &lt; one216&#39;, and</span>
 1459 |     | <span class='neutral'>  //</span>
 1460 |     | <span class='neutral'>  //  - &#39;getIntegralLimit() &gt;= zeroX216&#39; because of the first input</span>
 1461 |     | <span class='neutral'>  //    requirement.</span>
 1462 |     | <span class='neutral'>  if (outgoing &lt;= outgoingLimit) return (false, outgoing);</span>
 1463 |     | <span class='neutral'></span>
 1464 |     | <span class='neutral'>  // &#39;zeroForOne&#39; is loaded from the memory.</span>
 1465 |     | <span class='neutral'>  bool left = getZeroForOne();</span>
 1466 |     | <span class='neutral'></span>
 1467 |     | <span class='neutral'>  // &#39;|qTotal1 - qTotal0|&#39; is calculated once and used throughout the search.</span>
 1468 |     | <span class='neutral'>  //</span>
 1469 |     | <span class='neutral'>  // As we argued before, if &#39;left == false&#39;, then</span>
 1470 |     | <span class='neutral'>  //</span>
 1471 |     | <span class='neutral'>  //  &#39;qTotal0 &lt;= qBegin &lt;= qTarget &lt;= qTotal1&#39;.</span>
 1472 |     | <span class='neutral'>  //</span>
 1473 |     | <span class='neutral'>  // and if &#39;left == true&#39;, then</span>
 1474 |     | <span class='neutral'>  //</span>
 1475 |     | <span class='neutral'>  //  &#39;qTotal1 &lt;= qTarget &lt;= qBegin &lt;= qTotal0&#39;.</span>
 1476 |     | <span class='neutral'>  X59 db = left ? </span>
 1477 |     | <span class='neutral'>    _total0_.log() - _total1_.log() : </span>
 1478 |     | <span class='neutral'>    _total1_.log() - _total0_.log();</span>
 1479 |     | <span class='neutral'></span>
 1480 |     | <span class='neutral'>  // &#39;cTotal1 - cTotal0&#39; is calculated once and used throughout the search.</span>
 1481 |     | <span class='neutral'>  //</span>
 1482 |     | <span class='neutral'>  // The subtraction is safe because &#39;total0&#39; and &#39;total1&#39; correspond to the</span>
 1483 |     | <span class='neutral'>  // kernel breakpoints &#39;indexKernelTotal - oneIndex&#39; and &#39;indexKernelTotal&#39;,</span>
 1484 |     | <span class='neutral'>  // respectively, and the vertical coordinates of kernel breakpoints are</span>
 1485 |     | <span class='neutral'>  // monotonically non-decreasing due to the custom error</span>
 1486 |     | <span class='neutral'>  // &#39;NonMonotonicVerticalCoordinates&#39; in &#39;KernelCompact.sol&#39;.</span>
 1487 |     | <span class='neutral'>  X15 dc = _total1_.height() - _total0_.height();</span>
 1488 |     | <span class='neutral'></span>
 1489 |     | <span class='neutral'>  // Next we calculate</span>
 1490 |     | <span class='neutral'>  //</span>
 1491 |     | <span class='neutral'>  //  &#39;q2 := 2 * (cTotal1 - cTotal0)&#39;</span>
 1492 |     | <span class='neutral'>  //</span>
 1493 |     | <span class='neutral'>  // The multiplication is safe because &#39;twoX59&#39; is positive and the output</span>
 1494 |     | <span class='neutral'>  // does not exceed &#39;64 + 16 == 80&#39; bits.</span>
 1495 |     | <span class='neutral'>  X74 q2 = twoX59.times(dc);</span>
 1496 |     | <span class='neutral'></span>
 1497 |     | <span class='neutral'>  // The second coefficient is calculated as</span>
 1498 |     | <span class='neutral'>  //</span>
 1499 |     | <span class='neutral'>  // &#39;q1 := (cTotal1 - cTotal0) * (2 + |qBegin - qTotal0|)</span>
 1500 |     | <span class='neutral'>  //      + cTotal0 * |qTotal1 - qTotal0|&#39;</span>
 1501 |     | <span class='neutral'></span>
 1502 |     | <span class='neutral'>  // The multiplication &#39;db.times(_total0_.height())&#39; is safe because the</span>
 1503 |     | <span class='neutral'>  // output does not exceed 80 bits.</span>
 1504 |     | <span class='neutral'>  //</span>
 1505 |     | <span class='neutral'>  // The addition is safe because neither &#39;q2&#39; nor</span>
 1506 |     | <span class='neutral'>  // &#39;db.times(_total0_.height())&#39; do not exceed 80 bits.</span>
 1507 |     | <span class='neutral'>  X74 q1 = q2 + db.times(_total0_.height());</span>
 1508 |     | <span class='neutral'></span>
 1509 |     | <span class='neutral'>  // The subtractions are safe because of the last input requirement and the</span>
 1510 |     | <span class='neutral'>  // fact that</span>
 1511 |     | <span class='neutral'>  //</span>
 1512 |     | <span class='neutral'>  //  &#39;getDirection() == getZeroForOne() == left&#39;.</span>
 1513 |     | <span class='neutral'>  //</span>
 1514 |     | <span class='neutral'>  // Lastly, the additions are safe because neither values exceed 81 bits.</span>
 1515 |     | <span class='neutral'>  q1 = left ? </span>
 1516 |     | <span class='neutral'>    q1 + (_total0_.log() - _begin_.log()).times(dc) : </span>
 1517 |     | <span class='neutral'>    q1 + (_begin_.log() - _total0_.log()).times(dc);</span>
 1518 |     | <span class='neutral'></span>
 1519 |     | <span class='neutral'>  // Next, in order to compute &#39;q0&#39;, if &#39;left == false&#39;, we calculate:</span>
 1520 |     | <span class='neutral'>  //</span>
 1521 |     | <span class='neutral'>  //        outgoingLimit          db</span>
 1522 |     | <span class='neutral'>  //  &#39;---------------------- * --------- * exp(+ qBegin / 2) ==</span>
 1523 |     | <span class='neutral'>  //    (2 ** 216) * exp(-8)     2 ** 59</span>
 1524 |     | <span class='neutral'>  //</span>
 1525 |     | <span class='neutral'>  //    outgoingLimit * db * ((2 ** 216) * exp(- 8 + qBegin / 2))</span>
 1526 |     | <span class='neutral'>  //   ----------------------------------------------------------- ==</span>
 1527 |     | <span class='neutral'>  //                  (2 ** (216 + 59)) * exp(-16)</span>
 1528 |     | <span class='neutral'>  //</span>
 1529 |     | <span class='neutral'>  //    outgoingLimit * db * _begin_.sqrt(true)</span>
 1530 |     | <span class='neutral'>  //   -----------------------------------------&#39;</span>
 1531 |     | <span class='neutral'>  //         (2 ** (216 + 59)) * exp(-16)</span>
 1532 |     | <span class='neutral'>  //</span>
 1533 |     | <span class='neutral'>  // and if &#39;left == true&#39;, we calculate:</span>
 1534 |     | <span class='neutral'>  //</span>
 1535 |     | <span class='neutral'>  //        outgoingLimit          db</span>
 1536 |     | <span class='neutral'>  //  &#39;---------------------- * --------- * exp(- qBegin / 2) ==</span>
 1537 |     | <span class='neutral'>  //    (2 ** 216) * exp(-8)     2 ** 59</span>
 1538 |     | <span class='neutral'>  //</span>
 1539 |     | <span class='neutral'>  //    outgoingLimit * db * ((2 ** 216) * exp(- 8 - qBegin / 2))</span>
 1540 |     | <span class='neutral'>  //   ----------------------------------------------------------- ==</span>
 1541 |     | <span class='neutral'>  //                  (2 ** (216 + 59)) * exp(-16)</span>
 1542 |     | <span class='neutral'>  //</span>
 1543 |     | <span class='neutral'>  //    outgoingLimit * db * _begin_.sqrt(false)</span>
 1544 |     | <span class='neutral'>  //   ------------------------------------------&#39;.</span>
 1545 |     | <span class='neutral'>  //          (2 ** (216 + 59)) * exp(-16)</span>
 1546 |     | <span class='neutral'>  //</span>
 1547 |     | <span class='neutral'>  // The three inputs of &#39;mulDivByExpInv16&#39; are non-negative and overflow is</span>
 1548 |     | <span class='neutral'>  // not possible because</span>
 1549 |     | <span class='neutral'>  //</span>
 1550 |     | <span class='neutral'>  //    outgoingLimit * db * _begin_.sqrt(!left)</span>
 1551 |     | <span class='neutral'>  //  &#39;------------------------------------------ &lt; </span>
 1552 |     | <span class='neutral'>  //          (2 ** (216 + 59)) * exp(-16)</span>
 1553 |     | <span class='neutral'>  //</span>
 1554 |     | <span class='neutral'>  //    (2 ** 216) * (2 ** 64) * (2 ** 216)</span>
 1555 |     | <span class='neutral'>  //   ------------------------------------- == </span>
 1556 |     | <span class='neutral'>  //       (2 ** (216 + 59)) * exp(-16)</span>
 1557 |     | <span class='neutral'>  //</span>
 1558 |     | <span class='neutral'>  //   32 * exp(16) * oneX216 &lt; 2 ** 256 - 1&#39;.</span>
 1559 |     | <span class='neutral'>  //</span>
 1560 |     | <span class='neutral'>  // Hence, the requirements of &#39;mulDivByExpInv16&#39; are satisfied.</span>
 1561 |     | <span class='neutral'>  //</span>
 1562 |     | <span class='neutral'>  // Additionally, &#39;toX216&#39; does not overflow because &#39;q1&#39; does not exceed</span>
 1563 |     | <span class='neutral'>  // &#39;81&#39; bits.</span>
 1564 |     | <span class='neutral'>  //</span>
 1565 |     | <span class='neutral'>  // Next, we need to prove that the subtraction is safe. Consider the case of</span>
 1566 |     | <span class='neutral'>  // &#39;getDirection() == false&#39; as the other case can be argued similarly. To</span>
 1567 |     | <span class='neutral'>  // that end, we need to show that</span>
 1568 |     | <span class='neutral'>  //</span>
 1569 |     | <span class='neutral'>  //      q1             outgoingLimit          db</span>
 1570 |     | <span class='neutral'>  //  &#39;--------- &gt;= ---------------------- * --------- * exp(+ qBegin / 2)&#39;.</span>
 1571 |     | <span class='neutral'>  //    2 ** 74      (2 ** 216) * exp(-8)     2 ** 59</span>
 1572 |     | <span class='neutral'>  //</span>
 1573 |     | <span class='neutral'>  // Or equivalently:</span>
 1574 |     | <span class='neutral'>  //</span>
 1575 |     | <span class='neutral'>  //  &#39;cTotal1 * (2 - qTotal0 + qBegin) - cTotal0 * (2 - qTotal1 + qBegin) &gt;=</span>
 1576 |     | <span class='neutral'>  //</span>
 1577 |     | <span class='neutral'>  //        outgoingLimit          db</span>
 1578 |     | <span class='neutral'>  //   ---------------------- * --------- * exp(+ qBegin / 2)&#39;.</span>
 1579 |     | <span class='neutral'>  //    (2 ** 216) * exp(-8)     2 ** 59</span>
 1580 |     | <span class='neutral'>  //</span>
 1581 |     | <span class='neutral'>  // Notice that due to our prior check,</span>
 1582 |     | <span class='neutral'>  //</span>
 1583 |     | <span class='neutral'>  //       outgoingLimit</span>
 1584 |     | <span class='neutral'>  //  &#39;----------------------&#39;</span>
 1585 |     | <span class='neutral'>  //    exp(-8) * (2 ** 216)</span>
 1586 |     | <span class='neutral'>  //</span>
 1587 |     | <span class='neutral'>  // does not exceed</span>
 1588 |     | <span class='neutral'>  //</span>
 1589 |     | <span class='neutral'>  //         / qTarget</span>
 1590 |     | <span class='neutral'>  //    1   |   - h / 2             cTotal1 - cTotal0</span>
 1591 |     | <span class='neutral'>  //  &#39;---  |  e        (cTotal0 + ------------------- (h - qTotal0)) dh&#39;</span>
 1592 |     | <span class='neutral'>  //    2   |                       qTotal1 - qTotal0</span>
 1593 |     | <span class='neutral'>  //       / qBegin</span>
 1594 |     | <span class='neutral'>  //</span>
 1595 |     | <span class='neutral'>  // which is equal to:</span>
 1596 |     | <span class='neutral'>  //</span>
 1597 |     | <span class='neutral'>  //  &#39;cTotal0 * (exp(- qBegin / 2) - exp(- qTarget / 2)) +</span>
 1598 |     | <span class='neutral'>  //</span>
 1599 |     | <span class='neutral'>  //    cTotal1 - cTotal0</span>
 1600 |     | <span class='neutral'>  //   ------------------- * (</span>
 1601 |     | <span class='neutral'>  //    qTotal1 - qTotal0</span>
 1602 |     | <span class='neutral'>  //</span>
 1603 |     | <span class='neutral'>  //     (qBegin - qTotal0 + 2) * exp(- qBegin / 2) - </span>
 1604 |     | <span class='neutral'>  //     (qTarget - qTotal0 + 2) * exp(- qTarget / 2)</span>
 1605 |     | <span class='neutral'>  //   )&#39;</span>
 1606 |     | <span class='neutral'>  //</span>
 1607 |     | <span class='neutral'>  // Hence, we need to prove that</span>
 1608 |     | <span class='neutral'>  //</span>
 1609 |     | <span class='neutral'>  //  &#39;cTotal1 * (2 - qTotal0 + qBegin) - cTotal0 * (2 - qTotal1 + qBegin) &gt;=</span>
 1610 |     | <span class='neutral'>  //</span>
 1611 |     | <span class='neutral'>  //   (qTotal1 - qTotal0) * exp(+ qBegin / 2) * (</span>
 1612 |     | <span class='neutral'>  //</span>
 1613 |     | <span class='neutral'>  //     cTotal0 * (exp(- qBegin / 2) - exp(- qTarget / 2)) + </span>
 1614 |     | <span class='neutral'>  //</span>
 1615 |     | <span class='neutral'>  //      cTotal1 - cTotal0</span>
 1616 |     | <span class='neutral'>  //     ------------------- * (</span>
 1617 |     | <span class='neutral'>  //      qTotal1 - qTotal0</span>
 1618 |     | <span class='neutral'>  //</span>
 1619 |     | <span class='neutral'>  //       (qBegin - qTotal0 + 2) * exp(- qBegin/2) - </span>
 1620 |     | <span class='neutral'>  //       (qTarget - qTotal0 + 2) * exp(- qTarget/2)</span>
 1621 |     | <span class='neutral'>  //     )</span>
 1622 |     | <span class='neutral'>  //   )&#39;</span>
 1623 |     | <span class='neutral'>  //</span>
 1624 |     | <span class='neutral'>  // which is equivalent to:</span>
 1625 |     | <span class='neutral'>  //</span>
 1626 |     | <span class='neutral'>  //  &#39;(2 + qTarget - qTotal0) * (cTotal1 - cTotal0) + </span>
 1627 |     | <span class='neutral'>  //   cTotal0 * (qTotal1 - qTotal0) &gt;= 0&#39;.</span>
 1628 |     | <span class='neutral'>  //</span>
 1629 |     | <span class='neutral'>  // As we have already proven, if &#39;getDirection() == false&#39;, then</span>
 1630 |     | <span class='neutral'>  //</span>
 1631 |     | <span class='neutral'>  //  &#39;qTotal0 &lt;= qBegin &lt;= qTarget &lt;= qTotal1&#39;.</span>
 1632 |     | <span class='neutral'>  //</span>
 1633 |     | <span class='neutral'>  // which means that the subtraction is safe.</span>
 1634 |     | <span class='neutral'>  X216 q0 = </span>
 1635 |     | <span class='neutral'>    q1.toX216() - db.mulDivByExpInv16(_begin_.sqrt(!left), outgoingLimit);</span>
 1636 |     | <span class='neutral'>  // The following addition is also safe, because</span>
 1637 |     | <span class='neutral'>  // </span>
 1638 |     | <span class='neutral'>  //       q0           q1</span>
 1639 |     | <span class='neutral'>  //  &#39;---------- &lt;= --------- == </span>
 1640 |     | <span class='neutral'>  //    2 ** 216      2 ** 74</span>
 1641 |     | <span class='neutral'>  //</span>
 1642 |     | <span class='neutral'>  //   cTotal1 * (2 - qTotal0 + qBegin) - cTotal0 * (2 - qTotal1 + qBegin) &lt;= </span>
 1643 |     | <span class='neutral'>  //</span>
 1644 |     | <span class='neutral'>  //   (cTotal1 - cTotal0) * (2 + qBegin) + </span>
 1645 |     | <span class='neutral'>  //</span>
 1646 |     | <span class='neutral'>  //   cTotal0 * qTotal1 - cTotal1 * qTotal0 &lt;= </span>
 1647 |     | <span class='neutral'>  //</span>
 1648 |     | <span class='neutral'>  //   1 * (2 + 16) + 1 * 16 + 1 * 16 &lt;= 50</span>
 1649 |     | <span class='neutral'>  //</span>
 1650 |     | <span class='neutral'>  // which concludes that &#39;q0&#39; does not take more than 222-bits in &#39;X216&#39;</span>
 1651 |     | <span class='neutral'>  // representation.</span>
 1652 |     | <span class='neutral'>  q0 = q0 + q0;</span>
 1653 |     | <span class='neutral'></span>
 1654 |     | <span class='neutral'>  // The initial value for &#39;x&#39; is calculated here. The subtractions are safe</span>
 1655 |     | <span class='neutral'>  // because as we argued before, if &#39;left == false&#39;, then</span>
 1656 |     | <span class='neutral'>  //</span>
 1657 |     | <span class='neutral'>  //  &#39;qTotal0 &lt;= qBegin &lt;= qTarget &lt;= qTotal1&#39;</span>
 1658 |     | <span class='neutral'>  //</span>
 1659 |     | <span class='neutral'>  // and if &#39;left == true&#39;, then</span>
 1660 |     | <span class='neutral'>  //</span>
 1661 |     | <span class='neutral'>  //  &#39;qTotal1 &lt;= qTarget &lt;= qBegin &lt;= qTotal0&#39;.</span>
 1662 |     | <span class='neutral'>  X59 xLimit = </span>
 1663 |     | <span class='neutral'>    left ? _begin_.log() - _target_.log() : _target_.log() - _begin_.log();</span>
 1664 |     | <span class='neutral'></span>
 1665 |     | <span class='neutral'>  // All three inputs of &#39;cheapMulDiv&#39; are non-negative.</span>
 1666 |     | <span class='neutral'>  //</span>
 1667 |     | <span class='neutral'>  // Due to the prior check, &#39;outgoingLimit &lt; outgoing&#39;. Additionally, we have</span>
 1668 |     | <span class='neutral'>  //</span>
 1669 |     | <span class='neutral'>  //  &#39;|_begin_.log() - _target_.log()| &lt;= 2 ** 64 - 1 &lt; </span>
 1670 |     | <span class='neutral'>  //</span>
 1671 |     | <span class='neutral'>  //   75557863725914323375445 &lt;= (2 ** 216) * </span>
 1672 |     | <span class='neutral'>  //</span>
 1673 |     | <span class='neutral'>  //                                      1</span>
 1674 |     | <span class='neutral'>  //      - 8     / 16                --------- - 0</span>
 1675 |     | <span class='neutral'>  //    e        |   - h / 2           2 ** 15</span>
 1676 |     | <span class='neutral'>  //   ------- * |  e           (0 + ---------------  * (h + 16)) dh &lt;</span>
 1677 |     | <span class='neutral'>  //      2      |                     16 - (- 16)</span>
 1678 |     | <span class='neutral'>  //            / 16 - 1 / (2 ** 59)</span>
 1679 |     | <span class='neutral'>  //</span>
 1680 |     | <span class='neutral'>  //   outgoing&#39;.</span>
 1681 |     | <span class='neutral'>  //</span>
 1682 |     | <span class='neutral'>  // Here, &#39;75557863725914323375445&#39; is the minimum value for an outgoing</span>
 1683 |     | <span class='neutral'>  // integral. Hence, we have:</span>
 1684 |     | <span class='neutral'>  //</span>
 1685 |     | <span class='neutral'>  //  &#39;xLimit * outgoingLimit &lt; outgoing * (outgoing - 1)&#39;</span>
 1686 |     | <span class='neutral'>  //</span>
 1687 |     | <span class='neutral'>  // and the requirement of &#39;cheapMulDiv&#39; is met.</span>
 1688 |     | <span class='neutral'>  //</span>
 1689 |     | <span class='neutral'>  // Signed comparison is valid because the first term is a positive constant</span>
 1690 |     | <span class='neutral'>  // and the second term is non-negative.</span>
 1691 |     | <span class='neutral'>  X59 x = max(epsilonX59, xLimit.cheapMulDiv(outgoingLimit, outgoing));</span>
 1692 |     | <span class='neutral'></span>
 1693 |     | <span class='neutral'>  while (true) {</span>
 1694 |     | <span class='neutral'>    // For each iteration, we evaluate &#39;g(x)&#39; and &#39;h(x)&#39; in &#39;X74&#39; and &#39;X216&#39;</span>
 1695 |     | <span class='neutral'>    // representations, respectively.</span>
 1696 |     | <span class='neutral'>    //</span>
 1697 |     | <span class='neutral'>    // &#39;x.times(dc)&#39; is safe because &#39;x&#39; is not less than &#39;epsilonX59&#39; due to</span>
 1698 |     | <span class='neutral'>    // the above check and we have already checked that &#39;dc&#39; is nonnegative.</span>
 1699 |     | <span class='neutral'>    //</span>
 1700 |     | <span class='neutral'>    // The addition &#39;x.times(dc) + q1&#39; is safe because both values do not</span>
 1701 |     | <span class='neutral'>    // exceed 81-bits.</span>
 1702 |     | <span class='neutral'>    //</span>
 1703 |     | <span class='neutral'>    // Next, we prove the requirements of &#39;cheapMulDiv&#39;.</span>
 1704 |     | <span class='neutral'>    //</span>
 1705 |     | <span class='neutral'>    // Upon initializing a pool, the given curve sequence is validated by the</span>
 1706 |     | <span class='neutral'>    // method &#39;validate&#39; in &#39;Curve.sol&#39;. When validating the curve sequence,</span>
 1707 |     | <span class='neutral'>    // the custom error &#39;BlankIntervalsShouldBeAvoided&#39; ensures that:</span>
 1708 |     | <span class='neutral'>    // </span>
 1709 |     | <span class='neutral'>    //  &#39;qSpacing &lt; 16 + qLower &lt; 16 + qUpper &lt; 32 - qSpacing&#39;</span>
 1710 |     | <span class='neutral'>    //</span>
 1711 |     | <span class='neutral'>    // Hence,</span>
 1712 |     | <span class='neutral'>    //</span>
 1713 |     | <span class='neutral'>    //  &#39;32 - qSpacing &gt; 16 + qUpper == 16 + qLower + qSpacing &gt; 2 * qSpacing&#39;</span>
 1714 |     | <span class='neutral'>    //</span>
 1715 |     | <span class='neutral'>    // which concludes:</span>
 1716 |     | <span class='neutral'>    //</span>
 1717 |     | <span class='neutral'>    //  &#39;|_target_.log() - _begin_.log()| / (2 ** 59) &lt;= qSpacing &lt; 32 / 3&#39;.</span>
 1718 |     | <span class='neutral'>    //</span>
 1719 |     | <span class='neutral'>    // Due to the above arguments, the input requirements of &#39;expInverse&#39; are</span>
 1720 |     | <span class='neutral'>    // satisfied because &#39;x&#39; is not less than &#39;epsilonX59&#39; and</span>
 1721 |     | <span class='neutral'>    //</span>
 1722 |     | <span class='neutral'>    //  &#39;x &lt;= |_target_.log() - _begin_.log()| &lt; (2 ** 64) / 3&#39;.</span>
 1723 |     | <span class='neutral'>    //</span>
 1724 |     | <span class='neutral'>    // Hence,</span>
 1725 |     | <span class='neutral'>    //</span>
 1726 |     | <span class='neutral'>    //  &#39;x.expInverse() == (2 ** 256) * exp(- x / (2 ** 60))</span>
 1727 |     | <span class='neutral'>    //                  &gt;= (2 ** 256) * exp(- qSpacing / 2)</span>
 1728 |     | <span class='neutral'>    //                  &gt;= (2 ** 256) * exp(- 16 / 3) &gt; 2 ** 248.</span>
 1729 |     | <span class='neutral'>    //</span>
 1730 |     | <span class='neutral'>    // On the other hand, &#39;q0&#39; is non-negative and may not be more than</span>
 1731 |     | <span class='neutral'>    // 223-bits as we argued before.</span>
 1732 |     | <span class='neutral'>    //</span>
 1733 |     | <span class='neutral'>    // Hence, the input requirement of &#39;cheapMulDiv&#39; is satisfied because</span>
 1734 |     | <span class='neutral'>    // the number of bits for &#39;q0 * (1 &lt;&lt; 255)&#39; does not exceed the number of</span>
 1735 |     | <span class='neutral'>    // bits for &#39;x.expInverse()&#39;, i.e.,</span>
 1736 |     | <span class='neutral'>    //</span>
 1737 |     | <span class='neutral'>    //  &#39;223 bits + 255 bits &lt; 248 bits + 248 bits&#39;.</span>
 1738 |     | <span class='neutral'>    //</span>
 1739 |     | <span class='neutral'>    // The subtraction &#39;g - q2&#39; is safe because:</span>
 1740 |     | <span class='neutral'>    //</span>
 1741 |     | <span class='neutral'>    //  &#39;g(x) := (cTotal1 - cTotal0) * x + q1 - q2</span>
 1742 |     | <span class='neutral'>    //</span>
 1743 |     | <span class='neutral'>    //        == (cTotal1 - cTotal0) * x + </span>
 1744 |     | <span class='neutral'>    //           cTotal1 * (2 - qTotal0 + qBegin) - </span>
 1745 |     | <span class='neutral'>    //           cTotal0 * (2 - qTotal1 + qBegin) - </span>
 1746 |     | <span class='neutral'>    //           2 * (cTotal1 - cTotal0)</span>
 1747 |     | <span class='neutral'>    //</span>
 1748 |     | <span class='neutral'>    //        == (cTotal1 - cTotal0) * (x + qBegin) + </span>
 1749 |     | <span class='neutral'>    //           cTotal0 * qTotal1 - cTotal1 * qTotal0</span>
 1750 |     | <span class='neutral'>    //</span>
 1751 |     | <span class='neutral'>    //        == (cTotal1 - cTotal0) * (x + qBegin - qTotal0) + </span>
 1752 |     | <span class='neutral'>    //           cTotal0 * (qTotal1 - qTotal0)</span>
 1753 |     | <span class='neutral'>    //</span>
 1754 |     | <span class='neutral'>    //        &gt;= (cTotal1 - cTotal0) * x &gt;= 1 / ((2 ** 15) * (2 ** 59)) &gt; 0&#39;</span>
 1755 |     | <span class='neutral'>    //</span>
 1756 |     | <span class='neutral'>    // where &#39;qBegin &gt;= qTotal0&#39; is concluded from the last input requirement.</span>
 1757 |     | <span class='neutral'>    // Also, &#39;cTotal1 - cTotal0 &gt;= 1 / (2 ** 15)&#39; is concluded from the initial</span>
 1758 |     | <span class='neutral'>    // check for the determination of &#39;exactAmount&#39;, because if</span>
 1759 |     | <span class='neutral'>    // &#39;cTotal1 == cTotal0 == 0&#39;, then we have &#39;exactAmount == false&#39; and this</span>
 1760 |     | <span class='neutral'>    // part of the code would not be reached. Hence, &#39;g&#39; is positive which will</span>
 1761 |     | <span class='neutral'>    // be used later.</span>
 1762 |     | <span class='neutral'>    //</span>
 1763 |     | <span class='neutral'>    // The subtraction &#39;g.toX216() - q0.cheapMulDiv(1 &lt;&lt; 255, x.expInverse())&#39;</span>
 1764 |     | <span class='neutral'>    // is unsafe and may be negative.</span>
 1765 |     | <span class='neutral'>    X74 g = x.times(dc) + q1;</span>
 1766 |     | <span class='neutral'>    X216 h = g.toX216() - q0.cheapMulDiv(1 &lt;&lt; 255, x.expInverse());</span>
 1767 |     | <span class='neutral'>    g = g - q2;</span>
 1768 |     | <span class='neutral'></span>
 1769 |     | <span class='neutral'>    // Next, we calculate the following Halley step:</span>
 1770 |     | <span class='neutral'>    //</span>
 1771 |     | <span class='neutral'>    //                            2 * (h(x) / g(x))</span>
 1772 |     | <span class='neutral'>    //  &#39;step = -----------------------------------------------------&#39;</span>
 1773 |     | <span class='neutral'>    //           1 - (h(x) / g(x)) / 2 + (h(x) / g(x)) * (dc / g(x))</span>
 1774 |     | <span class='neutral'>    //</span>
 1775 |     | <span class='neutral'>    // in &#39;X59&#39; representation.</span>
 1776 |     | <span class='neutral'>    //</span>
 1777 |     | <span class='neutral'>    // The numerator is in &#39;X142&#39; representation.</span>
 1778 |     | <span class='neutral'>    // The denominator is in &#39;X83&#39; representation.</span>
 1779 |     | <span class='neutral'>    X59 step;</span>
 1780 |     | <span class='neutral'>    uint256 denominator;</span>
 1781 |     | <span class='neutral'>    assembly {</span>
 1782 |     | <span class='neutral'>      // The division is safe because &#39;g&#39; is positive as we argued before.</span>
 1783 |     | <span class='neutral'>      let h_over_g_X142 := sdiv(h, g) // h(x) / g(x)</span>
 1784 |     | <span class='neutral'>      denominator := sub(</span>
 1785 |     | <span class='neutral'>        shl(83, 1), // oneX83</span>
 1786 |     | <span class='neutral'>        sub(</span>
 1787 |     | <span class='neutral'>          // Here, &#39;h_over_g_X142&#39; is shifted to the right by</span>
 1788 |     | <span class='neutral'>          // &#39;60 == 142 - 83 + 1&#39; bits where &#39;1&#39; appears because we are</span>
 1789 |     | <span class='neutral'>          // dividing by two. &#39;142&#39; appears because we are casting from the </span>
 1790 |     | <span class='neutral'>          // &#39;X142&#39; representation and &#39;83&#39; appears because we are casting to  </span>
 1791 |     | <span class='neutral'>          // the &#39;X83&#39; representation.</span>
 1792 |     | <span class='neutral'>          sar(60, h_over_g_X142), // (h(x) / g(x)) / 2</span>
 1793 |     | <span class='neutral'>          sdiv(mul(h_over_g_X142, dc), g) // (h(x) / g(x)) * (dc / g(x))</span>
 1794 |     | <span class='neutral'>        )</span>
 1795 |     | <span class='neutral'>      ) // 1 - (h(x) / g(x)) / 2 + (h(x) / g(x)) * (dc / g(x))</span>
 1796 |     | <span class='neutral'>      step := sdiv(</span>
 1797 |     | <span class='neutral'>        add(h_over_g_X142, h_over_g_X142), // 2 * (h(x) / g(x))</span>
 1798 |     | <span class='neutral'>        denominator</span>
 1799 |     | <span class='neutral'>      )</span>
 1800 |     | <span class='neutral'>    }</span>
 1801 |     | <span class='neutral'></span>
 1802 |     | <span class='neutral'>    if (step == zeroX59) {</span>
 1803 |     | <span class='neutral'>      require(denominator != 0, SearchingForOutgoingTargetFailed());</span>
 1804 |     | <span class='neutral'>      break;</span>
 1805 |     | <span class='neutral'>    }</span>
 1806 |     | <span class='neutral'></span>
 1807 |     | <span class='neutral'>    // The solution is capped by &#39;epsilonX59&#39; and &#39;xLimit&#39;. Hence, we do not</span>
 1808 |     | <span class='neutral'>    // need to argue whether the addition &#39;x + step&#39; is safe or not.</span>
 1809 |     | <span class='neutral'>    x = min(max(epsilonX59, x + step), xLimit);</span>
 1810 |     | <span class='neutral'>  }</span>
 1811 |     | <span class='neutral'></span>
 1812 |     | <span class='neutral'>  // The subtraction and the addition are safe because if &#39;left == false&#39;:</span>
 1813 |     | <span class='neutral'>  //</span>
 1814 |     | <span class='neutral'>  //  &#39;0 &lt; x &lt;= xLimit := qTarget - qBegin&#39;,</span>
 1815 |     | <span class='neutral'>  //</span>
 1816 |     | <span class='neutral'>  // and if &#39;left == true&#39;:</span>
 1817 |     | <span class='neutral'>  //</span>
 1818 |     | <span class='neutral'>  //  &#39;0 &lt; x &lt;= xLimit := qBegin - qTarget&#39;.</span>
 1819 |     | <span class='neutral'>  //</span>
 1820 |     | <span class='neutral'>  x = left ? _begin_.log() - x : _begin_.log() + x;</span>
 1821 |     | <span class='neutral'></span>
 1822 |     | <span class='neutral'>  // The output should be stored in both of the memory spaces that are pointed</span>
 1823 |     | <span class='neutral'>  // to by &#39;_overshoot_&#39; and &#39;_target_&#39;.</span>
 1824 |     | <span class='neutral'>  //</span>
 1825 |     | <span class='neutral'>  // The requirements of &#39;storePrice&#39; and &#39;outgoing&#39; are satisfied because</span>
 1826 |     | <span class='neutral'>  //</span>
 1827 |     | <span class='neutral'>  //  &#39;min(qBegin, qTarget) &lt;= x &lt;= max(qBegin, qTarget)&#39;.</span>
 1828 |     | <span class='neutral'>  //</span>
 1829 |     | <span class='neutral'>  _overshoot_.storePrice(x);</span>
 1830 |     | <span class='neutral'></span>
 1831 |     | <span class='neutral'>  // As argued before, if &#39;getDirection() == false&#39;, then</span>
 1832 |     | <span class='neutral'>  //</span>
 1833 |     | <span class='neutral'>  //  &#39;qTotal0 &lt;= qBegin &lt;= qOvershoot &lt;= qTarget &lt;= qTotal1&#39;.</span>
 1834 |     | <span class='neutral'>  //</span>
 1835 |     | <span class='neutral'>  // and if &#39;getDirection() == true&#39;, then</span>
 1836 |     | <span class='neutral'>  //</span>
 1837 |     | <span class='neutral'>  //  &#39;qTotal1 &lt;= qTarget &lt;= qOvershoot &lt;= qBegin &lt;= qTotal0&#39;.</span>
 1838 |     | <span class='neutral'>  //</span>
 1839 |     | <span class='neutral'>  // Additionally, since the vertical coordinates of kernel are monotonic, we</span>
 1840 |     | <span class='neutral'>  // have &#39;cTotal0 &lt;= cTotal1&#39; and the input requirements of &#39;outgoing&#39; are</span>
 1841 |     | <span class='neutral'>  // satisfied.</span>
 1842 |     | <span class='neutral'>  outgoing = _total0_.outgoing(_begin_, _overshoot_);</span>
 1843 |     | <span class='neutral'></span>
 1844 |     | <span class='neutral'>  // &#39;x&#39; is moved forward to ensure that the resulting integral is an over</span>
 1845 |     | <span class='neutral'>  // approximation.</span>
 1846 |     | <span class='neutral'>  while (outgoing &lt; outgoingLimit) {</span>
 1847 |     | <span class='neutral'>    // The addition and the subtraction are safe here because:</span>
 1848 |     | <span class='neutral'>    //</span>
 1849 |     | <span class='neutral'>    //  &#39;outgoingLimit &lt; _total0_.outgoing(_begin_, _target_)&#39;.</span>
 1850 |     | <span class='neutral'>    //</span>
 1851 |     | <span class='neutral'>    // Hence, the loop is stopped before we reach &#39;qTarget&#39;.</span>
 1852 |     | <span class='neutral'>    x = left ? x - epsilonX59 : x + epsilonX59;</span>
 1853 |     | <span class='neutral'></span>
 1854 |     | <span class='neutral'>    // Due to the above argument, if &#39;left == false&#39; then</span>
 1855 |     | <span class='neutral'>    //</span>
 1856 |     | <span class='neutral'>    //  &#39;qOvershoot + 1 / (2 ** 59) &lt; qTarget &lt;= qUpper&#39;</span>
 1857 |     | <span class='neutral'>    //</span>
 1858 |     | <span class='neutral'>    // and if &#39;left == true&#39; then</span>
 1859 |     | <span class='neutral'>    //</span>
 1860 |     | <span class='neutral'>    //  &#39;qLower &lt;= qTarget &lt; qOvershoot - 1 / (2 ** 59)&#39;.</span>
 1861 |     | <span class='neutral'>    //</span>
 1862 |     | <span class='neutral'>    // Hence the input requirements of &#39;moveOvershootByEpsilon&#39; are satisfied.</span>
 1863 |     | <span class='neutral'>    moveOvershootByEpsilon(left);</span>
 1864 |     | <span class='neutral'></span>
 1865 |     | <span class='neutral'>    // As argued before, if &#39;getDirection() == false&#39;, then</span>
 1866 |     | <span class='neutral'>    //</span>
 1867 |     | <span class='neutral'>    //  &#39;qTotal0 &lt;= qBegin &lt;= qOvershoot &lt;= qTarget &lt;= qTotal1&#39;.</span>
 1868 |     | <span class='neutral'>    //</span>
 1869 |     | <span class='neutral'>    // and if &#39;getDirection() == true&#39;, then</span>
 1870 |     | <span class='neutral'>    //</span>
 1871 |     | <span class='neutral'>    //  &#39;qTotal1 &lt;= qTarget &lt;= qOvershoot &lt;= qBegin &lt;= qTotal0&#39;.</span>
 1872 |     | <span class='neutral'>    //</span>
 1873 |     | <span class='neutral'>    // Additionally, since the vertical coordinates of kernel are monotonic, we</span>
 1874 |     | <span class='neutral'>    // have &#39;cTotal0 &lt;= cTotal1&#39; and the input requirements of &#39;outgoing&#39; are</span>
 1875 |     | <span class='neutral'>    // satisfied.</span>
 1876 |     | <span class='neutral'>    outgoing = _total0_.outgoing(_begin_, _overshoot_);</span>
 1877 |     | <span class='neutral'>  }</span>
 1878 |     | <span class='neutral'></span>
 1879 |     | <span class='neutral'>  // The output should be stored in both of the memory spaces that are pointed</span>
 1880 |     | <span class='neutral'>  // to by &#39;_overshoot_&#39; and &#39;_target_&#39;.</span>
 1881 |     | <span class='neutral'>  _target_.copyPrice(_overshoot_);</span>
 1882 |     | <span class='neutral'></span>
 1883 |     | <span class='neutral'>  return (true, outgoing);</span>
 1884 |     | <span class='neutral'>}</span>
 1885 |     | <span class='neutral'></span>
 1886 |     | <span class='neutral'>/// @notice For the case &#39;exactInput == true&#39;, i.e., when the specified amount</span>
 1887 |     | <span class='neutral'>/// is incoming, this function performs a Halley search to determine &#39;qTarget&#39;</span>
 1888 |     | <span class='neutral'>/// based on &#39;integralLimit&#39;. As explained in &#39;Memory.sol&#39;, &#39;integralLimit&#39; is</span>
 1889 |     | <span class='neutral'>/// is derived from &#39;amountSpecified&#39;.</span>
 1890 |     | <span class='neutral'>///</span>
 1891 |     | <span class='neutral'>/// Let</span>
 1892 |     | <span class='neutral'>///</span>
 1893 |     | <span class='neutral'>///  &#39;cTotal0 := c[indexKernelTotal - 1]&#39;,</span>
 1894 |     | <span class='neutral'>///  &#39;cTotal1 := c[indexKernelTotal]&#39;,</span>
 1895 |     | <span class='neutral'>///</span>
 1896 |     | <span class='neutral'>/// represent the vertical coordinates of the kernel breakpoints corresponding</span>
 1897 |     | <span class='neutral'>/// to &#39;indexKernelTotal - 1&#39; and &#39;indexKernelTotal&#39;, respectively. As</span>
 1898 |     | <span class='neutral'>/// explained in &#39;Memory.sol&#39;, the memory spaces that are pointed to by</span>
 1899 |     | <span class='neutral'>/// &#39;_total0_&#39; and &#39;_total1_&#39; host the following vertical coordinates:</span>
 1900 |     | <span class='neutral'>///</span>
 1901 |     | <span class='neutral'>///  &#39;_total0_.height() := (2 ** 15) * cTotal0&#39;,</span>
 1902 |     | <span class='neutral'>///  &#39;_total1_.height() := (2 ** 15) * cTotal1&#39;.</span>
 1903 |     | <span class='neutral'>///</span>
 1904 |     | <span class='neutral'>/// Additionally, if &#39;getDirection() == false&#39;, define</span>
 1905 |     | <span class='neutral'>///</span>
 1906 |     | <span class='neutral'>///  &#39;qTotal0 := qOrigin + b[indexKernelTotal - 1]&#39;,</span>
 1907 |     | <span class='neutral'>///  &#39;qTotal1 := qOrigin + b[indexKernelTotal]&#39;,</span>
 1908 |     | <span class='neutral'>///</span>
 1909 |     | <span class='neutral'>/// and if &#39;getDirection() == true&#39;, define</span>
 1910 |     | <span class='neutral'>///</span>
 1911 |     | <span class='neutral'>///  &#39;qTotal0 := qOrigin - b[indexKernelTotal - 1]&#39;,</span>
 1912 |     | <span class='neutral'>///  &#39;qTotal1 := qOrigin - b[indexKernelTotal]&#39;,</span>
 1913 |     | <span class='neutral'>///</span>
 1914 |     | <span class='neutral'>/// as the shifted horizontal coordinates of the kernel breakpoint</span>
 1915 |     | <span class='neutral'>/// corresponding to &#39;indexKernelTotal - 1&#39; and &#39;indexKernelTotal&#39;,</span>
 1916 |     | <span class='neutral'>/// respectively. Hence, the memory spaces that are pointed to by &#39;_total0_&#39;</span>
 1917 |     | <span class='neutral'>/// and &#39;_total1_&#39; host the following horizontal coordinates as well:</span>
 1918 |     | <span class='neutral'>/// </span>
 1919 |     | <span class='neutral'>///  &#39;_total0_.log() := (2 ** 59) * (16 + qTotal0)&#39;,</span>
 1920 |     | <span class='neutral'>///  &#39;_total1_.log() := (2 ** 59) * (16 + qTotal1)&#39;,</span>
 1921 |     | <span class='neutral'>/// </span>
 1922 |     | <span class='neutral'>/// Let &#39;qBegin&#39; and &#39;qCurrent&#39; represent the offsetted logarithmic prices that</span>
 1923 |     | <span class='neutral'>/// are hosted by the memory pointers &#39;_begin_&#39; and &#39;_current_&#39;, i.e.,</span>
 1924 |     | <span class='neutral'>///</span>
 1925 |     | <span class='neutral'>///  &#39;_begin_.log() == (2 ** 59) * (16 + qBegin)&#39;,</span>
 1926 |     | <span class='neutral'>///  &#39;_current_.log() == (2 ** 59) * (16 + qCurrent)&#39;.</span>
 1927 |     | <span class='neutral'>///</span>
 1928 |     | <span class='neutral'>/// At this stage, &#39;qTarget&#39; is not yet determined. Hence, if </span>
 1929 |     | <span class='neutral'>/// &#39;getZeroForOne() == false&#39;, we have:</span>
 1930 |     | <span class='neutral'>///</span>
 1931 |     | <span class='neutral'>///                                   - 8     / qBegin</span>
 1932 |     | <span class='neutral'>///    incomingCurrentToTarget      e        |    + h / 2</span>
 1933 |     | <span class='neutral'>///  &#39;------------------------- := ------- * |  e         k(w(h)) dh&#39;</span>
 1934 |     | <span class='neutral'>///           2 ** 216                2      |</span>
 1935 |     | <span class='neutral'>///                                         / qCurrent</span>
 1936 |     | <span class='neutral'>///</span>
 1937 |     | <span class='neutral'>/// and we want to determine &#39;qTarget&#39; based on the following equation:</span>
 1938 |     | <span class='neutral'>///</span>
 1939 |     | <span class='neutral'>///                              - 8     / qTarget</span>
 1940 |     | <span class='neutral'>///    getIntegralLimit()      e        |    + h / 2</span>
 1941 |     | <span class='neutral'>///  &#39;-------------------- == ------- * |  e         k(w(h)) dh&#39;,</span>
 1942 |     | <span class='neutral'>///         2 ** 216             2      |</span>
 1943 |     | <span class='neutral'>///                                    / qCurrent</span>
 1944 |     | <span class='neutral'>///</span>
 1945 |     | <span class='neutral'>/// which is equivalent to</span>
 1946 |     | <span class='neutral'>///</span>
 1947 |     | <span class='neutral'>///    getIntegralLimit() - incomingCurrentToTarget</span>
 1948 |     | <span class='neutral'>///  &#39;---------------------------------------------- == </span>
 1949 |     | <span class='neutral'>///                      2 ** 216</span>
 1950 |     | <span class='neutral'>///</span>
 1951 |     | <span class='neutral'>///      - 8     / qTarget</span>
 1952 |     | <span class='neutral'>///    e        |    + h / 2</span>
 1953 |     | <span class='neutral'>///   ------- * |  e         k(w(h)) dh == </span>
 1954 |     | <span class='neutral'>///      2      |</span>
 1955 |     | <span class='neutral'>///            / qBegin</span>
 1956 |     | <span class='neutral'>///</span>
 1957 |     | <span class='neutral'>///      - 8     / qTarget</span>
 1958 |     | <span class='neutral'>///    e        |    + h / 2             cTotal1 - cTotal0</span>
 1959 |     | <span class='neutral'>///   ------- * |  e         (cTotal0 + ------------------- (h - qTotal0)) dh&#39;.</span>
 1960 |     | <span class='neutral'>///      2      |                        qTotal1 - qTotal0</span>
 1961 |     | <span class='neutral'>///            / qBegin</span>
 1962 |     | <span class='neutral'>///</span>
 1963 |     | <span class='neutral'>/// Hence, we define</span>
 1964 |     | <span class='neutral'>///</span>
 1965 |     | <span class='neutral'>///  &#39;incomingLimit := getIntegralLimit() - incomingCurrentToTarget&#39;.</span>
 1966 |     | <span class='neutral'>///</span>
 1967 |     | <span class='neutral'>/// and solve</span>
 1968 |     | <span class='neutral'>///</span>
 1969 |     | <span class='neutral'>///      - 8     / qBegin + x</span>
 1970 |     | <span class='neutral'>///    e        |   + h / 2             cTotal1 - cTotal0</span>
 1971 |     | <span class='neutral'>///  &#39;------- * |  e        (cTotal0 + ------------------- (h - qTotal0)) dh</span>
 1972 |     | <span class='neutral'>///      2      |                       qTotal1 - qTotal0</span>
 1973 |     | <span class='neutral'>///            / qBegin</span>
 1974 |     | <span class='neutral'>///</span>
 1975 |     | <span class='neutral'>///       incomingLimit</span>
 1976 |     | <span class='neutral'>///   == ---------------&#39;</span>
 1977 |     | <span class='neutral'>///         2 ** 216</span>
 1978 |     | <span class='neutral'>///</span>
 1979 |     | <span class='neutral'>/// with respect to &#39;x&#39; and then we store</span>
 1980 |     | <span class='neutral'>///</span>
 1981 |     | <span class='neutral'>///  &#39;qTarget := qBegin + x&#39;.</span>
 1982 |     | <span class='neutral'>///</span>
 1983 |     | <span class='neutral'>/// in the memory spaces that are pointed to by &#39;_target_&#39; and &#39;_overshoot_&#39;.</span>
 1984 |     | <span class='neutral'>///</span>
 1985 |     | <span class='neutral'>/// Similarly, if &#39;getZeroForOne() == true&#39;, we solve the equation:</span>
 1986 |     | <span class='neutral'>///</span>
 1987 |     | <span class='neutral'>///      - 8     / qBegin</span>
 1988 |     | <span class='neutral'>///    e        |   - h / 2             cTotal1 - cTotal0</span>
 1989 |     | <span class='neutral'>///  &#39;------- * |  e        (cTotal0 + ------------------- (qTotal0 - h)) dh</span>
 1990 |     | <span class='neutral'>///      2      |                       qTotal0 - qTotal1</span>
 1991 |     | <span class='neutral'>///            / qBegin - x</span>
 1992 |     | <span class='neutral'>///</span>
 1993 |     | <span class='neutral'>///       incomingLimit</span>
 1994 |     | <span class='neutral'>///   == ---------------&#39;</span>
 1995 |     | <span class='neutral'>///         2 ** 216</span>
 1996 |     | <span class='neutral'>///</span>
 1997 |     | <span class='neutral'>/// with respect to &#39;x&#39; and then we store:</span>
 1998 |     | <span class='neutral'>///</span>
 1999 |     | <span class='neutral'>///  &#39;qTarget := qBegin - x&#39;.</span>
 2000 |     | <span class='neutral'>///</span>
 2001 |     | <span class='neutral'>/// in the memory spaces that are pointed to by &#39;_target_&#39; and &#39;_overshoot_&#39;.</span>
 2002 |     | <span class='neutral'>///</span>
 2003 |     | <span class='neutral'>/// For simplicity, consider the first case of &#39;getZeroForOne() == false&#39;,</span>
 2004 |     | <span class='neutral'>/// since the second case &#39;getZeroForOne() == true&#39; can be argued similarly.</span>
 2005 |     | <span class='neutral'>/// Define:</span>
 2006 |     | <span class='neutral'>///</span>
 2007 |     | <span class='neutral'>///  &#39;q2 := 2 * (cTotal1 - cTotal0)&#39;</span>
 2008 |     | <span class='neutral'>///</span>
 2009 |     | <span class='neutral'>///  &#39;q1 := cTotal1 * (2 + qTotal0 - qBegin) - </span>
 2010 |     | <span class='neutral'>///         cTotal0 * (2 + qTotal1 - qBegin)&#39;</span>
 2011 |     | <span class='neutral'>///</span>
 2012 |     | <span class='neutral'>///                                     incomingLimit</span>
 2013 |     | <span class='neutral'>///  &#39;q0 := q1 - (qTotal1 - qTotal0) * --------------- * exp(- qBegin / 2)&#39;</span>
 2014 |     | <span class='neutral'>///                                        2 ** 216</span>
 2015 |     | <span class='neutral'>///</span>
 2016 |     | <span class='neutral'>/// Then the equation can be cast as &#39;f(x) == 0&#39;, where</span>
 2017 |     | <span class='neutral'>///</span>
 2018 |     | <span class='neutral'>///  &#39;  f(x) == + ((cTotal1 - cTotal0) * x - q1) * exp(x / 2) + q0&#39;</span>
 2019 |     | <span class='neutral'>///</span>
 2020 |     | <span class='neutral'>///  &#39; f&#39;(x) == + ((cTotal1 - cTotal0) * x - q1 + q2) * exp(x / 2) / 2&#39;</span>
 2021 |     | <span class='neutral'>///</span>
 2022 |     | <span class='neutral'>///  &#39;f&#39;&#39;(x) == + ((cTotal1 - cTotal0) * x - q1 + q2 + q2) * exp(x / 2) / 4&#39;</span>
 2023 |     | <span class='neutral'>///</span>
 2024 |     | <span class='neutral'>/// Define:</span>
 2025 |     | <span class='neutral'>///</span>
 2026 |     | <span class='neutral'>///  &#39;g(x) == (cTotal1 - cTotal0) * x - q1 + q2&#39;</span>
 2027 |     | <span class='neutral'>///</span>
 2028 |     | <span class='neutral'>///  &#39;h(x) == (cTotal1 - cTotal0) * x - q1 + q0 * exp(- x / 2)&#39;</span>
 2029 |     | <span class='neutral'>///</span>
 2030 |     | <span class='neutral'>/// To solve our equation, we perform the following Halley&#39;s search:</span>
 2031 |     | <span class='neutral'>///</span>
 2032 |     | <span class='neutral'>/// &#39;x = x - </span>
 2033 |     | <span class='neutral'>///                            4 * (h(x) / g(x))</span>
 2034 |     | <span class='neutral'>///  ----------------------------------------------------------------------&#39;</span>
 2035 |     | <span class='neutral'>///   2 - (h(x) / g(x)) - 2 * (h(x) / g(x)) * ((cTotal1 - cTotal0) / g(x))</span>
 2036 |     | <span class='neutral'>///</span>
 2037 |     | <span class='neutral'>/// --------------------------------------------------------------------------- </span>
 2038 |     | <span class='neutral'>///</span>
 2039 |     | <span class='neutral'>/// Underflow of &#39;getIntegralLimit() - _incomingCurrentToTarget_.integral()&#39;</span>
 2040 |     | <span class='neutral'>/// should be avoided externally.</span>
 2041 |     | <span class='neutral'>///</span>
 2042 |     | <span class='neutral'>/// We should have &#39;getDirection() == getZeroForOne()&#39;.</span>
 2043 |     | <span class='neutral'>///</span>
 2044 |     | <span class='neutral'>/// @return exactAmount Whether the search is performed.</span>
 2045 |     | <span class='neutral'>///</span>
 2046 |     | <span class='neutral'>/// Let &#39;qTarget&#39; represent the existing value stored in the memory space which</span>
 2047 |     | <span class='neutral'>/// is pointed to by &#39;_target_&#39; (prior to calling this function). As explained</span>
 2048 |     | <span class='neutral'>/// in &#39;Memory.sol&#39;, we have:</span>
 2049 |     | <span class='neutral'>///</span>
 2050 |     | <span class='neutral'>///   &#39;qTarget := (</span>
 2051 |     | <span class='neutral'>///                 getDirection() == getZeroForOne()</span>
 2052 |     | <span class='neutral'>///               ) ? (</span>
 2053 |     | <span class='neutral'>///                 getDirection() ? </span>
 2054 |     | <span class='neutral'>///                 max(max(qEnd, qTotal1), qLimitWithinInterval) : </span>
 2055 |     | <span class='neutral'>///                 min(min(qEnd, qTotal1), qLimitWithinInterval)</span>
 2056 |     | <span class='neutral'>///               ) : (</span>
 2057 |     | <span class='neutral'>///                 getDirection() ? </span>
 2058 |     | <span class='neutral'>///                 max(qEnd, qTotal1) : </span>
 2059 |     | <span class='neutral'>///                 min(qEnd, qTotal1)</span>
 2060 |     | <span class='neutral'>///               )&#39;,</span>
 2061 |     | <span class='neutral'>///</span>
 2062 |     | <span class='neutral'>/// Additionally, because of the input requirement</span>
 2063 |     | <span class='neutral'>///</span>
 2064 |     | <span class='neutral'>///   &#39;getDirection() == getZeroForOne()&#39;,</span>
 2065 |     | <span class='neutral'>///</span>
 2066 |     | <span class='neutral'>/// the above equation is equivalent to:</span>
 2067 |     | <span class='neutral'>///</span>
 2068 |     | <span class='neutral'>///   &#39;qTarget := getDirection() ? </span>
 2069 |     | <span class='neutral'>///               max(max(qEnd, qTotal1), qLimitWithinInterval) : </span>
 2070 |     | <span class='neutral'>///               min(min(qEnd, qTotal1), qLimitWithinInterval)&#39;.</span>
 2071 |     | <span class='neutral'>///</span>
 2072 |     | <span class='neutral'>/// If &#39;getZeroForOne() == false&#39;, then the current &#39;qTarget&#39; is an upper bound</span>
 2073 |     | <span class='neutral'>/// for the unknown value &#39;qBegin + x&#39; and the numerical search for &#39;x&#39; is</span>
 2074 |     | <span class='neutral'>/// performed within the range &#39;0&#39; to &#39;qTarget - qBegin&#39;. In this case, we</span>
 2075 |     | <span class='neutral'>/// first need to check the following inequality:</span>
 2076 |     | <span class='neutral'>///</span>
 2077 |     | <span class='neutral'>///      - 8     / qTarget</span>
 2078 |     | <span class='neutral'>///    e        |   + h / 2             cTotal1 - cTotal0</span>
 2079 |     | <span class='neutral'>///  &#39;------- * |  e        (cTotal0 + ------------------- (h - qTotal0)) dh</span>
 2080 |     | <span class='neutral'>///      2      |                       qTotal1 - qTotal0</span>
 2081 |     | <span class='neutral'>///            / qBegin</span>
 2082 |     | <span class='neutral'>///</span>
 2083 |     | <span class='neutral'>///      incomingLimit</span>
 2084 |     | <span class='neutral'>///   &lt; ---------------&#39;.</span>
 2085 |     | <span class='neutral'>///        2 ** 216</span>
 2086 |     | <span class='neutral'>///</span>
 2087 |     | <span class='neutral'>/// If satisfied, then the incoming integral across the entire range does not</span>
 2088 |     | <span class='neutral'>/// reach &#39;incomingLimit / (2 ** 216)&#39;, which means that there is no solution.</span>
 2089 |     | <span class='neutral'>/// In this case, we simply return the value for the above integral in &#39;X216&#39;</span>
 2090 |     | <span class='neutral'>/// representation along with &#39;exactAmount == false&#39;.</span>
 2091 |     | <span class='neutral'>///</span>
 2092 |     | <span class='neutral'>/// Similarly, if &#39;getZeroForOne == true&#39;, then &#39;qTarget&#39; is a lower bound for</span>
 2093 |     | <span class='neutral'>/// the unknown value &#39;qTarget == qBegin - x&#39; and the numerical search for &#39;x&#39;</span>
 2094 |     | <span class='neutral'>/// is performed within the range &#39;0&#39; to &#39;qBegin - qTarget&#39;. In this case,</span>
 2095 |     | <span class='neutral'>/// we first need to check the following inequality:</span>
 2096 |     | <span class='neutral'>///</span>
 2097 |     | <span class='neutral'>///      - 8     / qBegin</span>
 2098 |     | <span class='neutral'>///    e        |   + h / 2             cTotal1 - cTotal0</span>
 2099 |     | <span class='neutral'>///  &#39;------- * |  e        (cTotal0 + ------------------- (qTotal0 - h)) dh</span>
 2100 |     | <span class='neutral'>///      2      |                       qTotal0 - qTotal1</span>
 2101 |     | <span class='neutral'>///            / qTarget</span>
 2102 |     | <span class='neutral'>///</span>
 2103 |     | <span class='neutral'>///      incomingLimit</span>
 2104 |     | <span class='neutral'>///   &lt; ---------------&#39;.</span>
 2105 |     | <span class='neutral'>///        2 ** 216</span>
 2106 |     | <span class='neutral'>///</span>
 2107 |     | <span class='neutral'>/// If satisfied, then the incoming integral across the entire range does not</span>
 2108 |     | <span class='neutral'>/// reach &#39;incomingLimit / (2 ** 216)&#39;, which means that there is no solution.</span>
 2109 |     | <span class='neutral'>/// In this case, we simply return the value for the above integral in &#39;X216&#39;</span>
 2110 |     | <span class='neutral'>/// representation along with &#39;exactAmount == false&#39;.</span>
 2111 |     | <span class='neutral'>///</span>
 2112 |     | <span class='neutral'>/// @return incoming Integral increment to be added to</span>
 2113 |     | <span class='neutral'>/// &#39;incomingCurrentToTarget / (2 ** 216)&#39;, i.e.,</span>
 2114 |     | <span class='neutral'>///</span>
 2115 |     | <span class='neutral'>///      - 8     / qTarget</span>
 2116 |     | <span class='neutral'>///    e        |   + h / 2             cTotal1 - cTotal0</span>
 2117 |     | <span class='neutral'>///  &#39;------- * |  e        (cTotal0 + ------------------- (h - qTotal0)) dh&#39;</span>
 2118 |     | <span class='neutral'>///      2      |                       qTotal1 - qTotal0</span>
 2119 |     | <span class='neutral'>///            / qBegin</span>
 2120 |     | <span class='neutral'>///</span>
 2121 |     | <span class='neutral'>/// if &#39;getZeroForOne() == false&#39; and</span>
 2122 |     | <span class='neutral'>///</span>
 2123 |     | <span class='neutral'>///      - 8     / qBegin</span>
 2124 |     | <span class='neutral'>///    e        |   - h / 2             cTotal1 - cTotal0</span>
 2125 |     | <span class='neutral'>///  &#39;------- * |  e        (cTotal0 + ------------------- (qTotal0 - h)) dh&#39;</span>
 2126 |     | <span class='neutral'>///      2      |                       qTotal0 - qTotal1</span>
 2127 |     | <span class='neutral'>///            / qTarget</span>
 2128 |     | <span class='neutral'>///</span>
 2129 |     | <span class='neutral'>/// if &#39;getZeroForOne() == true&#39;.</span>
 2130 |     | <span class='neutral'>///</span>
 2131 |     | <span class='neutral'>/// If &#39;exactAmount == false&#39;, this value is equal to the incoming integral</span>
 2132 |     | <span class='neutral'>/// across the entire search range and if the search is performed, this value</span>
 2133 |     | <span class='neutral'>/// is equal to the left hand side of the equation that we are solving.</span>
 2134 |     | <span class='neutral'>function searchIncomingTarget() pure returns (</span>
 2135 |     | <span class='neutral'>  bool exactAmount,</span>
 2136 |     | <span class='neutral'>  X216 incoming</span>
 2137 |     | <span class='neutral'>) {</span>
 2138 |     | <span class='neutral'>  // First, we subtract &#39;incomingCurrentToTarget&#39; from &#39;getIntegralLimit()&#39; in</span>
 2139 |     | <span class='neutral'>  // order to get &#39;incomingLimit&#39;.</span>
 2140 |     | <span class='neutral'>  //</span>
 2141 |     | <span class='neutral'>  // Subtraction is safe because underflow is handled externally.</span>
 2142 |     | <span class='neutral'>  X216 incomingLimit = </span>
 2143 |     | <span class='neutral'>    getIntegralLimit() - _incomingCurrentToTarget_.integral();</span>
 2144 |     | <span class='neutral'></span>
 2145 |     | <span class='neutral'>  // The next step is to see if the integral taken across the entire search</span>
 2146 |     | <span class='neutral'>  // range between &#39;qBegin&#39; and &#39;qTarget&#39; exceeds &#39;incomingLimit&#39; or not. If it</span>
 2147 |     | <span class='neutral'>  // does not, then we simply stop the search and return the resulting integral</span>
 2148 |     | <span class='neutral'>  // along with &#39;exactAmount == false&#39;.</span>
 2149 |     | <span class='neutral'>  //</span>
 2150 |     | <span class='neutral'>  // As defined in &#39;Memory.sol&#39;, we have</span>
 2151 |     | <span class='neutral'>  //</span>
 2152 |     | <span class='neutral'>  //  &#39;qBegin := getDirection() ? </span>
 2153 |     | <span class='neutral'>  //             min(q[indexCurve + 2], qTotal0) : </span>
 2154 |     | <span class='neutral'>  //             max(q[indexCurve + 2], qTotal0)&#39;,</span>
 2155 |     | <span class='neutral'>  //</span>
 2156 |     | <span class='neutral'>  //  &#39;qTarget := (</span>
 2157 |     | <span class='neutral'>  //                getDirection() == getZeroForOne()</span>
 2158 |     | <span class='neutral'>  //              ) ? (</span>
 2159 |     | <span class='neutral'>  //                getDirection() ? </span>
 2160 |     | <span class='neutral'>  //                max(max(qEnd, qTotal1), qLimitWithinInterval) : </span>
 2161 |     | <span class='neutral'>  //                min(min(qEnd, qTotal1), qLimitWithinInterval)</span>
 2162 |     | <span class='neutral'>  //              ) : (</span>
 2163 |     | <span class='neutral'>  //                getDirection() ? </span>
 2164 |     | <span class='neutral'>  //                max(qEnd, qTotal1) : </span>
 2165 |     | <span class='neutral'>  //                min(qEnd, qTotal1)</span>
 2166 |     | <span class='neutral'>  //              )</span>
 2167 |     | <span class='neutral'>  //           == getDirection() ? </span>
 2168 |     | <span class='neutral'>  //              max(max(qEnd, qTotal1), qLimitWithinInterval) : </span>
 2169 |     | <span class='neutral'>  //              min(min(qEnd, qTotal1), qLimitWithinInterval)</span>
 2170 |     | <span class='neutral'>  //</span>
 2171 |     | <span class='neutral'>  // which implies that if &#39;getDirection() == false&#39;, then</span>
 2172 |     | <span class='neutral'>  //</span>
 2173 |     | <span class='neutral'>  //  &#39;qTotal0 &lt;= qBegin &lt;= qTarget &lt;= qTotal1&#39;.</span>
 2174 |     | <span class='neutral'>  //</span>
 2175 |     | <span class='neutral'>  // and if &#39;getDirection() == true&#39;, then</span>
 2176 |     | <span class='neutral'>  //</span>
 2177 |     | <span class='neutral'>  //  &#39;qTotal1 &lt;= qTarget &lt;= qBegin &lt;= qTotal0&#39;.</span>
 2178 |     | <span class='neutral'>  //</span>
 2179 |     | <span class='neutral'>  // Additionally, since the vertical coordinates of kernel are monotonic, we</span>
 2180 |     | <span class='neutral'>  // have &#39;cTotal0 &lt;= cTotal1&#39; and the input requirements of &#39;incoming&#39; are</span>
 2181 |     | <span class='neutral'>  // satisfied.</span>
 2182 |     | <span class='neutral'>  incoming = _total0_.incoming(_begin_, _target_);</span>
 2183 |     | <span class='neutral'>  // Signed comparison is valid because:</span>
 2184 |     | <span class='neutral'>  //</span>
 2185 |     | <span class='neutral'>  //  - the output of &#39;incoming&#39; is always a nonnegative value which is less</span>
 2186 |     | <span class='neutral'>  //    than &#39;oneX216&#39;.</span>
 2187 |     | <span class='neutral'>  //</span>
 2188 |     | <span class='neutral'>  //  - &#39;incomingLimit &lt;= getIntegralLimit() &lt; one216&#39;, and</span>
 2189 |     | <span class='neutral'>  //</span>
 2190 |     | <span class='neutral'>  //  - &#39;getIntegralLimit() &gt;= zeroX216&#39; because of the first input</span>
 2191 |     | <span class='neutral'>  //    requirement.</span>
 2192 |     | <span class='neutral'>  if (incoming &lt;= incomingLimit) return (false, incoming);</span>
 2193 |     | <span class='neutral'></span>
 2194 |     | <span class='neutral'>  // &#39;zeroForOne&#39; is loaded from the memory.</span>
 2195 |     | <span class='neutral'>  bool left = getZeroForOne();</span>
 2196 |     | <span class='neutral'></span>
 2197 |     | <span class='neutral'>  // &#39;|qTotal1 - qTotal0|&#39; is calculated once and used throughout the search.</span>
 2198 |     | <span class='neutral'>  //</span>
 2199 |     | <span class='neutral'>  // As we argued before, if &#39;left == false&#39;, then</span>
 2200 |     | <span class='neutral'>  //</span>
 2201 |     | <span class='neutral'>  //  &#39;qTotal0 &lt;= qBegin &lt;= qTarget &lt;= qTotal1&#39;.</span>
 2202 |     | <span class='neutral'>  //</span>
 2203 |     | <span class='neutral'>  // and if &#39;left == true&#39;, then</span>
 2204 |     | <span class='neutral'>  //</span>
 2205 |     | <span class='neutral'>  //  &#39;qTotal1 &lt;= qTarget &lt;= qBegin &lt;= qTotal0&#39;.</span>
 2206 |     | <span class='neutral'>  X59 db = left ? </span>
 2207 |     | <span class='neutral'>    _total0_.log() - _total1_.log() : </span>
 2208 |     | <span class='neutral'>    _total1_.log() - _total0_.log();</span>
 2209 |     | <span class='neutral'></span>
 2210 |     | <span class='neutral'>  // &#39;cTotal1 - cTotal0&#39; is calculated once and used throughout the search.</span>
 2211 |     | <span class='neutral'>  //</span>
 2212 |     | <span class='neutral'>  // The subtraction is safe because &#39;total0&#39; and &#39;total1&#39; correspond to the</span>
 2213 |     | <span class='neutral'>  // kernel breakpoints &#39;indexKernelTotal - oneIndex&#39; and &#39;indexKernelTotal&#39;,</span>
 2214 |     | <span class='neutral'>  // respectively, and the vertical coordinates of kernel breakpoints are</span>
 2215 |     | <span class='neutral'>  // monotonically non-decreasing due to the custom error</span>
 2216 |     | <span class='neutral'>  // &#39;NonMonotonicVerticalCoordinates&#39; in &#39;KernelCompact.sol&#39;.</span>
 2217 |     | <span class='neutral'>  X15 dc = _total1_.height() - _total0_.height();</span>
 2218 |     | <span class='neutral'></span>
 2219 |     | <span class='neutral'>  // Next we calculate</span>
 2220 |     | <span class='neutral'>  //</span>
 2221 |     | <span class='neutral'>  //  &#39;q2 := 2 * (cTotal1 - cTotal0)&#39;</span>
 2222 |     | <span class='neutral'>  //</span>
 2223 |     | <span class='neutral'>  // The multiplication is safe because &#39;twoX59&#39; is positive and the output</span>
 2224 |     | <span class='neutral'>  // does not exceed &#39;64 + 16 == 80&#39; bits.</span>
 2225 |     | <span class='neutral'>  X74 q2 = twoX59.times(dc);</span>
 2226 |     | <span class='neutral'></span>
 2227 |     | <span class='neutral'>  // The second coefficient is calculated as</span>
 2228 |     | <span class='neutral'>  //</span>
 2229 |     | <span class='neutral'>  // &#39;q1 := (cTotal1 - cTotal0) * (2 + |qTotal1 - qBegin|)</span>
 2230 |     | <span class='neutral'>  //      - cTotal1 * |qTotal1 - qTotal0|&#39;</span>
 2231 |     | <span class='neutral'></span>
 2232 |     | <span class='neutral'>  // The multiplication &#39;db.times(_total1_.height())&#39; is safe because the</span>
 2233 |     | <span class='neutral'>  // output does not exceed 80 bits.</span>
 2234 |     | <span class='neutral'>  //</span>
 2235 |     | <span class='neutral'>  // The subtraction is unsafe and &#39;q1&#39; may be negative.</span>
 2236 |     | <span class='neutral'>  X74 q1 = q2 - db.times(_total1_.height());</span>
 2237 |     | <span class='neutral'></span>
 2238 |     | <span class='neutral'>  // The subtractions are safe because of the last input requirement and the</span>
 2239 |     | <span class='neutral'>  // fact that</span>
 2240 |     | <span class='neutral'>  //</span>
 2241 |     | <span class='neutral'>  //  &#39;getDirection() == getZeroForOne() == left&#39;.</span>
 2242 |     | <span class='neutral'>  //</span>
 2243 |     | <span class='neutral'>  // Lastly, the additions are safe because neither values exceed 81 bits.</span>
 2244 |     | <span class='neutral'>  q1 = left ? </span>
 2245 |     | <span class='neutral'>    q1 + (_begin_.log() - _total1_.log()).times(dc) : </span>
 2246 |     | <span class='neutral'>    q1 + (_total1_.log() - _begin_.log()).times(dc);</span>
 2247 |     | <span class='neutral'></span>
 2248 |     | <span class='neutral'>  // Next, in order to compute &#39;q0&#39;, if &#39;left == false&#39;, we calculate:</span>
 2249 |     | <span class='neutral'>  //</span>
 2250 |     | <span class='neutral'>  //        incomingLimit          db</span>
 2251 |     | <span class='neutral'>  //  &#39;---------------------- * --------- * exp(- qBegin / 2) ==</span>
 2252 |     | <span class='neutral'>  //    (2 ** 216) * exp(-8)     2 ** 59</span>
 2253 |     | <span class='neutral'>  //</span>
 2254 |     | <span class='neutral'>  //    incomingLimit * db * ((2 ** 216) * exp(- 8 - qBegin / 2))</span>
 2255 |     | <span class='neutral'>  //   ----------------------------------------------------------- ==</span>
 2256 |     | <span class='neutral'>  //                  (2 ** (216 + 59)) * exp(-16)</span>
 2257 |     | <span class='neutral'>  //</span>
 2258 |     | <span class='neutral'>  //    incomingLimit * db * _begin_.sqrt(false)</span>
 2259 |     | <span class='neutral'>  //   ------------------------------------------&#39;</span>
 2260 |     | <span class='neutral'>  //          (2 ** (216 + 59)) * exp(-16)</span>
 2261 |     | <span class='neutral'>  //</span>
 2262 |     | <span class='neutral'>  // and if &#39;left == true&#39;, we calculate:</span>
 2263 |     | <span class='neutral'>  //</span>
 2264 |     | <span class='neutral'>  //        incomingLimit          db</span>
 2265 |     | <span class='neutral'>  //  &#39;---------------------- * --------- * exp(+ qBegin / 2) ==</span>
 2266 |     | <span class='neutral'>  //    (2 ** 216) * exp(-8)     2 ** 59</span>
 2267 |     | <span class='neutral'>  //</span>
 2268 |     | <span class='neutral'>  //    incomingLimit * db * ((2 ** 216) * exp(- 8 + qBegin / 2))</span>
 2269 |     | <span class='neutral'>  //   ----------------------------------------------------------- ==</span>
 2270 |     | <span class='neutral'>  //                  (2 ** (216 + 59)) * exp(-16)</span>
 2271 |     | <span class='neutral'>  //</span>
 2272 |     | <span class='neutral'>  //    incomingLimit * db * _begin_.sqrt(true)</span>
 2273 |     | <span class='neutral'>  //   -----------------------------------------&#39;.</span>
 2274 |     | <span class='neutral'>  //          (2 ** (216 + 59)) * exp(-16)</span>
 2275 |     | <span class='neutral'>  //</span>
 2276 |     | <span class='neutral'>  // The three inputs of &#39;mulDivByExpInv16&#39; are non-negative and overflow is</span>
 2277 |     | <span class='neutral'>  // not possible because</span>
 2278 |     | <span class='neutral'>  //</span>
 2279 |     | <span class='neutral'>  //    incomingLimit * db * _begin_.sqrt(left)</span>
 2280 |     | <span class='neutral'>  //  &#39;----------------------------------------- &lt; </span>
 2281 |     | <span class='neutral'>  //          (2 ** (216 + 59)) * exp(-16)</span>
 2282 |     | <span class='neutral'>  //</span>
 2283 |     | <span class='neutral'>  //    (2 ** 216) * (2 ** 64) * (2 ** 216)</span>
 2284 |     | <span class='neutral'>  //   ------------------------------------- == </span>
 2285 |     | <span class='neutral'>  //       (2 ** (216 + 59)) * exp(-16)</span>
 2286 |     | <span class='neutral'>  //</span>
 2287 |     | <span class='neutral'>  //   32 * exp(16) * oneX216 &lt; 2 ** 256 - 1&#39;.</span>
 2288 |     | <span class='neutral'>  //</span>
 2289 |     | <span class='neutral'>  // Hence, the requirements of &#39;mulDivByExpInv16&#39; are satisfied.</span>
 2290 |     | <span class='neutral'>  //</span>
 2291 |     | <span class='neutral'>  // Additionally, &#39;toX216&#39; does not overflow because</span>
 2292 |     | <span class='neutral'>  //</span>
 2293 |     | <span class='neutral'>  //  &#39;- (2 ** 80) &lt; q1 &lt; + (2 ** 80)&#39;.</span>
 2294 |     | <span class='neutral'>  //</span>
 2295 |     | <span class='neutral'>  // The subtraction is unsafe and may be negative.</span>
 2296 |     | <span class='neutral'>  X216 q0 = </span>
 2297 |     | <span class='neutral'>    q1.toX216() - db.mulDivByExpInv16(_begin_.sqrt(left), incomingLimit);</span>
 2298 |     | <span class='neutral'></span>
 2299 |     | <span class='neutral'>  // The initial value for &#39;x&#39; is calculated here. The subtractions are safe</span>
 2300 |     | <span class='neutral'>  // because as we argued before, if &#39;left == false&#39;, then</span>
 2301 |     | <span class='neutral'>  //</span>
 2302 |     | <span class='neutral'>  //  &#39;qTotal0 &lt;= qBegin &lt;= qTarget &lt;= qTotal1&#39;</span>
 2303 |     | <span class='neutral'>  //</span>
 2304 |     | <span class='neutral'>  // and if &#39;left == true&#39;, then</span>
 2305 |     | <span class='neutral'>  //</span>
 2306 |     | <span class='neutral'>  //  &#39;qTotal1 &lt;= qTarget &lt;= qBegin &lt;= qTotal0&#39;.</span>
 2307 |     | <span class='neutral'>  X59 xLimit = </span>
 2308 |     | <span class='neutral'>    left ? _begin_.log() - _target_.log() : _target_.log() - _begin_.log();</span>
 2309 |     | <span class='neutral'></span>
 2310 |     | <span class='neutral'>  X59 x = xLimit;</span>
 2311 |     | <span class='neutral'>  if (X59.unwrap(xLimit) &lt;= X216.unwrap(incoming)) {</span>
 2312 |     | <span class='neutral'>    // All three inputs of &#39;cheapMulDiv&#39; are non-negative.</span>
 2313 |     | <span class='neutral'>    //</span>
 2314 |     | <span class='neutral'>    // Due to the prior check, &#39;incomingLimit &lt; incoming&#39;. Additionally, due to</span>
 2315 |     | <span class='neutral'>    // the above condition, we have &#39;xLimit &lt;= incoming&#39;. Hence,</span>
 2316 |     | <span class='neutral'>    //</span>
 2317 |     | <span class='neutral'>    //  &#39;xLimit * incomingLimit &lt; incoming * (incoming - 1)&#39;</span>
 2318 |     | <span class='neutral'>    //</span>
 2319 |     | <span class='neutral'>    // and the requirement of &#39;cheapMulDiv&#39; is met.</span>
 2320 |     | <span class='neutral'>    //</span>
 2321 |     | <span class='neutral'>    // Signed comparison is valid because the first term is a positive constant</span>
 2322 |     | <span class='neutral'>    // and the second term is non-negative.</span>
 2323 |     | <span class='neutral'>    x = max(epsilonX59, xLimit.cheapMulDiv(incomingLimit, incoming));</span>
 2324 |     | <span class='neutral'>  }</span>
 2325 |     | <span class='neutral'></span>
 2326 |     | <span class='neutral'>  while (true) {</span>
 2327 |     | <span class='neutral'>    // For each iteration, we evaluate &#39;g(x)&#39; and &#39;h(x)&#39; in &#39;X74&#39; and &#39;X216&#39;</span>
 2328 |     | <span class='neutral'>    // representations, respectively.</span>
 2329 |     | <span class='neutral'>    //</span>
 2330 |     | <span class='neutral'>    // &#39;x.times(dc)&#39; is safe because &#39;x&#39; is not less than &#39;epsilonX59&#39; due to</span>
 2331 |     | <span class='neutral'>    // the above check and we have already checked that &#39;dc&#39; is nonnegative.</span>
 2332 |     | <span class='neutral'>    //</span>
 2333 |     | <span class='neutral'>    // &#39;g.toX216()&#39; is safe because:</span>
 2334 |     | <span class='neutral'>    //</span>
 2335 |     | <span class='neutral'>    //   &#39;- (2 ** 81) &lt; x.times(dc) - q1 &lt; + (2 ** 81)&#39;.</span>
 2336 |     | <span class='neutral'>    //</span>
 2337 |     | <span class='neutral'>    // The input requirements of &#39;expInverse&#39; are satisfied because &#39;x&#39; is not</span>
 2338 |     | <span class='neutral'>    // less than &#39;epsilonX59&#39; and</span>
 2339 |     | <span class='neutral'>    //</span>
 2340 |     | <span class='neutral'>    //  &#39;x &lt;= |_target_.log() - _begin_.log()| &lt; (2 ** 64) / 3&#39;.</span>
 2341 |     | <span class='neutral'>    //</span>
 2342 |     | <span class='neutral'>    // Additionally,</span>
 2343 |     | <span class='neutral'>    //</span>
 2344 |     | <span class='neutral'>    //  &#39;x.expInverse() == (2 ** 256) * exp(- x / (2 ** 60))</span>
 2345 |     | <span class='neutral'>    //                  &gt;= (2 ** 256) * exp(- qSpacing / 2)</span>
 2346 |     | <span class='neutral'>    //                  &gt;= (2 ** 256) * exp(- 16 / 3) &gt; 2 ** 248</span>
 2347 |     | <span class='neutral'>    //</span>
 2348 |     | <span class='neutral'>    // Hence,</span>
 2349 |     | <span class='neutral'>    //</span>
 2350 |     | <span class='neutral'>    //  &#39;(x.expInverse() &gt;&gt; 40) &lt; oneX216&#39;</span>
 2351 |     | <span class='neutral'>    //</span>
 2352 |     | <span class='neutral'>    // which means that casting to &#39;int256&#39; is safe and the product</span>
 2353 |     | <span class='neutral'>    //</span>
 2354 |     | <span class='neutral'>    //  &#39;q0 * X216.wrap(int256(x.expInverse() &gt;&gt; 40))&#39;</span>
 2355 |     | <span class='neutral'>    //</span>
 2356 |     | <span class='neutral'>    // does not overflow.</span>
 2357 |     | <span class='neutral'>    //</span>
 2358 |     | <span class='neutral'>    // However, the addition</span>
 2359 |     | <span class='neutral'>    //</span>
 2360 |     | <span class='neutral'>    //   &#39;h = g.toX216() + q0 * X216.wrap(int256(x.expInverse() &gt;&gt; 40))&#39;</span>
 2361 |     | <span class='neutral'>    //</span>
 2362 |     | <span class='neutral'>    // is unsafe and &#39;h&#39; may be negative.</span>
 2363 |     | <span class='neutral'>    //</span>
 2364 |     | <span class='neutral'>    // On the other hand, the addition &#39;g + q2&#39; is safe and the outcome is</span>
 2365 |     | <span class='neutral'>    // positive because</span>
 2366 |     | <span class='neutral'>    //</span>
 2367 |     | <span class='neutral'>    //   &#39;g(x) := (cTotal1 - cTotal0) * x - q1 + q2</span>
 2368 |     | <span class='neutral'>    //</span>
 2369 |     | <span class='neutral'>    //         == (cTotal1 - cTotal0) * x + </span>
 2370 |     | <span class='neutral'>    //            2 * (cTotal1 - cTotal0) - </span>
 2371 |     | <span class='neutral'>    //            (cTotal1 - cTotal0) * (2 + |qTotal1 - qBegin|) + </span>
 2372 |     | <span class='neutral'>    //            cTotal1 * |qTotal1 - qTotal0|</span>
 2373 |     | <span class='neutral'>    //</span>
 2374 |     | <span class='neutral'>    //         == (cTotal1 - cTotal0) * x + </span>
 2375 |     | <span class='neutral'>    //            cTotal0 * |qTotal1 - qBegin| + </span>
 2376 |     | <span class='neutral'>    //            cTotal1 * (|qTotal1 - qTotal0| - |qTotal1 - qBegin|)</span>
 2377 |     | <span class='neutral'>    //</span>
 2378 |     | <span class='neutral'>    //         &gt; (cTotal1 - cTotal0) * x &gt;= 1 / ((2 ** 15) * (2 ** 59)) &gt; 0&#39;</span>
 2379 |     | <span class='neutral'>    //</span>
 2380 |     | <span class='neutral'>    // where the first inequality is concluded from the fact that, if</span>
 2381 |     | <span class='neutral'>    // &#39;left == false&#39;, then</span>
 2382 |     | <span class='neutral'>    //</span>
 2383 |     | <span class='neutral'>    //  &#39;qTotal0 &lt;= qBegin &lt;= qTarget &lt;= qTotal1&#39;</span>
 2384 |     | <span class='neutral'>    //</span>
 2385 |     | <span class='neutral'>    // and if &#39;left == true&#39;, then</span>
 2386 |     | <span class='neutral'>    //</span>
 2387 |     | <span class='neutral'>    //  &#39;qTotal1 &lt;= qTarget &lt;= qBegin &lt;= qTotal0&#39;.</span>
 2388 |     | <span class='neutral'>    //</span>
 2389 |     | <span class='neutral'>    // Also, &#39;cTotal1 - cTotal0 &gt;= 1 / (2 ** 15)&#39; is concluded from the initial</span>
 2390 |     | <span class='neutral'>    // check for the determination of &#39;exactAmount&#39;, because if</span>
 2391 |     | <span class='neutral'>    // &#39;cTotal1 == cTotal0 == 0&#39;, then we have &#39;exactAmount == false&#39; and this</span>
 2392 |     | <span class='neutral'>    // part of the code would not be reached. Hence, &#39;g&#39; is positive which will</span>
 2393 |     | <span class='neutral'>    // be used later.</span>
 2394 |     | <span class='neutral'>    X74 g = x.times(dc) - q1;</span>
 2395 |     | <span class='neutral'>    X216 h = g.toX216() + q0 * X216.wrap(int256(x.expInverse() &gt;&gt; 40));</span>
 2396 |     | <span class='neutral'>    g = g + q2;</span>
 2397 |     | <span class='neutral'></span>
 2398 |     | <span class='neutral'>    // Next, we calculate the following Halley step:</span>
 2399 |     | <span class='neutral'>    //</span>
 2400 |     | <span class='neutral'>    //                           2 * (h(x) / g(x))</span>
 2401 |     | <span class='neutral'>    //  &#39;step = -----------------------------------------------------&#39;</span>
 2402 |     | <span class='neutral'>    //           1 - (h(x) / g(x)) / 2 - (h(x) / g(x)) * (dc / g(x))</span>
 2403 |     | <span class='neutral'>    //</span>
 2404 |     | <span class='neutral'>    // in &#39;X59&#39; representation.</span>
 2405 |     | <span class='neutral'>    //</span>
 2406 |     | <span class='neutral'>    // The numerator is in &#39;X142&#39; representation.</span>
 2407 |     | <span class='neutral'>    // The denominator is in &#39;X83&#39; representation.</span>
 2408 |     | <span class='neutral'>    X59 step;</span>
 2409 |     | <span class='neutral'>    uint256 denominator;</span>
 2410 |     | <span class='neutral'>    assembly {</span>
 2411 |     | <span class='neutral'>      // The division is safe because &#39;g&#39; is positive as we argued before.</span>
 2412 |     | <span class='neutral'>      let h_over_g_X142 := sdiv(h, g) // h(x) / g(x)</span>
 2413 |     | <span class='neutral'>      denominator := sub(</span>
 2414 |     | <span class='neutral'>        shl(83, 1), // oneX83</span>
 2415 |     | <span class='neutral'>        add(</span>
 2416 |     | <span class='neutral'>          // Here, &#39;h_over_g_X142&#39; is shifted to the right by</span>
 2417 |     | <span class='neutral'>          // &#39;60 == 142 - 83 + 1&#39; bits where &#39;1&#39; appears because we are</span>
 2418 |     | <span class='neutral'>          // dividing by two. &#39;142&#39; appears because we are casting from the </span>
 2419 |     | <span class='neutral'>          // &#39;X142&#39; representation and &#39;83&#39; appears because we are casting to  </span>
 2420 |     | <span class='neutral'>          // the &#39;X83&#39; representation.</span>
 2421 |     | <span class='neutral'>          sar(60, h_over_g_X142), // (h(x) / g(x)) / 2</span>
 2422 |     | <span class='neutral'>          sdiv(mul(h_over_g_X142, dc), g) // (h(x) / g(x)) * (dc / g(x))</span>
 2423 |     | <span class='neutral'>        )</span>
 2424 |     | <span class='neutral'>      ) // 1 - (h(x) / g(x)) / 2 - (h(x) / g(x)) * (dc / g(x))</span>
 2425 |     | <span class='neutral'>      step := sdiv(</span>
 2426 |     | <span class='neutral'>        add(h_over_g_X142, h_over_g_X142), // 2 * (h(x) / g(x))</span>
 2427 |     | <span class='neutral'>        denominator</span>
 2428 |     | <span class='neutral'>      )</span>
 2429 |     | <span class='neutral'>    }</span>
 2430 |     | <span class='neutral'></span>
 2431 |     | <span class='neutral'>    if (step == zeroX59) {</span>
 2432 |     | <span class='neutral'>      require(denominator != 0, SearchingForIncomingTargetFailed());</span>
 2433 |     | <span class='neutral'>      break;</span>
 2434 |     | <span class='neutral'>    }</span>
 2435 |     | <span class='neutral'></span>
 2436 |     | <span class='neutral'>    // The solution is capped by &#39;epsilonX59&#39; and &#39;xLimit&#39;. Hence, we do not</span>
 2437 |     | <span class='neutral'>    // need to argue whether the addition &#39;x - step&#39; is safe or not.</span>
 2438 |     | <span class='neutral'>    x = min(max(epsilonX59, x - step), xLimit);</span>
 2439 |     | <span class='neutral'>  }</span>
 2440 |     | <span class='neutral'></span>
 2441 |     | <span class='neutral'>  // The subtraction and the addition are safe because if &#39;left == false&#39;:</span>
 2442 |     | <span class='neutral'>  //</span>
 2443 |     | <span class='neutral'>  //  &#39;0 &lt; x &lt;= xLimit := qTarget - qBegin&#39;,</span>
 2444 |     | <span class='neutral'>  //</span>
 2445 |     | <span class='neutral'>  // and if &#39;left == true&#39;:</span>
 2446 |     | <span class='neutral'>  //</span>
 2447 |     | <span class='neutral'>  //  &#39;0 &lt; x &lt;= xLimit := qBegin - qTarget&#39;.</span>
 2448 |     | <span class='neutral'>  //</span>
 2449 |     | <span class='neutral'>  x = min(x + epsilonX59, xLimit);</span>
 2450 |     | <span class='neutral'>  x = left ? _begin_.log() - x : _begin_.log() + x;</span>
 2451 |     | <span class='neutral'></span>
 2452 |     | <span class='neutral'>  // The output should be stored in both of the memory spaces that are pointed</span>
 2453 |     | <span class='neutral'>  // to by &#39;_overshoot_&#39; and &#39;_target_&#39;.</span>
 2454 |     | <span class='neutral'>  //</span>
 2455 |     | <span class='neutral'>  // The requirements of &#39;storePrice&#39; and &#39;incoming&#39; are satisfied because</span>
 2456 |     | <span class='neutral'>  //</span>
 2457 |     | <span class='neutral'>  //  &#39;min(qBegin, qTarget) &lt;= x &lt;= max(qBegin, qTarget)&#39;.</span>
 2458 |     | <span class='neutral'>  //</span>
 2459 |     | <span class='neutral'>  _overshoot_.storePrice(x);</span>
 2460 |     | <span class='neutral'></span>
 2461 |     | <span class='neutral'>  // As argued before, if &#39;getDirection() == false&#39;, then</span>
 2462 |     | <span class='neutral'>  //</span>
 2463 |     | <span class='neutral'>  //  &#39;qTotal0 &lt;= qBegin &lt;= qOvershoot &lt;= qTarget &lt;= qTotal1&#39;.</span>
 2464 |     | <span class='neutral'>  //</span>
 2465 |     | <span class='neutral'>  // and if &#39;getDirection() == true&#39;, then</span>
 2466 |     | <span class='neutral'>  //</span>
 2467 |     | <span class='neutral'>  //  &#39;qTotal1 &lt;= qTarget &lt;= qOvershoot &lt;= qBegin &lt;= qTotal0&#39;.</span>
 2468 |     | <span class='neutral'>  //</span>
 2469 |     | <span class='neutral'>  // Additionally, since the vertical coordinates of kernel are monotonic, we</span>
 2470 |     | <span class='neutral'>  // have &#39;cTotal0 &lt;= cTotal1&#39; and the input requirements of &#39;incoming&#39; are</span>
 2471 |     | <span class='neutral'>  // satisfied.</span>
 2472 |     | <span class='neutral'>  incoming = _total0_.incoming(_begin_, _overshoot_);</span>
 2473 |     | <span class='neutral'></span>
 2474 |     | <span class='neutral'>  // &#39;x&#39; is moved backward to ensure that the resulting integral is an under</span>
 2475 |     | <span class='neutral'>  // approximation.</span>
 2476 |     | <span class='neutral'>  while (incoming &gt; incomingLimit) {</span>
 2477 |     | <span class='neutral'>    // All safety requirements are satisfied here, because:</span>
 2478 |     | <span class='neutral'>    //</span>
 2479 |     | <span class='neutral'>    //  &#39;incomingLimit &lt; _total0_.incoming(_begin_, _target_)&#39;.</span>
 2480 |     | <span class='neutral'>    //</span>
 2481 |     | <span class='neutral'>    // Hence, the loop is stopped before we reach &#39;qTarget&#39;.</span>
 2482 |     | <span class='neutral'>    x = left ? x + epsilonX59 : x - epsilonX59;</span>
 2483 |     | <span class='neutral'></span>
 2484 |     | <span class='neutral'>    // Due to the above argument, if &#39;left == false&#39; then</span>
 2485 |     | <span class='neutral'>    //</span>
 2486 |     | <span class='neutral'>    //  &#39;qOvershoot + 1 / (2 ** 59) &lt; qTarget &lt;= qUpper&#39;</span>
 2487 |     | <span class='neutral'>    //</span>
 2488 |     | <span class='neutral'>    // and if &#39;left == true&#39; then</span>
 2489 |     | <span class='neutral'>    //</span>
 2490 |     | <span class='neutral'>    //  &#39;qLower &lt;= qTarget &lt; qOvershoot - 1 / (2 ** 59)&#39;.</span>
 2491 |     | <span class='neutral'>    //</span>
 2492 |     | <span class='neutral'>    // Hence the input requirements of &#39;moveOvershootByEpsilon&#39; are satisfied.</span>
 2493 |     | <span class='neutral'>    moveOvershootByEpsilon(!left);</span>
 2494 |     | <span class='neutral'></span>
 2495 |     | <span class='neutral'>    // As argued before, if &#39;getDirection() == false&#39;, then</span>
 2496 |     | <span class='neutral'>    //</span>
 2497 |     | <span class='neutral'>    //  &#39;qTotal0 &lt;= qBegin &lt;= qOvershoot &lt;= qTarget &lt;= qTotal1&#39;.</span>
 2498 |     | <span class='neutral'>    //</span>
 2499 |     | <span class='neutral'>    // and if &#39;getDirection() == true&#39;, then</span>
 2500 |     | <span class='neutral'>    //</span>
 2501 |     | <span class='neutral'>    //  &#39;qTotal1 &lt;= qTarget &lt;= qOvershoot &lt;= qBegin &lt;= qTotal0&#39;.</span>
 2502 |     | <span class='neutral'>    //</span>
 2503 |     | <span class='neutral'>    // Additionally, since the vertical coordinates of kernel are monotonic, we</span>
 2504 |     | <span class='neutral'>    // have &#39;cTotal0 &lt;= cTotal1&#39; and the input requirements of &#39;incoming&#39; are</span>
 2505 |     | <span class='neutral'>    // satisfied.</span>
 2506 |     | <span class='neutral'>    incoming = _total0_.incoming(_begin_, _overshoot_);</span>
 2507 |     | <span class='neutral'>  }</span>
 2508 |     | <span class='neutral'></span>
 2509 |     | <span class='neutral'>  // The output should be stored in both of the memory spaces that are pointed</span>
 2510 |     | <span class='neutral'>  // to by &#39;_overshoot_&#39; and &#39;_target_&#39;.</span>
 2511 |     | <span class='neutral'>  _target_.copyPrice(_overshoot_);</span>
 2512 |     | <span class='neutral'></span>
 2513 |     | <span class='neutral'>  return (true, incoming);</span>
 2514 |     | <span class='neutral'>}</span>
 2515 |     | <span class='neutral'></span>
 2516 |     | <span class='neutral'>/// @notice Enumerates the pieces of the liquidity distribution function</span>
 2517 |     | <span class='neutral'>/// &#39;k(w(.))&#39; in search for the logarithmic price &#39;qTarget&#39; which satisfies</span>
 2518 |     | <span class='neutral'>/// either of the following two conditions:</span>
 2519 |     | <span class='neutral'>///</span>
 2520 |     | <span class='neutral'>///  - &#39;qLimitWithinInterval == qTarget&#39;, or</span>
 2521 |     | <span class='neutral'>///</span>
 2522 |     | <span class='neutral'>///  - &#39;integralLimit == (</span>
 2523 |     | <span class='neutral'>///       getExactInput() ? incomingCurrentToTarget : currentToTarget</span>
 2524 |     | <span class='neutral'>///     )&#39;.</span>
 2525 |     | <span class='neutral'>///</span>
 2526 |     | <span class='neutral'>/// As explained in &#39;Memory.sol&#39;, the boundaries of the current piece under</span>
 2527 |     | <span class='neutral'>/// exploration is given as:</span>
 2528 |     | <span class='neutral'>///</span>
 2529 |     | <span class='neutral'>///  &#39;qBegin := getDirection() ? </span>
 2530 |     | <span class='neutral'>///             min(q[indexCurve + 2], qTotal0) : </span>
 2531 |     | <span class='neutral'>///             max(q[indexCurve + 2], qTotal0)&#39;,</span>
 2532 |     | <span class='neutral'>///</span>
 2533 |     | <span class='neutral'>///  &#39;qTarget := (</span>
 2534 |     | <span class='neutral'>///                getDirection() == getZeroForOne()</span>
 2535 |     | <span class='neutral'>///              ) ? (</span>
 2536 |     | <span class='neutral'>///                getDirection() ? </span>
 2537 |     | <span class='neutral'>///                max(max(qEnd, qTotal1), qLimitWithinInterval) : </span>
 2538 |     | <span class='neutral'>///                min(min(qEnd, qTotal1), qLimitWithinInterval)</span>
 2539 |     | <span class='neutral'>///              ) : (</span>
 2540 |     | <span class='neutral'>///                getDirection() ? </span>
 2541 |     | <span class='neutral'>///                max(qEnd, qTotal1) : </span>
 2542 |     | <span class='neutral'>///                min(qEnd, qTotal1)</span>
 2543 |     | <span class='neutral'>///              )&#39;.</span>
 2544 |     | <span class='neutral'>///</span>
 2545 |     | <span class='neutral'>/// The present function transitions to the next piece of &#39;k(w(.))&#39; by updating </span>
 2546 |     | <span class='neutral'>/// the appropriate values in memory and by incrementing the following</span>
 2547 |     | <span class='neutral'>/// integrals:</span>
 2548 |     | <span class='neutral'>///  </span>
 2549 |     | <span class='neutral'>///  - &#39;currentToTarget&#39;,</span>
 2550 |     | <span class='neutral'>///</span>
 2551 |     | <span class='neutral'>///  - &#39;incomingCurrentToTarget&#39;,</span>
 2552 |     | <span class='neutral'>///</span>
 2553 |     | <span class='neutral'>///  - &#39;currentToOrigin&#39;,</span>
 2554 |     | <span class='neutral'>///</span>
 2555 |     | <span class='neutral'>///  - &#39;originToOvershoot&#39;.</span>
 2556 |     | <span class='neutral'>///</span>
 2557 |     | <span class='neutral'>/// --------------------------------------------------------------------------- </span>
 2558 |     | <span class='neutral'>///</span>
 2559 |     | <span class='neutral'>/// The underflow of</span>
 2560 |     | <span class='neutral'>///</span>
 2561 |     | <span class='neutral'>///  &#39;getIntegralLimit() - getExactInput() ? </span>
 2562 |     | <span class='neutral'>///                        _incomingCurrentToTarget_.integral() : </span>
 2563 |     | <span class='neutral'>///                        _currentToTarget_.integral()&#39;</span>
 2564 |     | <span class='neutral'>///</span>
 2565 |     | <span class='neutral'>/// should be avoided externally.</span>
 2566 |     | <span class='neutral'>///</span>
 2567 |     | <span class='neutral'>/// Out of range values for &#39;indexKernelTotal&#39; should be avoided externally.</span>
 2568 |     | <span class='neutral'>///</span>
 2569 |     | <span class='neutral'>/// Underflow of &#39;indexCurve&#39; should be avoided externally.</span>
 2570 |     | <span class='neutral'>function moveTarget() pure returns (</span>
 2571 |     | <span class='neutral'>  bool stop</span>
 2572 |     | <span class='neutral'>) {</span>
 2573 |     | <span class='neutral'>  // According to the above definitions for &#39;qBegin&#39; and &#39;qTarget&#39;, if</span>
 2574 |     | <span class='neutral'>  // &#39;getDirection() == false&#39;, then we have:</span>
 2575 |     | <span class='neutral'>  //</span>
 2576 |     | <span class='neutral'>  //  &#39;qTotal0 &lt;= qBegin &lt;= qTarget &lt;= qTotal1&#39;.</span>
 2577 |     | <span class='neutral'>  //</span>
 2578 |     | <span class='neutral'>  // In this case, if &#39;qTarget == qTotal1&#39; as illustrated below,</span>
 2579 |     | <span class='neutral'>  //</span>
 2580 |     | <span class='neutral'>  //      +---------+---------+</span>
 2581 |     | <span class='neutral'>  //      |         |         |</span>
 2582 |     | <span class='neutral'>  //   qTotal0   qBegin    qTotal1</span>
 2583 |     | <span class='neutral'>  //                          |</span>
 2584 |     | <span class='neutral'>  //                       qTarget</span>
 2585 |     | <span class='neutral'>  //</span>
 2586 |     | <span class='neutral'>  // then &#39;indexKernelTotal&#39; is incremented and the next piece of &#39;k(.)&#39; is</span>
 2587 |     | <span class='neutral'>  // loaded and stored in the memory spaces that are pointed to by &#39;_total0_&#39;</span>
 2588 |     | <span class='neutral'>  // and &#39;_total1_&#39;:</span>
 2589 |     | <span class='neutral'>  //</span>
 2590 |     | <span class='neutral'>  //      +---------+---------+-------------------+</span>
 2591 |     | <span class='neutral'>  //                |         |                   |</span>
 2592 |     | <span class='neutral'>  //             qBegin    qTotal0             qTotal1</span>
 2593 |     | <span class='neutral'>  //                          |</span>
 2594 |     | <span class='neutral'>  //                       qTarget</span>
 2595 |     | <span class='neutral'>  //</span>
 2596 |     | <span class='neutral'>  // If &#39;getDirection() == true&#39;, then we have:</span>
 2597 |     | <span class='neutral'>  //</span>
 2598 |     | <span class='neutral'>  //  &#39;qTotal1 &lt;= qTarget &lt;= qBegin &lt;= qTotal0&#39;.</span>
 2599 |     | <span class='neutral'>  //</span>
 2600 |     | <span class='neutral'>  // In this case, if &#39;qTarget == qTotal1&#39; as illustrated below,</span>
 2601 |     | <span class='neutral'>  //</span>
 2602 |     | <span class='neutral'>  //                          +---------+---------+</span>
 2603 |     | <span class='neutral'>  //                          |         |         |</span>
 2604 |     | <span class='neutral'>  //                       qTotal1   qBegin    qTotal0</span>
 2605 |     | <span class='neutral'>  //                          |</span>
 2606 |     | <span class='neutral'>  //                       qTarget</span>
 2607 |     | <span class='neutral'>  //</span>
 2608 |     | <span class='neutral'>  // then &#39;indexKernelTotal&#39; is incremented and the next piece of &#39;k(.)&#39; is</span>
 2609 |     | <span class='neutral'>  // loaded and stored in the memory spaces that are pointed to by &#39;_total0_&#39;</span>
 2610 |     | <span class='neutral'>  // and &#39;_total1_&#39;:</span>
 2611 |     | <span class='neutral'>  //</span>
 2612 |     | <span class='neutral'>  //      +-------------------+---------+---------+</span>
 2613 |     | <span class='neutral'>  //      |                   |         |</span>
 2614 |     | <span class='neutral'>  //   qTotal1             qTotal0   qBegin</span>
 2615 |     | <span class='neutral'>  //                          |</span>
 2616 |     | <span class='neutral'>  //                       qTarget</span>
 2617 |     | <span class='neutral'>  //</span>
 2618 |     | <span class='neutral'>  // Out of range values for &#39;indexKernelTotal&#39; are avoided because of an</span>
 2619 |     | <span class='neutral'>  // input requirement for the present function.</span>
 2620 |     | <span class='neutral'>  if (_target_.log() == _total1_.log()) moveBreakpointTotal();</span>
 2621 |     | <span class='neutral'></span>
 2622 |     | <span class='neutral'>  // The current direction is loaded from memory.</span>
 2623 |     | <span class='neutral'>  bool direction = getDirection();</span>
 2624 |     | <span class='neutral'></span>
 2625 |     | <span class='neutral'>  // According to the above definitions for &#39;qBegin&#39; and &#39;qTarget&#39;, if</span>
 2626 |     | <span class='neutral'>  // &#39;getDirection() == false&#39;, then we have:</span>
 2627 |     | <span class='neutral'>  //</span>
 2628 |     | <span class='neutral'>  //  &#39;q[indexCurve + 2] &lt;= qBegin &lt;= qTarget &lt;= qEnd&#39;.</span>
 2629 |     | <span class='neutral'>  //</span>
 2630 |     | <span class='neutral'>  // In this case, if &#39;qTarget == qEnd&#39; as illustrated below,</span>
 2631 |     | <span class='neutral'>  //</span>
 2632 |     | <span class='neutral'>  //         w(q)</span>
 2633 |     | <span class='neutral'>  //          ^</span>
 2634 |     | <span class='neutral'>  //  spacing |                                              /</span>
 2635 |     | <span class='neutral'>  //          |                                             /</span>
 2636 |     | <span class='neutral'>  //          |                                            /</span>
 2637 |     | <span class='neutral'>  //          |                                           /</span>
 2638 |     | <span class='neutral'>  //          |                                          /</span>
 2639 |     | <span class='neutral'>  //          |                                         /</span>
 2640 |     | <span class='neutral'>  //          |                                        /</span>
 2641 |     | <span class='neutral'>  //          |                                       /</span>
 2642 |     | <span class='neutral'>  //          |                                      /</span>
 2643 |     | <span class='neutral'>  //          |                                     /</span>
 2644 |     | <span class='neutral'>  //          |                                    /</span>
 2645 |     | <span class='neutral'>  //          |\</span>
 2646 |     | <span class='neutral'>  //          | \</span>
 2647 |     | <span class='neutral'>  //          |  \</span>
 2648 |     | <span class='neutral'>  //          |   \</span>
 2649 |     | <span class='neutral'>  //          |    \</span>
 2650 |     | <span class='neutral'>  //          |     \</span>
 2651 |     | <span class='neutral'>  //          |      \</span>
 2652 |     | <span class='neutral'>  //          |       \</span>
 2653 |     | <span class='neutral'>  //          |        \</span>
 2654 |     | <span class='neutral'>  //          |         \</span>
 2655 |     | <span class='neutral'>  //          |          \</span>
 2656 |     | <span class='neutral'>  //          |                                  /</span>
 2657 |     | <span class='neutral'>  //          |                                 /</span>
 2658 |     | <span class='neutral'>  //          |                                /</span>
 2659 |     | <span class='neutral'>  //          |                               /</span>
 2660 |     | <span class='neutral'>  //          |                              /</span>
 2661 |     | <span class='neutral'>  //          |                             /</span>
 2662 |     | <span class='neutral'>  //          |                            /</span>
 2663 |     | <span class='neutral'>  //          |                           /</span>
 2664 |     | <span class='neutral'>  //          |                          /</span>
 2665 |     | <span class='neutral'>  //          |                         /</span>
 2666 |     | <span class='neutral'>  //          |                        /</span>
 2667 |     | <span class='neutral'>  //          |            \</span>
 2668 |     | <span class='neutral'>  //          |             \</span>
 2669 |     | <span class='neutral'>  //          |              \</span>
 2670 |     | <span class='neutral'>  //          |               \</span>
 2671 |     | <span class='neutral'>  //          |                \</span>
 2672 |     | <span class='neutral'>  //          |                 \</span>
 2673 |     | <span class='neutral'>  //          |                  \</span>
 2674 |     | <span class='neutral'>  //          |                   \</span>
 2675 |     | <span class='neutral'>  //          |                    \</span>
 2676 |     | <span class='neutral'>  //          |                     \</span>
 2677 |     | <span class='neutral'>  //          |                      \</span>
 2678 |     | <span class='neutral'>  //        0 +-----------+-----------+-----+-----+-----+-----+&gt; q</span>
 2679 |     | <span class='neutral'>  //                      |           |     |     |</span>
 2680 |     | <span class='neutral'>  //                   qOrigin        |  qBegin  qEnd</span>
 2681 |     | <span class='neutral'>  //                                  |           |</span>
 2682 |     | <span class='neutral'>  //                                  |        qTarget</span>
 2683 |     | <span class='neutral'>  //                                  |</span>
 2684 |     | <span class='neutral'>  //                          q[indexCurve + 2]</span>
 2685 |     | <span class='neutral'>  //</span>
 2686 |     | <span class='neutral'>  // then &#39;indexCurve&#39; is decremented, the direction is flipped and the next</span>
 2687 |     | <span class='neutral'>  // phase of &#39;w(.)&#39; is loaded by setting:</span>
 2688 |     | <span class='neutral'>  //</span>
 2689 |     | <span class='neutral'>  //  &#39;qEnd := q[indexCurve]&#39;</span>
 2690 |     | <span class='neutral'>  //</span>
 2691 |     | <span class='neutral'>  //  &#39;qOrigin := q[indexCurve + 1]&#39;</span>
 2692 |     | <span class='neutral'>  //</span>
 2693 |     | <span class='neutral'>  //  &#39;qBegin := q[indexCurve + 2]&#39;</span>
 2694 |     | <span class='neutral'>  //</span>
 2695 |     | <span class='neutral'>  // which is illustrated as follows:</span>
 2696 |     | <span class='neutral'>  //</span>
 2697 |     | <span class='neutral'>  //         w(q)</span>
 2698 |     | <span class='neutral'>  //          ^</span>
 2699 |     | <span class='neutral'>  //  spacing |                                              /</span>
 2700 |     | <span class='neutral'>  //          |                                             /</span>
 2701 |     | <span class='neutral'>  //          |                                            /</span>
 2702 |     | <span class='neutral'>  //          |                                           /</span>
 2703 |     | <span class='neutral'>  //          |                                          /</span>
 2704 |     | <span class='neutral'>  //          |                                         /</span>
 2705 |     | <span class='neutral'>  //          |                                        /</span>
 2706 |     | <span class='neutral'>  //          |                                       /</span>
 2707 |     | <span class='neutral'>  //          |                                      /</span>
 2708 |     | <span class='neutral'>  //          |                                     /</span>
 2709 |     | <span class='neutral'>  //          |                                    /</span>
 2710 |     | <span class='neutral'>  //          |\</span>
 2711 |     | <span class='neutral'>  //          | \</span>
 2712 |     | <span class='neutral'>  //          |  \</span>
 2713 |     | <span class='neutral'>  //          |   \</span>
 2714 |     | <span class='neutral'>  //          |    \</span>
 2715 |     | <span class='neutral'>  //          |     \</span>
 2716 |     | <span class='neutral'>  //          |      \</span>
 2717 |     | <span class='neutral'>  //          |       \</span>
 2718 |     | <span class='neutral'>  //          |        \</span>
 2719 |     | <span class='neutral'>  //          |         \</span>
 2720 |     | <span class='neutral'>  //          |          \</span>
 2721 |     | <span class='neutral'>  //          |                                  /</span>
 2722 |     | <span class='neutral'>  //          |                                 /</span>
 2723 |     | <span class='neutral'>  //          |                                /</span>
 2724 |     | <span class='neutral'>  //          |                               /</span>
 2725 |     | <span class='neutral'>  //          |                              /</span>
 2726 |     | <span class='neutral'>  //          |                             /</span>
 2727 |     | <span class='neutral'>  //          |                            /</span>
 2728 |     | <span class='neutral'>  //          |                           /</span>
 2729 |     | <span class='neutral'>  //          |                          /</span>
 2730 |     | <span class='neutral'>  //          |                         /</span>
 2731 |     | <span class='neutral'>  //          |                        /</span>
 2732 |     | <span class='neutral'>  //          |            \</span>
 2733 |     | <span class='neutral'>  //          |             \</span>
 2734 |     | <span class='neutral'>  //          |              \</span>
 2735 |     | <span class='neutral'>  //          |               \</span>
 2736 |     | <span class='neutral'>  //          |                \</span>
 2737 |     | <span class='neutral'>  //          |                 \</span>
 2738 |     | <span class='neutral'>  //          |                  \</span>
 2739 |     | <span class='neutral'>  //          |                   \</span>
 2740 |     | <span class='neutral'>  //          |                    \</span>
 2741 |     | <span class='neutral'>  //          |                     \</span>
 2742 |     | <span class='neutral'>  //          |                      \</span>
 2743 |     | <span class='neutral'>  //        0 +-----------+-----------+-----------+-----------+&gt; q</span>
 2744 |     | <span class='neutral'>  //          |           |                       |</span>
 2745 |     | <span class='neutral'>  //        qEnd       qBegin                  qOrigin</span>
 2746 |     | <span class='neutral'>  //                      |                       |</span>
 2747 |     | <span class='neutral'>  //              q[indexCurve + 2]            qTarget</span>
 2748 |     | <span class='neutral'>  //</span>
 2749 |     | <span class='neutral'>  // If &#39;getDirection() == true&#39;, then we have:</span>
 2750 |     | <span class='neutral'>  //</span>
 2751 |     | <span class='neutral'>  //  &#39;qEnd &lt;= qTarget &lt;= qBegin &lt;= q[indexCurve + 2]&#39;.</span>
 2752 |     | <span class='neutral'>  //</span>
 2753 |     | <span class='neutral'>  // and a similar argument can be made.</span>
 2754 |     | <span class='neutral'>  if (_target_.log() == _end_.log()) {</span>
 2755 |     | <span class='neutral'>    // Once we move the phase, the direction flips and &#39;qOrigin&#39; will be moved</span>
 2756 |     | <span class='neutral'>    // to &#39;qEnd&#39;. Hence, the following integral</span>
 2757 |     | <span class='neutral'>    //</span>
 2758 |     | <span class='neutral'>    //                             - 8</span>
 2759 |     | <span class='neutral'>    //    originToOvershoot      e</span>
 2760 |     | <span class='neutral'>    //  &#39;------------------- == ------- * (</span>
 2761 |     | <span class='neutral'>    //        2 ** 216             2</span>
 2762 |     | <span class='neutral'>    //</span>
 2763 |     | <span class='neutral'>    //     getZeroForOne() ? </span>
 2764 |     | <span class='neutral'>    //</span>
 2765 |     | <span class='neutral'>    //       / qOrigin</span>
 2766 |     | <span class='neutral'>    //      |    + h / 2</span>
 2767 |     | <span class='neutral'>    //      |  e         k(qOrigin - h) dh :</span>
 2768 |     | <span class='neutral'>    //      |</span>
 2769 |     | <span class='neutral'>    //     / qEnd</span>
 2770 |     | <span class='neutral'>    //</span>
 2771 |     | <span class='neutral'>    //       / qEnd</span>
 2772 |     | <span class='neutral'>    //      |    - h / 2</span>
 2773 |     | <span class='neutral'>    //      |  e         k(h - qOrigin) dh</span>
 2774 |     | <span class='neutral'>    //      |</span>
 2775 |     | <span class='neutral'>    //     / qOrigin</span>
 2776 |     | <span class='neutral'>    //</span>
 2777 |     | <span class='neutral'>    //   )&#39;</span>
 2778 |     | <span class='neutral'>    //</span>
 2779 |     | <span class='neutral'>    // should be transformed to</span>
 2780 |     | <span class='neutral'>    //</span>
 2781 |     | <span class='neutral'>    //                             - 8</span>
 2782 |     | <span class='neutral'>    //    originToOvershoot      e</span>
 2783 |     | <span class='neutral'>    //  &#39;------------------- := ------- * (</span>
 2784 |     | <span class='neutral'>    //        2 ** 216             2</span>
 2785 |     | <span class='neutral'>    //</span>
 2786 |     | <span class='neutral'>    //     getZeroForOne() ? </span>
 2787 |     | <span class='neutral'>    //</span>
 2788 |     | <span class='neutral'>    //       / qOrigin</span>
 2789 |     | <span class='neutral'>    //      |    - h / 2</span>
 2790 |     | <span class='neutral'>    //      |  e         k(h - qEnd) dh :</span>
 2791 |     | <span class='neutral'>    //      |</span>
 2792 |     | <span class='neutral'>    //     / qEnd</span>
 2793 |     | <span class='neutral'>    //</span>
 2794 |     | <span class='neutral'>    //       / qEnd</span>
 2795 |     | <span class='neutral'>    //      |    + h / 2</span>
 2796 |     | <span class='neutral'>    //      |  e         k(qEnd - h) dh</span>
 2797 |     | <span class='neutral'>    //      |</span>
 2798 |     | <span class='neutral'>    //     / qOrigin</span>
 2799 |     | <span class='neutral'>    //</span>
 2800 |     | <span class='neutral'>    //   )&#39;</span>
 2801 |     | <span class='neutral'>    //</span>
 2802 |     | <span class='neutral'>    // Notice that at this stage &#39;overshoot&#39; and &#39;target&#39; are equal.</span>
 2803 |     | <span class='neutral'>    //</span>
 2804 |     | <span class='neutral'>    // The loaded integral does not exceed 216-bits and hence, the input</span>
 2805 |     | <span class='neutral'>    // requirement of shift is satisfied.</span>
 2806 |     | <span class='neutral'>    _originToOvershoot_.setIntegral(</span>
 2807 |     | <span class='neutral'>      _originToOvershoot_.integral().shift(_target_, _origin_, direction)</span>
 2808 |     | <span class='neutral'>    );</span>
 2809 |     | <span class='neutral'></span>
 2810 |     | <span class='neutral'>    // Underflow of &#39;indexCurve&#39; is avoided externally via an input requirement</span>
 2811 |     | <span class='neutral'>    // of the present function.</span>
 2812 |     | <span class='neutral'>    direction = movePhase();</span>
 2813 |     | <span class='neutral'>  }</span>
 2814 |     | <span class='neutral'></span>
 2815 |     | <span class='neutral'>  // If the phase is moved, then we have:</span>
 2816 |     | <span class='neutral'>  //</span>
 2817 |     | <span class='neutral'>  //  &#39;qBegin == q[indexCurve + 2]&#39;.</span>
 2818 |     | <span class='neutral'>  //</span>
 2819 |     | <span class='neutral'>  // If the phase is not moved, then the kernel piece is moved and we have:</span>
 2820 |     | <span class='neutral'>  //</span>
 2821 |     | <span class='neutral'>  //  &#39;qBegin &lt;= qTarget == qTotal0&#39;.</span>
 2822 |     | <span class='neutral'>  //</span>
 2823 |     | <span class='neutral'>  // In both cases, we need to set:</span>
 2824 |     | <span class='neutral'>  //</span>
 2825 |     | <span class='neutral'>  //  &#39;qBegin := direction ? min(qBegin, qTotal0) : max(qBegin, qTotal0)&#39;</span>
 2826 |     | <span class='neutral'>  //</span>
 2827 |     | <span class='neutral'>  // which is equivalent to setting:</span>
 2828 |     | <span class='neutral'>  //</span>
 2829 |     | <span class='neutral'>  //  &#39;qBegin := qTotal0&#39;</span>
 2830 |     | <span class='neutral'>  //</span>
 2831 |     | <span class='neutral'>  // if and only if &#39;direction != (qBegin &lt; qTotal0)&#39;.</span>
 2832 |     | <span class='neutral'>  //</span>
 2833 |     | <span class='neutral'>  // Signed comparison is valid because as we argued before in this script,</span>
 2834 |     | <span class='neutral'>  // both &#39;qBegin&#39; and &#39;qTotal0&#39; are greater than &#39;0&#39; and less than &#39;32&#39;. This</span>
 2835 |     | <span class='neutral'>  // is due to the custom error &#39;BlankIntervalsShouldBeAvoided&#39; ensures that</span>
 2836 |     | <span class='neutral'>  // &#39;16 + qLower&#39; is greater than &#39;qSpacing&#39; and &#39;16 + qUpper&#39; is smaller than</span>
 2837 |     | <span class='neutral'>  // &#39;32 - qSpacing&#39;.</span>
 2838 |     | <span class='neutral'>  if (direction != (_begin_.log() &lt; _total0_.log())) {</span>
 2839 |     | <span class='neutral'>    _begin_.copyPrice(_total0_);</span>
 2840 |     | <span class='neutral'>  }</span>
 2841 |     | <span class='neutral'></span>
 2842 |     | <span class='neutral'>  // Next, we need to set:</span>
 2843 |     | <span class='neutral'>  //</span>
 2844 |     | <span class='neutral'>  //  &#39;qTarget := direction ? min(qEnd, qTotal1) : max(qEnd, qTotal1)&#39;</span>
 2845 |     | <span class='neutral'>  //</span>
 2846 |     | <span class='neutral'>  // which is equivalent to setting:</span>
 2847 |     | <span class='neutral'>  //</span>
 2848 |     | <span class='neutral'>  //  &#39;qTarget := qTotal1&#39;</span>
 2849 |     | <span class='neutral'>  //</span>
 2850 |     | <span class='neutral'>  // if and only if &#39;direction == (qEnd &lt;= qTotal1)&#39; and</span>
 2851 |     | <span class='neutral'>  //</span>
 2852 |     | <span class='neutral'>  //  &#39;qTarget := qEnd&#39;</span>
 2853 |     | <span class='neutral'>  //</span>
 2854 |     | <span class='neutral'>  // otherwise.</span>
 2855 |     | <span class='neutral'>  //</span>
 2856 |     | <span class='neutral'>  // Signed comparison is valid because as we argued before in this script,</span>
 2857 |     | <span class='neutral'>  // both &#39;qEnd&#39; and &#39;qTotal1&#39; are greater than &#39;0&#39; and less than &#39;32&#39;. This</span>
 2858 |     | <span class='neutral'>  // is due to the custom error &#39;BlankIntervalsShouldBeAvoided&#39; ensures that</span>
 2859 |     | <span class='neutral'>  // &#39;16 + qLower&#39; is greater than &#39;qSpacing&#39; and &#39;16 + qUpper&#39; is smaller than</span>
 2860 |     | <span class='neutral'>  // &#39;32 - qSpacing&#39;.</span>
 2861 |     | <span class='neutral'>  _target_.copyPrice(</span>
 2862 |     | <span class='neutral'>    (direction == (_end_.log() &lt;= _total1_.log())) ? _total1_ : _end_</span>
 2863 |     | <span class='neutral'>  );</span>
 2864 |     | <span class='neutral'></span>
 2865 |     | <span class='neutral'>  // Next, if &#39;direction == getZeroForOne()&#39;, we increment the integrals:</span>
 2866 |     | <span class='neutral'>  //</span>
 2867 |     | <span class='neutral'>  //  - &#39;currentToTarget&#39;,</span>
 2868 |     | <span class='neutral'>  //  - &#39;incomingCurrentToTarget&#39;,</span>
 2869 |     | <span class='neutral'>  //</span>
 2870 |     | <span class='neutral'>  // and search for &#39;qTarget&#39;. Otherwise, we increment the integral:</span>
 2871 |     | <span class='neutral'>  //</span>
 2872 |     | <span class='neutral'>  //  - &#39;currentToOrigin&#39;</span>
 2873 |     | <span class='neutral'>  //</span>
 2874 |     | <span class='neutral'>  // and in both cases we increment &#39;originToOvershoot&#39; as well.</span>
 2875 |     | <span class='neutral'>  X216 outgoing;</span>
 2876 |     | <span class='neutral'>  if (direction == getZeroForOne()) {</span>
 2877 |     | <span class='neutral'>    // &#39;qLimitWithinInterval&#39; is loaded from the memory.</span>
 2878 |     | <span class='neutral'>    X59 logPriceLimitOffsettedWithinInterval = </span>
 2879 |     | <span class='neutral'>      getLogPriceLimitOffsettedWithinInterval();</span>
 2880 |     | <span class='neutral'></span>
 2881 |     | <span class='neutral'>    // If &#39;qTarget&#39; encounters &#39;qLimitWithinInterval&#39;, then we set &#39;qTarget&#39; as</span>
 2882 |     | <span class='neutral'>    // &#39;qLimitWithinInterval&#39;.</span>
 2883 |     | <span class='neutral'>    //</span>
 2884 |     | <span class='neutral'>    // Signed comparison is valid as we argued before.</span>
 2885 |     | <span class='neutral'>    if (direction != (logPriceLimitOffsettedWithinInterval &lt; _target_.log())) {</span>
 2886 |     | <span class='neutral'>      // &#39;_target_&#39; is a constant value which satisfies the input requirement</span>
 2887 |     | <span class='neutral'>      // of &#39;storePrice&#39;.</span>
 2888 |     | <span class='neutral'>      //</span>
 2889 |     | <span class='neutral'>      // Also we have: </span>
 2890 |     | <span class='neutral'>      //</span>
 2891 |     | <span class='neutral'>      //  &#39;0 &lt; qLower &lt;= qLimitWithinInterval &lt;= qUpper &lt; 2 ** 64&#39;</span>
 2892 |     | <span class='neutral'>      //</span>
 2893 |     | <span class='neutral'>      // which means that &#39;logPriceLimitOffsettedWithinInterval&#39; satisfies the</span>
 2894 |     | <span class='neutral'>      // input requirement of &#39;storePrice&#39;.</span>
 2895 |     | <span class='neutral'>      _target_.storePrice(logPriceLimitOffsettedWithinInterval);</span>
 2896 |     | <span class='neutral'>    }</span>
 2897 |     | <span class='neutral'></span>
 2898 |     | <span class='neutral'>    X216 incoming;</span>
 2899 |     | <span class='neutral'>    // Check if &#39;amountSpecified&#39; is incoming or outgoing.</span>
 2900 |     | <span class='neutral'>    if (getExactInput()) {</span>
 2901 |     | <span class='neutral'>      // In this case, we search for a &#39;qTarget&#39; which satisfies</span>
 2902 |     | <span class='neutral'>      //</span>
 2903 |     | <span class='neutral'>      //                              - 8     / qTarget</span>
 2904 |     | <span class='neutral'>      //    getIntegralLimit()      e        |    + h / 2</span>
 2905 |     | <span class='neutral'>      //  &#39;-------------------- == ------- * |  e         k(w(h)) dh&#39;,</span>
 2906 |     | <span class='neutral'>      //         2 ** 216             2      |</span>
 2907 |     | <span class='neutral'>      //                                    / qCurrent</span>
 2908 |     | <span class='neutral'>      //</span>
 2909 |     | <span class='neutral'>      // if &#39;zeroForOne == false&#39; and satisfies:</span>
 2910 |     | <span class='neutral'>      //</span>
 2911 |     | <span class='neutral'>      //                              - 8     / qCurrent</span>
 2912 |     | <span class='neutral'>      //    getIntegralLimit()      e        |    - h / 2</span>
 2913 |     | <span class='neutral'>      //  &#39;-------------------- == ------- * |  e         k(w(h)) dh&#39;,</span>
 2914 |     | <span class='neutral'>      //         2 ** 216             2      |</span>
 2915 |     | <span class='neutral'>      //                                    / qTarget</span>
 2916 |     | <span class='neutral'>      //</span>
 2917 |     | <span class='neutral'>      // if &#39;zeroForOne == true&#39;. If no solution exists, then the integral</span>
 2918 |     | <span class='neutral'>      // within the whole range from &#39;min(qCurrent, qTarget)&#39; to</span>
 2919 |     | <span class='neutral'>      // &#39;max(qCurrent, qTarget)&#39; is calculated to be used as an increment to</span>
 2920 |     | <span class='neutral'>      // update &#39;incomingCurrentToTarget&#39;.</span>
 2921 |     | <span class='neutral'>      //</span>
 2922 |     | <span class='neutral'>      // The input requirement &#39;getDirection() == getZeroForOne()&#39; is checked</span>
 2923 |     | <span class='neutral'>      // by the above &#39;if&#39;.</span>
 2924 |     | <span class='neutral'>      //</span>
 2925 |     | <span class='neutral'>      // The underflow of</span>
 2926 |     | <span class='neutral'>      //</span>
 2927 |     | <span class='neutral'>      //  &#39;getIntegralLimit() - _incomingCurrentToTarget_.integral()&#39;</span>
 2928 |     | <span class='neutral'>      //</span>
 2929 |     | <span class='neutral'>      // is not possible because of the input requirement of the present</span>
 2930 |     | <span class='neutral'>      // function.</span>
 2931 |     | <span class='neutral'>      (stop, incoming) = searchIncomingTarget();</span>
 2932 |     | <span class='neutral'></span>
 2933 |     | <span class='neutral'>      // As argued before, if &#39;getDirection() == false&#39;, then</span>
 2934 |     | <span class='neutral'>      //</span>
 2935 |     | <span class='neutral'>      //  &#39;qTotal0 &lt;= qBegin &lt;= qTarget &lt;= qTotal1&#39;.</span>
 2936 |     | <span class='neutral'>      //</span>
 2937 |     | <span class='neutral'>      // and if &#39;getDirection() == true&#39;, then</span>
 2938 |     | <span class='neutral'>      //</span>
 2939 |     | <span class='neutral'>      //  &#39;qTotal1 &lt;= qTarget &lt;= qBegin &lt;= qTotal0&#39;.</span>
 2940 |     | <span class='neutral'>      //</span>
 2941 |     | <span class='neutral'>      // Additionally, since the vertical coordinates of kernel are monotonic,</span>
 2942 |     | <span class='neutral'>      // we have &#39;cTotal0 &lt;= cTotal1&#39; and the input requirements of &#39;outgoing&#39;</span>
 2943 |     | <span class='neutral'>      // are satisfied.</span>
 2944 |     | <span class='neutral'>      outgoing = _total0_.outgoing(_begin_, _target_);</span>
 2945 |     | <span class='neutral'>    } else {</span>
 2946 |     | <span class='neutral'>      // In this case, we search for a &#39;qTarget&#39; which satisfies</span>
 2947 |     | <span class='neutral'>      //</span>
 2948 |     | <span class='neutral'>      //                              - 8     / qTarget</span>
 2949 |     | <span class='neutral'>      //    getIntegralLimit()      e        |    - h / 2</span>
 2950 |     | <span class='neutral'>      //  &#39;-------------------- == ------- * |  e         k(w(h)) dh&#39;,</span>
 2951 |     | <span class='neutral'>      //         2 ** 216             2      |</span>
 2952 |     | <span class='neutral'>      //                                    / qCurrent</span>
 2953 |     | <span class='neutral'>      //</span>
 2954 |     | <span class='neutral'>      // if &#39;zeroForOne == false&#39; and satisfies:</span>
 2955 |     | <span class='neutral'>      //</span>
 2956 |     | <span class='neutral'>      //                              - 8     / qCurrent</span>
 2957 |     | <span class='neutral'>      //    getIntegralLimit()      e        |    + h / 2</span>
 2958 |     | <span class='neutral'>      //  &#39;-------------------- == ------- * |  e         k(w(h)) dh&#39;,</span>
 2959 |     | <span class='neutral'>      //         2 ** 216             2      |</span>
 2960 |     | <span class='neutral'>      //                                    / qTarget</span>
 2961 |     | <span class='neutral'>      //</span>
 2962 |     | <span class='neutral'>      // if &#39;zeroForOne == true&#39;. If no solution exists, then the integral</span>
 2963 |     | <span class='neutral'>      // within the whole range from &#39;min(qCurrent, qTarget)&#39; to</span>
 2964 |     | <span class='neutral'>      // &#39;max(qCurrent, qTarget)&#39; is calculated to be used as an increment to</span>
 2965 |     | <span class='neutral'>      // update &#39;currentToTarget&#39;.</span>
 2966 |     | <span class='neutral'>      //</span>
 2967 |     | <span class='neutral'>      // The input requirement &#39;getDirection() == getZeroForOne()&#39; is checked</span>
 2968 |     | <span class='neutral'>      // by the above &#39;if&#39;.</span>
 2969 |     | <span class='neutral'>      //</span>
 2970 |     | <span class='neutral'>      // The underflow of</span>
 2971 |     | <span class='neutral'>      //</span>
 2972 |     | <span class='neutral'>      //  &#39;getIntegralLimit() - _currentToTarget_.integral()&#39;</span>
 2973 |     | <span class='neutral'>      //</span>
 2974 |     | <span class='neutral'>      // is not possible because of the input requirement of the present</span>
 2975 |     | <span class='neutral'>      // function.</span>
 2976 |     | <span class='neutral'>      (stop, outgoing) = searchOutgoingTarget();</span>
 2977 |     | <span class='neutral'></span>
 2978 |     | <span class='neutral'>      // As argued before, if &#39;getDirection() == false&#39;, then</span>
 2979 |     | <span class='neutral'>      //</span>
 2980 |     | <span class='neutral'>      //  &#39;qTotal0 &lt;= qBegin &lt;= qTarget &lt;= qTotal1&#39;.</span>
 2981 |     | <span class='neutral'>      //</span>
 2982 |     | <span class='neutral'>      // and if &#39;getDirection() == true&#39;, then</span>
 2983 |     | <span class='neutral'>      //</span>
 2984 |     | <span class='neutral'>      //  &#39;qTotal1 &lt;= qTarget &lt;= qBegin &lt;= qTotal0&#39;.</span>
 2985 |     | <span class='neutral'>      //</span>
 2986 |     | <span class='neutral'>      // Additionally, since the vertical coordinates of kernel are monotonic,</span>
 2987 |     | <span class='neutral'>      // we have &#39;cTotal0 &lt;= cTotal1&#39; and the input requirements of &#39;incoming&#39;</span>
 2988 |     | <span class='neutral'>      // are satisfied.</span>
 2989 |     | <span class='neutral'>      incoming = _total0_.incoming(_begin_, _target_);</span>
 2990 |     | <span class='neutral'>    }</span>
 2991 |     | <span class='neutral'></span>
 2992 |     | <span class='neutral'>    // Next, &#39;currentToTarget&#39; is incremented with &#39;outgoing&#39;.</span>
 2993 |     | <span class='neutral'>    //</span>
 2994 |     | <span class='neutral'>    //                   - 8     / qTarget</span>
 2995 |     | <span class='neutral'>    //                 e        |    - h / 2</span>
 2996 |     | <span class='neutral'>    //  &#39;(2 ** 216) * ------- * |  e         k(w(h)) dh   &lt;</span>
 2997 |     | <span class='neutral'>    //                   2      |</span>
 2998 |     | <span class='neutral'>    //                         / qCurrent</span>
 2999 |     | <span class='neutral'>    //</span>
 3000 |     | <span class='neutral'>    //                   - 8     / +16</span>
 3001 |     | <span class='neutral'>    //                 e        |    - h / 2</span>
 3002 |     | <span class='neutral'>    //   (2 ** 216) * ------- * |  e         dh   &lt;   2 ** 216 - 1.</span>
 3003 |     | <span class='neutral'>    //                   2      |</span>
 3004 |     | <span class='neutral'>    //                         / -16</span>
 3005 |     | <span class='neutral'>    //</span>
 3006 |     | <span class='neutral'>    // Based on the above inequality, overflow is not possible because</span>
 3007 |     | <span class='neutral'>    // theoretically, no outgoing or incoming integral may exceed 216 bits.</span>
 3008 |     | <span class='neutral'>    _currentToTarget_.incrementIntegral(outgoing);</span>
 3009 |     | <span class='neutral'></span>
 3010 |     | <span class='neutral'>    // Next, &#39;incomingCurrentToTarget&#39; is incremented with &#39;incoming&#39;.</span>
 3011 |     | <span class='neutral'>    // Based on the above argument, overflow is not possible because</span>
 3012 |     | <span class='neutral'>    // theoretically, no outgoing or incoming integral may exceed 216 bits.</span>
 3013 |     | <span class='neutral'>    _incomingCurrentToTarget_.incrementIntegral(incoming);</span>
 3014 |     | <span class='neutral'>  } else {</span>
 3015 |     | <span class='neutral'>    // As argued before, if &#39;getDirection() == false&#39;, then</span>
 3016 |     | <span class='neutral'>    //</span>
 3017 |     | <span class='neutral'>    //  &#39;qTotal0 &lt;= qBegin &lt;= qTarget &lt;= qTotal1&#39;.</span>
 3018 |     | <span class='neutral'>    //</span>
 3019 |     | <span class='neutral'>    // and if &#39;getDirection() == true&#39;, then</span>
 3020 |     | <span class='neutral'>    //</span>
 3021 |     | <span class='neutral'>    //  &#39;qTotal1 &lt;= qTarget &lt;= qBegin &lt;= qTotal0&#39;.</span>
 3022 |     | <span class='neutral'>    //</span>
 3023 |     | <span class='neutral'>    // Additionally, since the vertical coordinates of kernel are monotonic,</span>
 3024 |     | <span class='neutral'>    // we have &#39;cTotal0 &lt;= cTotal1&#39; and the input requirements of &#39;outgoing&#39;</span>
 3025 |     | <span class='neutral'>    // are satisfied.</span>
 3026 |     | <span class='neutral'>    outgoing = _total0_.outgoing(_begin_, _target_);</span>
 3027 |     | <span class='neutral'></span>
 3028 |     | <span class='neutral'>    // Next, &#39;currentToOrigin&#39; is incremented with &#39;outgoing&#39;.</span>
 3029 |     | <span class='neutral'>    // Based on the above argument, overflow is not possible because</span>
 3030 |     | <span class='neutral'>    // theoretically, no outgoing or incoming integral may exceed 216 bits.</span>
 3031 |     | <span class='neutral'>    _currentToOrigin_.incrementIntegral(outgoing);</span>
 3032 |     | <span class='neutral'>  }</span>
 3033 |     | <span class='neutral'></span>
 3034 |     | <span class='neutral'>  // In both cases, (i.e. regardless of &#39;direction == getZeroForOne()&#39;) the</span>
 3035 |     | <span class='neutral'>  // integral &#39;originToOvershoot&#39; should be incremented with &#39;outgoing&#39;.</span>
 3036 |     | <span class='neutral'>  // Based on the above argument, overflow is not possible because</span>
 3037 |     | <span class='neutral'>  // theoretically, no outgoing or incoming integral may exceed 216 bits.</span>
 3038 |     | <span class='neutral'>  _originToOvershoot_.incrementIntegral(outgoing);</span>
 3039 |     | <span class='neutral'>}</span>
 3040 |     | <span class='neutral'></span>
 3041 |     | <span class='neutral'>/// @notice Calculates &#39;outgoingMax&#39;, &#39;incomingMax&#39;, and</span>
 3042 |     | <span class='neutral'>/// &#39;outgoingMaxModularInverse&#39;, and sets each in the dedicated memory space.</span>
 3043 |     | <span class='neutral'>///</span>
 3044 |     | <span class='neutral'>/// &#39;outgoingMax&#39; is calculated based on the formula:</span>
 3045 |     | <span class='neutral'>///</span>
 3046 |     | <span class='neutral'>///                       - 8 + qLower / 2     / qUpper</span>
 3047 |     | <span class='neutral'>///    outgoingMax      e                     |    - h / 2</span>
 3048 |     | <span class='neutral'>///  &#39;------------- := -------------------- * |  e         k(h - qLower) dh</span>
 3049 |     | <span class='neutral'>///     2 ** 216                 2            |</span>
 3050 |     | <span class='neutral'>///                                          / qLower</span>
 3051 |     | <span class='neutral'>///</span>
 3052 |     | <span class='neutral'>///                          - 8     / qSpacing + qEpsilon</span>
 3053 |     | <span class='neutral'>///        qEpsilon / 2    e        |                        - h / 2</span>
 3054 |     | <span class='neutral'>///   == e              * ------- * |    k(h - qEpsilon) * e         dh&#39;</span>
 3055 |     | <span class='neutral'>///                          2      |</span>
 3056 |     | <span class='neutral'>///                                / qEpsilon</span>
 3057 |     | <span class='neutral'>///</span>
 3058 |     | <span class='neutral'>/// and &#39;incomingMax&#39; is calculated based on the formula:</span>
 3059 |     | <span class='neutral'>///</span>
 3060 |     | <span class='neutral'>///                       - 8 - qUpper / 2     / qUpper</span>
 3061 |     | <span class='neutral'>///    incomingMax      e                     |    + h / 2</span>
 3062 |     | <span class='neutral'>///  &#39;------------- := -------------------- * |  e         k(h - qLower) dh</span>
 3063 |     | <span class='neutral'>///     2 ** 216                 2            |</span>
 3064 |     | <span class='neutral'>///                                          / qLower</span>
 3065 |     | <span class='neutral'>///</span>
 3066 |     | <span class='neutral'>///        - (qSpacing + qEpsilon) / 2</span>
 3067 |     | <span class='neutral'>///   == e                             *</span>
 3068 |     | <span class='neutral'>///</span>
 3069 |     | <span class='neutral'>///         - 8     / qSpacing + qEpsilon</span>
 3070 |     | <span class='neutral'>///       e        |                        + h / 2</span>
 3071 |     | <span class='neutral'>///      ------- * |    k(h - qEpsilon) * e         dh&#39;.</span>
 3072 |     | <span class='neutral'>///         2      |</span>
 3073 |     | <span class='neutral'>///               / qEpsilon</span>
 3074 |     | <span class='neutral'>///</span>
 3075 |     | <span class='neutral'>/// where &#39;qEpsilon := - 16 + 1 / (2 ** 59)&#39;.</span>
 3076 |     | <span class='neutral'>///</span>
 3077 |     | <span class='neutral'>/// Let &#39;2 ** n&#39; be the largest power of &#39;2&#39; that divides &#39;outgoingMax&#39; and</span>
 3078 |     | <span class='neutral'>/// define &#39;outgoingMaxModularInverse&#39; as the modular inverse of </span>
 3079 |     | <span class='neutral'>/// </span>
 3080 |     | <span class='neutral'>///    outgoingMax</span>
 3081 |     | <span class='neutral'>///  &#39;-------------&#39;</span>
 3082 |     | <span class='neutral'>///      2 ** n</span>
 3083 |     | <span class='neutral'>///</span>
 3084 |     | <span class='neutral'>/// modulo &#39;2 ** 256&#39;.</span>
 3085 |     | <span class='neutral'>function calculateMaxIntegrals() pure {</span>
 3086 |     | <span class='neutral'>  // In order to calculate &#39;outgoingMax&#39; and &#39;incomingMax&#39; we need to create</span>
 3087 |     | <span class='neutral'>  // the following curve sequence in memory:</span>
 3088 |     | <span class='neutral'>  //</span>
 3089 |     | <span class='neutral'>  //  &#39;q[0] := qSpacing + qEpsilon&#39;,</span>
 3090 |     | <span class='neutral'>  //  &#39;q[1] := qEpsilon&#39;,</span>
 3091 |     | <span class='neutral'>  //</span>
 3092 |     | <span class='neutral'>  // which we refer to as &#39;toyCurve&#39;.</span>
 3093 |     | <span class='neutral'></span>
 3094 |     | <span class='neutral'>  // To this end, we first cache the memory pointer for the current curve</span>
 3095 |     | <span class='neutral'>  // sequence and the current &#39;curveLength&#39; from the memory.</span>
 3096 |     | <span class='neutral'>  Curve curve = getCurve();</span>
 3097 |     | <span class='neutral'>  Index curveLength = getCurveLength();</span>
 3098 |     | <span class='neutral'></span>
 3099 |     | <span class='neutral'>  // Next, a plain curve is constructed in the first slot of the memory so that</span>
 3100 |     | <span class='neutral'>  // &#39;outgoingMax&#39; and &#39;incomingMax&#39; can be calculated.</span>
 3101 |     | <span class='neutral'>  //</span>
 3102 |     | <span class='neutral'>  // The first member of &#39;toyCurve&#39; is set as:</span>
 3103 |     | <span class='neutral'>  //</span>
 3104 |     | <span class='neutral'>  //  &#39;qLimit := qSpacing + 1 / (2 ** 59)&#39;.</span>
 3105 |     | <span class='neutral'>  //</span>
 3106 |     | <span class='neutral'>  // The addition is safe because as we argued before in this script:</span>
 3107 |     | <span class='neutral'>  //</span>
 3108 |     | <span class='neutral'>  //  &#39;qSpacing &lt; (2 ** 64) / 3&#39;.</span>
 3109 |     | <span class='neutral'>  //</span>
 3110 |     | <span class='neutral'>  X59 qLimit = _spacing_.log() + epsilonX59;</span>
 3111 |     | <span class='neutral'>  {</span>
 3112 |     | <span class='neutral'>    // A new pointer is initialized and set in memory.</span>
 3113 |     | <span class='neutral'>    Curve toyCurve;</span>
 3114 |     | <span class='neutral'>    setCurve(toyCurve);</span>
 3115 |     | <span class='neutral'></span>
 3116 |     | <span class='neutral'>    // Both inputs are positive and less than &#39;thirtyTwoX59&#39;. So, the</span>
 3117 |     | <span class='neutral'>    // requirements of &#39;newCurve&#39; are satisfied.</span>
 3118 |     | <span class='neutral'>    toyCurve.newCurve(epsilonX59, qLimit);</span>
 3119 |     | <span class='neutral'>  }</span>
 3120 |     | <span class='neutral'></span>
 3121 |     | <span class='neutral'>  // As is the case for swaps, we employ the method &#39;moveTarget()&#39; in order to</span>
 3122 |     | <span class='neutral'>  // calculate both of the integrals:</span>
 3123 |     | <span class='neutral'>  //</span>
 3124 |     | <span class='neutral'>  //      - 8     / qLimit</span>
 3125 |     | <span class='neutral'>  //    e        |                        - h / 2</span>
 3126 |     | <span class='neutral'>  //  &#39;------- * |    k(h - qEpsilon) * e         dh&#39;</span>
 3127 |     | <span class='neutral'>  //      2      |</span>
 3128 |     | <span class='neutral'>  //            / qEpsilon</span>
 3129 |     | <span class='neutral'>  //</span>
 3130 |     | <span class='neutral'>  // and</span>
 3131 |     | <span class='neutral'>  //</span>
 3132 |     | <span class='neutral'>  //      - 8     / qLimit</span>
 3133 |     | <span class='neutral'>  //    e        |                        + h / 2</span>
 3134 |     | <span class='neutral'>  //  &#39;------- * |    k(h - qEpsilon) * e         dh&#39;.</span>
 3135 |     | <span class='neutral'>  //      2      |</span>
 3136 |     | <span class='neutral'>  //            / qEpsilon</span>
 3137 |     | <span class='neutral'>  //</span>
 3138 |     | <span class='neutral'>  // To this end, &#39;qLimit&#39; is set in memory as the end of the interval.</span>
 3139 |     | <span class='neutral'>  setLogPriceLimitOffsetted(qLimit);</span>
 3140 |     | <span class='neutral'></span>
 3141 |     | <span class='neutral'>  // And, &#39;|amountSpecified|&#39; is set to &#39;infinity&#39;.</span>
 3142 |     | <span class='neutral'>  setIntegralLimit(oneX216 - epsilonX216);</span>
 3143 |     | <span class='neutral'>  </span>
 3144 |     | <span class='neutral'>  // A fresh interval is initiated for us to start the swap that calculates the</span>
 3145 |     | <span class='neutral'>  // two integrals.</span>
 3146 |     | <span class='neutral'>  initiateInterval();</span>
 3147 |     | <span class='neutral'>  </span>
 3148 |     | <span class='neutral'>  // &#39;currentToTarget&#39; and &#39;incomingCurrentToTarget&#39; are incremented until </span>
 3149 |     | <span class='neutral'>  // &#39;qTarget&#39; reaches &#39;qLimit&#39;.</span>
 3150 |     | <span class='neutral'>  while (_target_.log() != qLimit) {</span>
 3151 |     | <span class='neutral'>    // The input requirement of &#39;moveTarget()&#39; are satisfied because</span>
 3152 |     | <span class='neutral'>    // &#39;integralLimit&#39; is set to &#39;infinity&#39; and because &#39;qTarget&#39; reaches</span>
 3153 |     | <span class='neutral'>    // &#39;qLimit&#39; before &#39;indexKernelTotal&#39; becomes out of range or &#39;indexCurve&#39;</span>
 3154 |     | <span class='neutral'>    // underflows.</span>
 3155 |     | <span class='neutral'>    if (moveTarget()) break;</span>
 3156 |     | <span class='neutral'>  }</span>
 3157 |     | <span class='neutral'>  </span>
 3158 |     | <span class='neutral'>  // The &#39;curve&#39; pointer and &#39;curveLength&#39; are set to their previous value.</span>
 3159 |     | <span class='neutral'>  setCurve(curve);</span>
 3160 |     | <span class='neutral'>  setCurveLength(curveLength);</span>
 3161 |     | <span class='neutral'></span>
 3162 |     | <span class='neutral'>  {</span>
 3163 |     | <span class='neutral'>    // Next, &#39;outgoingMax&#39; is calculated from &#39;currentToTarget&#39; as follows:</span>
 3164 |     | <span class='neutral'>    //</span>
 3165 |     | <span class='neutral'>    //    outgoingMax</span>
 3166 |     | <span class='neutral'>    //  &#39;------------- ==</span>
 3167 |     | <span class='neutral'>    //     2 ** 216</span>
 3168 |     | <span class='neutral'>    //</span>
 3169 |     | <span class='neutral'>    //                       - 8     / qLimit</span>
 3170 |     | <span class='neutral'>    //     qEpsilon / 2    e        |                      - h / 2</span>
 3171 |     | <span class='neutral'>    //   e              * ------- * |  k(h - qEpsilon) * e         dh ==</span>
 3172 |     | <span class='neutral'>    //                       2      |</span>
 3173 |     | <span class='neutral'>    //                             / qEpsilon</span>
 3174 |     | <span class='neutral'>    //</span>
 3175 |     | <span class='neutral'>    //     qEpsilon / 2    currentToTarget</span>
 3176 |     | <span class='neutral'>    //   e              * ----------------- ==</span>
 3177 |     | <span class='neutral'>    //                        2 ** 216</span>
 3178 |     | <span class='neutral'>    //</span>
 3179 |     | <span class='neutral'>    //     - 8    currentToTarget      1 / (2 ** 60)</span>
 3180 |     | <span class='neutral'>    //   e     * ----------------- * e              &#39;</span>
 3181 |     | <span class='neutral'>    //               2 ** 216</span>
 3182 |     | <span class='neutral'>    //</span>
 3183 |     | <span class='neutral'>    // The use of &#39;cheapMul&#39; is safe, because &#39;expInverse8X216&#39; is positive and</span>
 3184 |     | <span class='neutral'>    // less than &#39;oneX216&#39;. Moreover, like every outgoing integral,</span>
 3185 |     | <span class='neutral'>    // &#39;currentToTarget&#39; is nonnegative and less than &#39;oneX216&#39;.</span>
 3186 |     | <span class='neutral'>    //</span>
 3187 |     | <span class='neutral'>    // Overflow of &#39;multiplyByExpEpsilon&#39; is impossible because, theoretically,</span>
 3188 |     | <span class='neutral'>    // the output satisfies:</span>
 3189 |     | <span class='neutral'>    //</span>
 3190 |     | <span class='neutral'>    //                       - 8     / qSpacing</span>
 3191 |     | <span class='neutral'>    //    outgoingMax      e        |    - h / 2</span>
 3192 |     | <span class='neutral'>    //  &#39;------------- := ------- * |  e         k(h) dh</span>
 3193 |     | <span class='neutral'>    //     2 ** 216          2      |</span>
 3194 |     | <span class='neutral'>    //                             / 0</span>
 3195 |     | <span class='neutral'>    //</span>
 3196 |     | <span class='neutral'>    //                       - 8     / 32</span>
 3197 |     | <span class='neutral'>    //                     e        |    - h / 2</span>
 3198 |     | <span class='neutral'>    //                  &lt; ------- * |  e         dh &lt; 1</span>
 3199 |     | <span class='neutral'>    //                       2      |</span>
 3200 |     | <span class='neutral'>    //                             / 0</span>
 3201 |     | <span class='neutral'>    //</span>
 3202 |     | <span class='neutral'>    X216 outgoingMax = (</span>
 3203 |     | <span class='neutral'>      _currentToTarget_.integral() &amp; expInverse8X216</span>
 3204 |     | <span class='neutral'>    ).multiplyByExpEpsilon();</span>
 3205 |     | <span class='neutral'></span>
 3206 |     | <span class='neutral'>    // Due to the above argument, &#39;outgoingMax&#39; does not exceed 216 bits and</span>
 3207 |     | <span class='neutral'>    // can be safely stored in the dedicated memory space which is pointed to</span>
 3208 |     | <span class='neutral'>    // by &#39;_outgoingMax_&#39;.</span>
 3209 |     | <span class='neutral'>    setOutgoingMax(outgoingMax);</span>
 3210 |     | <span class='neutral'></span>
 3211 |     | <span class='neutral'>    // Next, the modular inverse of the largest odd factor of &#39;outgoingMax&#39;</span>
 3212 |     | <span class='neutral'>    // is calculated.</span>
 3213 |     | <span class='neutral'>    //</span>
 3214 |     | <span class='neutral'>    // Let &#39;outgoingMax == (2 ** n) * (2 * r + 1)&#39; where &#39;n&#39; and &#39;r&#39; are</span>
 3215 |     | <span class='neutral'>    // nonnegative integers (i.e., &#39;2 ** n&#39; is the largest power of &#39;2&#39; that</span>
 3216 |     | <span class='neutral'>    // divides &#39;outgoingMax&#39;). Then, the binary representation of &#39;outgoingMax&#39;</span>
 3217 |     | <span class='neutral'>    // looks like:</span>
 3218 |     | <span class='neutral'>    //</span>
 3219 |     | <span class='neutral'>    //        ___________</span>
 3220 |     | <span class='neutral'>    //        r 1 0 ... 0</span>
 3221 |     | <span class='neutral'>    //</span>
 3222 |     | <span class='neutral'>    // with exactly &#39;n&#39; zero digits appearing as the least significant. On the</span>
 3223 |     | <span class='neutral'>    // other hand, the binary representation of &#39;(2 ** 256) - outgoingMax&#39;</span>
 3224 |     | <span class='neutral'>    // looks like:</span>
 3225 |     | <span class='neutral'>    //</span>
 3226 |     | <span class='neutral'>    //   ________________</span>
 3227 |     | <span class='neutral'>    //   not(r) 1 0 ... 0</span>
 3228 |     | <span class='neutral'>    //</span>
 3229 |     | <span class='neutral'>    // with exactly &#39;n&#39; zero digits appearing as the least significant.</span>
 3230 |     | <span class='neutral'>    //</span>
 3231 |     | <span class='neutral'>    // Hence, we have:</span>
 3232 |     | <span class='neutral'>    //</span>
 3233 |     | <span class='neutral'>    //  &#39;outgoingMax &amp; ((2 ** 256) - outgoingMax) == 2 ** n&#39;.</span>
 3234 |     | <span class='neutral'>    //</span>
 3235 |     | <span class='neutral'>    uint256 outgoingMaxLargestOddFactor;</span>
 3236 |     | <span class='neutral'>    assembly {</span>
 3237 |     | <span class='neutral'>      // &#39;outgoingMax / (2 ** n)&#39;</span>
 3238 |     | <span class='neutral'>      outgoingMaxLargestOddFactor := div(</span>
 3239 |     | <span class='neutral'>        outgoingMax,</span>
 3240 |     | <span class='neutral'>        and(sub(0, outgoingMax), outgoingMax) // &#39;2 ** n&#39;</span>
 3241 |     | <span class='neutral'>      )</span>
 3242 |     | <span class='neutral'>    }</span>
 3243 |     | <span class='neutral'>    setOutgoingMaxModularInverse(</span>
 3244 |     | <span class='neutral'>      FullMathLibrary.modularInverse(outgoingMaxLargestOddFactor)</span>
 3245 |     | <span class='neutral'>    );</span>
 3246 |     | <span class='neutral'>  }</span>
 3247 |     | <span class='neutral'></span>
 3248 |     | <span class='neutral'>  // Next, &#39;incomingMax&#39; is calculated from &#39;incomingCurrentToTarget&#39; as</span>
 3249 |     | <span class='neutral'>  // follows:</span>
 3250 |     | <span class='neutral'>  //</span>
 3251 |     | <span class='neutral'>  //    incomingMax       - (qSpacing + qEpsilon) / 2</span>
 3252 |     | <span class='neutral'>  //  &#39;------------- == e                             *</span>
 3253 |     | <span class='neutral'>  //     2 ** 216</span>
 3254 |     | <span class='neutral'>  //</span>
 3255 |     | <span class='neutral'>  //      - 8     / qLimit</span>
 3256 |     | <span class='neutral'>  //    e        |                      + h / 2</span>
 3257 |     | <span class='neutral'>  //   ------- * |  k(h - qEpsilon) * e         dh ==</span>
 3258 |     | <span class='neutral'>  //      2      |</span>
 3259 |     | <span class='neutral'>  //            / qEpsilon</span>
 3260 |     | <span class='neutral'>  //</span>
 3261 |     | <span class='neutral'>  //     - (qSpacing + qEpsilon) / 2    incomingCurrentToTarget</span>
 3262 |     | <span class='neutral'>  //   e                             * ------------------------- ==</span>
 3263 |     | <span class='neutral'>  //                                           2 ** 216</span>
 3264 |     | <span class='neutral'>  //</span>
 3265 |     | <span class='neutral'>  //      - qSpacing    incomingCurrentToTarget</span>
 3266 |     | <span class='neutral'>  //    e            * -------------------------</span>
 3267 |     | <span class='neutral'>  //                          2 ** 216                - 1 / (2 ** 60)</span>
 3268 |     | <span class='neutral'>  //   ------------------------------------------ * e                 &#39;.</span>
 3269 |     | <span class='neutral'>  //                       - 8</span>
 3270 |     | <span class='neutral'>  //                     e</span>
 3271 |     | <span class='neutral'>  //</span>
 3272 |     | <span class='neutral'>  // The use of &#39;mulDivByExpInv8&#39; is safe, because both inputs are positive and</span>
 3273 |     | <span class='neutral'>  // less than &#39;oneX216&#39;. Moreover, overflow is not possible because the output</span>
 3274 |     | <span class='neutral'>  // of &#39;mulDivByExpInv8&#39; is smaller than &#39;incomingMax&#39; which satisfies</span>
 3275 |     | <span class='neutral'>  //</span>
 3276 |     | <span class='neutral'>  //                       - 8 - qSpacing / 2     / qSpacing</span>
 3277 |     | <span class='neutral'>  //    incomingMax      e                       |    + h / 2</span>
 3278 |     | <span class='neutral'>  //  &#39;------------- := ---------------------- * |  e         k(h) dh</span>
 3279 |     | <span class='neutral'>  //     2 ** 216                 2              |</span>
 3280 |     | <span class='neutral'>  //                                            / 0</span>
 3281 |     | <span class='neutral'>  //</span>
 3282 |     | <span class='neutral'>  //                       - 24     / 32</span>
 3283 |     | <span class='neutral'>  //                     e         |    + h / 2</span>
 3284 |     | <span class='neutral'>  //                  &lt; -------- * |  e         dh &lt; 1</span>
 3285 |     | <span class='neutral'>  //                       2       |</span>
 3286 |     | <span class='neutral'>  //                              / 0</span>
 3287 |     | <span class='neutral'>  //</span>
 3288 |     | <span class='neutral'>  setIncomingMax((</span>
 3289 |     | <span class='neutral'>    _incomingCurrentToTarget_.integral() % _spacing_.sqrt(false)</span>
 3290 |     | <span class='neutral'>  ).divideByExpEpsilon());</span>
 3291 |     | <span class='neutral'></span>
 3292 |     | <span class='neutral'>  // Clears memory so that it can be used later for the calculation of</span>
 3293 |     | <span class='neutral'>  // &#39;integral0&#39; and &#39;integral1&#39;.</span>
 3294 |     | <span class='neutral'>  clearInterval();</span>
 3295 |     | <span class='neutral'>}</span>
 3296 |     | <span class='neutral'></span>
 3297 |     | <span class='neutral'>/// @notice Calculates &#39;integral0&#39; and &#39;integral1&#39; where:</span>
 3298 |     | <span class='neutral'>///</span>
 3299 |     | <span class='neutral'>///                     - 8     / qUpper</span>
 3300 |     | <span class='neutral'>///    integral0      e        |    - h / 2</span>
 3301 |     | <span class='neutral'>///  &#39;----------- := ------- * |  e         k(w(h)) dh&#39;,</span>
 3302 |     | <span class='neutral'>///    2 ** 216         2      |</span>
 3303 |     | <span class='neutral'>///                           / qCurrent</span>
 3304 |     | <span class='neutral'>///</span>
 3305 |     | <span class='neutral'>/// and</span>
 3306 |     | <span class='neutral'>///</span>
 3307 |     | <span class='neutral'>///                     - 8     / qCurrent</span>
 3308 |     | <span class='neutral'>///    integral1      e        |    + h / 2</span>
 3309 |     | <span class='neutral'>///  &#39;----------- := ------- * |  e         k(w(h)) dh&#39;.</span>
 3310 |     | <span class='neutral'>///    2 ** 216         2      |</span>
 3311 |     | <span class='neutral'>///                           / qLower</span>
 3312 |     | <span class='neutral'>///</span>
 3313 |     | <span class='neutral'>/// This method is called during initialization.</span>
 3314 |     | <span class='neutral'>function calculateIntegrals() pure {</span>
 3315 |     | <span class='neutral'>  // In order to calculate &#39;integral0&#39; and &#39;integral1&#39;, we need to employ the</span>
 3316 |     | <span class='neutral'>  // method &#39;moveTarget()&#39;. To this end, &#39;qLimit&#39; is set as the very first</span>
 3317 |     | <span class='neutral'>  // member of the curve sequence which is one of the interval boundaries.</span>
 3318 |     | <span class='neutral'>  X59 qLimit = getCurve().member(zeroIndex);</span>
 3319 |     | <span class='neutral'></span>
 3320 |     | <span class='neutral'>  // &#39;qLimit&#39; is set in memory.</span>
 3321 |     | <span class='neutral'>  setLogPriceLimitOffsetted(qLimit);</span>
 3322 |     | <span class='neutral'></span>
 3323 |     | <span class='neutral'>  // The direction of our exploration is set with respect to &#39;qLimit&#39;.</span>
 3324 |     | <span class='neutral'>  setZeroForOne(qLimit &lt;= getLogPriceCurrent());</span>
 3325 |     | <span class='neutral'></span>
 3326 |     | <span class='neutral'>  // &#39;integralLimit&#39; (i.e., &#39;|amountSpecified|&#39;) is set to &#39;infinity&#39;.</span>
 3327 |     | <span class='neutral'>  setIntegralLimit(oneX216 - epsilonX216);</span>
 3328 |     | <span class='neutral'></span>
 3329 |     | <span class='neutral'>  // A fresh interval is initiated for us to start the swap that calculates the</span>
 3330 |     | <span class='neutral'>  // two integrals.</span>
 3331 |     | <span class='neutral'>  initiateInterval();</span>
 3332 |     | <span class='neutral'></span>
 3333 |     | <span class='neutral'>  // &#39;currentToTarget&#39; and &#39;incomingCurrentToTarget&#39; are incremented until </span>
 3334 |     | <span class='neutral'>  // &#39;qTarget&#39; reaches &#39;qLimit&#39;.</span>
 3335 |     | <span class='neutral'>  while (_target_.log() != qLimit) {</span>
 3336 |     | <span class='neutral'>    // The input requirement of &#39;moveTarget()&#39; are satisfied because</span>
 3337 |     | <span class='neutral'>    // &#39;integralLimit&#39; is set to &#39;infinity&#39; and because &#39;qTarget&#39; reaches</span>
 3338 |     | <span class='neutral'>    // &#39;qLimit&#39; before &#39;indexKernelTotal&#39; becomes out of range or &#39;indexCurve&#39;</span>
 3339 |     | <span class='neutral'>    // underflows.</span>
 3340 |     | <span class='neutral'>    if (moveTarget()) break;</span>
 3341 |     | <span class='neutral'>  }</span>
 3342 |     | <span class='neutral'></span>
 3343 |     | <span class='neutral'>  // Depending on the direction, the two integrals are determined and set in</span>
 3344 |     | <span class='neutral'>  // their dedicated memory location.</span>
 3345 |     | <span class='neutral'>  (X216 integral0, X216 integral1) = getZeroForOne() ? (</span>
 3346 |     | <span class='neutral'>    _currentToOrigin_.integral(),</span>
 3347 |     | <span class='neutral'>    _currentToTarget_.integral()</span>
 3348 |     | <span class='neutral'>  ) : (</span>
 3349 |     | <span class='neutral'>    _currentToTarget_.integral(),</span>
 3350 |     | <span class='neutral'>    _currentToOrigin_.integral()</span>
 3351 |     | <span class='neutral'>  );</span>
 3352 |     | <span class='neutral'>  setIntegral0(integral0);</span>
 3353 |     | <span class='neutral'>  setIntegral1(integral1);</span>
 3354 |     | <span class='neutral'>}</span>
 3355 |     | <span class='neutral'></span>
 3356 |     | <span class='neutral'>/// @notice Assume that the search for &#39;qTarget&#39; is concluded and we need to</span>
 3357 |     | <span class='neutral'>/// determine &#39;qOvershoot&#39;. To this end, the following equation should be</span>
 3358 |     | <span class='neutral'>/// solved:</span>
 3359 |     | <span class='neutral'>///</span>
 3360 |     | <span class='neutral'>///   &#39;f(qOvershoot) == 0&#39;</span>
 3361 |     | <span class='neutral'>///</span>
 3362 |     | <span class='neutral'>/// where</span>
 3363 |     | <span class='neutral'>///</span>
 3364 |     | <span class='neutral'>///   &#39;f(qOvershoot) := getZeroForOne() ? </span>
 3365 |     | <span class='neutral'>///                     s0(qOvershoot) - s1(qOvershoot) : </span>
 3366 |     | <span class='neutral'>///                     s1(qOvershoot) - s0(qOvershoot)&#39;,</span>
 3367 |     | <span class='neutral'>///</span>
 3368 |     | <span class='neutral'>/// and the two functions &#39;s0&#39; and &#39;s1&#39; are defined as:</span>
 3369 |     | <span class='neutral'>///</span>
 3370 |     | <span class='neutral'>///                          - 8      / qTarget</span>
 3371 |     | <span class='neutral'>///                        e         |   + h / 2</span>
 3372 |     | <span class='neutral'>///                       ------- *  |  e        k(wAmended(h)) dh</span>
 3373 |     | <span class='neutral'>///                          2       |</span>
 3374 |     | <span class='neutral'>///                                 / qLower</span>
 3375 |     | <span class='neutral'>///   &#39;s1(qOvershoot) := ------------------------------------------&#39;,</span>
 3376 |     | <span class='neutral'>///                                integral1Incremented</span>
 3377 |     | <span class='neutral'>///</span>
 3378 |     | <span class='neutral'>///                          - 8      / qUpper</span>
 3379 |     | <span class='neutral'>///                        e         |   - h / 2</span>
 3380 |     | <span class='neutral'>///                       ------- *  |  e        k(wAmended(h)) dh</span>
 3381 |     | <span class='neutral'>///                          2       |</span>
 3382 |     | <span class='neutral'>///                                 / qTarget</span>
 3383 |     | <span class='neutral'>///   &#39;s0(qOvershoot) := ------------------------------------------&#39;,</span>
 3384 |     | <span class='neutral'>///                                integral0Incremented</span>
 3385 |     | <span class='neutral'>///</span>
 3386 |     | <span class='neutral'>/// where, according to the amendment procedure which is described in</span>
 3387 |     | <span class='neutral'>/// &#39;Curve.sol&#39;, if &#39;getZeroForOne() == false&#39;, we have:</span>
 3388 |     | <span class='neutral'>///</span>
 3389 |     | <span class='neutral'>///                       / k(w(h))            if  qOvershoot &lt; h &lt; qUpper</span>
 3390 |     | <span class='neutral'>///   &#39;k(wAmended(h)) == |  k(h - qTarget)     if  qTarget &lt; h &lt; qOvershoot &#39;</span>
 3391 |     | <span class='neutral'>///                      |  k(qOvershoot - h)  if  qOrigin &lt; h &lt; qTarget</span>
 3392 |     | <span class='neutral'>///                       \ k(w(h))            if  qLower &lt; h &lt; qOrigin</span>
 3393 |     | <span class='neutral'>///</span>
 3394 |     | <span class='neutral'>/// and if &#39;getZeroForOne() == true&#39;, we have:</span>
 3395 |     | <span class='neutral'>///</span>
 3396 |     | <span class='neutral'>///                       / k(w(h))            if  qLower &lt; h &lt; qOvershoot</span>
 3397 |     | <span class='neutral'>///   &#39;k(wAmended(h)) == |  k(qTarget - h)     if  qOvershoot &lt; h &lt; qTarget &#39;.</span>
 3398 |     | <span class='neutral'>///                      |  k(h - qOvershoot)  if  qTarget &lt; h &lt; qOrigin</span>
 3399 |     | <span class='neutral'>///                       \ k(w(h))            if  qOrigin &lt; h &lt; qUpper</span>
 3400 |     | <span class='neutral'>///</span>
 3401 |     | <span class='neutral'>/// The present function evaluates the mismatch function &#39;f(qOvershoot)&#39;. To</span>
 3402 |     | <span class='neutral'>/// this end, we use the following formula which is proven in &#39;Memory.sol&#39;.</span>
 3403 |     | <span class='neutral'>///</span>
 3404 |     | <span class='neutral'>///   &#39;f(qOvershoot) := getZeroForOne() ? (</span>
 3405 |     | <span class='neutral'>///</span>
 3406 |     | <span class='neutral'>///      (</span>
 3407 |     | <span class='neutral'>///</span>
 3408 |     | <span class='neutral'>///        exp(- (qOrigin + qOvershoot) / 2) * originToOvershoot -</span>
 3409 |     | <span class='neutral'>///</span>
 3410 |     | <span class='neutral'>///        exp(- (qTarget + qOvershoot) / 2) * targetToOvershoot - </span>
 3411 |     | <span class='neutral'>///</span>
 3412 |     | <span class='neutral'>///        incomingCurrentToTarget - currentToOrigin</span>
 3413 |     | <span class='neutral'>///</span>
 3414 |     | <span class='neutral'>///      ) / integral0Incremented - (</span>
 3415 |     | <span class='neutral'>///</span>
 3416 |     | <span class='neutral'>///        targetToOvershoot + currentToTarget - currentToOvershoot</span>
 3417 |     | <span class='neutral'>///      </span>
 3418 |     | <span class='neutral'>///      ) / integral1Incremented</span>
 3419 |     | <span class='neutral'>///</span>
 3420 |     | <span class='neutral'>///    ) : (</span>
 3421 |     | <span class='neutral'>///</span>
 3422 |     | <span class='neutral'>///      (</span>
 3423 |     | <span class='neutral'>///</span>
 3424 |     | <span class='neutral'>///        exp(+ (qOrigin + qOvershoot) / 2) * originToOvershoot -</span>
 3425 |     | <span class='neutral'>///</span>
 3426 |     | <span class='neutral'>///        exp(+ (qTarget + qOvershoot) / 2) * targetToOvershoot - </span>
 3427 |     | <span class='neutral'>///</span>
 3428 |     | <span class='neutral'>///        incomingCurrentToTarget - currentToOrigin</span>
 3429 |     | <span class='neutral'>///</span>
 3430 |     | <span class='neutral'>///      ) / integral1Incremented - (</span>
 3431 |     | <span class='neutral'>///</span>
 3432 |     | <span class='neutral'>///        targetToOvershoot + currentToTarget - currentToOvershoot</span>
 3433 |     | <span class='neutral'>///      </span>
 3434 |     | <span class='neutral'>///      ) / integral0Incremented</span>
 3435 |     | <span class='neutral'>///</span>
 3436 |     | <span class='neutral'>///    )&#39;.</span>
 3437 |     | <span class='neutral'>///</span>
 3438 |     | <span class='neutral'>/// @param integral0Incremented The integral of the liquidity distribution</span>
 3439 |     | <span class='neutral'>/// function from &#39;qTarget&#39; to &#39;qUpper&#39; prior to the amendment of the curve</span>
 3440 |     | <span class='neutral'>/// sequence:</span>
 3441 |     | <span class='neutral'>///</span>
 3442 |     | <span class='neutral'>///                                 - 8     / qUpper</span>
 3443 |     | <span class='neutral'>///     integral0Incremented      e        |    - h / 2</span>
 3444 |     | <span class='neutral'>///   &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;,</span>
 3445 |     | <span class='neutral'>///           2 ** 216              2      |</span>
 3446 |     | <span class='neutral'>///                                       / qTarget</span>
 3447 |     | <span class='neutral'>///</span>
 3448 |     | <span class='neutral'>/// @param integral1Incremented The integral of the liquidity distribution</span>
 3449 |     | <span class='neutral'>/// function from &#39;qLower&#39; to &#39;qTarget&#39; prior to the amendment of the curve</span>
 3450 |     | <span class='neutral'>/// sequence:</span>
 3451 |     | <span class='neutral'>///</span>
 3452 |     | <span class='neutral'>///                                 - 8     / qTarget</span>
 3453 |     | <span class='neutral'>///     integral1Incremented      e        |    + h / 2</span>
 3454 |     | <span class='neutral'>///   &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;.</span>
 3455 |     | <span class='neutral'>///           2 ** 216              2      |</span>
 3456 |     | <span class='neutral'>///                                       / qLower</span>
 3457 |     | <span class='neutral'>///</span>
 3458 |     | <span class='neutral'>function getMismatch(</span>
 3459 |     | <span class='neutral'>  X216 integral0Incremented,</span>
 3460 |     | <span class='neutral'>  X216 integral1Incremented</span>
 3461 |     | <span class='neutral'>) pure returns (</span>
 3462 |     | <span class='neutral'>  X216 mismatch</span>
 3463 |     | <span class='neutral'>) {</span>
 3464 |     | <span class='neutral'>  // First &#39;zeroForOne&#39; is loaded from the memory.</span>
 3465 |     | <span class='neutral'>  bool zeroForOne = getZeroForOne();</span>
 3466 |     | <span class='neutral'></span>
 3467 |     | <span class='neutral'>  // The following value is calculated next:</span>
 3468 |     | <span class='neutral'>  //</span>
 3469 |     | <span class='neutral'>  //  &#39;zeroForOne ? (</span>
 3470 |     | <span class='neutral'>  //</span>
 3471 |     | <span class='neutral'>  //     exp(- (qOrigin + qOvershoot) / 2) * originToOvershoot -</span>
 3472 |     | <span class='neutral'>  //</span>
 3473 |     | <span class='neutral'>  //     exp(- (qTarget + qOvershoot) / 2) * targetToOvershoot - </span>
 3474 |     | <span class='neutral'>  //</span>
 3475 |     | <span class='neutral'>  //     incomingCurrentToTarget - currentToOrigin</span>
 3476 |     | <span class='neutral'>  //</span>
 3477 |     | <span class='neutral'>  //   ) : (</span>
 3478 |     | <span class='neutral'>  //</span>
 3479 |     | <span class='neutral'>  //     exp(+ (qOrigin + qOvershoot) / 2) * originToOvershoot -</span>
 3480 |     | <span class='neutral'>  //</span>
 3481 |     | <span class='neutral'>  //     exp(+ (qTarget + qOvershoot) / 2) * targetToOvershoot - </span>
 3482 |     | <span class='neutral'>  //</span>
 3483 |     | <span class='neutral'>  //     incomingCurrentToTarget - currentToOrigin</span>
 3484 |     | <span class='neutral'>  //</span>
 3485 |     | <span class='neutral'>  //   )&#39;.</span>
 3486 |     | <span class='neutral'>  //</span>
 3487 |     | <span class='neutral'>  // The requirement of &#39;shift&#39; is satisfied because all of the integrals are</span>
 3488 |     | <span class='neutral'>  // read from 216 bits of memory and do not exceed oneX216.</span>
 3489 |     | <span class='neutral'>  //</span>
 3490 |     | <span class='neutral'>  // The subtractions are unsafe and</span>
 3491 |     | <span class='neutral'>  // &#39;integral1AmendedMinusIntegral1Incremented&#39; may or may not be negative.</span>
 3492 |     | <span class='neutral'>  X216 integral1AmendedMinusIntegral1Incremented = </span>
 3493 |     | <span class='neutral'>    _originToOvershoot_.integral().shift(</span>
 3494 |     | <span class='neutral'>      _overshoot_,</span>
 3495 |     | <span class='neutral'>      _origin_,</span>
 3496 |     | <span class='neutral'>      zeroForOne</span>
 3497 |     | <span class='neutral'>    ) - _targetToOvershoot_.integral().shift(</span>
 3498 |     | <span class='neutral'>      _overshoot_,</span>
 3499 |     | <span class='neutral'>      _target_,</span>
 3500 |     | <span class='neutral'>      zeroForOne</span>
 3501 |     | <span class='neutral'>    ) - _currentToOrigin_.integral() - _incomingCurrentToTarget_.integral();</span>
 3502 |     | <span class='neutral'></span>
 3503 |     | <span class='neutral'>  // Now, we calculate:</span>
 3504 |     | <span class='neutral'>  //</span>
 3505 |     | <span class='neutral'>  //  &#39;targetToOvershoot + currentToTarget - currentToOvershoot&#39;</span>
 3506 |     | <span class='neutral'>  //  </span>
 3507 |     | <span class='neutral'>  // The subtractions are unsafe and</span>
 3508 |     | <span class='neutral'>  // &#39;integral0AmendedMinusIntegral0Incremented&#39; may or may not be negative.</span>
 3509 |     | <span class='neutral'>  X216 integral0AmendedMinusIntegral0Incremented = _currentToTarget_.integral()</span>
 3510 |     | <span class='neutral'>    + _targetToOvershoot_.integral()</span>
 3511 |     | <span class='neutral'>    - _currentToOvershoot_.integral();</span>
 3512 |     | <span class='neutral'></span>
 3513 |     | <span class='neutral'>  // Neither of &#39;integral0Incremented&#39; and &#39;integral1Incremented&#39; do not exceed</span>
 3514 |     | <span class='neutral'>  // &#39;oneX216&#39;. Additionally, since each of</span>
 3515 |     | <span class='neutral'>  // &#39;integral0AmendedMinusIntegral0Incremented&#39; and</span>
 3516 |     | <span class='neutral'>  // &#39;integral1AmendedMinusIntegral1Incremented&#39; are composed of up to four</span>
 3517 |     | <span class='neutral'>  // integrals, their absolute value do not exceed &#39;4 * oneX216&#39;. Hence, both</span>
 3518 |     | <span class='neutral'>  // multiplications are safe.</span>
 3519 |     | <span class='neutral'>  //</span>
 3520 |     | <span class='neutral'>  // The subtractions are unsafe and the output may or may not be negative.</span>
 3521 |     | <span class='neutral'>  return zeroForOne ? (</span>
 3522 |     | <span class='neutral'>    (</span>
 3523 |     | <span class='neutral'>      integral1AmendedMinusIntegral1Incremented * integral1Incremented</span>
 3524 |     | <span class='neutral'>    ) - (</span>
 3525 |     | <span class='neutral'>      integral0AmendedMinusIntegral0Incremented * integral0Incremented</span>
 3526 |     | <span class='neutral'>    )</span>
 3527 |     | <span class='neutral'>  ) : (</span>
 3528 |     | <span class='neutral'>    (</span>
 3529 |     | <span class='neutral'>      integral1AmendedMinusIntegral1Incremented * integral0Incremented</span>
 3530 |     | <span class='neutral'>    ) - (</span>
 3531 |     | <span class='neutral'>      integral0AmendedMinusIntegral0Incremented * integral1Incremented</span>
 3532 |     | <span class='neutral'>    )</span>
 3533 |     | <span class='neutral'>  );</span>
 3534 |     | <span class='neutral'>}</span>
 3535 |     | <span class='neutral'></span>
 3536 |     | <span class='neutral'>/// @notice Enumerates the pieces of the liquidity distribution function</span>
 3537 |     | <span class='neutral'>/// &#39;k(w(.))&#39; in search for the pair of logarithmic prices:</span>
 3538 |     | <span class='neutral'>///</span>
 3539 |     | <span class='neutral'>///   &#39;qBegin := (</span>
 3540 |     | <span class='neutral'>///                direction == getZeroForOne()</span>
 3541 |     | <span class='neutral'>///              ) ? (</span>
 3542 |     | <span class='neutral'>///                direction ? </span>
 3543 |     | <span class='neutral'>///                max(max(q[indexCurve + 2], qTotal0), qForward0) : </span>
 3544 |     | <span class='neutral'>///                min(min(q[indexCurve + 2], qTotal0), qForward0)</span>
 3545 |     | <span class='neutral'>///              ) : (</span>
 3546 |     | <span class='neutral'>///                direction ? </span>
 3547 |     | <span class='neutral'>///                max(q[indexCurve + 2], qTotal0) : </span>
 3548 |     | <span class='neutral'>///                min(q[indexCurve + 2], qTotal0)</span>
 3549 |     | <span class='neutral'>///              )&#39;,</span>
 3550 |     | <span class='neutral'>///</span>
 3551 |     | <span class='neutral'>/// and</span>
 3552 |     | <span class='neutral'>///</span>
 3553 |     | <span class='neutral'>///   &#39;qOvershoot := (</span>
 3554 |     | <span class='neutral'>///                    direction == getZeroForOne()</span>
 3555 |     | <span class='neutral'>///                  ) ? (</span>
 3556 |     | <span class='neutral'>///                    direction ? </span>
 3557 |     | <span class='neutral'>///                    max(max(qEnd, qTotal1), qForward1) : </span>
 3558 |     | <span class='neutral'>///                    min(min(qEnd, qTotal1), qForward1)</span>
 3559 |     | <span class='neutral'>///                  ) : (</span>
 3560 |     | <span class='neutral'>///                    direction ? </span>
 3561 |     | <span class='neutral'>///                    max(qEnd, qTotal1) : </span>
 3562 |     | <span class='neutral'>///                    min(qEnd, qTotal1)</span>
 3563 |     | <span class='neutral'>///                  )&#39;,</span>
 3564 |     | <span class='neutral'>///</span>
 3565 |     | <span class='neutral'>/// which satisfy:</span>
 3566 |     | <span class='neutral'>///</span>
 3567 |     | <span class='neutral'>///   &#39;f(qBegin) &lt;= 0&#39; and &#39;f(qOvershoot) &gt;  0&#39;.</span>
 3568 |     | <span class='neutral'>///</span>
 3569 |     | <span class='neutral'>/// where the mismatch function &#39;f(.)&#39; is defined in &#39;Memory.sol&#39; and earlier</span>
 3570 |     | <span class='neutral'>/// in this document.</span>
 3571 |     | <span class='neutral'>///</span>
 3572 |     | <span class='neutral'>/// The present function transitions to the next piece of &#39;k(w(.))&#39; by updating </span>
 3573 |     | <span class='neutral'>/// the appropriate values in memory and by incrementing the following</span>
 3574 |     | <span class='neutral'>/// integrals:</span>
 3575 |     | <span class='neutral'>///  </span>
 3576 |     | <span class='neutral'>///  - &#39;currentToOvershoot&#39;,</span>
 3577 |     | <span class='neutral'>///</span>
 3578 |     | <span class='neutral'>///  - &#39;targetToOvershoot&#39;,</span>
 3579 |     | <span class='neutral'>///</span>
 3580 |     | <span class='neutral'>///  - &#39;currentToOrigin&#39;,</span>
 3581 |     | <span class='neutral'>///</span>
 3582 |     | <span class='neutral'>///  - &#39;originToOvershoot&#39;.</span>
 3583 |     | <span class='neutral'>///</span>
 3584 |     | <span class='neutral'>/// ---------------------------------------------------------------------------</span>
 3585 |     | <span class='neutral'>///</span>
 3586 |     | <span class='neutral'>/// The underflow of</span>
 3587 |     | <span class='neutral'>///</span>
 3588 |     | <span class='neutral'>///  &#39;getIntegralLimit() - getExactInput() ? </span>
 3589 |     | <span class='neutral'>///                        _incomingCurrentToTarget_.integral() : </span>
 3590 |     | <span class='neutral'>///                        _currentToTarget_.integral()&#39;</span>
 3591 |     | <span class='neutral'>///</span>
 3592 |     | <span class='neutral'>/// should be avoided externally.</span>
 3593 |     | <span class='neutral'>///</span>
 3594 |     | <span class='neutral'>/// Out of range values for &#39;indexKernelTotal&#39; should be avoided externally.</span>
 3595 |     | <span class='neutral'>///</span>
 3596 |     | <span class='neutral'>/// Out of range values for &#39;indexKernelForward&#39; should be avoided externally.</span>
 3597 |     | <span class='neutral'>///</span>
 3598 |     | <span class='neutral'>/// Underflow of &#39;indexCurve&#39; should be avoided externally.</span>
 3599 |     | <span class='neutral'>///</span>
 3600 |     | <span class='neutral'>/// @param integral0Incremented The integral of the liquidity distribution</span>
 3601 |     | <span class='neutral'>/// function from &#39;qTarget&#39; to &#39;qUpper&#39; prior to the amendment of the curve</span>
 3602 |     | <span class='neutral'>/// sequence:</span>
 3603 |     | <span class='neutral'>///</span>
 3604 |     | <span class='neutral'>///                                 - 8     / qUpper</span>
 3605 |     | <span class='neutral'>///     integral0Incremented      e        |    - h / 2</span>
 3606 |     | <span class='neutral'>///   &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;,</span>
 3607 |     | <span class='neutral'>///           2 ** 216              2      |</span>
 3608 |     | <span class='neutral'>///                                       / qTarget</span>
 3609 |     | <span class='neutral'>///</span>
 3610 |     | <span class='neutral'>/// @param integral1Incremented The integral of the liquidity distribution</span>
 3611 |     | <span class='neutral'>/// function from &#39;qLower&#39; to &#39;qTarget&#39; prior to the amendment of the curve</span>
 3612 |     | <span class='neutral'>/// sequence:</span>
 3613 |     | <span class='neutral'>///</span>
 3614 |     | <span class='neutral'>///                                 - 8     / qTarget</span>
 3615 |     | <span class='neutral'>///     integral1Incremented      e        |    + h / 2</span>
 3616 |     | <span class='neutral'>///   &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;.</span>
 3617 |     | <span class='neutral'>///           2 ** 216              2      |</span>
 3618 |     | <span class='neutral'>///                                       / qLower</span>
 3619 |     | <span class='neutral'>///</span>
 3620 |     | <span class='neutral'>/// @return proceed whether to proceed forward in the search for &#39;qTarget&#39; and</span>
 3621 |     | <span class='neutral'>/// &#39;qOvershoot&#39;.</span>
 3622 |     | <span class='neutral'>function moveOvershoot(</span>
 3623 |     | <span class='neutral'>  X216 integral0Incremented,</span>
 3624 |     | <span class='neutral'>  X216 integral1Incremented</span>
 3625 |     | <span class='neutral'>) pure returns (</span>
 3626 |     | <span class='neutral'>  bool proceed</span>
 3627 |     | <span class='neutral'>) {</span>
 3628 |     | <span class='neutral'>  // According to the above definitions for &#39;qBegin&#39; and &#39;qOvershoot&#39;, if</span>
 3629 |     | <span class='neutral'>  // &#39;direction != getZeroForOne() == false&#39;, we have:</span>
 3630 |     | <span class='neutral'>  //</span>
 3631 |     | <span class='neutral'>  //  &#39;qOvershoot &lt; qBegin &lt;= qCurrent &lt;= qForward0 &lt;= qForward1&#39;,</span>
 3632 |     | <span class='neutral'>  //</span>
 3633 |     | <span class='neutral'>  // and if &#39;direction != getZeroForOne() == true&#39;, we have:</span>
 3634 |     | <span class='neutral'>  //</span>
 3635 |     | <span class='neutral'>  //  &#39;qForward1 &lt;= qForward0 &lt;= qCurrent &lt;= qBegin &lt; qOvershoot&#39;.</span>
 3636 |     | <span class='neutral'>  //</span>
 3637 |     | <span class='neutral'>  // In both cases, the &#39;if&#39; condition is bypassed.</span>
 3638 |     | <span class='neutral'>  //</span>
 3639 |     | <span class='neutral'>  // However, if &#39;getDirection() == getZeroForOne() == false&#39;, we have:</span>
 3640 |     | <span class='neutral'>  //</span>
 3641 |     | <span class='neutral'>  //  &#39;qForward0 &lt;= qBegin &lt;= qOvershoot &lt;= qForward1&#39;.</span>
 3642 |     | <span class='neutral'>  //</span>
 3643 |     | <span class='neutral'>  // In this case, if &#39;qOvershoot == qForward1&#39; as illustrated below,</span>
 3644 |     | <span class='neutral'>  //</span>
 3645 |     | <span class='neutral'>  //      +---------+---------+</span>
 3646 |     | <span class='neutral'>  //      |         |         |</span>
 3647 |     | <span class='neutral'>  //  qForward0  qBegin   qForward1</span>
 3648 |     | <span class='neutral'>  //                          |</span>
 3649 |     | <span class='neutral'>  //                     qOvershoot</span>
 3650 |     | <span class='neutral'>  //</span>
 3651 |     | <span class='neutral'>  // then &#39;indexKernelForward&#39; is incremented and the next piece of &#39;k(.)&#39; is</span>
 3652 |     | <span class='neutral'>  // loaded and stored in the memory spaces that are pointed to by &#39;_forward0_&#39;</span>
 3653 |     | <span class='neutral'>  // and &#39;_forward1_&#39;:</span>
 3654 |     | <span class='neutral'>  //</span>
 3655 |     | <span class='neutral'>  //      +---------+---------+-------------------+</span>
 3656 |     | <span class='neutral'>  //                |         |                   |</span>
 3657 |     | <span class='neutral'>  //             qBegin   qForward0           qForward1</span>
 3658 |     | <span class='neutral'>  //                          |</span>
 3659 |     | <span class='neutral'>  //                     qOvershoot</span>
 3660 |     | <span class='neutral'>  //</span>
 3661 |     | <span class='neutral'>  // If &#39;getDirection() == getZeroForOne() == true&#39;, then we have:</span>
 3662 |     | <span class='neutral'>  //</span>
 3663 |     | <span class='neutral'>  //  &#39;qForward1 &lt;= qOvershoot &lt;= qBegin &lt;= qForward0&#39;.</span>
 3664 |     | <span class='neutral'>  //</span>
 3665 |     | <span class='neutral'>  // In this case, if &#39;qOvershoot == qForward1&#39; as illustrated below,</span>
 3666 |     | <span class='neutral'>  //</span>
 3667 |     | <span class='neutral'>  //                          +---------+---------+</span>
 3668 |     | <span class='neutral'>  //                          |         |         |</span>
 3669 |     | <span class='neutral'>  //                      qForward1  qBegin   qForward0</span>
 3670 |     | <span class='neutral'>  //                          |</span>
 3671 |     | <span class='neutral'>  //                     qOvershoot</span>
 3672 |     | <span class='neutral'>  //</span>
 3673 |     | <span class='neutral'>  // then &#39;indexKernelForward&#39; is incremented and the next piece of &#39;k(.)&#39; is</span>
 3674 |     | <span class='neutral'>  // loaded and stored in the memory spaces that are pointed to by &#39;_forward0_&#39;</span>
 3675 |     | <span class='neutral'>  // and &#39;_forward1_&#39;:</span>
 3676 |     | <span class='neutral'>  //</span>
 3677 |     | <span class='neutral'>  //      +-------------------+---------+---------+</span>
 3678 |     | <span class='neutral'>  //      |                   |         |</span>
 3679 |     | <span class='neutral'>  //  qForward1           qForward0  qBegin</span>
 3680 |     | <span class='neutral'>  //                          |</span>
 3681 |     | <span class='neutral'>  //                     qOvershoot</span>
 3682 |     | <span class='neutral'>  //</span>
 3683 |     | <span class='neutral'>  // Out of range values for &#39;indexKernelForward&#39; are avoided because of an</span>
 3684 |     | <span class='neutral'>  // input requirement here.</span>
 3685 |     | <span class='neutral'>  if (_overshoot_.log() == _forward1_.log()) moveBreakpointForward();</span>
 3686 |     | <span class='neutral'></span>
 3687 |     | <span class='neutral'>  // According to the above definitions for &#39;qBegin&#39; and &#39;qOvershoot&#39;, if</span>
 3688 |     | <span class='neutral'>  // &#39;getDirection() == false&#39;, then we have:</span>
 3689 |     | <span class='neutral'>  //</span>
 3690 |     | <span class='neutral'>  //  &#39;qTotal0 &lt;= qBegin &lt;= qOvershoot &lt;= qTotal1&#39;.</span>
 3691 |     | <span class='neutral'>  //</span>
 3692 |     | <span class='neutral'>  // In this case, if &#39;qOvershoot == qTotal1&#39; as illustrated below,</span>
 3693 |     | <span class='neutral'>  //</span>
 3694 |     | <span class='neutral'>  //      +---------+---------+</span>
 3695 |     | <span class='neutral'>  //      |         |         |</span>
 3696 |     | <span class='neutral'>  //   qTotal0   qBegin    qTotal1</span>
 3697 |     | <span class='neutral'>  //                          |</span>
 3698 |     | <span class='neutral'>  //                     qOvershoot</span>
 3699 |     | <span class='neutral'>  //</span>
 3700 |     | <span class='neutral'>  // then &#39;indexKernelTotal&#39; is incremented and the next piece of &#39;k(.)&#39; is</span>
 3701 |     | <span class='neutral'>  // loaded and stored in the memory spaces that are pointed to by &#39;_total0_&#39;</span>
 3702 |     | <span class='neutral'>  // and &#39;_total1_&#39;:</span>
 3703 |     | <span class='neutral'>  //</span>
 3704 |     | <span class='neutral'>  //      +---------+---------+-------------------+</span>
 3705 |     | <span class='neutral'>  //                |         |                   |</span>
 3706 |     | <span class='neutral'>  //             qBegin    qTotal0             qTotal1</span>
 3707 |     | <span class='neutral'>  //                          |</span>
 3708 |     | <span class='neutral'>  //                     qOvershoot</span>
 3709 |     | <span class='neutral'>  //</span>
 3710 |     | <span class='neutral'>  // If &#39;getDirection() == true&#39;, then we have:</span>
 3711 |     | <span class='neutral'>  //</span>
 3712 |     | <span class='neutral'>  //  &#39;qTotal1 &lt;= qOvershoot &lt;= qBegin &lt;= qTotal0&#39;.</span>
 3713 |     | <span class='neutral'>  //</span>
 3714 |     | <span class='neutral'>  // In this case, if &#39;qOvershoot == qTotal1&#39; as illustrated below,</span>
 3715 |     | <span class='neutral'>  //</span>
 3716 |     | <span class='neutral'>  //                          +---------+---------+</span>
 3717 |     | <span class='neutral'>  //                          |         |         |</span>
 3718 |     | <span class='neutral'>  //                       qTotal1   qBegin    qTotal0</span>
 3719 |     | <span class='neutral'>  //                          |</span>
 3720 |     | <span class='neutral'>  //                     qOvershoot</span>
 3721 |     | <span class='neutral'>  //</span>
 3722 |     | <span class='neutral'>  // then &#39;indexKernelTotal&#39; is incremented and the next piece of &#39;k(.)&#39; is</span>
 3723 |     | <span class='neutral'>  // loaded and stored in the memory spaces that are pointed to by &#39;_total0_&#39;</span>
 3724 |     | <span class='neutral'>  // and &#39;_total1_&#39;:</span>
 3725 |     | <span class='neutral'>  //</span>
 3726 |     | <span class='neutral'>  //      +-------------------+---------+---------+</span>
 3727 |     | <span class='neutral'>  //      |                   |         |</span>
 3728 |     | <span class='neutral'>  //   qTotal1             qTotal0   qBegin</span>
 3729 |     | <span class='neutral'>  //                          |</span>
 3730 |     | <span class='neutral'>  //                     qOvershoot</span>
 3731 |     | <span class='neutral'>  //</span>
 3732 |     | <span class='neutral'>  // Out of range values for &#39;indexKernelTotal&#39; are avoided because of an</span>
 3733 |     | <span class='neutral'>  // input requirement here.</span>
 3734 |     | <span class='neutral'>  if (_overshoot_.log() == _total1_.log()) moveBreakpointTotal();</span>
 3735 |     | <span class='neutral'></span>
 3736 |     | <span class='neutral'>  // The current direction is loaded from memory.</span>
 3737 |     | <span class='neutral'>  bool direction = getDirection();</span>
 3738 |     | <span class='neutral'></span>
 3739 |     | <span class='neutral'>  // According to the above definitions for &#39;qBegin&#39; and &#39;qOvershoot&#39;, if</span>
 3740 |     | <span class='neutral'>  // &#39;getDirection() == false&#39;, then we have:</span>
 3741 |     | <span class='neutral'>  //</span>
 3742 |     | <span class='neutral'>  //  &#39;q[indexCurve + 2] &lt;= qBegin &lt;= qOvershoot &lt;= qEnd&#39;.</span>
 3743 |     | <span class='neutral'>  //</span>
 3744 |     | <span class='neutral'>  // In this case, if &#39;qOvershoot == qEnd&#39; as illustrated below,</span>
 3745 |     | <span class='neutral'>  //</span>
 3746 |     | <span class='neutral'>  //         w(q)</span>
 3747 |     | <span class='neutral'>  //          ^</span>
 3748 |     | <span class='neutral'>  //  spacing |                                              /</span>
 3749 |     | <span class='neutral'>  //          |                                             /</span>
 3750 |     | <span class='neutral'>  //          |                                            /</span>
 3751 |     | <span class='neutral'>  //          |                                           /</span>
 3752 |     | <span class='neutral'>  //          |                                          /</span>
 3753 |     | <span class='neutral'>  //          |                                         /</span>
 3754 |     | <span class='neutral'>  //          |                                        /</span>
 3755 |     | <span class='neutral'>  //          |                                       /</span>
 3756 |     | <span class='neutral'>  //          |                                      /</span>
 3757 |     | <span class='neutral'>  //          |                                     /</span>
 3758 |     | <span class='neutral'>  //          |                                    /</span>
 3759 |     | <span class='neutral'>  //          |\</span>
 3760 |     | <span class='neutral'>  //          | \</span>
 3761 |     | <span class='neutral'>  //          |  \</span>
 3762 |     | <span class='neutral'>  //          |   \</span>
 3763 |     | <span class='neutral'>  //          |    \</span>
 3764 |     | <span class='neutral'>  //          |     \</span>
 3765 |     | <span class='neutral'>  //          |      \</span>
 3766 |     | <span class='neutral'>  //          |       \</span>
 3767 |     | <span class='neutral'>  //          |        \</span>
 3768 |     | <span class='neutral'>  //          |         \</span>
 3769 |     | <span class='neutral'>  //          |          \</span>
 3770 |     | <span class='neutral'>  //          |                                  /</span>
 3771 |     | <span class='neutral'>  //          |                                 /</span>
 3772 |     | <span class='neutral'>  //          |                                /</span>
 3773 |     | <span class='neutral'>  //          |                               /</span>
 3774 |     | <span class='neutral'>  //          |                              /</span>
 3775 |     | <span class='neutral'>  //          |                             /</span>
 3776 |     | <span class='neutral'>  //          |                            /</span>
 3777 |     | <span class='neutral'>  //          |                           /</span>
 3778 |     | <span class='neutral'>  //          |                          /</span>
 3779 |     | <span class='neutral'>  //          |                         /</span>
 3780 |     | <span class='neutral'>  //          |                        /</span>
 3781 |     | <span class='neutral'>  //          |            \</span>
 3782 |     | <span class='neutral'>  //          |             \</span>
 3783 |     | <span class='neutral'>  //          |              \</span>
 3784 |     | <span class='neutral'>  //          |               \</span>
 3785 |     | <span class='neutral'>  //          |                \</span>
 3786 |     | <span class='neutral'>  //          |                 \</span>
 3787 |     | <span class='neutral'>  //          |                  \</span>
 3788 |     | <span class='neutral'>  //          |                   \</span>
 3789 |     | <span class='neutral'>  //          |                    \</span>
 3790 |     | <span class='neutral'>  //          |                     \</span>
 3791 |     | <span class='neutral'>  //          |                      \</span>
 3792 |     | <span class='neutral'>  //        0 +-----------+-----------+-----+-----+-----+-----+&gt; q</span>
 3793 |     | <span class='neutral'>  //                      |           |     |     |</span>
 3794 |     | <span class='neutral'>  //                   qOrigin        |  qBegin  qEnd</span>
 3795 |     | <span class='neutral'>  //                                  |           |</span>
 3796 |     | <span class='neutral'>  //                                  |       qOvershoot</span>
 3797 |     | <span class='neutral'>  //                                  |</span>
 3798 |     | <span class='neutral'>  //                                  |</span>
 3799 |     | <span class='neutral'>  //                                  |</span>
 3800 |     | <span class='neutral'>  //                          q[indexCurve + 2]</span>
 3801 |     | <span class='neutral'>  //</span>
 3802 |     | <span class='neutral'>  // then &#39;indexCurve&#39; is decremented, the direction is flipped and the next</span>
 3803 |     | <span class='neutral'>  // phase of &#39;w(.)&#39; is loaded by setting:</span>
 3804 |     | <span class='neutral'>  //</span>
 3805 |     | <span class='neutral'>  //  &#39;qEnd := q[indexCurve]&#39;</span>
 3806 |     | <span class='neutral'>  //</span>
 3807 |     | <span class='neutral'>  //  &#39;qOrigin := q[indexCurve + 1]&#39;</span>
 3808 |     | <span class='neutral'>  //</span>
 3809 |     | <span class='neutral'>  //  &#39;qBegin := q[indexCurve + 2]&#39;</span>
 3810 |     | <span class='neutral'>  //</span>
 3811 |     | <span class='neutral'>  // which is illustrated as follows:</span>
 3812 |     | <span class='neutral'>  //</span>
 3813 |     | <span class='neutral'>  //         w(q)</span>
 3814 |     | <span class='neutral'>  //          ^</span>
 3815 |     | <span class='neutral'>  //  spacing |                                              /</span>
 3816 |     | <span class='neutral'>  //          |                                             /</span>
 3817 |     | <span class='neutral'>  //          |                                            /</span>
 3818 |     | <span class='neutral'>  //          |                                           /</span>
 3819 |     | <span class='neutral'>  //          |                                          /</span>
 3820 |     | <span class='neutral'>  //          |                                         /</span>
 3821 |     | <span class='neutral'>  //          |                                        /</span>
 3822 |     | <span class='neutral'>  //          |                                       /</span>
 3823 |     | <span class='neutral'>  //          |                                      /</span>
 3824 |     | <span class='neutral'>  //          |                                     /</span>
 3825 |     | <span class='neutral'>  //          |                                    /</span>
 3826 |     | <span class='neutral'>  //          |\</span>
 3827 |     | <span class='neutral'>  //          | \</span>
 3828 |     | <span class='neutral'>  //          |  \</span>
 3829 |     | <span class='neutral'>  //          |   \</span>
 3830 |     | <span class='neutral'>  //          |    \</span>
 3831 |     | <span class='neutral'>  //          |     \</span>
 3832 |     | <span class='neutral'>  //          |      \</span>
 3833 |     | <span class='neutral'>  //          |       \</span>
 3834 |     | <span class='neutral'>  //          |        \</span>
 3835 |     | <span class='neutral'>  //          |         \</span>
 3836 |     | <span class='neutral'>  //          |          \</span>
 3837 |     | <span class='neutral'>  //          |                                  /</span>
 3838 |     | <span class='neutral'>  //          |                                 /</span>
 3839 |     | <span class='neutral'>  //          |                                /</span>
 3840 |     | <span class='neutral'>  //          |                               /</span>
 3841 |     | <span class='neutral'>  //          |                              /</span>
 3842 |     | <span class='neutral'>  //          |                             /</span>
 3843 |     | <span class='neutral'>  //          |                            /</span>
 3844 |     | <span class='neutral'>  //          |                           /</span>
 3845 |     | <span class='neutral'>  //          |                          /</span>
 3846 |     | <span class='neutral'>  //          |                         /</span>
 3847 |     | <span class='neutral'>  //          |                        /</span>
 3848 |     | <span class='neutral'>  //          |            \</span>
 3849 |     | <span class='neutral'>  //          |             \</span>
 3850 |     | <span class='neutral'>  //          |              \</span>
 3851 |     | <span class='neutral'>  //          |               \</span>
 3852 |     | <span class='neutral'>  //          |                \</span>
 3853 |     | <span class='neutral'>  //          |                 \</span>
 3854 |     | <span class='neutral'>  //          |                  \</span>
 3855 |     | <span class='neutral'>  //          |                   \</span>
 3856 |     | <span class='neutral'>  //          |                    \</span>
 3857 |     | <span class='neutral'>  //          |                     \</span>
 3858 |     | <span class='neutral'>  //          |                      \</span>
 3859 |     | <span class='neutral'>  //        0 +-----------+-----------+-----------+-----------+&gt; q</span>
 3860 |     | <span class='neutral'>  //          |           |                       |</span>
 3861 |     | <span class='neutral'>  //        qEnd       qBegin                  qOrigin</span>
 3862 |     | <span class='neutral'>  //                      |                       |</span>
 3863 |     | <span class='neutral'>  //              q[indexCurve + 2]          qOvershoot</span>
 3864 |     | <span class='neutral'>  //</span>
 3865 |     | <span class='neutral'>  // If &#39;getDirection() == true&#39;, then we have:</span>
 3866 |     | <span class='neutral'>  //</span>
 3867 |     | <span class='neutral'>  //  &#39;qEnd &lt;= qOvershoot &lt;= qBegin &lt;= q[indexCurve + 2]&#39;.</span>
 3868 |     | <span class='neutral'>  //</span>
 3869 |     | <span class='neutral'>  // and a similar argument can be made.</span>
 3870 |     | <span class='neutral'>  if (_overshoot_.log() == _end_.log()) {</span>
 3871 |     | <span class='neutral'>    // Once we move the phase, the direction flips and &#39;qOrigin&#39; will be moved</span>
 3872 |     | <span class='neutral'>    // to &#39;qEnd&#39;. Hence, the following integral</span>
 3873 |     | <span class='neutral'>    //</span>
 3874 |     | <span class='neutral'>    //                             - 8</span>
 3875 |     | <span class='neutral'>    //    originToOvershoot      e</span>
 3876 |     | <span class='neutral'>    //  &#39;------------------- == ------- * (</span>
 3877 |     | <span class='neutral'>    //        2 ** 216             2</span>
 3878 |     | <span class='neutral'>    //</span>
 3879 |     | <span class='neutral'>    //     getZeroForOne() ? </span>
 3880 |     | <span class='neutral'>    //</span>
 3881 |     | <span class='neutral'>    //       / qOrigin</span>
 3882 |     | <span class='neutral'>    //      |    + h / 2</span>
 3883 |     | <span class='neutral'>    //      |  e         k(qOrigin - h) dh :</span>
 3884 |     | <span class='neutral'>    //      |</span>
 3885 |     | <span class='neutral'>    //     / qEnd</span>
 3886 |     | <span class='neutral'>    //</span>
 3887 |     | <span class='neutral'>    //       / qEnd</span>
 3888 |     | <span class='neutral'>    //      |    - h / 2</span>
 3889 |     | <span class='neutral'>    //      |  e         k(h - qOrigin) dh</span>
 3890 |     | <span class='neutral'>    //      |</span>
 3891 |     | <span class='neutral'>    //     / qOrigin</span>
 3892 |     | <span class='neutral'>    //</span>
 3893 |     | <span class='neutral'>    //   )&#39;</span>
 3894 |     | <span class='neutral'>    //</span>
 3895 |     | <span class='neutral'>    // should be transformed to</span>
 3896 |     | <span class='neutral'>    //</span>
 3897 |     | <span class='neutral'>    //                             - 8</span>
 3898 |     | <span class='neutral'>    //    originToOvershoot      e</span>
 3899 |     | <span class='neutral'>    //  &#39;------------------- := ------- * (</span>
 3900 |     | <span class='neutral'>    //        2 ** 216             2</span>
 3901 |     | <span class='neutral'>    //</span>
 3902 |     | <span class='neutral'>    //     getZeroForOne() ? </span>
 3903 |     | <span class='neutral'>    //</span>
 3904 |     | <span class='neutral'>    //       / qOrigin</span>
 3905 |     | <span class='neutral'>    //      |    - h / 2</span>
 3906 |     | <span class='neutral'>    //      |  e         k(h - qEnd) dh :</span>
 3907 |     | <span class='neutral'>    //      |</span>
 3908 |     | <span class='neutral'>    //     / qEnd</span>
 3909 |     | <span class='neutral'>    //</span>
 3910 |     | <span class='neutral'>    //       / qEnd</span>
 3911 |     | <span class='neutral'>    //      |    + h / 2</span>
 3912 |     | <span class='neutral'>    //      |  e         k(qEnd - h) dh</span>
 3913 |     | <span class='neutral'>    //      |</span>
 3914 |     | <span class='neutral'>    //     / qOrigin</span>
 3915 |     | <span class='neutral'>    //</span>
 3916 |     | <span class='neutral'>    //   )&#39;</span>
 3917 |     | <span class='neutral'>    //</span>
 3918 |     | <span class='neutral'>    // The loaded integral does not exceed 216-bits and hence, the input</span>
 3919 |     | <span class='neutral'>    // requirement of shift is satisfied.</span>
 3920 |     | <span class='neutral'>    _originToOvershoot_.setIntegral(</span>
 3921 |     | <span class='neutral'>      _originToOvershoot_.integral().shift(_overshoot_, _origin_, direction)</span>
 3922 |     | <span class='neutral'>    );</span>
 3923 |     | <span class='neutral'></span>
 3924 |     | <span class='neutral'>    // Underflow of &#39;indexCurve&#39; is avoided externally via an input requirement</span>
 3925 |     | <span class='neutral'>    // of the present function.</span>
 3926 |     | <span class='neutral'>    direction = movePhase();</span>
 3927 |     | <span class='neutral'>  }</span>
 3928 |     | <span class='neutral'></span>
 3929 |     | <span class='neutral'>  // If the phase is moved, then we have:</span>
 3930 |     | <span class='neutral'>  //</span>
 3931 |     | <span class='neutral'>  //  &#39;qBegin == q[indexCurve + 2]&#39;.</span>
 3932 |     | <span class='neutral'>  //</span>
 3933 |     | <span class='neutral'>  // If the phase is not moved, then the kernel piece is moved and we have:</span>
 3934 |     | <span class='neutral'>  //</span>
 3935 |     | <span class='neutral'>  //  &#39;qBegin &lt;= qOvershoot == qTotal0&#39;.</span>
 3936 |     | <span class='neutral'>  //</span>
 3937 |     | <span class='neutral'>  // In both cases, we need to set:</span>
 3938 |     | <span class='neutral'>  //</span>
 3939 |     | <span class='neutral'>  //  &#39;qBegin := direction ? min(qBegin, qTotal0) : max(qBegin, qTotal0)&#39;</span>
 3940 |     | <span class='neutral'>  //</span>
 3941 |     | <span class='neutral'>  // which is equivalent to setting:</span>
 3942 |     | <span class='neutral'>  //</span>
 3943 |     | <span class='neutral'>  //  &#39;qBegin := qTotal0&#39;</span>
 3944 |     | <span class='neutral'>  //</span>
 3945 |     | <span class='neutral'>  // if and only if &#39;direction != (qBegin &lt; qTotal0)&#39;.</span>
 3946 |     | <span class='neutral'>  //</span>
 3947 |     | <span class='neutral'>  // Signed comparison is valid because as we argued before in this script,</span>
 3948 |     | <span class='neutral'>  // both &#39;qBegin&#39; and &#39;qTotal0&#39; are greater than &#39;0&#39; and less than &#39;32&#39;. This</span>
 3949 |     | <span class='neutral'>  // is due to the custom error &#39;BlankIntervalsShouldBeAvoided&#39; ensures that</span>
 3950 |     | <span class='neutral'>  // &#39;16 + qLower&#39; is greater than &#39;qSpacing&#39; and &#39;16 + qUpper&#39; is smaller than</span>
 3951 |     | <span class='neutral'>  // &#39;32 - qSpacing&#39;.</span>
 3952 |     | <span class='neutral'>  if (direction != _begin_.log() &lt; _total0_.log()) {</span>
 3953 |     | <span class='neutral'>    _begin_.copyPrice(_total0_);</span>
 3954 |     | <span class='neutral'>  }</span>
 3955 |     | <span class='neutral'></span>
 3956 |     | <span class='neutral'>  // Next, we need to set:</span>
 3957 |     | <span class='neutral'>  //</span>
 3958 |     | <span class='neutral'>  //  &#39;qOvershoot := direction ? min(qEnd, qTotal1) : max(qEnd, qTotal1)&#39;</span>
 3959 |     | <span class='neutral'>  //</span>
 3960 |     | <span class='neutral'>  // which is equivalent to setting:</span>
 3961 |     | <span class='neutral'>  //</span>
 3962 |     | <span class='neutral'>  //  &#39;qOvershoot := qTotal1&#39;</span>
 3963 |     | <span class='neutral'>  //</span>
 3964 |     | <span class='neutral'>  // if and only if &#39;direction == (qEnd &lt; qTotal1)&#39; and</span>
 3965 |     | <span class='neutral'>  //</span>
 3966 |     | <span class='neutral'>  //  &#39;qOvershoot := qEnd&#39;</span>
 3967 |     | <span class='neutral'>  //</span>
 3968 |     | <span class='neutral'>  // otherwise.</span>
 3969 |     | <span class='neutral'>  //</span>
 3970 |     | <span class='neutral'>  // Signed comparison is valid because as we argued before.</span>
 3971 |     | <span class='neutral'>  _overshoot_.copyPrice(</span>
 3972 |     | <span class='neutral'>    (direction == (_end_.log() &lt; _total1_.log())) ? _total1_ : _end_</span>
 3973 |     | <span class='neutral'>  );</span>
 3974 |     | <span class='neutral'></span>
 3975 |     | <span class='neutral'>  if (direction == getZeroForOne()) {</span>
 3976 |     | <span class='neutral'>    // In this case, we need to set:</span>
 3977 |     | <span class='neutral'>    //</span>
 3978 |     | <span class='neutral'>    //  &#39;qBegin := direction ? min(qBegin, qForward0) : max(qBegin, qForward0)&#39;</span>
 3979 |     | <span class='neutral'>    //</span>
 3980 |     | <span class='neutral'>    // which is equivalent to setting:</span>
 3981 |     | <span class='neutral'>    //</span>
 3982 |     | <span class='neutral'>    //  &#39;qBegin := qForward0&#39;</span>
 3983 |     | <span class='neutral'>    //</span>
 3984 |     | <span class='neutral'>    // if and only if &#39;direction != (qBegin &lt; qForward0)&#39;.</span>
 3985 |     | <span class='neutral'>    //</span>
 3986 |     | <span class='neutral'>    // Signed comparison is valid because as we argued before.</span>
 3987 |     | <span class='neutral'>    if (direction != (_begin_.log() &lt; _forward0_.log())) {</span>
 3988 |     | <span class='neutral'>      _begin_.copyPrice(_forward0_);</span>
 3989 |     | <span class='neutral'>    }</span>
 3990 |     | <span class='neutral'></span>
 3991 |     | <span class='neutral'>    // Next, we need to set:</span>
 3992 |     | <span class='neutral'>    //</span>
 3993 |     | <span class='neutral'>    //  &#39;qOvershoot := direction ? </span>
 3994 |     | <span class='neutral'>    //                 min(qOvershoot, qForward1) : </span>
 3995 |     | <span class='neutral'>    //                 max(qOvershoot, qForward1)&#39;</span>
 3996 |     | <span class='neutral'>    //</span>
 3997 |     | <span class='neutral'>    // which is equivalent to setting:</span>
 3998 |     | <span class='neutral'>    //</span>
 3999 |     | <span class='neutral'>    //  &#39;qOvershoot := qForward1&#39;</span>
 4000 |     | <span class='neutral'>    //</span>
 4001 |     | <span class='neutral'>    // if and only if &#39;direction == (qOvershoot &lt; qForward1)&#39;.</span>
 4002 |     | <span class='neutral'>    //</span>
 4003 |     | <span class='neutral'>    // Signed comparison is valid because as we argued before.</span>
 4004 |     | <span class='neutral'>    if (direction == (_overshoot_.log() &lt; _forward1_.log())) {</span>
 4005 |     | <span class='neutral'>      _overshoot_.copyPrice(_forward1_);</span>
 4006 |     | <span class='neutral'>    }</span>
 4007 |     | <span class='neutral'>  }</span>
 4008 |     | <span class='neutral'></span>
 4009 |     | <span class='neutral'>  // Next, if &#39;direction == getZeroForOne()&#39;, we increment the integrals:</span>
 4010 |     | <span class='neutral'>  //</span>
 4011 |     | <span class='neutral'>  //  - &#39;currentToOvershoot&#39;,</span>
 4012 |     | <span class='neutral'>  //  - &#39;targetToOvershoot&#39;,</span>
 4013 |     | <span class='neutral'>  //  - &#39;originToOvershoot&#39;.</span>
 4014 |     | <span class='neutral'>  //</span>
 4015 |     | <span class='neutral'>  // Otherwise, we increment the integrals:</span>
 4016 |     | <span class='neutral'>  //</span>
 4017 |     | <span class='neutral'>  //  - &#39;currentToOrigin&#39;</span>
 4018 |     | <span class='neutral'>  //  - &#39;originToOvershoot&#39;</span>
 4019 |     | <span class='neutral'>  //</span>
 4020 |     | <span class='neutral'>  // As argued before, if &#39;direction == false&#39;, then</span>
 4021 |     | <span class='neutral'>  //</span>
 4022 |     | <span class='neutral'>  //  &#39;qTotal0 &lt;= qBegin &lt;= qOvershoot &lt;= qTotal1&#39;.</span>
 4023 |     | <span class='neutral'>  //</span>
 4024 |     | <span class='neutral'>  // and if &#39;direction == true&#39;, then</span>
 4025 |     | <span class='neutral'>  //</span>
 4026 |     | <span class='neutral'>  //  &#39;qTotal1 &lt;= qOvershoot &lt;= qBegin &lt;= qTotal0&#39;.</span>
 4027 |     | <span class='neutral'>  //</span>
 4028 |     | <span class='neutral'>  // Additionally, since the vertical coordinates of kernel are monotonic,</span>
 4029 |     | <span class='neutral'>  // we have &#39;cTotal0 &lt;= cTotal1&#39; and the input requirements of &#39;outgoing&#39;</span>
 4030 |     | <span class='neutral'>  // are satisfied.</span>
 4031 |     | <span class='neutral'>  X216 outgoingTotal = _total0_.outgoing(_begin_, _overshoot_);</span>
 4032 |     | <span class='neutral'>  if (direction == getZeroForOne()) {</span>
 4033 |     | <span class='neutral'>    // As argued before, if &#39;direction == false&#39;, then</span>
 4034 |     | <span class='neutral'>    //</span>
 4035 |     | <span class='neutral'>    //  &#39;qForward0 &lt;= qBegin &lt;= qOvershoot &lt;= qForward1&#39;.</span>
 4036 |     | <span class='neutral'>    //</span>
 4037 |     | <span class='neutral'>    // and if &#39;direction == true&#39;, then</span>
 4038 |     | <span class='neutral'>    //</span>
 4039 |     | <span class='neutral'>    //  &#39;qForward1 &lt;= qOvershoot &lt;= qBegin &lt;= qForward0&#39;.</span>
 4040 |     | <span class='neutral'>    //</span>
 4041 |     | <span class='neutral'>    // Additionally, since the vertical coordinates of kernel are monotonic,</span>
 4042 |     | <span class='neutral'>    // we have &#39;cForward0 &lt;= cForward1&#39; and the input requirements of</span>
 4043 |     | <span class='neutral'>    // &#39;outgoing&#39; are satisfied.</span>
 4044 |     | <span class='neutral'>    X216 outgoingForward = _forward0_.outgoing(_begin_, _overshoot_);</span>
 4045 |     | <span class='neutral'></span>
 4046 |     | <span class='neutral'>    // Next, &#39;currentToOvershoot&#39; is incremented with &#39;outgoingTotal&#39;. Based on</span>
 4047 |     | <span class='neutral'>    // the earlier argument in this script, overflow is not possible because</span>
 4048 |     | <span class='neutral'>    // theoretically, no outgoing or incoming integral may exceed 216 bits.</span>
 4049 |     | <span class='neutral'>    _currentToOvershoot_.incrementIntegral(outgoingTotal);</span>
 4050 |     | <span class='neutral'></span>
 4051 |     | <span class='neutral'>    // Next, &#39;targetToOvershoot&#39; is incremented with &#39;outgoingForward&#39;. Based</span>
 4052 |     | <span class='neutral'>    // on the earlier argument in this script, overflow is not possible because</span>
 4053 |     | <span class='neutral'>    // theoretically, no outgoing or incoming integral may exceed 216 bits.</span>
 4054 |     | <span class='neutral'>    _targetToOvershoot_.incrementIntegral(outgoingForward);</span>
 4055 |     | <span class='neutral'></span>
 4056 |     | <span class='neutral'>    // Next, &#39;originToOvershoot&#39; is incremented with &#39;outgoingTotal&#39;. Based on</span>
 4057 |     | <span class='neutral'>    // the earlier argument in this script, overflow is not possible because</span>
 4058 |     | <span class='neutral'>    // theoretically, no outgoing or incoming integral may exceed 216 bits.</span>
 4059 |     | <span class='neutral'>    _originToOvershoot_.incrementIntegral(outgoingTotal);</span>
 4060 |     | <span class='neutral'></span>
 4061 |     | <span class='neutral'>    // If &#39;f(qOvershoot) &gt; 0&#39;, then we project all of the integrals back to</span>
 4062 |     | <span class='neutral'>    // their original values (prior to calling this function) and return</span>
 4063 |     | <span class='neutral'>    // &#39;false&#39;. The numerical search for overshoot will then start from</span>
 4064 |     | <span class='neutral'>    // &#39;qBegin&#39;.</span>
 4065 |     | <span class='neutral'>    if (getMismatch(integral0Incremented, integral1Incremented) &gt; zeroX216) {</span>
 4066 |     | <span class='neutral'>      _end_.copyPrice(_overshoot_);</span>
 4067 |     | <span class='neutral'>      _currentToOvershoot_.decrementIntegral(outgoingTotal);</span>
 4068 |     | <span class='neutral'>      _targetToOvershoot_.decrementIntegral(outgoingForward);</span>
 4069 |     | <span class='neutral'>      _originToOvershoot_.decrementIntegral(outgoingTotal);</span>
 4070 |     | <span class='neutral'>      _overshoot_.copyPrice(_begin_);</span>
 4071 |     | <span class='neutral'>      return false;</span>
 4072 |     | <span class='neutral'>    }</span>
 4073 |     | <span class='neutral'>  } else {</span>
 4074 |     | <span class='neutral'>    // Next, &#39;currentToOrigin&#39; is incremented with &#39;outgoingTotal&#39;. Based on</span>
 4075 |     | <span class='neutral'>    // the earlier argument in this script, overflow is not possible because</span>
 4076 |     | <span class='neutral'>    // theoretically, no outgoing or incoming integral may exceed 216 bits.</span>
 4077 |     | <span class='neutral'>    _currentToOrigin_.incrementIntegral(outgoingTotal);</span>
 4078 |     | <span class='neutral'></span>
 4079 |     | <span class='neutral'>    // Next, &#39;originToOvershoot&#39; is incremented with &#39;outgoingTotal&#39;. Based on</span>
 4080 |     | <span class='neutral'>    // the earlier argument in this script, overflow is not possible because</span>
 4081 |     | <span class='neutral'>    // theoretically, no outgoing or incoming integral may exceed 216 bits.</span>
 4082 |     | <span class='neutral'>    _originToOvershoot_.incrementIntegral(outgoingTotal);</span>
 4083 |     | <span class='neutral'>  }</span>
 4084 |     | <span class='neutral'>  return true;</span>
 4085 |     | <span class='neutral'>}</span>
 4086 |     | <span class='neutral'></span>
 4087 |     | <span class='neutral'>/// @notice Assume that the search for &#39;qTarget&#39; is concluded and we need to</span>
 4088 |     | <span class='neutral'>/// determine &#39;qOvershoot&#39;. To this end, the following equation should be</span>
 4089 |     | <span class='neutral'>/// solved:</span>
 4090 |     | <span class='neutral'>///</span>
 4091 |     | <span class='neutral'>///   &#39;f(qOvershoot) == 0&#39;</span>
 4092 |     | <span class='neutral'>///</span>
 4093 |     | <span class='neutral'>/// where</span>
 4094 |     | <span class='neutral'>///</span>
 4095 |     | <span class='neutral'>///   &#39;f(qOvershoot) := getZeroForOne() ? </span>
 4096 |     | <span class='neutral'>///                     s0(qOvershoot) - s1(qOvershoot) : </span>
 4097 |     | <span class='neutral'>///                     s1(qOvershoot) - s0(qOvershoot)&#39;,</span>
 4098 |     | <span class='neutral'>///</span>
 4099 |     | <span class='neutral'>/// and the two functions &#39;s0&#39; and &#39;s1&#39; are defined as:</span>
 4100 |     | <span class='neutral'>///</span>
 4101 |     | <span class='neutral'>///                          - 8      / qTarget</span>
 4102 |     | <span class='neutral'>///                        e         |   + h / 2</span>
 4103 |     | <span class='neutral'>///                       ------- *  |  e        k(wAmended(h)) dh</span>
 4104 |     | <span class='neutral'>///                          2       |</span>
 4105 |     | <span class='neutral'>///                                 / qLower</span>
 4106 |     | <span class='neutral'>///   &#39;s1(qOvershoot) := ------------------------------------------&#39;,</span>
 4107 |     | <span class='neutral'>///                                integral1Incremented</span>
 4108 |     | <span class='neutral'>///</span>
 4109 |     | <span class='neutral'>///                          - 8      / qUpper</span>
 4110 |     | <span class='neutral'>///                        e         |   - h / 2</span>
 4111 |     | <span class='neutral'>///                       ------- *  |  e        k(wAmended(h)) dh</span>
 4112 |     | <span class='neutral'>///                          2       |</span>
 4113 |     | <span class='neutral'>///                                 / qTarget</span>
 4114 |     | <span class='neutral'>///   &#39;s0(qOvershoot) := ------------------------------------------&#39;,</span>
 4115 |     | <span class='neutral'>///                                integral0Incremented</span>
 4116 |     | <span class='neutral'>///</span>
 4117 |     | <span class='neutral'>/// where, according to the amendment procedure which is described in</span>
 4118 |     | <span class='neutral'>/// &#39;Curve.sol&#39;, if &#39;getZeroForOne() == false&#39;, we have:</span>
 4119 |     | <span class='neutral'>///</span>
 4120 |     | <span class='neutral'>///                       / k(w(h))            if  qOvershoot &lt; h &lt; qUpper</span>
 4121 |     | <span class='neutral'>///   &#39;k(wAmended(h)) == |  k(h - qTarget)     if  qTarget &lt; h &lt; qOvershoot &#39;</span>
 4122 |     | <span class='neutral'>///                      |  k(qOvershoot - h)  if  qOrigin &lt; h &lt; qTarget</span>
 4123 |     | <span class='neutral'>///                       \ k(w(h))            if  qLower &lt; h &lt; qOrigin</span>
 4124 |     | <span class='neutral'>///</span>
 4125 |     | <span class='neutral'>/// and if &#39;getZeroForOne() == true&#39;, we have:</span>
 4126 |     | <span class='neutral'>///</span>
 4127 |     | <span class='neutral'>///                       / k(w(h))            if  qLower &lt; h &lt; qOvershoot</span>
 4128 |     | <span class='neutral'>///   &#39;k(wAmended(h)) == |  k(qTarget - h)     if  qOvershoot &lt; h &lt; qTarget &#39;.</span>
 4129 |     | <span class='neutral'>///                      |  k(h - qOvershoot)  if  qTarget &lt; h &lt; qOrigin</span>
 4130 |     | <span class='neutral'>///                       \ k(w(h))            if  qOrigin &lt; h &lt; qUpper</span>
 4131 |     | <span class='neutral'>///</span>
 4132 |     | <span class='neutral'>/// The present function evaluates the Newton step:</span>
 4133 |     | <span class='neutral'>///</span>
 4134 |     | <span class='neutral'>///                    f(qOvershoot)</span>
 4135 |     | <span class='neutral'>///   &#39;qStep = ------------------------------&#39;.</span>
 4136 |     | <span class='neutral'>///                   d</span>
 4137 |     | <span class='neutral'>///             -------------- f(qOvershoot)</span>
 4138 |     | <span class='neutral'>///              d qOvershoot</span>
 4139 |     | <span class='neutral'>///</span>
 4140 |     | <span class='neutral'>/// To this end, we use the following formula for &#39;f(qOvershoot)&#39; which is</span>
 4141 |     | <span class='neutral'>/// proven in &#39;Memory.sol&#39;:</span>
 4142 |     | <span class='neutral'>///</span>
 4143 |     | <span class='neutral'>///   &#39;f(qOvershoot) := getZeroForOne() ? (</span>
 4144 |     | <span class='neutral'>///</span>
 4145 |     | <span class='neutral'>///          integral0Amended         integral1Amended</span>
 4146 |     | <span class='neutral'>///       ---------------------- - ----------------------</span>
 4147 |     | <span class='neutral'>///        integral0Incremented     integral1Incremented</span>
 4148 |     | <span class='neutral'>///</span>
 4149 |     | <span class='neutral'>///    ) : (</span>
 4150 |     | <span class='neutral'>///</span>
 4151 |     | <span class='neutral'>///          integral1Amended         integral0Amended</span>
 4152 |     | <span class='neutral'>///       ---------------------- - ----------------------</span>
 4153 |     | <span class='neutral'>///        integral1Incremented     integral0Incremented</span>
 4154 |     | <span class='neutral'>///</span>
 4155 |     | <span class='neutral'>///    )&#39;,</span>
 4156 |     | <span class='neutral'>///</span>
 4157 |     | <span class='neutral'>/// where</span>
 4158 |     | <span class='neutral'>///</span>
 4159 |     | <span class='neutral'>///   &#39;integral0Amended := getZeroForOne() ? (</span>
 4160 |     | <span class='neutral'>///</span>
 4161 |     | <span class='neutral'>///       exp(- (qOrigin + qOvershoot) / 2) * originToOvershoot -</span>
 4162 |     | <span class='neutral'>///</span>
 4163 |     | <span class='neutral'>///       exp(- (qTarget + qOvershoot) / 2) * targetToOvershoot - </span>
 4164 |     | <span class='neutral'>///</span>
 4165 |     | <span class='neutral'>///       integral0Incremented + incomingCurrentToTarget - currentToOrigin</span>
 4166 |     | <span class='neutral'>///</span>
 4167 |     | <span class='neutral'>///    ) : (</span>
 4168 |     | <span class='neutral'>///</span>
 4169 |     | <span class='neutral'>///       integral0Incremented + targetToOvershoot + </span>
 4170 |     | <span class='neutral'>///</span>
 4171 |     | <span class='neutral'>///       currentToTarget - currentToOvershoot</span>
 4172 |     | <span class='neutral'>///</span>
 4173 |     | <span class='neutral'>///    )&#39;,</span>
 4174 |     | <span class='neutral'>///</span>
 4175 |     | <span class='neutral'>/// and</span>
 4176 |     | <span class='neutral'>///</span>
 4177 |     | <span class='neutral'>///   &#39;integral1Amended := getZeroForOne() ? (</span>
 4178 |     | <span class='neutral'>///</span>
 4179 |     | <span class='neutral'>///       integral1Incremented + targetToOvershoot + </span>
 4180 |     | <span class='neutral'>///</span>
 4181 |     | <span class='neutral'>///       currentToTarget - currentToOvershoot</span>
 4182 |     | <span class='neutral'>///</span>
 4183 |     | <span class='neutral'>///    ) : (</span>
 4184 |     | <span class='neutral'>///</span>
 4185 |     | <span class='neutral'>///       exp(+ (qOrigin + qOvershoot) / 2) * originToOvershoot -</span>
 4186 |     | <span class='neutral'>///</span>
 4187 |     | <span class='neutral'>///       exp(+ (qTarget + qOvershoot) / 2) * targetToOvershoot - </span>
 4188 |     | <span class='neutral'>///</span>
 4189 |     | <span class='neutral'>///       integral1Incremented + incomingCurrentToTarget - currentToOrigin</span>
 4190 |     | <span class='neutral'>///</span>
 4191 |     | <span class='neutral'>///    )&#39;.</span>
 4192 |     | <span class='neutral'>///</span>
 4193 |     | <span class='neutral'>/// In addition the following formula is used to compute the derivative:</span>
 4194 |     | <span class='neutral'>///</span>
 4195 |     | <span class='neutral'>///          d f</span>
 4196 |     | <span class='neutral'>///   &#39;-------------- == getZeroForOne() ? (</span>
 4197 |     | <span class='neutral'>///     d qOvershoot</span>
 4198 |     | <span class='neutral'>///</span>
 4199 |     | <span class='neutral'>///      (</span>
 4200 |     | <span class='neutral'>///</span>
 4201 |     | <span class='neutral'>///           - 8 + qOvershoot / 2</span>
 4202 |     | <span class='neutral'>///         e</span>
 4203 |     | <span class='neutral'>///        ------------------------ * k(qTarget - qOvershoot) - </span>
 4204 |     | <span class='neutral'>///                    2</span>
 4205 |     | <span class='neutral'>///</span>
 4206 |     | <span class='neutral'>///           - 8 + qOvershoot / 2</span>
 4207 |     | <span class='neutral'>///         e</span>
 4208 |     | <span class='neutral'>///        ------------------------ * k(qOrigin - qOvershoot) </span>
 4209 |     | <span class='neutral'>///                    2</span>
 4210 |     | <span class='neutral'>///</span>
 4211 |     | <span class='neutral'>///      ) / integral1Incremented - (</span>
 4212 |     | <span class='neutral'>///</span>
 4213 |     | <span class='neutral'>///          - (qOrigin + qOvershoot) / 2    originToOvershoot</span>
 4214 |     | <span class='neutral'>///        e                              * ------------------- -</span>
 4215 |     | <span class='neutral'>///                                                  2</span>
 4216 |     | <span class='neutral'>///</span>
 4217 |     | <span class='neutral'>///          - (qTarget + qOvershoot) / 2    targetToOvershoot</span>
 4218 |     | <span class='neutral'>///        e                              * ------------------- +</span>
 4219 |     | <span class='neutral'>///                                                  2</span>
 4220 |     | <span class='neutral'>///           - 8 - qOrigin / 2</span>
 4221 |     | <span class='neutral'>///         e</span>
 4222 |     | <span class='neutral'>///        --------------------- * k(qOrigin - qOvershoot) - </span>
 4223 |     | <span class='neutral'>///                  2</span>
 4224 |     | <span class='neutral'>///</span>
 4225 |     | <span class='neutral'>///           - 8 - qTarget / 2</span>
 4226 |     | <span class='neutral'>///         e</span>
 4227 |     | <span class='neutral'>///        --------------------- * k(qTarget - qOvershoot)</span>
 4228 |     | <span class='neutral'>///                  2</span>
 4229 |     | <span class='neutral'>///</span>
 4230 |     | <span class='neutral'>///      ) / integral0Incremented</span>
 4231 |     | <span class='neutral'>///</span>
 4232 |     | <span class='neutral'>///    ) : (</span>
 4233 |     | <span class='neutral'>///</span>
 4234 |     | <span class='neutral'>///      (</span>
 4235 |     | <span class='neutral'>///</span>
 4236 |     | <span class='neutral'>///          + (qOrigin + qOvershoot) / 2    originToOvershoot</span>
 4237 |     | <span class='neutral'>///        e                              * ------------------- -</span>
 4238 |     | <span class='neutral'>///                                                  2</span>
 4239 |     | <span class='neutral'>///</span>
 4240 |     | <span class='neutral'>///          + (qTarget + qOvershoot) / 2    targetToOvershoot</span>
 4241 |     | <span class='neutral'>///        e                              * ------------------- +</span>
 4242 |     | <span class='neutral'>///                                                  2</span>
 4243 |     | <span class='neutral'>///           - 8 + qOrigin / 2</span>
 4244 |     | <span class='neutral'>///         e</span>
 4245 |     | <span class='neutral'>///        --------------------- * k(qOvershoot - qOrigin) -</span>
 4246 |     | <span class='neutral'>///                  2</span>
 4247 |     | <span class='neutral'>///</span>
 4248 |     | <span class='neutral'>///           - 8 + qTarget / 2</span>
 4249 |     | <span class='neutral'>///         e</span>
 4250 |     | <span class='neutral'>///        --------------------- * k(qOvershoot - qTarget)</span>
 4251 |     | <span class='neutral'>///                  2</span>
 4252 |     | <span class='neutral'>///</span>
 4253 |     | <span class='neutral'>///      ) / integral1Incremented - (</span>
 4254 |     | <span class='neutral'>///</span>
 4255 |     | <span class='neutral'>///           - 8 - qOvershoot / 2</span>
 4256 |     | <span class='neutral'>///         e</span>
 4257 |     | <span class='neutral'>///        ------------------------ * k(qOvershoot - qTarget) - </span>
 4258 |     | <span class='neutral'>///                    2</span>
 4259 |     | <span class='neutral'>///</span>
 4260 |     | <span class='neutral'>///           - 8 - qOvershoot / 2</span>
 4261 |     | <span class='neutral'>///         e</span>
 4262 |     | <span class='neutral'>///        ------------------------ * k(qOvershoot - qOrigin) </span>
 4263 |     | <span class='neutral'>///                    2</span>
 4264 |     | <span class='neutral'>///</span>
 4265 |     | <span class='neutral'>///      ) / integral0Incremented</span>
 4266 |     | <span class='neutral'>///</span>
 4267 |     | <span class='neutral'>///    )&#39;.</span>
 4268 |     | <span class='neutral'>///</span>
 4269 |     | <span class='neutral'>/// @param integral0Incremented The integral of the liquidity distribution</span>
 4270 |     | <span class='neutral'>/// function from &#39;qTarget&#39; to &#39;qUpper&#39; prior to the amendment of the curve</span>
 4271 |     | <span class='neutral'>/// sequence:</span>
 4272 |     | <span class='neutral'>///</span>
 4273 |     | <span class='neutral'>///                                 - 8     / qUpper</span>
 4274 |     | <span class='neutral'>///     integral0Incremented      e        |    - h / 2</span>
 4275 |     | <span class='neutral'>///   &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;,</span>
 4276 |     | <span class='neutral'>///           2 ** 216              2      |</span>
 4277 |     | <span class='neutral'>///                                       / qTarget</span>
 4278 |     | <span class='neutral'>///</span>
 4279 |     | <span class='neutral'>/// @param integral1Incremented The integral of the liquidity distribution</span>
 4280 |     | <span class='neutral'>/// function from &#39;qLower&#39; to &#39;qTarget&#39; prior to the amendment of the curve</span>
 4281 |     | <span class='neutral'>/// sequence:</span>
 4282 |     | <span class='neutral'>///</span>
 4283 |     | <span class='neutral'>///                                 - 8     / qTarget</span>
 4284 |     | <span class='neutral'>///     integral1Incremented      e        |    + h / 2</span>
 4285 |     | <span class='neutral'>///   &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;.</span>
 4286 |     | <span class='neutral'>///           2 ** 216              2      |</span>
 4287 |     | <span class='neutral'>///                                       / qLower</span>
 4288 |     | <span class='neutral'>///</span>
 4289 |     | <span class='neutral'>/// @return sign The sign of Newton step.</span>
 4290 |     | <span class='neutral'>/// @return step Newton step to be added to/subtracted from the current value</span>
 4291 |     | <span class='neutral'>/// of &#39;qOvershoot&#39;.</span>
 4292 |     | <span class='neutral'>/// @return integral0Amended The integral of the liquidity distribution function</span>
 4293 |     | <span class='neutral'>/// from &#39;qTarget&#39; to &#39;qUpper&#39; after the amendment of the curve sequence:</span>
 4294 |     | <span class='neutral'>///</span>
 4295 |     | <span class='neutral'>///                             - 8     / qUpper</span>
 4296 |     | <span class='neutral'>///     integral0Amended      e        |    - h / 2</span>
 4297 |     | <span class='neutral'>///   &#39;------------------ := ------- * |  e         k(wAmended(h)) dh&#39;.</span>
 4298 |     | <span class='neutral'>///         2 ** 216            2      |</span>
 4299 |     | <span class='neutral'>///                                   / qTarget</span>
 4300 |     | <span class='neutral'>///</span>
 4301 |     | <span class='neutral'>/// @return integral1Amended The integral of the liquidity distribution function</span>
 4302 |     | <span class='neutral'>/// from &#39;qLower&#39; to &#39;qTarget&#39; after the amendment of the curve sequence:</span>
 4303 |     | <span class='neutral'>///</span>
 4304 |     | <span class='neutral'>///                             - 8     / qTarget</span>
 4305 |     | <span class='neutral'>///     integral1Amended      e        |    + h / 2</span>
 4306 |     | <span class='neutral'>///   &#39;------------------ := ------- * |  e         k(wAmended(h)) dh&#39;.</span>
 4307 |     | <span class='neutral'>///         2 ** 216            2      |</span>
 4308 |     | <span class='neutral'>///                                   / qLower</span>
 4309 |     | <span class='neutral'>///</span>
 4310 |     | <span class='neutral'>function newtonStep(</span>
 4311 |     | <span class='neutral'>  X216 integral0Incremented,</span>
 4312 |     | <span class='neutral'>  X216 integral1Incremented</span>
 4313 |     | <span class='neutral'>) pure returns (</span>
 4314 |     | <span class='neutral'>  bool sign,</span>
 4315 |     | <span class='neutral'>  X59 step,</span>
 4316 |     | <span class='neutral'>  X216 integral0Amended,</span>
 4317 |     | <span class='neutral'>  X216 integral1Amended</span>
 4318 |     | <span class='neutral'>) {</span>
 4319 |     | <span class='neutral'>  bool zeroForOne = getZeroForOne();</span>
 4320 |     | <span class='neutral'>  (integral0Incremented, integral1Incremented) = zeroForOne ? </span>
 4321 |     | <span class='neutral'>    (integral1Incremented, integral0Incremented) : </span>
 4322 |     | <span class='neutral'>    (integral0Incremented, integral1Incremented);</span>
 4323 |     | <span class='neutral'></span>
 4324 |     | <span class='neutral'>  X216 originToTarget;</span>
 4325 |     | <span class='neutral'>  {</span>
 4326 |     | <span class='neutral'>    // At this stage, we have:</span>
 4327 |     | <span class='neutral'>    //</span>
 4328 |     | <span class='neutral'>    //  &#39;currentToOvershoot := _currentToOvershoot_.integral() + outgoingTotal&#39;</span>
 4329 |     | <span class='neutral'>    //</span>
 4330 |     | <span class='neutral'>    // and</span>
 4331 |     | <span class='neutral'>    //</span>
 4332 |     | <span class='neutral'>    //  &#39;originToOvershoot := _originToOvershoot_.integral() + outgoingTotal&#39;</span>
 4333 |     | <span class='neutral'>    //</span>
 4334 |     | <span class='neutral'>    // where</span>
 4335 |     | <span class='neutral'>    //</span>
 4336 |     | <span class='neutral'>    //                         - 8</span>
 4337 |     | <span class='neutral'>    //    outgoingTotal      e</span>
 4338 |     | <span class='neutral'>    //  &#39;--------------- := ------- * (</span>
 4339 |     | <span class='neutral'>    //      2 ** 216           2</span>
 4340 |     | <span class='neutral'>    //</span>
 4341 |     | <span class='neutral'>    //     getZeroForOne() ? </span>
 4342 |     | <span class='neutral'>    //</span>
 4343 |     | <span class='neutral'>    //       / qBegin</span>
 4344 |     | <span class='neutral'>    //      |    + h / 2</span>
 4345 |     | <span class='neutral'>    //      |  e         k(w(h)) dh :</span>
 4346 |     | <span class='neutral'>    //      |</span>
 4347 |     | <span class='neutral'>    //     / qOvershoot</span>
 4348 |     | <span class='neutral'>    //</span>
 4349 |     | <span class='neutral'>    //       / qOvershoot</span>
 4350 |     | <span class='neutral'>    //      |    - h / 2</span>
 4351 |     | <span class='neutral'>    //      |  e         k(w(h)) dh</span>
 4352 |     | <span class='neutral'>    //      |</span>
 4353 |     | <span class='neutral'>    //     / qBegin</span>
 4354 |     | <span class='neutral'>    //</span>
 4355 |     | <span class='neutral'>    //   )&#39;.</span>
 4356 |     | <span class='neutral'>    //</span>
 4357 |     | <span class='neutral'>    // As argued before, if &#39;direction == false&#39;, then</span>
 4358 |     | <span class='neutral'>    //</span>
 4359 |     | <span class='neutral'>    //  &#39;qTotal0 &lt;= qBegin &lt;= qOvershoot &lt;= qTotal1&#39;.</span>
 4360 |     | <span class='neutral'>    //</span>
 4361 |     | <span class='neutral'>    // and if &#39;direction == true&#39;, then</span>
 4362 |     | <span class='neutral'>    //</span>
 4363 |     | <span class='neutral'>    //  &#39;qTotal1 &lt;= qOvershoot &lt;= qBegin &lt;= qTotal0&#39;.</span>
 4364 |     | <span class='neutral'>    //</span>
 4365 |     | <span class='neutral'>    // Additionally, since the vertical coordinates of kernel are monotonic,</span>
 4366 |     | <span class='neutral'>    // we have &#39;cTotal0 &lt;= cTotal1&#39; and the input requirements of &#39;outgoing&#39;</span>
 4367 |     | <span class='neutral'>    // are satisfied.</span>
 4368 |     | <span class='neutral'>    X216 outgoingTotal = _total0_.outgoing(_begin_, _overshoot_);</span>
 4369 |     | <span class='neutral'></span>
 4370 |     | <span class='neutral'>    // At this stage, we have:</span>
 4371 |     | <span class='neutral'>    //</span>
 4372 |     | <span class='neutral'>    //  &#39;targetToOvershoot := _targetToOvershoot_.integral() + outgoingForward&#39;</span>
 4373 |     | <span class='neutral'>    //</span>
 4374 |     | <span class='neutral'>    // where</span>
 4375 |     | <span class='neutral'>    //                           - 8</span>
 4376 |     | <span class='neutral'>    //    outgoingForward      e</span>
 4377 |     | <span class='neutral'>    //  &#39;----------------- := ------- * (</span>
 4378 |     | <span class='neutral'>    //       2 ** 216            2</span>
 4379 |     | <span class='neutral'>    //</span>
 4380 |     | <span class='neutral'>    //     getZeroForOne() ? </span>
 4381 |     | <span class='neutral'>    //</span>
 4382 |     | <span class='neutral'>    //       / qBegin</span>
 4383 |     | <span class='neutral'>    //      |    + h / 2</span>
 4384 |     | <span class='neutral'>    //      |  e         k(qTarget - h) dh :</span>
 4385 |     | <span class='neutral'>    //      |</span>
 4386 |     | <span class='neutral'>    //     / qOvershoot</span>
 4387 |     | <span class='neutral'>    //</span>
 4388 |     | <span class='neutral'>    //       / qOvershoot</span>
 4389 |     | <span class='neutral'>    //      |    - h / 2</span>
 4390 |     | <span class='neutral'>    //      |  e         k(h - qTarget) dh</span>
 4391 |     | <span class='neutral'>    //      |</span>
 4392 |     | <span class='neutral'>    //     / qBegin</span>
 4393 |     | <span class='neutral'>    //</span>
 4394 |     | <span class='neutral'>    //   )&#39;.</span>
 4395 |     | <span class='neutral'>    //</span>
 4396 |     | <span class='neutral'>    // As argued before, if &#39;direction == false&#39;, then</span>
 4397 |     | <span class='neutral'>    //</span>
 4398 |     | <span class='neutral'>    //  &#39;qForward0 &lt;= qBegin &lt;= qOvershoot &lt;= qForward1&#39;.</span>
 4399 |     | <span class='neutral'>    //</span>
 4400 |     | <span class='neutral'>    // and if &#39;direction == true&#39;, then</span>
 4401 |     | <span class='neutral'>    //</span>
 4402 |     | <span class='neutral'>    //  &#39;qForward1 &lt;= qOvershoot &lt;= qBegin &lt;= qForward0&#39;.</span>
 4403 |     | <span class='neutral'>    //</span>
 4404 |     | <span class='neutral'>    // Additionally, since the vertical coordinates of kernel are monotonic,</span>
 4405 |     | <span class='neutral'>    // we have &#39;cForward0 &lt;= cForward1&#39; and the input requirements of</span>
 4406 |     | <span class='neutral'>    // &#39;outgoing&#39; are satisfied.</span>
 4407 |     | <span class='neutral'>    X216 outgoingForward = _forward0_.outgoing(_begin_, _overshoot_);</span>
 4408 |     | <span class='neutral'></span>
 4409 |     | <span class='neutral'>    // Next, we calculate:</span>
 4410 |     | <span class='neutral'>    //</span>
 4411 |     | <span class='neutral'>    //  &#39;getZeroForOne() ? integral1Amended : integral0Amended&#39;.</span>
 4412 |     | <span class='neutral'>    //</span>
 4413 |     | <span class='neutral'>    // The operations are theoretically safe. However, the output may be negative</span>
 4414 |     | <span class='neutral'>    // due to rounding error.</span>
 4415 |     | <span class='neutral'>    integral0Amended = integral0Incremented</span>
 4416 |     | <span class='neutral'>      + _currentToTarget_.integral()</span>
 4417 |     | <span class='neutral'>      - (_currentToOvershoot_.integral() + outgoingTotal)</span>
 4418 |     | <span class='neutral'>      + (_targetToOvershoot_.integral() + outgoingForward);</span>
 4419 |     | <span class='neutral'></span>
 4420 |     | <span class='neutral'>    // The output is capped to prevent negative values due to rounding error.</span>
 4421 |     | <span class='neutral'>    integral0Amended = max(integral0Amended, zeroX216);</span>
 4422 |     | <span class='neutral'></span>
 4423 |     | <span class='neutral'>    // Define, &#39;originToTarget&#39; as:</span>
 4424 |     | <span class='neutral'>    //</span>
 4425 |     | <span class='neutral'>    //   &#39;getZeroForOne() ? (</span>
 4426 |     | <span class='neutral'>    //</span>
 4427 |     | <span class='neutral'>    //       exp(- (qOrigin + qOvershoot) / 2) * originToOvershoot -</span>
 4428 |     | <span class='neutral'>    //</span>
 4429 |     | <span class='neutral'>    //       exp(- (qTarget + qOvershoot) / 2) * targetToOvershoot</span>
 4430 |     | <span class='neutral'>    //</span>
 4431 |     | <span class='neutral'>    //    ) : (</span>
 4432 |     | <span class='neutral'>    //</span>
 4433 |     | <span class='neutral'>    //       exp(+ (qOrigin + qOvershoot) / 2) * originToOvershoot -</span>
 4434 |     | <span class='neutral'>    //</span>
 4435 |     | <span class='neutral'>    //       exp(+ (qTarget + qOvershoot) / 2) * targetToOvershoot</span>
 4436 |     | <span class='neutral'>    //</span>
 4437 |     | <span class='neutral'>    //    )&#39;</span>
 4438 |     | <span class='neutral'>    //</span>
 4439 |     | <span class='neutral'>    originToTarget = (</span>
 4440 |     | <span class='neutral'>      _originToOvershoot_.integral() + outgoingTotal</span>
 4441 |     | <span class='neutral'>    ).shift(</span>
 4442 |     | <span class='neutral'>      _overshoot_,</span>
 4443 |     | <span class='neutral'>      _origin_,</span>
 4444 |     | <span class='neutral'>      zeroForOne</span>
 4445 |     | <span class='neutral'>    ) - (</span>
 4446 |     | <span class='neutral'>      _targetToOvershoot_.integral() + outgoingForward</span>
 4447 |     | <span class='neutral'>    ).shift(</span>
 4448 |     | <span class='neutral'>      _overshoot_,</span>
 4449 |     | <span class='neutral'>      _target_,</span>
 4450 |     | <span class='neutral'>      zeroForOne</span>
 4451 |     | <span class='neutral'>    );</span>
 4452 |     | <span class='neutral'>  }</span>
 4453 |     | <span class='neutral'></span>
 4454 |     | <span class='neutral'>  // Next, we calculate:</span>
 4455 |     | <span class='neutral'>  //</span>
 4456 |     | <span class='neutral'>  //   &#39;integral1Amended := getZeroForOne() ? (</span>
 4457 |     | <span class='neutral'>  //</span>
 4458 |     | <span class='neutral'>  //       exp(- (qOrigin + qOvershoot) / 2) * originToOvershoot -</span>
 4459 |     | <span class='neutral'>  //</span>
 4460 |     | <span class='neutral'>  //       exp(- (qTarget + qOvershoot) / 2) * targetToOvershoot - </span>
 4461 |     | <span class='neutral'>  //</span>
 4462 |     | <span class='neutral'>  //       integral0Incremented + incomingCurrentToTarget - currentToOrigin</span>
 4463 |     | <span class='neutral'>  //</span>
 4464 |     | <span class='neutral'>  //    ) : (</span>
 4465 |     | <span class='neutral'>  //</span>
 4466 |     | <span class='neutral'>  //       exp(+ (qOrigin + qOvershoot) / 2) * originToOvershoot -</span>
 4467 |     | <span class='neutral'>  //</span>
 4468 |     | <span class='neutral'>  //       exp(+ (qTarget + qOvershoot) / 2) * targetToOvershoot - </span>
 4469 |     | <span class='neutral'>  //</span>
 4470 |     | <span class='neutral'>  //       integral1Incremented + incomingCurrentToTarget - currentToOrigin</span>
 4471 |     | <span class='neutral'>  //</span>
 4472 |     | <span class='neutral'>  //    )&#39;,</span>
 4473 |     | <span class='neutral'>  //</span>
 4474 |     | <span class='neutral'>  // The operations are theoretically safe. However, the output may be negative</span>
 4475 |     | <span class='neutral'>  // due to rounding error.</span>
 4476 |     | <span class='neutral'>  integral1Amended = integral1Incremented</span>
 4477 |     | <span class='neutral'>    + originToTarget</span>
 4478 |     | <span class='neutral'>    - _currentToOrigin_.integral()</span>
 4479 |     | <span class='neutral'>    - _incomingCurrentToTarget_.integral();</span>
 4480 |     | <span class='neutral'></span>
 4481 |     | <span class='neutral'>  // The output is capped to prevent negative values due to rounding error.</span>
 4482 |     | <span class='neutral'>  integral1Amended = max(integral1Amended, zeroX216);</span>
 4483 |     | <span class='neutral'></span>
 4484 |     | <span class='neutral'>  // Next, we calculate:</span>
 4485 |     | <span class='neutral'>  //</span>
 4486 |     | <span class='neutral'>  //      - 8</span>
 4487 |     | <span class='neutral'>  //    e</span>
 4488 |     | <span class='neutral'>  //  &#39;------- * k(|qOrigin - qOvershoot|)&#39;.</span>
 4489 |     | <span class='neutral'>  //      2</span>
 4490 |     | <span class='neutral'>  //</span>
 4491 |     | <span class='neutral'>  // As argued before, if &#39;direction == false&#39;, then</span>
 4492 |     | <span class='neutral'>  //</span>
 4493 |     | <span class='neutral'>  //  &#39;qTotal0 &lt;= qOvershoot &lt;= qTotal1&#39;.</span>
 4494 |     | <span class='neutral'>  //</span>
 4495 |     | <span class='neutral'>  // and if &#39;direction == true&#39;, then</span>
 4496 |     | <span class='neutral'>  //</span>
 4497 |     | <span class='neutral'>  //  &#39;qTotal1 &lt;= qOvershoot &lt;= qTotal0&#39;.</span>
 4498 |     | <span class='neutral'>  //</span>
 4499 |     | <span class='neutral'>  // Additionally, since the vertical coordinates of kernel are monotonic,</span>
 4500 |     | <span class='neutral'>  // we have &#39;cTotal0 &lt;= cTotal1&#39; and the input requirements of &#39;outgoing&#39;</span>
 4501 |     | <span class='neutral'>  // are satisfied.</span>
 4502 |     | <span class='neutral'>  X216 overshootMinusOrigin = _total0_.evaluate(_overshoot_);</span>
 4503 |     | <span class='neutral'></span>
 4504 |     | <span class='neutral'>  // Then:</span>
 4505 |     | <span class='neutral'>  //</span>
 4506 |     | <span class='neutral'>  //      - 8</span>
 4507 |     | <span class='neutral'>  //    e</span>
 4508 |     | <span class='neutral'>  //  &#39;------- * k(|qTarget - qOvershoot|)&#39;.</span>
 4509 |     | <span class='neutral'>  //      2</span>
 4510 |     | <span class='neutral'>  //</span>
 4511 |     | <span class='neutral'>  // As argued before, if &#39;direction == false&#39;, then</span>
 4512 |     | <span class='neutral'>  //</span>
 4513 |     | <span class='neutral'>  //  &#39;qForward0 &lt;= qOvershoot &lt;= qForward1&#39;.</span>
 4514 |     | <span class='neutral'>  //</span>
 4515 |     | <span class='neutral'>  // and if &#39;direction == true&#39;, then</span>
 4516 |     | <span class='neutral'>  //</span>
 4517 |     | <span class='neutral'>  //  &#39;qForward1 &lt;= qOvershoot &lt;= qForward0&#39;.</span>
 4518 |     | <span class='neutral'>  //</span>
 4519 |     | <span class='neutral'>  // Additionally, since the vertical coordinates of kernel are monotonic,</span>
 4520 |     | <span class='neutral'>  // we have &#39;cForward0 &lt;= cForward1&#39; and the input requirements of</span>
 4521 |     | <span class='neutral'>  // &#39;outgoing&#39; are satisfied.</span>
 4522 |     | <span class='neutral'>  X216 overshootMinusTarget = _forward0_.evaluate(_overshoot_);</span>
 4523 |     | <span class='neutral'></span>
 4524 |     | <span class='neutral'>  //  &#39;getZeroForOne() ? (</span>
 4525 |     | <span class='neutral'>  //</span>
 4526 |     | <span class='neutral'>  //         - 8 - qOrigin / 2</span>
 4527 |     | <span class='neutral'>  //       e</span>
 4528 |     | <span class='neutral'>  //      --------------------- * k(qOrigin - qOvershoot) - </span>
 4529 |     | <span class='neutral'>  //                2</span>
 4530 |     | <span class='neutral'>  //</span>
 4531 |     | <span class='neutral'>  //         - 8 - qTarget / 2</span>
 4532 |     | <span class='neutral'>  //       e</span>
 4533 |     | <span class='neutral'>  //      --------------------- * k(qTarget - qOvershoot)</span>
 4534 |     | <span class='neutral'>  //                2</span>
 4535 |     | <span class='neutral'>  //</span>
 4536 |     | <span class='neutral'>  //   ) : (</span>
 4537 |     | <span class='neutral'>  //</span>
 4538 |     | <span class='neutral'>  //         - 8 + qOrigin / 2</span>
 4539 |     | <span class='neutral'>  //       e</span>
 4540 |     | <span class='neutral'>  //      --------------------- * k(qOvershoot - qOrigin) -</span>
 4541 |     | <span class='neutral'>  //                2</span>
 4542 |     | <span class='neutral'>  //</span>
 4543 |     | <span class='neutral'>  //         - 8 + qTarget / 2</span>
 4544 |     | <span class='neutral'>  //       e</span>
 4545 |     | <span class='neutral'>  //      --------------------- * k(qOvershoot - qTarget)</span>
 4546 |     | <span class='neutral'>  //                2</span>
 4547 |     | <span class='neutral'>  //</span>
 4548 |     | <span class='neutral'>  //   )&#39;.</span>
 4549 |     | <span class='neutral'>  //</span>
 4550 |     | <span class='neutral'>  // The requirements &#39;mulDivByExpInv8&#39; are satisfied because:</span>
 4551 |     | <span class='neutral'>  //</span>
 4552 |     | <span class='neutral'>  //  &#39;zeroX216 &lt;= _origin_.sqrt(!zeroForOne) &lt; oneX216&#39;,</span>
 4553 |     | <span class='neutral'>  //  &#39;zeroX216 &lt;= _target_.sqrt(!zeroForOne) &lt; oneX216&#39;.</span>
 4554 |     | <span class='neutral'>  //</span>
 4555 |     | <span class='neutral'>  X216 integral1AmendedPrime = </span>
 4556 |     | <span class='neutral'>    _origin_.sqrt(!zeroForOne) % overshootMinusOrigin  - </span>
 4557 |     | <span class='neutral'>    _target_.sqrt(!zeroForOne) % overshootMinusTarget;</span>
 4558 |     | <span class='neutral'></span>
 4559 |     | <span class='neutral'>  //  &#39;getZeroForOne() ? (</span>
 4560 |     | <span class='neutral'>  //</span>
 4561 |     | <span class='neutral'>  //      exp(- (qOrigin + qOvershoot) / 2) * originToOvershoot -</span>
 4562 |     | <span class='neutral'>  //</span>
 4563 |     | <span class='neutral'>  //      exp(- (qTarget + qOvershoot) / 2) * targetToOvershoot +</span>
 4564 |     | <span class='neutral'>  //</span>
 4565 |     | <span class='neutral'>  //        - 8 - qOrigin / 2</span>
 4566 |     | <span class='neutral'>  //      e                   * k(qOrigin - qOvershoot) - </span>
 4567 |     | <span class='neutral'>  //</span>
 4568 |     | <span class='neutral'>  //        - 8 - qTarget / 2</span>
 4569 |     | <span class='neutral'>  //      e                   * k(qTarget - qOvershoot)</span>
 4570 |     | <span class='neutral'>  //</span>
 4571 |     | <span class='neutral'>  //   ) : (</span>
 4572 |     | <span class='neutral'>  //</span>
 4573 |     | <span class='neutral'>  //      exp(+ (qOrigin + qOvershoot) / 2) * originToOvershoot -</span>
 4574 |     | <span class='neutral'>  //</span>
 4575 |     | <span class='neutral'>  //      exp(+ (qTarget + qOvershoot) / 2) * targetToOvershoot +</span>
 4576 |     | <span class='neutral'>  //</span>
 4577 |     | <span class='neutral'>  //        - 8 + qOrigin / 2</span>
 4578 |     | <span class='neutral'>  //      e                   * k(qOvershoot - qOrigin) -</span>
 4579 |     | <span class='neutral'>  //</span>
 4580 |     | <span class='neutral'>  //        - 8 + qTarget / 2</span>
 4581 |     | <span class='neutral'>  //      e                   * k(qOvershoot - qTarget)</span>
 4582 |     | <span class='neutral'>  //</span>
 4583 |     | <span class='neutral'>  //   )&#39;.</span>
 4584 |     | <span class='neutral'>  integral1AmendedPrime = </span>
 4585 |     | <span class='neutral'>    originToTarget + integral1AmendedPrime + integral1AmendedPrime;</span>
 4586 |     | <span class='neutral'></span>
 4587 |     | <span class='neutral'>  //   &#39;getZeroForOne() ? (</span>
 4588 |     | <span class='neutral'>  //</span>
 4589 |     | <span class='neutral'>  //           - 8 + qOvershoot / 2</span>
 4590 |     | <span class='neutral'>  //         e                      * k(qTarget - qOvershoot) - </span>
 4591 |     | <span class='neutral'>  //</span>
 4592 |     | <span class='neutral'>  //           - 8 + qOvershoot / 2</span>
 4593 |     | <span class='neutral'>  //         e                      * k(qOrigin - qOvershoot) </span>
 4594 |     | <span class='neutral'>  //</span>
 4595 |     | <span class='neutral'>  //    ) : (</span>
 4596 |     | <span class='neutral'>  //</span>
 4597 |     | <span class='neutral'>  //           - 8 - qOvershoot / 2</span>
 4598 |     | <span class='neutral'>  //         e                      * k(qOvershoot - qTarget) - </span>
 4599 |     | <span class='neutral'>  //</span>
 4600 |     | <span class='neutral'>  //           - 8 - qOvershoot / 2</span>
 4601 |     | <span class='neutral'>  //         e                      * k(qOvershoot - qOrigin) </span>
 4602 |     | <span class='neutral'>  //</span>
 4603 |     | <span class='neutral'>  //    )&#39;.</span>
 4604 |     | <span class='neutral'>  X216 integral0AmendedPrime = _overshoot_.sqrt(zeroForOne) % (</span>
 4605 |     | <span class='neutral'>    overshootMinusOrigin - overshootMinusTarget</span>
 4606 |     | <span class='neutral'>  );</span>
 4607 |     | <span class='neutral'>  integral0AmendedPrime = integral0AmendedPrime + integral0AmendedPrime;</span>
 4608 |     | <span class='neutral'></span>
 4609 |     | <span class='neutral'>  // &#39;f(qOvershoot)&#39; is calculated next. The result may or may not be negative.</span>
 4610 |     | <span class='neutral'>  // The requirements of cheapMul are satisfied because all four integrals are</span>
 4611 |     | <span class='neutral'>  // non-negative and less than &#39;oneX216&#39;.</span>
 4612 |     | <span class='neutral'>  X216 mismatch;</span>
 4613 |     | <span class='neutral'>  (mismatch, integral0Amended, integral1Amended) = zeroForOne ? (</span>
 4614 |     | <span class='neutral'>    (</span>
 4615 |     | <span class='neutral'>      integral0Incremented &amp; integral1Amended</span>
 4616 |     | <span class='neutral'>    ) - (</span>
 4617 |     | <span class='neutral'>      integral1Incremented &amp; integral0Amended</span>
 4618 |     | <span class='neutral'>    ),</span>
 4619 |     | <span class='neutral'>    integral1Amended,</span>
 4620 |     | <span class='neutral'>    integral0Amended</span>
 4621 |     | <span class='neutral'>  ) : (</span>
 4622 |     | <span class='neutral'>    (</span>
 4623 |     | <span class='neutral'>      integral1Incremented &amp; integral0Amended</span>
 4624 |     | <span class='neutral'>    ) - (</span>
 4625 |     | <span class='neutral'>      integral0Incremented &amp; integral1Amended</span>
 4626 |     | <span class='neutral'>    ),</span>
 4627 |     | <span class='neutral'>    integral0Amended,</span>
 4628 |     | <span class='neutral'>    integral1Amended</span>
 4629 |     | <span class='neutral'>  );</span>
 4630 |     | <span class='neutral'></span>
 4631 |     | <span class='neutral'>  // Next, the derivative of &#39;f&#39; with respect to &#39;qOvershoot&#39; is calculated.</span>
 4632 |     | <span class='neutral'>  // Multiplications do not overflow because both integrals are non-negative</span>
 4633 |     | <span class='neutral'>  // and less than &#39;oneX216&#39;. Additionally, &#39;integral0AmendedPrime&#39; and</span>
 4634 |     | <span class='neutral'>  // &#39;integral1AmendedPrime&#39; are composed of up to 4 integrals and their</span>
 4635 |     | <span class='neutral'>  // absolute value does not exceed &#39;2 ** 218&#39;.</span>
 4636 |     | <span class='neutral'>  X216 mismatchPrime = (</span>
 4637 |     | <span class='neutral'>    integral0Incremented * integral1AmendedPrime</span>
 4638 |     | <span class='neutral'>  ) + (</span>
 4639 |     | <span class='neutral'>    integral1Incremented * integral0AmendedPrime</span>
 4640 |     | <span class='neutral'>  );</span>
 4641 |     | <span class='neutral'></span>
 4642 |     | <span class='neutral'>  // Sign of the Newton step is determined.</span>
 4643 |     | <span class='neutral'>  sign = (mismatch &gt; zeroX216) != (mismatchPrime &gt; zeroX216);</span>
 4644 |     | <span class='neutral'></span>
 4645 |     | <span class='neutral'>  // The Newton step is calculated next.</span>
 4646 |     | <span class='neutral'>  // Multiplication does not overflow because &#39;-oneX216 &lt;= mismatch &lt;= oneX216&#39;</span>
 4647 |     | <span class='neutral'>  // Division by zero results on &#39;step == zeroX59&#39;.</span>
 4648 |     | <span class='neutral'>  assembly {</span>
 4649 |     | <span class='neutral'>    step := sdiv(mul(shl(38, 1), mismatch), sar(22, mismatchPrime))</span>
 4650 |     | <span class='neutral'>  }</span>
 4651 |     | <span class='neutral'></span>
 4652 |     | <span class='neutral'>  if (step == zeroX59) {</span>
 4653 |     | <span class='neutral'>    assembly {</span>
 4654 |     | <span class='neutral'>      mismatchPrime := sar(22, mismatchPrime)</span>
 4655 |     | <span class='neutral'>    }</span>
 4656 |     | <span class='neutral'>    if (mismatch != zeroX216) {</span>
 4657 |     | <span class='neutral'>      require(mismatchPrime != zeroX216, SearchingForOvershootFailed());</span>
 4658 |     | <span class='neutral'>    }</span>
 4659 |     | <span class='neutral'>  }</span>
 4660 |     | <span class='neutral'>}</span>
 4661 |     | <span class='neutral'></span>
 4662 |     | <span class='neutral'>/// @notice Calculates &#39;integral0Amended&#39; and &#39;integral1Amended&#39; efficiently.</span>
 4663 |     | <span class='neutral'>///</span>
 4664 |     | <span class='neutral'>/// @param integral0Incremented The integral of the liquidity distribution</span>
 4665 |     | <span class='neutral'>/// function from &#39;qTarget&#39; to &#39;qUpper&#39; prior to the amendment of the curve</span>
 4666 |     | <span class='neutral'>/// sequence:</span>
 4667 |     | <span class='neutral'>///</span>
 4668 |     | <span class='neutral'>///                                 - 8     / qUpper</span>
 4669 |     | <span class='neutral'>///     integral0Incremented      e        |    - h / 2</span>
 4670 |     | <span class='neutral'>///   &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;,</span>
 4671 |     | <span class='neutral'>///           2 ** 216              2      |</span>
 4672 |     | <span class='neutral'>///                                       / qTarget</span>
 4673 |     | <span class='neutral'>///</span>
 4674 |     | <span class='neutral'>/// @param integral1Incremented The integral of the liquidity distribution</span>
 4675 |     | <span class='neutral'>/// function from &#39;qLower&#39; to &#39;qTarget&#39; prior to the amendment of the curve</span>
 4676 |     | <span class='neutral'>/// sequence:</span>
 4677 |     | <span class='neutral'>///</span>
 4678 |     | <span class='neutral'>///                                 - 8     / qTarget</span>
 4679 |     | <span class='neutral'>///     integral1Incremented      e        |    + h / 2</span>
 4680 |     | <span class='neutral'>///   &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;.</span>
 4681 |     | <span class='neutral'>///           2 ** 216              2      |</span>
 4682 |     | <span class='neutral'>///                                       / qLower</span>
 4683 |     | <span class='neutral'>///</span>
 4684 |     | <span class='neutral'>/// @return integral0Amended The integral of the liquidity distribution function</span>
 4685 |     | <span class='neutral'>/// from &#39;qTarget&#39; to &#39;qUpper&#39; after the amendment of the curve sequence:</span>
 4686 |     | <span class='neutral'>///</span>
 4687 |     | <span class='neutral'>///                             - 8     / qUpper</span>
 4688 |     | <span class='neutral'>///     integral0Amended      e        |    - h / 2</span>
 4689 |     | <span class='neutral'>///   &#39;------------------ := ------- * |  e         k(wAmended(h)) dh&#39;.</span>
 4690 |     | <span class='neutral'>///         2 ** 216            2      |</span>
 4691 |     | <span class='neutral'>///                                   / qTarget</span>
 4692 |     | <span class='neutral'>///</span>
 4693 |     | <span class='neutral'>/// @return integral1Amended The integral of the liquidity distribution function</span>
 4694 |     | <span class='neutral'>/// from &#39;qLower&#39; to &#39;qTarget&#39; after the amendment of the curve sequence:</span>
 4695 |     | <span class='neutral'>///</span>
 4696 |     | <span class='neutral'>///                             - 8     / qTarget</span>
 4697 |     | <span class='neutral'>///     integral1Amended      e        |    + h / 2</span>
 4698 |     | <span class='neutral'>///   &#39;------------------ := ------- * |  e         k(wAmended(h)) dh&#39;.</span>
 4699 |     | <span class='neutral'>///         2 ** 216            2      |</span>
 4700 |     | <span class='neutral'>///                                   / qLower</span>
 4701 |     | <span class='neutral'>///</span>
 4702 |     | <span class='neutral'>function newIntegrals(</span>
 4703 |     | <span class='neutral'>  X216 integral0Incremented,</span>
 4704 |     | <span class='neutral'>  X216 integral1Incremented</span>
 4705 |     | <span class='neutral'>) pure returns (</span>
 4706 |     | <span class='neutral'>  X216 integral0Amended,</span>
 4707 |     | <span class='neutral'>  X216 integral1Amended</span>
 4708 |     | <span class='neutral'>) {</span>
 4709 |     | <span class='neutral'>  bool zeroForOne = getZeroForOne();</span>
 4710 |     | <span class='neutral'>  (integral0Incremented, integral1Incremented) = zeroForOne ? </span>
 4711 |     | <span class='neutral'>    (integral1Incremented, integral0Incremented) : </span>
 4712 |     | <span class='neutral'>    (integral0Incremented, integral1Incremented);</span>
 4713 |     | <span class='neutral'></span>
 4714 |     | <span class='neutral'>  // At this stage, we have:</span>
 4715 |     | <span class='neutral'>  //</span>
 4716 |     | <span class='neutral'>  //  &#39;currentToOvershoot := _currentToOvershoot_.integral() + outgoingTotal&#39;</span>
 4717 |     | <span class='neutral'>  //</span>
 4718 |     | <span class='neutral'>  // and</span>
 4719 |     | <span class='neutral'>  //</span>
 4720 |     | <span class='neutral'>  //  &#39;originToOvershoot := _originToOvershoot_.integral() + outgoingTotal&#39;</span>
 4721 |     | <span class='neutral'>  //</span>
 4722 |     | <span class='neutral'>  // where</span>
 4723 |     | <span class='neutral'>  //</span>
 4724 |     | <span class='neutral'>  //                         - 8</span>
 4725 |     | <span class='neutral'>  //    outgoingTotal      e</span>
 4726 |     | <span class='neutral'>  //  &#39;--------------- := ------- * (</span>
 4727 |     | <span class='neutral'>  //      2 ** 216           2</span>
 4728 |     | <span class='neutral'>  //</span>
 4729 |     | <span class='neutral'>  //     getZeroForOne() ? </span>
 4730 |     | <span class='neutral'>  //</span>
 4731 |     | <span class='neutral'>  //       / qBegin</span>
 4732 |     | <span class='neutral'>  //      |    + h / 2</span>
 4733 |     | <span class='neutral'>  //      |  e         k(w(h)) dh :</span>
 4734 |     | <span class='neutral'>  //      |</span>
 4735 |     | <span class='neutral'>  //     / qOvershoot</span>
 4736 |     | <span class='neutral'>  //</span>
 4737 |     | <span class='neutral'>  //       / qOvershoot</span>
 4738 |     | <span class='neutral'>  //      |    - h / 2</span>
 4739 |     | <span class='neutral'>  //      |  e         k(w(h)) dh</span>
 4740 |     | <span class='neutral'>  //      |</span>
 4741 |     | <span class='neutral'>  //     / qBegin</span>
 4742 |     | <span class='neutral'>  //</span>
 4743 |     | <span class='neutral'>  //   )&#39;.</span>
 4744 |     | <span class='neutral'>  //</span>
 4745 |     | <span class='neutral'>  // As argued before, if &#39;direction == false&#39;, then</span>
 4746 |     | <span class='neutral'>  //</span>
 4747 |     | <span class='neutral'>  //  &#39;qTotal0 &lt;= qBegin &lt;= qOvershoot &lt;= qTotal1&#39;.</span>
 4748 |     | <span class='neutral'>  //</span>
 4749 |     | <span class='neutral'>  // and if &#39;direction == true&#39;, then</span>
 4750 |     | <span class='neutral'>  //</span>
 4751 |     | <span class='neutral'>  //  &#39;qTotal1 &lt;= qOvershoot &lt;= qBegin &lt;= qTotal0&#39;.</span>
 4752 |     | <span class='neutral'>  //</span>
 4753 |     | <span class='neutral'>  // Additionally, since the vertical coordinates of kernel are monotonic,</span>
 4754 |     | <span class='neutral'>  // we have &#39;cTotal0 &lt;= cTotal1&#39; and the input requirements of &#39;outgoing&#39;</span>
 4755 |     | <span class='neutral'>  // are satisfied.</span>
 4756 |     | <span class='neutral'>  X216 outgoingTotal = _total0_.outgoing(_begin_, _overshoot_);</span>
 4757 |     | <span class='neutral'></span>
 4758 |     | <span class='neutral'>  // At this stage, we have:</span>
 4759 |     | <span class='neutral'>  //</span>
 4760 |     | <span class='neutral'>  //  &#39;targetToOvershoot := _targetToOvershoot_.integral() + outgoingForward&#39;</span>
 4761 |     | <span class='neutral'>  //</span>
 4762 |     | <span class='neutral'>  // where</span>
 4763 |     | <span class='neutral'>  //                           - 8</span>
 4764 |     | <span class='neutral'>  //    outgoingForward      e</span>
 4765 |     | <span class='neutral'>  //  &#39;----------------- := ------- * (</span>
 4766 |     | <span class='neutral'>  //       2 ** 216            2</span>
 4767 |     | <span class='neutral'>  //</span>
 4768 |     | <span class='neutral'>  //     getZeroForOne() ? </span>
 4769 |     | <span class='neutral'>  //</span>
 4770 |     | <span class='neutral'>  //       / qBegin</span>
 4771 |     | <span class='neutral'>  //      |    + h / 2</span>
 4772 |     | <span class='neutral'>  //      |  e         k(qTarget - h) dh :</span>
 4773 |     | <span class='neutral'>  //      |</span>
 4774 |     | <span class='neutral'>  //     / qOvershoot</span>
 4775 |     | <span class='neutral'>  //</span>
 4776 |     | <span class='neutral'>  //       / qOvershoot</span>
 4777 |     | <span class='neutral'>  //      |    - h / 2</span>
 4778 |     | <span class='neutral'>  //      |  e         k(h - qTarget) dh</span>
 4779 |     | <span class='neutral'>  //      |</span>
 4780 |     | <span class='neutral'>  //     / qBegin</span>
 4781 |     | <span class='neutral'>  //</span>
 4782 |     | <span class='neutral'>  //   )&#39;.</span>
 4783 |     | <span class='neutral'>  //</span>
 4784 |     | <span class='neutral'>  // As argued before, if &#39;direction == false&#39;, then</span>
 4785 |     | <span class='neutral'>  //</span>
 4786 |     | <span class='neutral'>  //  &#39;qForward0 &lt;= qBegin &lt;= qOvershoot &lt;= qForward1&#39;.</span>
 4787 |     | <span class='neutral'>  //</span>
 4788 |     | <span class='neutral'>  // and if &#39;direction == true&#39;, then</span>
 4789 |     | <span class='neutral'>  //</span>
 4790 |     | <span class='neutral'>  //  &#39;qForward1 &lt;= qOvershoot &lt;= qBegin &lt;= qForward0&#39;.</span>
 4791 |     | <span class='neutral'>  //</span>
 4792 |     | <span class='neutral'>  // Additionally, since the vertical coordinates of kernel are monotonic,</span>
 4793 |     | <span class='neutral'>  // we have &#39;cForward0 &lt;= cForward1&#39; and the input requirements of</span>
 4794 |     | <span class='neutral'>  // &#39;outgoing&#39; are satisfied.</span>
 4795 |     | <span class='neutral'>  X216 outgoingForward = _forward0_.outgoing(_begin_, _overshoot_);</span>
 4796 |     | <span class='neutral'></span>
 4797 |     | <span class='neutral'>  // Define, &#39;originToTarget&#39; as:</span>
 4798 |     | <span class='neutral'>  //</span>
 4799 |     | <span class='neutral'>  //   &#39;getZeroForOne() ? (</span>
 4800 |     | <span class='neutral'>  //</span>
 4801 |     | <span class='neutral'>  //       exp(- (qOrigin + qOvershoot) / 2) * originToOvershoot -</span>
 4802 |     | <span class='neutral'>  //</span>
 4803 |     | <span class='neutral'>  //       exp(- (qTarget + qOvershoot) / 2) * targetToOvershoot</span>
 4804 |     | <span class='neutral'>  //</span>
 4805 |     | <span class='neutral'>  //    ) : (</span>
 4806 |     | <span class='neutral'>  //</span>
 4807 |     | <span class='neutral'>  //       exp(+ (qOrigin + qOvershoot) / 2) * originToOvershoot -</span>
 4808 |     | <span class='neutral'>  //</span>
 4809 |     | <span class='neutral'>  //       exp(+ (qTarget + qOvershoot) / 2) * targetToOvershoot</span>
 4810 |     | <span class='neutral'>  //</span>
 4811 |     | <span class='neutral'>  //    )&#39;</span>
 4812 |     | <span class='neutral'>  //</span>
 4813 |     | <span class='neutral'>  X216 originToTarget = (_originToOvershoot_.integral() + outgoingTotal).shift(</span>
 4814 |     | <span class='neutral'>    _overshoot_,</span>
 4815 |     | <span class='neutral'>    _origin_,</span>
 4816 |     | <span class='neutral'>    zeroForOne</span>
 4817 |     | <span class='neutral'>  ) - (_targetToOvershoot_.integral() + outgoingForward).shift(</span>
 4818 |     | <span class='neutral'>    _overshoot_,</span>
 4819 |     | <span class='neutral'>    _target_,</span>
 4820 |     | <span class='neutral'>    zeroForOne</span>
 4821 |     | <span class='neutral'>  );</span>
 4822 |     | <span class='neutral'></span>
 4823 |     | <span class='neutral'>  // Next, we calculate:</span>
 4824 |     | <span class='neutral'>  //</span>
 4825 |     | <span class='neutral'>  //  &#39;getZeroForOne() ? integral1Amended : integral0Amended&#39;.</span>
 4826 |     | <span class='neutral'>  //</span>
 4827 |     | <span class='neutral'>  // The operations are theoretically safe. However, the output may be negative</span>
 4828 |     | <span class='neutral'>  // due to rounding error.</span>
 4829 |     | <span class='neutral'>  integral0Amended = integral0Incremented</span>
 4830 |     | <span class='neutral'>    + _currentToTarget_.integral()</span>
 4831 |     | <span class='neutral'>    - (_currentToOvershoot_.integral() + outgoingTotal)</span>
 4832 |     | <span class='neutral'>    + (_targetToOvershoot_.integral() + outgoingForward);</span>
 4833 |     | <span class='neutral'></span>
 4834 |     | <span class='neutral'>  // The output is capped to prevent negative values due to rounding error.</span>
 4835 |     | <span class='neutral'>  integral0Amended = max(integral0Amended, zeroX216);</span>
 4836 |     | <span class='neutral'></span>
 4837 |     | <span class='neutral'>  // Next, we calculate:</span>
 4838 |     | <span class='neutral'>  //</span>
 4839 |     | <span class='neutral'>  //   &#39;integral1Amended := getZeroForOne() ? (</span>
 4840 |     | <span class='neutral'>  //</span>
 4841 |     | <span class='neutral'>  //       exp(- (qOrigin + qOvershoot) / 2) * originToOvershoot -</span>
 4842 |     | <span class='neutral'>  //</span>
 4843 |     | <span class='neutral'>  //       exp(- (qTarget + qOvershoot) / 2) * targetToOvershoot - </span>
 4844 |     | <span class='neutral'>  //</span>
 4845 |     | <span class='neutral'>  //       integral0Incremented + incomingCurrentToTarget - currentToOrigin</span>
 4846 |     | <span class='neutral'>  //</span>
 4847 |     | <span class='neutral'>  //    ) : (</span>
 4848 |     | <span class='neutral'>  //</span>
 4849 |     | <span class='neutral'>  //       exp(+ (qOrigin + qOvershoot) / 2) * originToOvershoot -</span>
 4850 |     | <span class='neutral'>  //</span>
 4851 |     | <span class='neutral'>  //       exp(+ (qTarget + qOvershoot) / 2) * targetToOvershoot - </span>
 4852 |     | <span class='neutral'>  //</span>
 4853 |     | <span class='neutral'>  //       integral1Incremented + incomingCurrentToTarget - currentToOrigin</span>
 4854 |     | <span class='neutral'>  //</span>
 4855 |     | <span class='neutral'>  //    )&#39;,</span>
 4856 |     | <span class='neutral'>  //</span>
 4857 |     | <span class='neutral'>  // The operations are theoretically safe. However, the output may be negative</span>
 4858 |     | <span class='neutral'>  // due to rounding error.</span>
 4859 |     | <span class='neutral'>  integral1Amended = integral1Incremented</span>
 4860 |     | <span class='neutral'>    + originToTarget</span>
 4861 |     | <span class='neutral'>    - _currentToOrigin_.integral()</span>
 4862 |     | <span class='neutral'>    - _incomingCurrentToTarget_.integral();</span>
 4863 |     | <span class='neutral'></span>
 4864 |     | <span class='neutral'>  // The output is capped to prevent negative values due to rounding error.</span>
 4865 |     | <span class='neutral'>  integral1Amended = max(integral1Amended, zeroX216);</span>
 4866 |     | <span class='neutral'></span>
 4867 |     | <span class='neutral'>  // The amended integrals are set depending on the direction.</span>
 4868 |     | <span class='neutral'>  (integral0Amended, integral1Amended) = zeroForOne ? </span>
 4869 |     | <span class='neutral'>    (integral1Amended, integral0Amended) : </span>
 4870 |     | <span class='neutral'>    (integral0Amended, integral1Amended);</span>
 4871 |     | <span class='neutral'>}</span>
 4872 |     | <span class='neutral'></span>
 4873 |     | <span class='neutral'>/// @notice Performs Newton search to find the optimal mismatch value.</span>
 4874 |     | <span class='neutral'>/// For each swap, the protocol moves the current price to an &#39;overshoot&#39; price</span>
 4875 |     | <span class='neutral'>/// and then projects it back to the &#39;target&#39; price. The &#39;overshoot&#39; value</span>
 4876 |     | <span class='neutral'>/// is determined using newton search in such a way that the total liquidity</span>
 4877 |     | <span class='neutral'>/// growth is maximized. Notice that the incoming and outgoing values are</span>
 4878 |     | <span class='neutral'>/// already determined and this process is only concerned with curve update.</span>
 4879 |     | <span class='neutral'>///</span>
 4880 |     | <span class='neutral'>/// @param integral0Incremented The integral of the liquidity distribution</span>
 4881 |     | <span class='neutral'>/// function from &#39;qTarget&#39; to &#39;qUpper&#39; prior to the amendment of the curve</span>
 4882 |     | <span class='neutral'>/// sequence:</span>
 4883 |     | <span class='neutral'>///</span>
 4884 |     | <span class='neutral'>///                                 - 8     / qUpper</span>
 4885 |     | <span class='neutral'>///     integral0Incremented      e        |    - h / 2</span>
 4886 |     | <span class='neutral'>///   &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;,</span>
 4887 |     | <span class='neutral'>///           2 ** 216              2      |</span>
 4888 |     | <span class='neutral'>///                                       / qTarget</span>
 4889 |     | <span class='neutral'>///</span>
 4890 |     | <span class='neutral'>/// @param integral1Incremented The integral of the liquidity distribution</span>
 4891 |     | <span class='neutral'>/// function from &#39;qLower&#39; to &#39;qTarget&#39; prior to the amendment of the curve</span>
 4892 |     | <span class='neutral'>/// sequence:</span>
 4893 |     | <span class='neutral'>///</span>
 4894 |     | <span class='neutral'>///                                 - 8     / qTarget</span>
 4895 |     | <span class='neutral'>///     integral1Incremented      e        |    + h / 2</span>
 4896 |     | <span class='neutral'>///   &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;.</span>
 4897 |     | <span class='neutral'>///           2 ** 216              2      |</span>
 4898 |     | <span class='neutral'>///                                       / qLower</span>
 4899 |     | <span class='neutral'>///</span>
 4900 |     | <span class='neutral'>/// @return integral0Amended The integral of the liquidity distribution function</span>
 4901 |     | <span class='neutral'>/// from &#39;qTarget&#39; to &#39;qUpper&#39; after the amendment of the curve sequence:</span>
 4902 |     | <span class='neutral'>///</span>
 4903 |     | <span class='neutral'>///                             - 8     / qUpper</span>
 4904 |     | <span class='neutral'>///     integral0Amended      e        |    - h / 2</span>
 4905 |     | <span class='neutral'>///   &#39;------------------ := ------- * |  e         k(wAmended(h)) dh&#39;.</span>
 4906 |     | <span class='neutral'>///         2 ** 216            2      |</span>
 4907 |     | <span class='neutral'>///                                   / qTarget</span>
 4908 |     | <span class='neutral'>///</span>
 4909 |     | <span class='neutral'>/// @return integral1Amended The integral of the liquidity distribution function</span>
 4910 |     | <span class='neutral'>/// from &#39;qLower&#39; to &#39;qTarget&#39; after the amendment of the curve sequence:</span>
 4911 |     | <span class='neutral'>///</span>
 4912 |     | <span class='neutral'>///                             - 8     / qTarget</span>
 4913 |     | <span class='neutral'>///     integral1Amended      e        |    + h / 2</span>
 4914 |     | <span class='neutral'>///   &#39;------------------ := ------- * |  e         k(wAmended(h)) dh&#39;.</span>
 4915 |     | <span class='neutral'>///         2 ** 216            2      |</span>
 4916 |     | <span class='neutral'>///                                   / qLower</span>
 4917 |     | <span class='neutral'>///</span>
 4918 |     | <span class='neutral'>function searchOvershoot(</span>
 4919 |     | <span class='neutral'>  X216 integral0Incremented,</span>
 4920 |     | <span class='neutral'>  X216 integral1Incremented</span>
 4921 |     | <span class='neutral'>) pure returns (</span>
 4922 |     | <span class='neutral'>  X216 integral0Amended,</span>
 4923 |     | <span class='neutral'>  X216 integral1Amended</span>
 4924 |     | <span class='neutral'>) {</span>
 4925 |     | <span class='neutral'>  bool zeroForOne = getZeroForOne();</span>
 4926 |     | <span class='neutral'></span>
 4927 |     | <span class='neutral'>  // Newton search is performed here:</span>
 4928 |     | <span class='neutral'>  X59 step;</span>
 4929 |     | <span class='neutral'>  bool sign;</span>
 4930 |     | <span class='neutral'>  while (true) {</span>
 4931 |     | <span class='neutral'>    (sign, step, integral0Amended, integral1Amended) = newtonStep(</span>
 4932 |     | <span class='neutral'>      integral0Incremented,</span>
 4933 |     | <span class='neutral'>      integral1Incremented</span>
 4934 |     | <span class='neutral'>    );</span>
 4935 |     | <span class='neutral'>    if (step == zeroX59) break;</span>
 4936 |     | <span class='neutral'>    // The addition is safe because overshoot remains within the interval.</span>
 4937 |     | <span class='neutral'>    _overshoot_.storePrice(</span>
 4938 |     | <span class='neutral'>      zeroForOne ? </span>
 4939 |     | <span class='neutral'>      min(max(_end_.log(), _overshoot_.log() + step), _begin_.log()) :</span>
 4940 |     | <span class='neutral'>      min(max(_begin_.log(), _overshoot_.log() + step), _end_.log())</span>
 4941 |     | <span class='neutral'>    );</span>
 4942 |     | <span class='neutral'>  }</span>
 4943 |     | <span class='neutral'></span>
 4944 |     | <span class='neutral'>  // We intend to maximize marginal growth which is equal to:</span>
 4945 |     | <span class='neutral'>  //</span>
 4946 |     | <span class='neutral'>  //        integral0Incremented     integral1Incremented</span>
 4947 |     | <span class='neutral'>  //  &#39;min(---------------------- , ----------------------)&#39;</span>
 4948 |     | <span class='neutral'>  //          integral0Amended         integral1Amended</span>
 4949 |     | <span class='neutral'>  //</span>
 4950 |     | <span class='neutral'>  // Given that &#39;integral0Incremented&#39; and &#39;integral1Incremented&#39; are constant,</span>
 4951 |     | <span class='neutral'>  // this is equivalent to minimizing the following.</span>
 4952 |     | <span class='neutral'>  //</span>
 4953 |     | <span class='neutral'>  // Both multiplications are safe because all four integrals do not exceed</span>
 4954 |     | <span class='neutral'>  // &#39;oneX216&#39;.</span>
 4955 |     | <span class='neutral'>  X216 growthInverse = max(</span>
 4956 |     | <span class='neutral'>    integral0Incremented &amp; integral1Amended,</span>
 4957 |     | <span class='neutral'>    integral1Incremented &amp; integral0Amended</span>
 4958 |     | <span class='neutral'>  );</span>
 4959 |     | <span class='neutral'></span>
 4960 |     | <span class='neutral'>  // Next, we move overshoot one step forward or backward to make sure that it</span>
 4961 |     | <span class='neutral'>  // is perfectly optimized.</span>
 4962 |     | <span class='neutral'></span>
 4963 |     | <span class='neutral'>  // If we are not at the end of the search interval and sign is aligned with</span>
 4964 |     | <span class='neutral'>  // zeroForOne, then overshoot is moved one step forward.</span>
 4965 |     | <span class='neutral'>  bool forward = (_overshoot_.log() != _end_.log()) &amp;&amp; (sign == zeroForOne);</span>
 4966 |     | <span class='neutral'></span>
 4967 |     | <span class='neutral'>  // If we are not at the beginning of the search interval and sign is not </span>
 4968 |     | <span class='neutral'>  // aligned with zeroForOne, then overshoot is moved one step backward.</span>
 4969 |     | <span class='neutral'>  bool backward = (_overshoot_.log() != _begin_.log()) &amp;&amp; (sign != zeroForOne);</span>
 4970 |     | <span class='neutral'></span>
 4971 |     | <span class='neutral'>  // If either forward or backward are true we move the overshoot.</span>
 4972 |     | <span class='neutral'>  if (forward || backward) {</span>
 4973 |     | <span class='neutral'>    // Backing up &#39;integral0Amended&#39; and &#39;integral1Amended&#39;.</span>
 4974 |     | <span class='neutral'>    X216 _integral0Amended = integral0Amended;</span>
 4975 |     | <span class='neutral'>    X216 _integral1Amended = integral1Amended;</span>
 4976 |     | <span class='neutral'>    _end_.copyPrice(_overshoot_); // Backing up &#39;overshoot&#39;.</span>
 4977 |     | <span class='neutral'></span>
 4978 |     | <span class='neutral'>    // Moving one step forward or backward.</span>
 4979 |     | <span class='neutral'>    // This is safe due to the prior &#39;if&#39;.</span>
 4980 |     | <span class='neutral'>    // Notice that &#39;forward&#39; and &#39;backward&#39; are mutually exclusive.</span>
 4981 |     | <span class='neutral'>    moveOvershootByEpsilon(forward == zeroForOne);</span>
 4982 |     | <span class='neutral'>    (integral0Amended, integral1Amended) = newIntegrals(</span>
 4983 |     | <span class='neutral'>      integral0Incremented,</span>
 4984 |     | <span class='neutral'>      integral1Incremented</span>
 4985 |     | <span class='neutral'>    );</span>
 4986 |     | <span class='neutral'></span>
 4987 |     | <span class='neutral'>    // Both multiplications are safe because all four integrals do not exceed</span>
 4988 |     | <span class='neutral'>    // &#39;oneX216&#39;.</span>
 4989 |     | <span class='neutral'>    X216 _growthInverse = max(</span>
 4990 |     | <span class='neutral'>      integral0Incremented &amp; integral1Amended,</span>
 4991 |     | <span class='neutral'>      integral1Incremented &amp; integral0Amended</span>
 4992 |     | <span class='neutral'>    );</span>
 4993 |     | <span class='neutral'></span>
 4994 |     | <span class='neutral'>    if (_growthInverse &gt;= growthInverse) {</span>
 4995 |     | <span class='neutral'>      _overshoot_.copyPrice(_end_); // Moving forward.</span>
 4996 |     | <span class='neutral'>      integral0Amended = _integral0Amended; // Moving forward.</span>
 4997 |     | <span class='neutral'>      integral1Amended = _integral1Amended; // Moving forward.</span>
 4998 |     | <span class='neutral'>    }</span>
 4999 |     | <span class='neutral'>  }</span>
 5000 |     | <span class='neutral'></span>
 5001 |     | <span class='neutral'>  // Amended integrals should never be greater than the original ones.</span>
 5002 |     | <span class='neutral'>  integral0Amended = min(integral0Incremented, integral0Amended);</span>
 5003 |     | <span class='neutral'>  integral1Amended = min(integral1Incremented, integral1Amended);</span>
 5004 |     | <span class='neutral'>}</span>
 5005 |     | <span class='neutral'></span>
 5006 |     | <span class='neutral'>/// @notice Clears this interval from memory so that a second &#39;swapWithin&#39; can</span>
 5007 |     | <span class='neutral'>/// be called.</span>
 5008 |     | <span class='neutral'>function clearInterval() pure {</span>
 5009 |     | <span class='neutral'>  assembly {</span>
 5010 |     | <span class='neutral'>    //</span>
 5011 |     | <span class='neutral'>    //  _interval_                               _endOfInterval_</span>
 5012 |     | <span class='neutral'>    //      |                                           |</span>
 5013 |     | <span class='neutral'>    //      +-------------------------------------------+</span>
 5014 |     | <span class='neutral'>    //      |                     0                     |</span>
 5015 |     | <span class='neutral'>    //      +-------------------------------------------+</span>
 5016 |     | <span class='neutral'>    //</span>
 5017 |     | <span class='neutral'>    codecopy(</span>
 5018 |     | <span class='neutral'>      _interval_,</span>
 5019 |     | <span class='neutral'>      sub(0, sub(_endOfInterval_, _interval_)),</span>
 5020 |     | <span class='neutral'>      sub(_endOfInterval_, _interval_)</span>
 5021 |     | <span class='neutral'>    )</span>
 5022 |     | <span class='neutral'>  }</span>
 5023 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/Kernel.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {Index, zeroIndex} from &quot;./Index.sol&quot;;</span>
   5 |     | <span class='neutral'>import {X15} from &quot;./X15.sol&quot;;</span>
   6 |     | <span class='neutral'>import {X59} from &quot;./X59.sol&quot;;</span>
   7 |     | <span class='neutral'>import {X216, oneX216} from &quot;./X216.sol&quot;;</span>
   8 |     | <span class='neutral'>import {PriceLibrary} from &quot;./Price.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>using PriceLibrary for uint16;</span>
  11 |     | <span class='neutral'>using PriceLibrary for uint256;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>// For every pool, the kernel function &#39;k : [0, qSpacing] -&gt; [0, 1]&#39; represents</span>
  14 |     | <span class='neutral'>// a monotonically non-decreasing piece-wise linear function whose breakpoints</span>
  15 |     | <span class='neutral'>// are listed in the storage smart contract. Let &#39;m + 1&#39; denote the number</span>
  16 |     | <span class='neutral'>// of these breakpoints. For every integer &#39;0 &lt;= i &lt;= m&#39; the i-th breakpoint of</span>
  17 |     | <span class='neutral'>// the kernel represents the pair &#39;(b[i], c[i])&#39; where</span>
  18 |     | <span class='neutral'>//</span>
  19 |     | <span class='neutral'>//  &#39;0 == b[0] &lt;  b[1] &lt;= b[2] &lt;= ... &lt;= b[m - 1] &lt;  b[m] == qSpacing&#39;,</span>
  20 |     | <span class='neutral'>//  &#39;0 == c[0] &lt;= c[1] &lt;= c[2] &lt;= ... &lt;= c[m - 1] &lt;= c[m] == 1&#39;.</span>
  21 |     | <span class='neutral'>// </span>
  22 |     | <span class='neutral'>// Each breakpoint occupies 64 bytes, in which:</span>
  23 |     | <span class='neutral'>//</span>
  24 |     | <span class='neutral'>//  - the &#39;X15&#39; representation of &#39;(2 ** 15) * c[i]&#39; occupies 2 bytes,</span>
  25 |     | <span class='neutral'>//</span>
  26 |     | <span class='neutral'>//  - the &#39;X59&#39; representation of &#39;(2 ** 59) * b[i]&#39; occupies 8 bytes,</span>
  27 |     | <span class='neutral'>//</span>
  28 |     | <span class='neutral'>//  - the &#39;X216&#39; representation of &#39;(2 ** 216) * exp(- b[i] / 2)&#39; occupies 27</span>
  29 |     | <span class='neutral'>//    bytes,</span>
  30 |     | <span class='neutral'>//</span>
  31 |     | <span class='neutral'>//  - the &#39;X216&#39; representation of &#39;(2 ** 216) * exp(- 16 + b[i] / 2)&#39; occupies</span>
  32 |     | <span class='neutral'>//    27 bytes.</span>
  33 |     | <span class='neutral'>//</span>
  34 |     | <span class='neutral'>// The above-mentioned layout is illustrated as follows:</span>
  35 |     | <span class='neutral'>//</span>
  36 |     | <span class='neutral'>//                      A 512 bit kernel breakpoint</span>
  37 |     | <span class='neutral'>//  +--+--------+---------------------------+---------------------------+</span>
  38 |     | <span class='neutral'>//  |  | 8 byte |          27 byte          |          27 byte          |</span>
  39 |     | <span class='neutral'>//  +--+--------+---------------------------+---------------------------+</span>
  40 |     | <span class='neutral'>//  |  |        |                           |</span>
  41 |     | <span class='neutral'>//  |  |        |                            \</span>
  42 |     | <span class='neutral'>//  |  |        |                             (2 ** 216) * exp(- 16 + b[i] / 2)</span>
  43 |     | <span class='neutral'>//  |  |         \</span>
  44 |     | <span class='neutral'>//  |  |          (2 ** 216) * exp(- b[i] / 2)</span>
  45 |     | <span class='neutral'>//  |   \</span>
  46 |     | <span class='neutral'>//  |    (2 ** 59) * b[i]</span>
  47 |     | <span class='neutral'>//   \</span>
  48 |     | <span class='neutral'>//    (2 ** 15) * c[i]</span>
  49 |     | <span class='neutral'>//</span>
  50 |     | <span class='neutral'>// Consider the following list of kernel breakpoints:</span>
  51 |     | <span class='neutral'>//</span>
  52 |     | <span class='neutral'>//  &#39;(b[0], c[0]), (b[1], c[1]), (b[2], c[2]), ..., (b[m], c[m])&#39;</span>
  53 |     | <span class='neutral'>//</span>
  54 |     | <span class='neutral'>// and for every integer &#39;0 &lt; i &lt;= m&#39;, define</span>
  55 |     | <span class='neutral'>//</span>
  56 |     | <span class='neutral'>//  &#39;k_i : [0, qSpacing] -&gt; [0, 1]&#39;</span>
  57 |     | <span class='neutral'>//</span>
  58 |     | <span class='neutral'>// as</span>
  59 |     | <span class='neutral'>//</span>
  60 |     | <span class='neutral'>//  &#39;k_i(q) :=</span>
  61 |     | <span class='neutral'>//</span>
  62 |     | <span class='neutral'>//    /            c[i] - c[i - 1]</span>
  63 |     | <span class='neutral'>//   | c[i - 1] + ----------------- * (q - b[i - 1])  if  b[i - 1] &lt; q &lt; b[i]</span>
  64 |     | <span class='neutral'>//   |             b[i] - b[i - 1]                                           &#39;,</span>
  65 |     | <span class='neutral'>//   | 0                                              otherwise</span>
  66 |     | <span class='neutral'>//    \</span>
  67 |     | <span class='neutral'>//</span>
  68 |     | <span class='neutral'>// which means that if &#39;b[i - 1] == b[i]&#39;, then &#39;k_i(q) := 0&#39;. Now, the kernel</span>
  69 |     | <span class='neutral'>// function</span>
  70 |     | <span class='neutral'>// </span>
  71 |     | <span class='neutral'>//  &#39;k : [0, qSpacing] -&gt; [0, 1]&#39;</span>
  72 |     | <span class='neutral'>//</span>
  73 |     | <span class='neutral'>// is defined as</span>
  74 |     | <span class='neutral'>//</span>
  75 |     | <span class='neutral'>//             m</span>
  76 |     | <span class='neutral'>//           -----</span>
  77 |     | <span class='neutral'>//           \</span>
  78 |     | <span class='neutral'>//  &#39;k(q) := /     k_i(q)&#39;.</span>
  79 |     | <span class='neutral'>//           -----</span>
  80 |     | <span class='neutral'>//           i = 1</span>
  81 |     | <span class='neutral'>//</span>
  82 |     | <span class='neutral'>type Kernel is uint256;</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>using KernelLibrary for Kernel global;</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>library KernelLibrary {</span>
  87 |     | <span class='neutral'>  /// @notice Returns the components of the kernel breakpoint which corresponds</span>
  88 |     | <span class='neutral'>  /// to the given index.</span>
  89 |     | <span class='neutral'>  ///</span>
  90 |     | <span class='neutral'>  /// Index out of range should be avoided externally.</span>
  91 |     | <span class='unexecuted'>  function member(</span>
  92 |     | <span class='neutral'>    Kernel kernel,</span>
  93 |     | <span class='neutral'>    Index index</span>
  94 |     | <span class='neutral'>  ) internal pure returns (</span>
  95 |     | <span class='unexecuted'>    X15 height,</span>
  96 |     | <span class='unexecuted'>    X59 logShift,</span>
  97 |     | <span class='unexecuted'>    X216 sqrtShift,</span>
  98 |     | <span class='unexecuted'>    X216 sqrtInverseShift</span>
  99 |     | <span class='neutral'>  ) {</span>
 100 |     | <span class='neutral'>    // If &#39;index&#39; is equal to 0, then this function should return </span>
 101 |     | <span class='neutral'>    // &#39;(zeroX15, zeroX59, oneX216, floor((2 ** 216) * exp(-16)))&#39;. Because the</span>
 102 |     | <span class='neutral'>    // first member of kernelCompact is always &#39;(zeroX15, zeroX59)&#39;.</span>
 103 |     | <span class='unexecuted'>    if (index &gt; zeroIndex) {</span>
 104 |     | <span class='unexecuted'>      uint256 pointer;</span>
 105 |     | <span class='neutral'>      assembly {</span>
 106 |     | <span class='neutral'>        // Each member of Kernel is &#39;64 == 2 ** 6&#39; bytes. Hence we shift</span>
 107 |     | <span class='neutral'>        // &#39;index&#39; by &#39;6&#39; digits which is equivalent to multiplying by &#39;64&#39;.</span>
 108 |     | <span class='neutral'>        // The origin is omitted and handled separately. We subtract by</span>
 109 |     | <span class='neutral'>        // &#39;62 = 8 + 27 + 27&#39; so that the pointer corresponding to </span>
 110 |     | <span class='neutral'>        // &#39;index == oneIndex&#39; follows this layout:</span>
 111 |     | <span class='neutral'>        //</span>
 112 |     | <span class='neutral'>        //        pointer</span>
 113 |     | <span class='neutral'>        //      /</span>
 114 |     | <span class='neutral'>        //     |        A 512 bit kernel breakpoint</span>
 115 |     | <span class='neutral'>        //  +--+--------+-----------------+-----------------+</span>
 116 |     | <span class='neutral'>        //  |  | 8 byte |     27 byte     |     27 byte     |</span>
 117 |     | <span class='neutral'>        //  +--+--------+-----------------+-----------------+</span>
 118 |     | <span class='neutral'>        //  |  |        |                 |</span>
 119 |     | <span class='neutral'>        //  |  |        |                  \</span>
 120 |     | <span class='neutral'>        //  |  |        |                   (2 ** 216) * exp(- 16 + b[i] / 2)</span>
 121 |     | <span class='neutral'>        //  |  |         \</span>
 122 |     | <span class='neutral'>        //  |  |          (2 ** 216) * exp(- b[i] / 2)</span>
 123 |     | <span class='neutral'>        //  |   \</span>
 124 |     | <span class='neutral'>        //  |    (2 ** 59) * b[i]</span>
 125 |     | <span class='neutral'>        //   \</span>
 126 |     | <span class='neutral'>        //    (2 ** 15) * c[i]</span>
 127 |     | <span class='neutral'>        //</span>
 128 |     | <span class='unexecuted'>        pointer := add(kernel, sub(shl(6, index), 62))</span>
 129 |     | <span class='neutral'>      }</span>
 130 |     | <span class='neutral'>      // Now that &#39;pointer&#39; points to a price with height according to the</span>
 131 |     | <span class='neutral'>      // above layout, all four values are loaded from memory using</span>
 132 |     | <span class='neutral'>      // &#39;PriceLibrary&#39;.</span>
 133 |     | <span class='unexecuted'>      height = pointer.height();</span>
 134 |     | <span class='unexecuted'>      logShift = pointer.log();</span>
 135 |     | <span class='unexecuted'>      sqrtShift = pointer.sqrt(false);</span>
 136 |     | <span class='unexecuted'>      sqrtInverseShift = pointer.sqrt(true);</span>
 137 |     | <span class='neutral'>    } else {</span>
 138 |     | <span class='neutral'>      // &#39;height&#39; and &#39;logShift&#39; are zero by default.</span>
 139 |     | <span class='unexecuted'>      sqrtShift = oneX216;</span>
 140 |     | <span class='unexecuted'>      sqrtInverseShift = X216.wrap(</span>
 141 |     | <span class='unexecuted'>        0x0000000000000001E355BBAEE85CADA65F73F32E88FB3CC629B709109F57564D</span>
 142 |     | <span class='neutral'>      ); // floor((2 ** 216) * exp(-16))</span>
 143 |     | <span class='neutral'>    }</span>
 144 |     | <span class='neutral'>  }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>  /// @notice This function calculates the resultant of the logarithmic price</span>
 147 |     | <span class='neutral'>  /// &#39;q&#39; which is stored in &#39;basePrice&#39; and the &#39;index&#39; breakpoint of</span>
 148 |     | <span class='neutral'>  /// &#39;kernel&#39;. The resultant is then stored in memory.</span>
 149 |     | <span class='neutral'>  ///</span>
 150 |     | <span class='neutral'>  /// If &#39;left == false&#39;, the resulting log price is equal to </span>
 151 |     | <span class='neutral'>  ///</span>
 152 |     | <span class='neutral'>  ///  &#39;qResultant := q + b[index]&#39;.</span>
 153 |     | <span class='neutral'>  ///</span>
 154 |     | <span class='neutral'>  /// In this case we should have: &#39;0 &lt; q + b[index] &lt; 2 ** 64&#39;.</span>
 155 |     | <span class='neutral'>  ///</span>
 156 |     | <span class='neutral'>  /// If &#39;left == true&#39;, the resulting log price is equal to </span>
 157 |     | <span class='neutral'>  ///</span>
 158 |     | <span class='neutral'>  ///  &#39;qResultant := q - b[index]&#39;.</span>
 159 |     | <span class='neutral'>  ///</span>
 160 |     | <span class='neutral'>  /// In this case we should have: &#39;0 &lt; q - b[index] &lt; 2 ** 64&#39;.</span>
 161 |     | <span class='neutral'>  ///</span>
 162 |     | <span class='neutral'>  /// Index out of range should be avoided externally.</span>
 163 |     | <span class='neutral'>  /// &#39;resultant&#39; should not be less than &#39;34&#39;.</span>
 164 |     | <span class='neutral'>  function impose(</span>
 165 |     | <span class='neutral'>    Kernel kernel,</span>
 166 |     | <span class='neutral'>    uint256 resultant,</span>
 167 |     | <span class='neutral'>    uint256 basePrice,</span>
 168 |     | <span class='neutral'>    Index index,</span>
 169 |     | <span class='neutral'>    bool left</span>
 170 |     | <span class='neutral'>  ) internal pure {</span>
 171 |     | <span class='neutral'>    // These four values correspond to the kernel&#39;s member.</span>
 172 |     | <span class='neutral'>    (X15 height, X59 logShift, X216 sqrtShift, X216 sqrtInverseShift) = </span>
 173 |     | <span class='neutral'>      kernel.member(index);</span>
 174 |     | <span class='neutral'>    </span>
 175 |     | <span class='neutral'>    // Addition or subtraction is safe due to the above requirements.</span>
 176 |     | <span class='neutral'>    // The multiplication does not overflow because both values are loaded from</span>
 177 |     | <span class='neutral'>    // 216 bits of memory. Hence, they are non-negative and are less than</span>
 178 |     | <span class='neutral'>    // oneX216.</span>
 179 |     | <span class='neutral'>    // The requirements of &#39;mulDivByExpInv16&#39; are met because both values are </span>
 180 |     | <span class='neutral'>    // loaded from 216 bits of memory. Hence, they are non-negative and are </span>
 181 |     | <span class='neutral'>    // less than oneX216. Additionally, &#39;mulDivByExpInv16&#39; does not overflow</span>
 182 |     | <span class='neutral'>    // and fits within 216 bits, because if &#39;left == false&#39;:</span>
 183 |     | <span class='neutral'>    //</span>
 184 |     | <span class='neutral'>    // &#39;(basePrice.sqrt(true) ^ sqrtInverseShift) / (2 ** 216) == </span>
 185 |     | <span class='neutral'>    //  exp(- 16 - 16 + (basePrice.log() + logShift) / (2 ** 60)) / exp(-16)</span>
 186 |     | <span class='neutral'>    //  == exp(- 16 + (basePrice.log() + logShift) / (2 ** 60)) &lt;</span>
 187 |     | <span class='neutral'>    //  == exp(- 16 + (2 ** 64) / (2 ** 60)) &lt;= 1&#39;</span>
 188 |     | <span class='neutral'>    //</span>
 189 |     | <span class='neutral'>    // and if &#39;left == true&#39;:</span>
 190 |     | <span class='neutral'>    //</span>
 191 |     | <span class='neutral'>    // &#39;(basePrice.sqrt(false) ^ sqrtInverseShift) / (2 ** 216) == </span>
 192 |     | <span class='neutral'>    //  exp(-16 - (basePrice.log() - logShift) / (2 ** 60)) / exp(-16) == </span>
 193 |     | <span class='neutral'>    //  exp(- (basePrice.log() - logShift) / (2 ** 60)) &lt; exp(0) &lt;= 1&#39;</span>
 194 |     | <span class='neutral'>    //</span>
 195 |     | <span class='neutral'>    // Hence, the outcome of the multiplication and &#39;mulDivByExpInv16&#39; do not</span>
 196 |     | <span class='neutral'>    // exceed 216 bits.</span>
 197 |     | <span class='neutral'>    (X59 logPrice, X216 sqrtPrice, X216 sqrtInversePrice) = left ? (</span>
 198 |     | <span class='neutral'>      basePrice.log() - logShift,</span>
 199 |     | <span class='neutral'>      basePrice.sqrt(false) ^ sqrtInverseShift,</span>
 200 |     | <span class='neutral'>      basePrice.sqrt(true) * sqrtShift</span>
 201 |     | <span class='neutral'>    ) : (</span>
 202 |     | <span class='neutral'>      basePrice.log() + logShift,</span>
 203 |     | <span class='neutral'>      basePrice.sqrt(false) * sqrtShift,</span>
 204 |     | <span class='neutral'>      basePrice.sqrt(true) ^ sqrtInverseShift</span>
 205 |     | <span class='neutral'>    );</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>    // The requirements of &#39;storePrice&#39; are satisfied due to the above</span>
 208 |     | <span class='neutral'>    // arguments and the input requirements.</span>
 209 |     | <span class='neutral'>    resultant.storePrice(height, logPrice, sqrtPrice, sqrtInversePrice);</span>
 210 |     | <span class='neutral'>  }</span>
 211 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/Memory.sol</b>
<code>
    1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
    2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>/// @dev Nofeeswap&#39;s memory layout.</span>
    5 |     | <span class='neutral'>/// @notice Each &#39;uint16&#39; value is a memory pointer referring to the</span>
    6 |     | <span class='neutral'>/// corresponding value in memory. This file is generated using &#39;Memory.py&#39;.</span>
    7 |     | <span class='neutral'></span>
    8 |     | <span class='neutral'>import {Tag} from &quot;./Tag.sol&quot;;</span>
    9 |     | <span class='neutral'>import {Index} from &quot;./Index.sol&quot;;</span>
   10 |     | <span class='neutral'>import {X15} from &quot;./X15.sol&quot;;</span>
   11 |     | <span class='neutral'>import {X23} from &quot;./X23.sol&quot;;</span>
   12 |     | <span class='neutral'>import {X47} from &quot;./X47.sol&quot;;</span>
   13 |     | <span class='neutral'>import {X59} from &quot;./X59.sol&quot;;</span>
   14 |     | <span class='neutral'>import {X111} from &quot;./X111.sol&quot;;</span>
   15 |     | <span class='neutral'>import {X127} from &quot;./X127.sol&quot;;</span>
   16 |     | <span class='neutral'>import {X208} from &quot;./X208.sol&quot;;</span>
   17 |     | <span class='neutral'>import {X216} from &quot;./X216.sol&quot;;</span>
   18 |     | <span class='neutral'>import {Curve} from &quot;./Curve.sol&quot;;</span>
   19 |     | <span class='neutral'>import {Kernel} from &quot;./Kernel.sol&quot;;</span>
   20 |     | <span class='neutral'></span>
   21 |     | <span class='neutral'>// Refers to the third slot of the memory which contains the free memory</span>
   22 |     | <span class='neutral'>// pointer.</span>
   23 |     | <span class='neutral'>uint16 constant _freeMemoryPointer_ = 64;</span>
   24 |     | <span class='neutral'></span>
   25 |     | <span class='neutral'>// Refers to the fourth slot of the memory which remains blank.</span>
   26 |     | <span class='neutral'>uint16 constant _blank_ = 96;</span>
   27 |     | <span class='neutral'></span>
   28 |     | <span class='neutral'>// When the protocol calls a hook or the sentinel contract, a snapshot of the</span>
   29 |     | <span class='neutral'>// memory (with &#39;_hookSelector_&#39; as the starting point) is sent to the target</span>
   30 |     | <span class='neutral'>// contract as calldata. Before calling the target contract, this 4 byte space</span>
   31 |     | <span class='neutral'>// is populated with the intended function selector of the target contract.</span>
   32 |     | <span class='neutral'>uint16 constant _hookSelector_ = 128;</span>
   33 |     | <span class='neutral'></span>
   34 |     | <span class='neutral'>// This space is populated with the abi offset &#39;0x20&#39; so that the hook or the</span>
   35 |     | <span class='neutral'>// sentinel contract can decode the given calldata. This offset value points to</span>
   36 |     | <span class='neutral'>// the slot that contains the byte count of the snapshot given to the hook or</span>
   37 |     | <span class='neutral'>// the sentinel contract</span>
   38 |     | <span class='neutral'>uint16 constant _hookInputHeader_ = 132;</span>
   39 |     | <span class='neutral'></span>
   40 |     | <span class='neutral'>// This space is populated with the byte count of &#39;bytes calldata hookInput&#39;</span>
   41 |     | <span class='neutral'>// which is passed as input to the hook or the sentinel contract.</span>
   42 |     | <span class='neutral'>uint16 constant _hookInputByteCount_ = 164;</span>
   43 |     | <span class='neutral'></span>
   44 |     | <span class='neutral'>// &#39;msg.sender&#39; in the current execution context is placed in this space to be</span>
   45 |     | <span class='neutral'>// passed to the hook or the sentinel contract. This way, the hook or the</span>
   46 |     | <span class='neutral'>// sentinel contract have access to &#39;msg.sender&#39; in the prior execution</span>
   47 |     | <span class='neutral'>// context (i.e., in the context where the protocol is called).</span>
   48 |     | <span class='neutral'>uint16 constant _msgSender_ = 196;</span>
   49 |     | <span class='neutral'></span>
   50 |     | <span class='neutral'>// This space is dedicated to the identifier of the intended pool. The least</span>
   51 |     | <span class='neutral'>// significant 160 bits of this memory space refer to the hook address. The</span>
   52 |     | <span class='neutral'>// next 20 bits are referred to as flags that are used by the protocol to know</span>
   53 |     | <span class='neutral'>// which methods from &#39;IHook.sol&#39; should be invoked and what permissions are</span>
   54 |     | <span class='neutral'>// activated. Flags are further explained in &#39;IHook.sol&#39;. The next 8 bits</span>
   55 |     | <span class='neutral'>// represent the natural logarithm of &#39;pOffset&#39; which must be greater than or</span>
   56 |     | <span class='neutral'>// equal to &#39;-89&#39; and less than or equal to &#39;89&#39; in &#39;int8&#39; representation</span>
   57 |     | <span class='neutral'>// (two&#39;s complement). Hence, &#39;pOffset&#39; is greater than or equal to &#39;exp(-89)&#39;</span>
   58 |     | <span class='neutral'>// and less than or equal to &#39;exp(+89)&#39;. As will be discussed later, the price</span>
   59 |     | <span class='neutral'>// of the pool is always greater than or equal to</span>
   60 |     | <span class='neutral'>//</span>
   61 |     | <span class='neutral'>//  &#39;pOffset * exp(- 16 + 1 / (2 ** 59))&#39;</span>
   62 |     | <span class='neutral'>//</span>
   63 |     | <span class='neutral'>// and less than or equal to</span>
   64 |     | <span class='neutral'>//</span>
   65 |     | <span class='neutral'>//  &#39;pOffset * exp(+ 16 - 1 / (2 ** 59))&#39;.</span>
   66 |     | <span class='neutral'>uint16 constant _poolId_ = 216;</span>
   67 |     | <span class='neutral'></span>
   68 |     | <span class='neutral'>// How does a swap work?</span>
   69 |     | <span class='neutral'>// ----------------------------------------------------------------------------</span>
   70 |     | <span class='neutral'>// A swap in a pool can be interpreted as a change in that pool&#39;s price. There</span>
   71 |     | <span class='neutral'>// are two types of swaps:</span>
   72 |     | <span class='neutral'>//</span>
   73 |     | <span class='neutral'>//  - If &#39;tag0&#39; is outgoing from the pool and &#39;tag1&#39; is incoming to the pool as</span>
   74 |     | <span class='neutral'>//    a result of a swap, then the swap is price increasing, i.e., the price</span>
   75 |     | <span class='neutral'>//    prior to the execution of the swap is lower than the price after the</span>
   76 |     | <span class='neutral'>//    execution of the swap.</span>
   77 |     | <span class='neutral'>//</span>
   78 |     | <span class='neutral'>//  - If &#39;tag0&#39; is incoming to the pool and &#39;tag1&#39; is outgoing from the pool as</span>
   79 |     | <span class='neutral'>//    a result of a swap, then the swap is price decreasing, i.e., the price</span>
   80 |     | <span class='neutral'>//    prior to the execution of the swap is higher than the price after the</span>
   81 |     | <span class='neutral'>//    execution of the swap.</span>
   82 |     | <span class='neutral'>//</span>
   83 |     | <span class='neutral'>// Let &#39;pOffset&#39; represent the offset price whose natural logarithm is encoded</span>
   84 |     | <span class='neutral'>// in &#39;poolId&#39; as described above (in the definition of &#39;poolId&#39;). The protocol</span>
   85 |     | <span class='neutral'>// offers liquidity providers (LPs) the flexibility to deposit their liquidity</span>
   86 |     | <span class='neutral'>// in a range of their choosing. To this end, the price horizon is partitioned</span>
   87 |     | <span class='neutral'>// into a number of liquidity intervals with equal length in the natural</span>
   88 |     | <span class='neutral'>// logarithmic scale. An LP may choose any consecutive range of liquidity</span>
   89 |     | <span class='neutral'>// intervals to deposit their liquidity. By doing so, the LP acquires a number</span>
   90 |     | <span class='neutral'>// of shares in every liquidity interval that belongs to the given range. The</span>
   91 |     | <span class='neutral'>// shares can be used later to withdraw liquidity along with any accumulated</span>
   92 |     | <span class='neutral'>// growth which is accrued as a result of swap and donate actions.</span>
   93 |     | <span class='neutral'>//</span>
   94 |     | <span class='neutral'>// At each moment, a single one of the above-mentioned intervals is active to</span>
   95 |     | <span class='neutral'>// which the current price of the pool belongs. Let &#39;pLower&#39; and &#39;pUpper&#39;,</span>
   96 |     | <span class='neutral'>// respectively, denote the minimum and maximum price in the current active</span>
   97 |     | <span class='neutral'>// liquidity interval and define</span>
   98 |     | <span class='neutral'>//</span>
   99 |     | <span class='neutral'>//  &#39;qLower := log(pLower / pOffset)&#39;</span>
  100 |     | <span class='neutral'>//  &#39;qUpper := log(pUpper / pOffset)&#39;</span>
  101 |     | <span class='neutral'>//  &#39;qSpacing := log(pUpper / pLower)&#39;.</span>
  102 |     | <span class='neutral'>//</span>
  103 |     | <span class='neutral'>// Then, for every integer &#39;j&#39;, the interval</span>
  104 |     | <span class='neutral'>//</span>
  105 |     | <span class='neutral'>//  &#39;[qLower + j * qSpacing, qUpper + j * qSpacing]&#39;</span>
  106 |     | <span class='neutral'>//</span>
  107 |     | <span class='neutral'>// is a valid liquidity interval if and only if:</span>
  108 |     | <span class='neutral'>//</span>
  109 |     | <span class='neutral'>//  &#39;- 16 + 1 / (2 ** 59) + qSpacing &lt; qLower + j * qSpacing&#39;</span>
  110 |     | <span class='neutral'>//</span>
  111 |     | <span class='neutral'>// and</span>
  112 |     | <span class='neutral'>//</span>
  113 |     | <span class='neutral'>//  &#39;qUpper + j * qSpacing &lt;= + 16 - 1 / (2 ** 59) - qSpacing&#39;.</span>
  114 |     | <span class='neutral'>//</span>
  115 |     | <span class='neutral'>// This includes the current active liquidity interval &#39;[qLower, qUpper]&#39;</span>
  116 |     | <span class='neutral'>// which corresponds to &#39;j == 0&#39;.</span>
  117 |     | <span class='neutral'>//</span>
  118 |     | <span class='neutral'>// Every swap has the following input parameters:</span>
  119 |     | <span class='neutral'>//</span>
  120 |     | <span class='neutral'>//  - &#39;logPriceLimit&#39;: This value is the natural logarithm of a price limit in</span>
  121 |     | <span class='neutral'>//    &#39;X59&#39; representation. It imposes a constraint on the price of the pool</span>
  122 |     | <span class='neutral'>//    post execution of the swap. For price increasing swaps, &#39;logPriceLimit&#39;</span>
  123 |     | <span class='neutral'>//    serves as an upper bound, in which case the price of the pool must not</span>
  124 |     | <span class='neutral'>//    exceed &#39;exp(logPriceLimit / (2 ** 59))&#39;. For price decreasing swaps,</span>
  125 |     | <span class='neutral'>//    &#39;logPriceLimit&#39; serves as a lower bound, in which case the price of the</span>
  126 |     | <span class='neutral'>//    pool must not subceed &#39;exp(logPriceLimit / (2 ** 59))&#39;. In both cases,</span>
  127 |     | <span class='neutral'>//    once the price of the pool reaches &#39;exp(logPriceLimit / (2 ** 59))&#39;, the</span>
  128 |     | <span class='neutral'>//    execution of the swap is halted. Put simply, no amount of tags are traded</span>
  129 |     | <span class='neutral'>//    with any price worst than &#39;exp(logPriceLimit / (2 ** 59))&#39; for the</span>
  130 |     | <span class='neutral'>//    swapper.</span>
  131 |     | <span class='neutral'>//</span>
  132 |     | <span class='neutral'>//  - &#39;zeroForOne&#39;: If &#39;zeroForOne == 0&#39;, then the swap is price increasing in</span>
  133 |     | <span class='neutral'>//    which case &#39;tag0&#39; is outgoing from the pool and &#39;tag1&#39; is incoming to the</span>
  134 |     | <span class='neutral'>//    pool. If &#39;zeroForOne == 1&#39;, then the swap is price decreasing in which</span>
  135 |     | <span class='neutral'>//    case &#39;tag0&#39; is incoming to the pool and &#39;tag1&#39; is outgoing from the pool.</span>
  136 |     | <span class='neutral'>//    Given any other value, the movement of the price is towards</span>
  137 |     | <span class='neutral'>//    &#39;logPriceLimit&#39;, i.e., the swap is price increasing if</span>
  138 |     | <span class='neutral'>//</span>
  139 |     | <span class='neutral'>//      &#39;pCurrent &lt; exp(logPriceLimit / (2 ** 59))&#39;</span>
  140 |     | <span class='neutral'>//</span>
  141 |     | <span class='neutral'>//    and the swap is price decreasing if</span>
  142 |     | <span class='neutral'>//</span>
  143 |     | <span class='neutral'>//      &#39;exp(logPriceLimit / (2 ** 59)) &lt; pCurrent&#39;</span>
  144 |     | <span class='neutral'>//</span>
  145 |     | <span class='neutral'>//    where &#39;pCurrent&#39; represents the current price of the pool.</span>
  146 |     | <span class='neutral'>//</span>
  147 |     | <span class='neutral'>//  - &#39;amountSpecified&#39;: If &#39;amountSpecified &gt; 0&#39; then &#39;amountSpecified&#39;</span>
  148 |     | <span class='neutral'>//    represents the amount of &#39;tag0&#39; (if the swap is price decreasing) or the</span>
  149 |     | <span class='neutral'>//    amount of &#39;tag1&#39; (if the swap is price increasing) to be given to the</span>
  150 |     | <span class='neutral'>//    pool subject to the constraint imposed by &#39;logPriceLimit&#39;. If</span>
  151 |     | <span class='neutral'>//    &#39;amountSpecified &lt; 0&#39; then &#39;0 - amountSpecified&#39; represents the amount of</span>
  152 |     | <span class='neutral'>//    &#39;tag0&#39; (if the swap is price increasing) or the amount of &#39;tag1&#39; (if the</span>
  153 |     | <span class='neutral'>//    swap is price decreasing) to be taken from the pool. Define</span>
  154 |     | <span class='neutral'>//</span>
  155 |     | <span class='neutral'>//      &#39;exactInput := amountSpecified &gt; 0&#39;</span>
  156 |     | <span class='neutral'>//</span>
  157 |     | <span class='neutral'>//    which determines whether &#39;amountSpecified&#39; is incoming to the pool or</span>
  158 |     | <span class='neutral'>//    outgoing from the pool. Additionally, if &#39;zeroForOne == exactInput&#39;, then</span>
  159 |     | <span class='neutral'>//    &#39;amountSpecified&#39; is with respect to &#39;tag0&#39; and if</span>
  160 |     | <span class='neutral'>//    &#39;zeroForOne != exactInput&#39; then &#39;amountSpecified&#39; is with respect to</span>
  161 |     | <span class='neutral'>//    &#39;tag1&#39;.</span>
  162 |     | <span class='neutral'>//</span>
  163 |     | <span class='neutral'>//  - &#39;crossThreshold&#39;: If large enough, a swap may involve transitioning from</span>
  164 |     | <span class='neutral'>//    the active liquidity interval to other intervals. &#39;crossThreshold&#39;</span>
  165 |     | <span class='neutral'>//    imposes a lower bound on the total number of shares that should be</span>
  166 |     | <span class='neutral'>//    available in any interval for the swapper to transact in that interval.</span>
  167 |     | <span class='neutral'>//    For example, if &#39;crossThreshold == 0&#39;, which is the default, no minimum</span>
  168 |     | <span class='neutral'>//    number of shares is imposed. If &#39;crossThreshold == 100&#39;, there has to be</span>
  169 |     | <span class='neutral'>//    at least 100 shares in the interval for the swap function to either swap</span>
  170 |     | <span class='neutral'>//    within or enter that interval.</span>
  171 |     | <span class='neutral'>//</span>
  172 |     | <span class='neutral'>// Consider a hypothetical pool that satisfies</span>
  173 |     | <span class='neutral'>//</span>
  174 |     | <span class='neutral'>//  &#39;qLower &lt; qCurrent &lt; qUpper&#39;,</span>
  175 |     | <span class='neutral'>//</span>
  176 |     | <span class='neutral'>// where</span>
  177 |     | <span class='neutral'>//</span>
  178 |     | <span class='neutral'>//  &#39;qCurrent := log(pCurrent / pOffset)&#39;</span>
  179 |     | <span class='neutral'>//</span>
  180 |     | <span class='neutral'>// and &#39;pCurrent&#39; is the current price of the pool.</span>
  181 |     | <span class='neutral'>//</span>
  182 |     | <span class='neutral'>// Consider a swap in this pool with the following parameters:</span>
  183 |     | <span class='neutral'>//</span>
  184 |     | <span class='neutral'>//  &#39;logPriceLimit := (2 ** 59) * log(pLimit)&#39;</span>
  185 |     | <span class='neutral'>//  &#39;zeroForOne := 1&#39;</span>
  186 |     | <span class='neutral'>//  &#39;amountSpecified := +oo&#39;</span>
  187 |     | <span class='neutral'>//  &#39;crossThreshold := 0&#39;</span>
  188 |     | <span class='neutral'>//</span>
  189 |     | <span class='neutral'>// where</span>
  190 |     | <span class='neutral'>//</span>
  191 |     | <span class='neutral'>//  &#39;pLimit := exp(- 3 * qSpacing) * pCurrent&#39;</span>
  192 |     | <span class='neutral'>//</span>
  193 |     | <span class='neutral'>// and</span>
  194 |     | <span class='neutral'>//</span>
  195 |     | <span class='neutral'>//  &#39;qLimit := log(pLimit / pOffset)&#39;.</span>
  196 |     | <span class='neutral'>//</span>
  197 |     | <span class='neutral'>// As explained later in this script, each of the above input parameters are</span>
  198 |     | <span class='neutral'>// loaded from calldata, transformed to appropriate formats and then stored in</span>
  199 |     | <span class='neutral'>// dedicated spaces in memory that are pointed to by the constant values</span>
  200 |     | <span class='neutral'>// &#39;_logPriceLimit_&#39;, &#39;_zeroForOne_&#39;, &#39;_amountSpecified_&#39;, and</span>
  201 |     | <span class='neutral'>// &#39;_crossThreshold_&#39;, respectively. Additionally, prior to the execution</span>
  202 |     | <span class='neutral'>// of the swap, &#39;qLimit&#39; is calculated and stored in the memory space which</span>
  203 |     | <span class='neutral'>// is pointed to by &#39;_logPriceLimitOffsetted_&#39;.</span>
  204 |     | <span class='neutral'>//</span>
  205 |     | <span class='neutral'>// In this example, we have:</span>
  206 |     | <span class='neutral'>//</span>
  207 |     | <span class='neutral'>//  &#39;qLower - 3 * qSpacing &lt; qLimit &lt; qUpper - 3 * qSpacing&#39;,</span>
  208 |     | <span class='neutral'>//</span>
  209 |     | <span class='neutral'>// which is illustrated as follows:</span>
  210 |     | <span class='neutral'>//</span>
  211 |     | <span class='neutral'>//             qLimit                                  qCurrent</span>
  212 |     | <span class='neutral'>//               |                                         |</span>
  213 |     | <span class='neutral'>//  ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
  214 |     | <span class='neutral'>//</span>
  215 |     | <span class='neutral'>// In the presence of liquidity, the further away &#39;qLimit&#39; is from &#39;qCurrent&#39;</span>
  216 |     | <span class='neutral'>// the larger the outgoing amount from the pool and the incoming amount to the</span>
  217 |     | <span class='neutral'>// pool are.</span>
  218 |     | <span class='neutral'>//</span>
  219 |     | <span class='neutral'>// In the above example, the swap is price decreasing which means that &#39;tag0&#39;</span>
  220 |     | <span class='neutral'>// is incoming to the pool and &#39;tag1&#39; is outgoing from the pool as a result of</span>
  221 |     | <span class='neutral'>// the swap.</span>
  222 |     | <span class='neutral'>//</span>
  223 |     | <span class='neutral'>// Observe that &#39;qLimit&#39; is three intervals away from &#39;qCurrent&#39;. Hence, in</span>
  224 |     | <span class='neutral'>// order to go from &#39;qCurrent&#39; to &#39;qLimit&#39; we need to transact in the following</span>
  225 |     | <span class='neutral'>// four intervals:</span>
  226 |     | <span class='neutral'>//</span>
  227 |     | <span class='neutral'>//  &#39;[qLower - 0 * qSpacing, qUpper - 0 * qSpacing]&#39;,</span>
  228 |     | <span class='neutral'>//  &#39;[qLower - 1 * qSpacing, qUpper - 1 * qSpacing]&#39;,</span>
  229 |     | <span class='neutral'>//  &#39;[qLower - 2 * qSpacing, qUpper - 2 * qSpacing]&#39;,</span>
  230 |     | <span class='neutral'>//  &#39;[qLower - 3 * qSpacing, qUpper - 3 * qSpacing]&#39;.</span>
  231 |     | <span class='neutral'>//</span>
  232 |     | <span class='neutral'>// At each point throughout the execution of the swap, as we transition from</span>
  233 |     | <span class='neutral'>// each interval to the next one, the memory pointers &#39;_back_&#39; and &#39;_next_&#39; are</span>
  234 |     | <span class='neutral'>// used in order to keep track of the boundaries for the current active</span>
  235 |     | <span class='neutral'>// interval. Each of these pointers refer to a memory space in which the</span>
  236 |     | <span class='neutral'>// following two values are enclosed:</span>
  237 |     | <span class='neutral'>//</span>
  238 |     | <span class='neutral'>//  &#39;qBack := log(pBack / pOffset)&#39;</span>
  239 |     | <span class='neutral'>//  &#39;qNext := log(pNext / pOffset)&#39;</span>
  240 |     | <span class='neutral'>//</span>
  241 |     | <span class='neutral'>// (among other values) where &#39;pBack&#39; is the boundary of the current active</span>
  242 |     | <span class='neutral'>// liquidity interval in the opposite direction of the swap and &#39;pNext&#39; is the</span>
  243 |     | <span class='neutral'>// other boundary in the direction of the swap.</span>
  244 |     | <span class='neutral'>//</span>
  245 |     | <span class='neutral'>// For price increasing swaps, the initial values for &#39;qBack&#39; and &#39;qNext&#39; are</span>
  246 |     | <span class='neutral'>// as follows</span>
  247 |     | <span class='neutral'>//</span>
  248 |     | <span class='neutral'>//  &#39;qBack := qLower&#39;</span>
  249 |     | <span class='neutral'>//  &#39;qNext := qUpper&#39;.</span>
  250 |     | <span class='neutral'>//</span>
  251 |     | <span class='neutral'>// However, in the present example, since the swap is price decreasing, these</span>
  252 |     | <span class='neutral'>// initial values are:</span>
  253 |     | <span class='neutral'>//</span>
  254 |     | <span class='neutral'>//  &#39;qBack := qUpper&#39;</span>
  255 |     | <span class='neutral'>//  &#39;qNext := qLower&#39;.</span>
  256 |     | <span class='neutral'>//</span>
  257 |     | <span class='neutral'>// as illustrated here:</span>
  258 |     | <span class='neutral'>//</span>
  259 |     | <span class='neutral'>//             qLimit                                   qCurrent</span>
  260 |     | <span class='neutral'>//               |                                         |</span>
  261 |     | <span class='neutral'>//  ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
  262 |     | <span class='neutral'>//                                                   |             |</span>
  263 |     | <span class='neutral'>//                                                 qNext         qBack</span>
  264 |     | <span class='neutral'>//</span>
  265 |     | <span class='neutral'>// As the price transitions to a new liquidity interval, the content of the</span>
  266 |     | <span class='neutral'>// memory spaces that are pointed to by &#39;_back_&#39; and &#39;_next_&#39; are updated</span>
  267 |     | <span class='neutral'>// accordingly.</span>
  268 |     | <span class='neutral'>//</span>
  269 |     | <span class='neutral'>// Now, in order to perform this swap, we need to proceed as follows:</span>
  270 |     | <span class='neutral'>//</span>
  271 |     | <span class='neutral'>//  - The dynamic parameters of the pool are read from the protocol&#39;s storage</span>
  272 |     | <span class='neutral'>//    which include the followings:</span>
  273 |     | <span class='neutral'>//</span>
  274 |     | <span class='neutral'>//    - &#39;sharesTotal&#39;: This is the total number of shares that are deposited in</span>
  275 |     | <span class='neutral'>//      the current active liquidity interval &#39;[qLower, qUpper]&#39; across all</span>
  276 |     | <span class='neutral'>//      LPs. Consider an example where we have only two LP positions such that</span>
  277 |     | <span class='neutral'>//      </span>
  278 |     | <span class='neutral'>//      - The first position has 2 shares in every interval from &#39;qLower&#39; to</span>
  279 |     | <span class='neutral'>//        &#39;qUpper + 2 * qSpacing&#39;, i.e., 2 shares in each of the intervals</span>
  280 |     | <span class='neutral'>//        &#39;[qLower, qUpper]&#39;, &#39;[qLower + qSpacing, qUpper + qSpacing]&#39;, and</span>
  281 |     | <span class='neutral'>//        &#39;[qSpacing + 2 * qSpacing, qUpper + 2 * qSpacing]&#39;.</span>
  282 |     | <span class='neutral'>//      </span>
  283 |     | <span class='neutral'>//      - The second position has 5 shares in every interval from</span>
  284 |     | <span class='neutral'>//        &#39;qLower - qSpacing&#39; to &#39;qUpper + qSpacing&#39;, i.e., 5 shares in each of</span>
  285 |     | <span class='neutral'>//        the intervals &#39;[qLower - qSpacing, qUpper - qSpacing]&#39;,</span>
  286 |     | <span class='neutral'>//        &#39;[qLower, qUpper]&#39;, and &#39;[qLower + qSpacing, qUpper + qSpacing]&#39;.</span>
  287 |     | <span class='neutral'>//</span>
  288 |     | <span class='neutral'>//      In this case, both LP positions include the active liquidity interval</span>
  289 |     | <span class='neutral'>//      &#39;[qLower, qUpper]&#39; which means that &#39;sharesTotal == 2 + 5 == 7&#39;.</span>
  290 |     | <span class='neutral'>//</span>
  291 |     | <span class='neutral'>//    - &#39;growth&#39;: The amount of liquidity which is allocated to a single LP</span>
  292 |     | <span class='neutral'>//      share in the active interval increases as a result of a swap or a</span>
  293 |     | <span class='neutral'>//      donation. We use this parameter to keep track of the amount of</span>
  294 |     | <span class='neutral'>//      liquidity for each share. &#39;growth&#39; is stored in &#39;X111&#39; format and we</span>
  295 |     | <span class='neutral'>//      always have &#39;growth &gt;= oneX111&#39;.</span>
  296 |     | <span class='neutral'>//</span>
  297 |     | <span class='neutral'>//    - &#39;qCurrent&#39;: This is equal to &#39;log(pCurrent / pOffset)&#39; where &#39;pCurrent&#39;</span>
  298 |     | <span class='neutral'>//      is the current price of the pool prior to the execution of the swap.</span>
  299 |     | <span class='neutral'>//</span>
  300 |     | <span class='neutral'>//    - &#39;staticParamsStoragePointer&#39;: Certain information about the pool that</span>
  301 |     | <span class='neutral'>//      never change (e.g., &#39;tag0&#39; and &#39;tag1&#39;) or do not change frequently are</span>
  302 |     | <span class='neutral'>//      encoded in an external smart contract&#39;s bytecode. We refer to this</span>
  303 |     | <span class='neutral'>//      external smart contract as the storage smart contract of the pool. This</span>
  304 |     | <span class='neutral'>//      way, the encoded parameters can be accessed by reading the storage</span>
  305 |     | <span class='neutral'>//      smart contract&#39;s bytecode which is more gas efficient than accessing</span>
  306 |     | <span class='neutral'>//      protocol&#39;s storage via &#39;sload&#39;. However, if we ever need to make any</span>
  307 |     | <span class='neutral'>//      modification, a new storage smart contract should be deployed with an</span>
  308 |     | <span class='neutral'>//      updated bytecode. Hence, the protocol needs to keep track of the</span>
  309 |     | <span class='neutral'>//      address for the storage smart contract associated with each pool.</span>
  310 |     | <span class='neutral'>//      Instead of storing a 20-byte address for each pool, we calculate it</span>
  311 |     | <span class='neutral'>//      from &#39;staticParamsStoragePointer&#39; as further explained in</span>
  312 |     | <span class='neutral'>//      &#39;Storage.sol&#39;. Hence, &#39;staticParamsStoragePointer&#39; is a 16-bit pointer</span>
  313 |     | <span class='neutral'>//      which is used to derive the address of the storage smart contract from</span>
  314 |     | <span class='neutral'>//      which additional information about the pool is read.</span>
  315 |     | <span class='neutral'>//</span>
  316 |     | <span class='neutral'>//  - The curve sequence is read from the protocol&#39;s storage. The &#39;curve&#39; is a</span>
  317 |     | <span class='neutral'>//    sequence containing historical prices in &#39;X59&#39; representation. It should</span>
  318 |     | <span class='neutral'>//    have at least two members. In other words, every  member of the curve</span>
  319 |     | <span class='neutral'>//    sequence represents a historical price &#39;pHistorical&#39; which is stored in</span>
  320 |     | <span class='neutral'>//    the form:</span>
  321 |     | <span class='neutral'>//</span>
  322 |     | <span class='neutral'>//      &#39;(2 ** 59) * (16 + qHistorical)&#39;</span>
  323 |     | <span class='neutral'>//</span>
  324 |     | <span class='neutral'>//    where</span>
  325 |     | <span class='neutral'>//</span>
  326 |     | <span class='neutral'>//      &#39;qHistorical := log(pHistorical / pOffset)&#39;.</span>
  327 |     | <span class='neutral'>//</span>
  328 |     | <span class='neutral'>//    Hence, each member of the curve occupies exactly &#39;64&#39; bits as explained</span>
  329 |     | <span class='neutral'>//    in &#39;Curve.sol&#39;. This is because &#39;pHistorical&#39; satisfies</span>
  330 |     | <span class='neutral'>//</span>
  331 |     | <span class='neutral'>//      &#39;pOffset * exp(- 16 + 1 / (2 ** 59)) &lt;= pHistorical&#39;</span>
  332 |     | <span class='neutral'>//</span>
  333 |     | <span class='neutral'>//    and</span>
  334 |     | <span class='neutral'>//</span>
  335 |     | <span class='neutral'>//      &#39;pHistorical &lt;= pOffset * exp(+ 16 - 1 / (2 ** 59))&#39;.</span>
  336 |     | <span class='neutral'>//</span>
  337 |     | <span class='neutral'>//    which conclude that</span>
  338 |     | <span class='neutral'>//</span>
  339 |     | <span class='neutral'>//      &#39;1 &lt;= (2 ** 59) * (16 + qHistorical) &lt;= 2 ** 64 - 1&#39;.</span>
  340 |     | <span class='neutral'>//</span>
  341 |     | <span class='neutral'>//    The first and the second members of the curve sequence correspond to the</span>
  342 |     | <span class='neutral'>//    boundaries of the current active liquidity interval (i.e., &#39;qLower&#39; and</span>
  343 |     | <span class='neutral'>//    &#39;qUpper&#39;) with the order depending on the pool&#39;s history. The last member</span>
  344 |     | <span class='neutral'>//    of the curve represents the current price of the pool, i.e., &#39;qCurrent&#39;.</span>
  345 |     | <span class='neutral'>//    </span>
  346 |     | <span class='neutral'>//    Let &#39;l&#39; denote the number of members in the curve sequence. Since, we</span>
  347 |     | <span class='neutral'>//    already know &#39;qCurrent&#39; from dynamic parameters, we can determine &#39;l&#39;</span>
  348 |     | <span class='neutral'>//    without having to load an entire length slot! In other words, we keep</span>
  349 |     | <span class='neutral'>//    reading members of the curve sequence from protocol&#39;s storage (four</span>
  350 |     | <span class='neutral'>//    members per slot) until we encounter &#39;qCurrent&#39; which is already known</span>
  351 |     | <span class='neutral'>//    from dynamic parameters. Then, &#39;l&#39; can be determined based on the</span>
  352 |     | <span class='neutral'>//    position of &#39;qCurrent&#39; in the curve sequence.</span>
  353 |     | <span class='neutral'>//</span>
  354 |     | <span class='neutral'>//    For every integer &#39;0 &lt;= i &lt; l&#39;, denote the (i + 1)-th historical price</span>
  355 |     | <span class='neutral'>//    recorded by the curve sequence as &#39;p[i]&#39;. Additionally, to simplify the</span>
  356 |     | <span class='neutral'>//    notations, the out-of-range price &#39;p[l]&#39; is assigned the same value as</span>
  357 |     | <span class='neutral'>//    &#39;p[l - 1]&#39;. Now, for every integer &#39;0 &lt;= i &lt;= l&#39;, define also </span>
  358 |     | <span class='neutral'>//    </span>
  359 |     | <span class='neutral'>//      &#39;q[i] := log(p[i] / pOffset)&#39;.</span>
  360 |     | <span class='neutral'>//</span>
  361 |     | <span class='neutral'>//    The curve sequence is constructed in such a way that for every</span>
  362 |     | <span class='neutral'>//    &#39;2 &lt;= i &lt; l&#39;, we have:</span>
  363 |     | <span class='neutral'>//</span>
  364 |     | <span class='neutral'>//      &#39;min(q[i - 1], q[i - 2]) &lt; q[i] &lt; max(q[i - 1], q[i - 2])&#39;.</span>
  365 |     | <span class='neutral'>//</span>
  366 |     | <span class='neutral'>//    This ordering rule is verified upon initialization of any pool and it is</span>
  367 |     | <span class='neutral'>//    preserved by every amendment to the curve sequence.</span>
  368 |     | <span class='neutral'>//    </span>
  369 |     | <span class='neutral'>//    In order to use the curve sequence, we need to define a number of</span>
  370 |     | <span class='neutral'>//    functions. For every &#39;0 &lt;= i &lt;= l - 2&#39;, if &#39;q[i + 2] &lt; q[i]&#39; define</span>
  371 |     | <span class='neutral'>//</span>
  372 |     | <span class='neutral'>//      &#39;w_i : [qLower, qUpper] -&gt; [0, qSpacing]&#39;</span>
  373 |     | <span class='neutral'>//</span>
  374 |     | <span class='neutral'>//    as</span>
  375 |     | <span class='neutral'>//</span>
  376 |     | <span class='neutral'>//                  /</span>
  377 |     | <span class='neutral'>//                 |  q - q[i + 1]  if q[i + 2] &lt; q &lt; q[i]</span>
  378 |     | <span class='neutral'>//      &#39;w_i(q) := |                                       &#39;</span>
  379 |     | <span class='neutral'>//                 |  0             otherwise</span>
  380 |     | <span class='neutral'>//                  \</span>
  381 |     | <span class='neutral'>//</span>
  382 |     | <span class='neutral'>//    and if &#39;q[i] &lt; q[i + 2]&#39; define</span>
  383 |     | <span class='neutral'>//</span>
  384 |     | <span class='neutral'>//      &#39;w_i : [qLower, qUpper] -&gt; [0, qSpacing]&#39;</span>
  385 |     | <span class='neutral'>//</span>
  386 |     | <span class='neutral'>//    as</span>
  387 |     | <span class='neutral'>//</span>
  388 |     | <span class='neutral'>//                  /</span>
  389 |     | <span class='neutral'>//                 |  q[i + 1] - q  if q[i] &lt; q &lt; q[i + 2]</span>
  390 |     | <span class='neutral'>//      &#39;w_i(q) := |                                        &#39;</span>
  391 |     | <span class='neutral'>//                 |  0             otherwise</span>
  392 |     | <span class='neutral'>//                  \</span>
  393 |     | <span class='neutral'>//</span>
  394 |     | <span class='neutral'>//    Each of the above functions is regarded as a phase. Observe that the</span>
  395 |     | <span class='neutral'>//    diagram for each of the phase is a compactly supported (i.e., equal to</span>
  396 |     | <span class='neutral'>//    zero outside of a bounded interval) segment with either &#39;45&#39; or &#39;135&#39;</span>
  397 |     | <span class='neutral'>//    degrees angle. Define</span>
  398 |     | <span class='neutral'>//</span>
  399 |     | <span class='neutral'>//      &#39;w : [qLower, qUpper] -&gt; [0, qSpacing]&#39;</span>
  400 |     | <span class='neutral'>//</span>
  401 |     | <span class='neutral'>//    as</span>
  402 |     | <span class='neutral'>//</span>
  403 |     | <span class='neutral'>//               l - 2</span>
  404 |     | <span class='neutral'>//               -----</span>
  405 |     | <span class='neutral'>//               \</span>
  406 |     | <span class='neutral'>//      &#39;w(q) := /     w_i(q).</span>
  407 |     | <span class='neutral'>//               -----</span>
  408 |     | <span class='neutral'>//               i = 0</span>
  409 |     | <span class='neutral'>//</span>
  410 |     | <span class='neutral'>//    This function will be used to determine the distribution of liquidity</span>
  411 |     | <span class='neutral'>//    within the active interval &#39;[qLower, qUpper]&#39;. As we will discuss later</span>
  412 |     | <span class='neutral'>//    in this script, the distribution of liquidity is modified with every swap</span>
  413 |     | <span class='neutral'>//    via amendments to the curve sequence and this process ensures liquidity</span>
  414 |     | <span class='neutral'>//    growth for the LPs without the need to charge fees.</span>
  415 |     | <span class='neutral'>//</span>
  416 |     | <span class='neutral'>//    For example, let</span>
  417 |     | <span class='neutral'>//</span>
  418 |     | <span class='neutral'>//      &#39;q[0] := qUpper&#39;</span>
  419 |     | <span class='neutral'>//      &#39;q[1] := qLower&#39;</span>
  420 |     | <span class='neutral'>//      &#39;q[2]&#39;</span>
  421 |     | <span class='neutral'>//      &#39;q[3] := qCurrent&#39;</span>
  422 |     | <span class='neutral'>//</span>
  423 |     | <span class='neutral'>//    represent the curve sequence. Then,</span>
  424 |     | <span class='neutral'>//</span>
  425 |     | <span class='neutral'>//      &#39;w(q) := w_0(q) + w_1(q) + w_2(q)&#39;</span>
  426 |     | <span class='neutral'>//</span>
  427 |     | <span class='neutral'>//    can be plotted as follows:</span>
  428 |     | <span class='neutral'>//</span>
  429 |     | <span class='neutral'>//            w(q)</span>
  430 |     | <span class='neutral'>//              ^</span>
  431 |     | <span class='neutral'>//      spacing |                /</span>
  432 |     | <span class='neutral'>//              |               /</span>
  433 |     | <span class='neutral'>//              |              /</span>
  434 |     | <span class='neutral'>//              |             /</span>
  435 |     | <span class='neutral'>//              |            /</span>
  436 |     | <span class='neutral'>//              |           /</span>
  437 |     | <span class='neutral'>//              |          /</span>
  438 |     | <span class='neutral'>//              |\</span>
  439 |     | <span class='neutral'>//              | \</span>
  440 |     | <span class='neutral'>//              |  \</span>
  441 |     | <span class='neutral'>//              |   \</span>
  442 |     | <span class='neutral'>//              |        /</span>
  443 |     | <span class='neutral'>//              |       /</span>
  444 |     | <span class='neutral'>//              |      /</span>
  445 |     | <span class='neutral'>//              |     /</span>
  446 |     | <span class='neutral'>//            0 +----+----+-------+-&gt; q</span>
  447 |     | <span class='neutral'>//           qLower  |    |       |</span>
  448 |     | <span class='neutral'>//                   |   q[2]   qUpper</span>
  449 |     | <span class='neutral'>//                   |</span>
  450 |     | <span class='neutral'>//               qCurrent</span>
  451 |     | <span class='neutral'>//    </span>
  452 |     | <span class='neutral'>//    To summarize, reading the curve sequence from the protocol&#39;s storage</span>
  453 |     | <span class='neutral'>//    gives us access to &#39;qLower&#39;, &#39;qUpper&#39; and the function &#39;w&#39;.</span>
  454 |     | <span class='neutral'>//</span>
  455 |     | <span class='neutral'>//    The curve sequence is defined for every inactive liquidity interval as</span>
  456 |     | <span class='neutral'>//    well, although we do not need to keep track of them. For every integer</span>
  457 |     | <span class='neutral'>//    &#39;j &gt; 0&#39;, the curve sequence associated with the interval:</span>
  458 |     | <span class='neutral'>//</span>
  459 |     | <span class='neutral'>//      &#39;[qLower + j * qSpacing, qUpper + j * qSpacing]&#39;</span>
  460 |     | <span class='neutral'>//</span>
  461 |     | <span class='neutral'>//    is composed of only two members:</span>
  462 |     | <span class='neutral'>//</span>
  463 |     | <span class='neutral'>//      &#39;q[0] := qUpper + j * qSpacing&#39; </span>
  464 |     | <span class='neutral'>//      &#39;q[1] := qLower + j * qSpacing&#39;. </span>
  465 |     | <span class='neutral'>//</span>
  466 |     | <span class='neutral'>//    Hence, the function</span>
  467 |     | <span class='neutral'>//</span>
  468 |     | <span class='neutral'>//      &#39;w : [qLower + j * qSpacing, qUpper + j * qSpacing] -&gt; [0, qSpacing]&#39;</span>
  469 |     | <span class='neutral'>//</span>
  470 |     | <span class='neutral'>//    corresponding to that interval is defined as:</span>
  471 |     | <span class='neutral'>//</span>
  472 |     | <span class='neutral'>//      &#39;w(q) := q - qLower - j * qSpacing&#39;</span>
  473 |     | <span class='neutral'>//</span>
  474 |     | <span class='neutral'>//    which is consistent with the prior definition of &#39;w&#39; for the active</span>
  475 |     | <span class='neutral'>//    interval. Additionally, for every integer &#39;j &lt; 0&#39;, the curve sequence</span>
  476 |     | <span class='neutral'>//    associated with the interval:</span>
  477 |     | <span class='neutral'>//</span>
  478 |     | <span class='neutral'>//      &#39;[qLower + j * qSpacing, qUpper + j * qSpacing]&#39;</span>
  479 |     | <span class='neutral'>//</span>
  480 |     | <span class='neutral'>//    is composed of only two members:</span>
  481 |     | <span class='neutral'>//</span>
  482 |     | <span class='neutral'>//      &#39;q[0] := qLower + j * qSpacing&#39; </span>
  483 |     | <span class='neutral'>//      &#39;q[1] := qUpper + j * qSpacing&#39;. </span>
  484 |     | <span class='neutral'>//</span>
  485 |     | <span class='neutral'>//    Hence, the function</span>
  486 |     | <span class='neutral'>//</span>
  487 |     | <span class='neutral'>//      &#39;w : [qLower + j * qSpacing, qUpper + j * qSpacing] -&gt; [0, qSpacing]&#39;</span>
  488 |     | <span class='neutral'>//</span>
  489 |     | <span class='neutral'>//    corresponding to that interval is defined as:</span>
  490 |     | <span class='neutral'>//</span>
  491 |     | <span class='neutral'>//      &#39;w(q) := qUpper + j * qSpacing - q&#39;</span>
  492 |     | <span class='neutral'>//    </span>
  493 |     | <span class='neutral'>//    which is also consistent with our prior definition.</span>
  494 |     | <span class='neutral'>//</span>
  495 |     | <span class='neutral'>//    After reading the curve sequence for the active interval, we store</span>
  496 |     | <span class='neutral'>//    &#39;qBack&#39; and &#39;qNext&#39; in their dedicated memory spaces in order to keep</span>
  497 |     | <span class='neutral'>//    track of the boundaries of the active liquidity interval. In the present</span>
  498 |     | <span class='neutral'>//    example, since the swap is price decreasing, the initial values for</span>
  499 |     | <span class='neutral'>//    &#39;qBack&#39; and &#39;qNext&#39; are as follows:</span>
  500 |     | <span class='neutral'>//</span>
  501 |     | <span class='neutral'>//      &#39;qBack := qUpper&#39;,</span>
  502 |     | <span class='neutral'>//      &#39;qNext := qLower&#39;.</span>
  503 |     | <span class='neutral'>//</span>
  504 |     | <span class='neutral'>//    For price increasing swaps, these initial values are</span>
  505 |     | <span class='neutral'>//</span>
  506 |     | <span class='neutral'>//      &#39;qBack := qLower&#39;,</span>
  507 |     | <span class='neutral'>//      &#39;qNext := qUpper&#39;.</span>
  508 |     | <span class='neutral'>//</span>
  509 |     | <span class='neutral'>//    As discussed before, &#39;qBack&#39; and &#39;qNext&#39; are continuously updated</span>
  510 |     | <span class='neutral'>//    throughout the execution of a swap as we transition to new liquidity</span>
  511 |     | <span class='neutral'>//    intervals.</span>
  512 |     | <span class='neutral'>//</span>
  513 |     | <span class='neutral'>//  - Next, the kernel function is read from the storage smart contract&#39;s</span>
  514 |     | <span class='neutral'>//    bytecode. To this end, the dynamic parameter &#39;staticParamsStoragePointer&#39;</span>
  515 |     | <span class='neutral'>//    is used to calculate the address to the storage smart contract associated</span>
  516 |     | <span class='neutral'>//    with the pool whose bytecode contains the kernel function. The kernel,</span>
  517 |     | <span class='neutral'>//    denoted by</span>
  518 |     | <span class='neutral'>//</span>
  519 |     | <span class='neutral'>//      &#39;k : [0, qSpacing] -&gt; [0, 1]&#39;,</span>
  520 |     | <span class='neutral'>//</span>
  521 |     | <span class='neutral'>//    is a monotonically non-decreasing piecewise linear function which is</span>
  522 |     | <span class='neutral'>//    characterized via a list of breakpoints. Each breakpoint has a horizontal</span>
  523 |     | <span class='neutral'>//    coordinate as well as a vertical coordinate. Consider the following</span>
  524 |     | <span class='neutral'>//    examples:</span>
  525 |     | <span class='neutral'>//</span>
  526 |     | <span class='neutral'>//      - The sequence of breakpoints</span>
  527 |     | <span class='neutral'>//</span>
  528 |     | <span class='neutral'>//          &#39;(0, 0), (qSpacing, 1)&#39;</span>
  529 |     | <span class='neutral'>//</span>
  530 |     | <span class='neutral'>//        implies that the diagram of &#39;k&#39; is a single segment connecting the</span>
  531 |     | <span class='neutral'>//        point &#39;(0, 0)&#39; to the point &#39;(qSpacing, 1)&#39;. This leads to the kernel</span>
  532 |     | <span class='neutral'>//        function:</span>
  533 |     | <span class='neutral'>//</span>
  534 |     | <span class='neutral'>//          &#39;k(h) := h / qSpacing&#39;.</span>
  535 |     | <span class='neutral'>//</span>
  536 |     | <span class='neutral'>//      - The sequence of breakpoints</span>
  537 |     | <span class='neutral'>//</span>
  538 |     | <span class='neutral'>//          &#39;(0, 0), (qSpacing / 2, 1), (qSpacing, 1)&#39;</span>
  539 |     | <span class='neutral'>//</span>
  540 |     | <span class='neutral'>//        implies that the diagram of &#39;k&#39; is composed of two segments:</span>
  541 |     | <span class='neutral'>//</span>
  542 |     | <span class='neutral'>//          - The first segment connects the point &#39;(0, 0)&#39; to the point</span>
  543 |     | <span class='neutral'>//            &#39;(qSpacing / 2, 1)&#39;.</span>
  544 |     | <span class='neutral'>//</span>
  545 |     | <span class='neutral'>//          - The second segment connects the point &#39;(qSpacing / 2, 1)&#39; to the</span>
  546 |     | <span class='neutral'>//            point &#39;(qSpacing, 1)&#39;.</span>
  547 |     | <span class='neutral'>//</span>
  548 |     | <span class='neutral'>//        The combination of the two segments leads to the kernel function:</span>
  549 |     | <span class='neutral'>//</span>
  550 |     | <span class='neutral'>//                    /</span>
  551 |     | <span class='neutral'>//                   |  2 * h / qSpacing    if 0 &lt; q &lt; qSpacing / 2</span>
  552 |     | <span class='neutral'>//          &#39;k(h) := |                                                      &#39;.</span>
  553 |     | <span class='neutral'>//                   |  1                   if qSpacing / 2 &lt; q &lt; qSpacing</span>
  554 |     | <span class='neutral'>//                    \</span>
  555 |     | <span class='neutral'>//</span>
  556 |     | <span class='neutral'>//      - The sequence of breakpoints</span>
  557 |     | <span class='neutral'>//</span>
  558 |     | <span class='neutral'>//          &#39;(0, 0), (qSpacing / 2, 0), (qSpacing / 2, 1 / 2), (qSpacing, 1)&#39;</span>
  559 |     | <span class='neutral'>//</span>
  560 |     | <span class='neutral'>//        implies that the diagram of &#39;k&#39; is composed of three segments:</span>
  561 |     | <span class='neutral'>//</span>
  562 |     | <span class='neutral'>//          - The first segment belongs to the horizontal axis connecting the</span>
  563 |     | <span class='neutral'>//            point &#39;(0, 0)&#39; to the point &#39;(qSpacing / 2, 0)&#39;.</span>
  564 |     | <span class='neutral'>//</span>
  565 |     | <span class='neutral'>//          - The second segment is vertical, connecting the point</span>
  566 |     | <span class='neutral'>//            &#39;(qSpacing / 2, 0)&#39; to the point &#39;(qSpacing / 2, 1 / 2)&#39;. A</span>
  567 |     | <span class='neutral'>//            vertical segment (i.e., two consecutive breakpoints with equal</span>
  568 |     | <span class='neutral'>//            horizontal coordinates) indicates that the kernel function is</span>
  569 |     | <span class='neutral'>//            discontinuous which is permitted by the protocol. In this case,</span>
  570 |     | <span class='neutral'>//            we have a discontinuity at point &#39;qSpacing / 2&#39; because:</span>
  571 |     | <span class='neutral'>//            </span>
  572 |     | <span class='neutral'>//              &#39;0 == k(qSpacing / 2 - epsilon) != </span>
  573 |     | <span class='neutral'>//                    k(qSpacing / 2 + epsilon) == 1 / 2 + epsilon / qSpacing&#39;</span>
  574 |     | <span class='neutral'>//            </span>
  575 |     | <span class='neutral'>//            where &#39;epsilon &gt; 0&#39; is an arbitrarily small value approaching 0.</span>
  576 |     | <span class='neutral'>//</span>
  577 |     | <span class='neutral'>//          - The third segment connects the point &#39;(qSpacing / 2, 1 / 2)&#39; to</span>
  578 |     | <span class='neutral'>//            the point &#39;(qSpacing, 1)&#39;.</span>
  579 |     | <span class='neutral'>//</span>
  580 |     | <span class='neutral'>//        The combination of the three segments leads to the kernel function:</span>
  581 |     | <span class='neutral'>//</span>
  582 |     | <span class='neutral'>//                    /</span>
  583 |     | <span class='neutral'>//                   |  0               if 0 &lt; q &lt; qSpacing / 2</span>
  584 |     | <span class='neutral'>//          &#39;k(h) := |                                                  &#39;.</span>
  585 |     | <span class='neutral'>//                   |  h / qSpacing    if qSpacing / 2 &lt; q &lt; qSpacing</span>
  586 |     | <span class='neutral'>//                    \</span>
  587 |     | <span class='neutral'>//    </span>
  588 |     | <span class='neutral'>//    Hence, reading the kernel breakpoints from the storage smart contract</span>
  589 |     | <span class='neutral'>//    gives us access to the function &#39;k&#39;.</span>
  590 |     | <span class='neutral'>//    </span>
  591 |     | <span class='neutral'>//    Define</span>
  592 |     | <span class='neutral'>//</span>
  593 |     | <span class='neutral'>//      &#39;k(w(.)) : [qLower, qUpper] -&gt; [0, 1]&#39;</span>
  594 |     | <span class='neutral'>//</span>
  595 |     | <span class='neutral'>//    as the liquidity distribution function. As we will demonstrate next, one</span>
  596 |     | <span class='neutral'>//    can determine the outgoing amount from the pool and the incoming amount</span>
  597 |     | <span class='neutral'>//    to the pool by integrating the liquidity distribution function. More</span>
  598 |     | <span class='neutral'>//    precisely, consider a swap that involves a movement of price from</span>
  599 |     | <span class='neutral'>//    &#39;qCurrent&#39; to</span>
  600 |     | <span class='neutral'>//</span>
  601 |     | <span class='neutral'>//      &#39;qTarget := log(pTarget / pOffset)&#39;</span>
  602 |     | <span class='neutral'>//</span>
  603 |     | <span class='neutral'>//    within the same active liquidity interval, i.e.,</span>
  604 |     | <span class='neutral'>//</span>
  605 |     | <span class='neutral'>//      &#39;qLower &lt;= qTarget &lt;= qUpper&#39;.</span>
  606 |     | <span class='neutral'>//</span>
  607 |     | <span class='neutral'>//    If &#39;qCurrent &lt; qTarget, then the outgoing amount of &#39;tag0&#39; as a result of</span>
  608 |     | <span class='neutral'>//    this movement is proportional to the following integration of the</span>
  609 |     | <span class='neutral'>//    liquidity distribution function:</span>
  610 |     | <span class='neutral'>//</span>
  611 |     | <span class='neutral'>//                               - 8     / qTarget</span>
  612 |     | <span class='neutral'>//        currentToTarget      e        |    - h / 2</span>
  613 |     | <span class='neutral'>//      &#39;----------------- := ------- * |  e         k(w(h)) dh&#39;.</span>
  614 |     | <span class='neutral'>//           2 ** 216            2      |</span>
  615 |     | <span class='neutral'>//                                     / qCurrent</span>
  616 |     | <span class='neutral'>//</span>
  617 |     | <span class='neutral'>//    In this case, the incoming amount of &#39;tag1&#39; as a result of this movement</span>
  618 |     | <span class='neutral'>//    is proportional to the following integration of the liquidity</span>
  619 |     | <span class='neutral'>//    distribution function:</span>
  620 |     | <span class='neutral'>//</span>
  621 |     | <span class='neutral'>//                                       - 8     / qTarget</span>
  622 |     | <span class='neutral'>//        incomingCurrentToTarget      e        |    + h / 2</span>
  623 |     | <span class='neutral'>//      &#39;------------------------- := ------- * |  e         k(w(h)) dh&#39;.</span>
  624 |     | <span class='neutral'>//               2 ** 216                2      |</span>
  625 |     | <span class='neutral'>//                                             / qCurrent</span>
  626 |     | <span class='neutral'>//</span>
  627 |     | <span class='neutral'>//    On the other hand, if &#39;qTarget &lt; qCurrent&#39;, then the outgoing amount of</span>
  628 |     | <span class='neutral'>//    &#39;tag1&#39; and the incoming amount of &#39;tag0&#39;, respectively, are proportional</span>
  629 |     | <span class='neutral'>//    to the following integrations of the liquidity distribution function:</span>
  630 |     | <span class='neutral'>//</span>
  631 |     | <span class='neutral'>//                               - 8     / qCurrent</span>
  632 |     | <span class='neutral'>//        currentToTarget      e        |    + h / 2</span>
  633 |     | <span class='neutral'>//      &#39;----------------- := ------- * |  e         k(w(h)) dh&#39;,</span>
  634 |     | <span class='neutral'>//           2 ** 216            2      |</span>
  635 |     | <span class='neutral'>//                                     / qTarget</span>
  636 |     | <span class='neutral'>//</span>
  637 |     | <span class='neutral'>//                                       - 8     / qCurrent</span>
  638 |     | <span class='neutral'>//        incomingCurrentToTarget      e        |    - h / 2</span>
  639 |     | <span class='neutral'>//      &#39;------------------------- := ------- * |  e         k(w(h)) dh&#39;.</span>
  640 |     | <span class='neutral'>//                2 ** 216               2      |</span>
  641 |     | <span class='neutral'>//                                             / qTarget</span>
  642 |     | <span class='neutral'>//</span>
  643 |     | <span class='neutral'>//    Now, imagine a scenario where we want to move all the way from &#39;qCurrent&#39;</span>
  644 |     | <span class='neutral'>//    to &#39;qUpper&#39; which is a price increasing swap. Hence, in this case, the</span>
  645 |     | <span class='neutral'>//    outgoing amount of &#39;tag0&#39; is proportional to:</span>
  646 |     | <span class='neutral'>//</span>
  647 |     | <span class='neutral'>//                         - 8     / qUpper</span>
  648 |     | <span class='neutral'>//        integral0      e        |    - h / 2</span>
  649 |     | <span class='neutral'>//      &#39;----------- := ------- * |  e         k(w(h)) dh&#39;.</span>
  650 |     | <span class='neutral'>//        2 ** 216         2      |</span>
  651 |     | <span class='neutral'>//                               / qCurrent</span>
  652 |     | <span class='neutral'>//</span>
  653 |     | <span class='neutral'>//    Observe that moving from &#39;qCurrent&#39; to &#39;qUpper&#39; depletes the entire</span>
  654 |     | <span class='neutral'>//    reserve of &#39;tag0&#39;, within the interval &#39;[qLower, qUpper]&#39; (because we</span>
  655 |     | <span class='neutral'>//    cannot go further than that without transitioning to a new interval).</span>
  656 |     | <span class='neutral'>//    Hence, the total reserve of &#39;tag0&#39; within the interval &#39;[qLower, qUpper]&#39;</span>
  657 |     | <span class='neutral'>//    is proportional to &#39;integral0&#39; which is given by the above formula.</span>
  658 |     | <span class='neutral'>//</span>
  659 |     | <span class='neutral'>//    Similarly, imagine a scenario where we want to move all the way from</span>
  660 |     | <span class='neutral'>//    &#39;qCurrent&#39; to &#39;qLower&#39; which is a price decreasing swap. Hence, in this</span>
  661 |     | <span class='neutral'>//    case, the outgoing amount of &#39;tag1&#39; is proportional to:</span>
  662 |     | <span class='neutral'>//</span>
  663 |     | <span class='neutral'>//                         - 8     / qCurrent</span>
  664 |     | <span class='neutral'>//        integral1      e        |    + h / 2</span>
  665 |     | <span class='neutral'>//      &#39;----------- := ------- * |  e         k(w(h)) dh&#39;,</span>
  666 |     | <span class='neutral'>//        2 ** 216         2      |</span>
  667 |     | <span class='neutral'>//                               / qLower</span>
  668 |     | <span class='neutral'>//</span>
  669 |     | <span class='neutral'>//    Observe that moving from &#39;qCurrent&#39; to &#39;qLower&#39; depletes the entire</span>
  670 |     | <span class='neutral'>//    reserve of &#39;tag1&#39;, within the interval &#39;[qLower, qUpper]&#39; (because we</span>
  671 |     | <span class='neutral'>//    cannot go further than that without transitioning to a new interval).</span>
  672 |     | <span class='neutral'>//    Hence, the total reserve of &#39;tag1&#39; within the interval &#39;[qLower, qUpper]&#39;</span>
  673 |     | <span class='neutral'>//    is proportional to &#39;integral1&#39; which is given by the above formula.</span>
  674 |     | <span class='neutral'>//</span>
  675 |     | <span class='neutral'>//    The values &#39;integral0&#39; and &#39;integral1&#39; are stored among the dynamic</span>
  676 |     | <span class='neutral'>//    parameters. This is because storing and updating them with every swap is</span>
  677 |     | <span class='neutral'>//    more gas efficient than recalculating them.</span>
  678 |     | <span class='neutral'>//</span>
  679 |     | <span class='neutral'>//    To summarize, in order to execute a swap,</span>
  680 |     | <span class='neutral'>//</span>
  681 |     | <span class='neutral'>//      - the function &#39;w&#39; is formed by reading the members of the curve</span>
  682 |     | <span class='neutral'>//        sequence from the protocol&#39;s storage,</span>
  683 |     | <span class='neutral'>//   </span>
  684 |     | <span class='neutral'>//      - the kernel function &#39;k&#39; is formed by reading its breakpoints from the</span>
  685 |     | <span class='neutral'>//        pool&#39;s storage smart contract, and</span>
  686 |     | <span class='neutral'>//</span>
  687 |     | <span class='neutral'>//      - the outgoing amount from the pool and the incoming amount to the pool</span>
  688 |     | <span class='neutral'>//        are determined by integrating the liquidity distribution function</span>
  689 |     | <span class='neutral'>//        &#39;k(w(.))&#39;.</span>
  690 |     | <span class='neutral'>//</span>
  691 |     | <span class='neutral'>//    An alternative way to look at the notion of liquidity distribution is to</span>
  692 |     | <span class='neutral'>//    imagine a traditional automated market making (AMM) diagram as</span>
  693 |     | <span class='neutral'>//    illustrated below:</span>
  694 |     | <span class='neutral'>//</span>
  695 |     | <span class='neutral'>//                tag1   pUpper</span>
  696 |     | <span class='neutral'>//                  ^   /</span>
  697 |     | <span class='neutral'>//                  |  /</span>
  698 |     | <span class='neutral'>//                  | /</span>
  699 |     | <span class='neutral'>//                  *</span>
  700 |     | <span class='neutral'>//                  |.</span>
  701 |     | <span class='neutral'>//                  | .</span>
  702 |     | <span class='neutral'>//                  |  .    </span>
  703 |     | <span class='neutral'>//                  |   .           pCurrent</span>
  704 |     | <span class='neutral'>//                  |     .        /</span>
  705 |     | <span class='neutral'>//                  |       .     /</span>
  706 |     | <span class='neutral'>//                  |         .  /           pTarget</span>
  707 |     | <span class='neutral'>//        integral1 + - - - - - *           /</span>
  708 |     | <span class='neutral'>//                  |           |  .       /         pLower</span>
  709 |     | <span class='neutral'>//                  |           |     .   /         /</span>
  710 |     | <span class='neutral'>//                  |           |        *         /</span>
  711 |     | <span class='neutral'>//                  |           |            .    /</span>
  712 |     | <span class='neutral'>//                  +-----------+----------------*----&gt; tag0</span>
  713 |     | <span class='neutral'>//                              |</span>
  714 |     | <span class='neutral'>//                          integral0 </span>
  715 |     | <span class='neutral'>//</span>
  716 |     | <span class='neutral'>//    where the horizontal and vertical coordinates, respectively, correspond</span>
  717 |     | <span class='neutral'>//    to the reserves of &#39;tag0&#39; and &#39;tag1&#39;, in the active liquidity interval.</span>
  718 |     | <span class='neutral'>//</span>
  719 |     | <span class='neutral'>//    Remember that the current reserve of &#39;tag0&#39; in &#39;[qLower, qUpper]&#39; is</span>
  720 |     | <span class='neutral'>//    proportional to &#39;integral0&#39; and the current reserve of &#39;tag1&#39; in the same</span>
  721 |     | <span class='neutral'>//    interval is proportional to &#39;integral1&#39;. Because of this, the point</span>
  722 |     | <span class='neutral'>//    &#39;(integral0, integral1)&#39; in the above diagram is indicated as &#39;pCurrent&#39;</span>
  723 |     | <span class='neutral'>//    which is the current price of the pool. As a result, &#39;0 - pCurrent&#39; is</span>
  724 |     | <span class='neutral'>//    equal to the slope of the diagram at the point &#39;(integral0, integral1)&#39;.</span>
  725 |     | <span class='neutral'>//    </span>
  726 |     | <span class='neutral'>//    A swapper is permitted to move to any point that belongs to the above</span>
  727 |     | <span class='neutral'>//    diagram by giving or taking appropriate amounts of &#39;tag0&#39; and &#39;tag1&#39;.</span>
  728 |     | <span class='neutral'>//    When a swapper moves on the above diagram we calculate the outgoing and</span>
  729 |     | <span class='neutral'>//    incoming amounts of &#39;tag0&#39; and &#39;tag1&#39; by computing the two integrals</span>
  730 |     | <span class='neutral'>//    &#39;currentToTarget&#39; and &#39;incomingCurrentToTarget&#39;. In short, the shape of</span>
  731 |     | <span class='neutral'>//    the above diagram is determined by the liquidity distribution function</span>
  732 |     | <span class='neutral'>//    &#39;k(w(.))&#39;.</span>
  733 |     | <span class='neutral'>//</span>
  734 |     | <span class='neutral'>//    As we will discuss later in this script, after a movement to &#39;pTarget&#39;,</span>
  735 |     | <span class='neutral'>//    the curve sequence is amended in preparation for the next swap which</span>
  736 |     | <span class='neutral'>//    renders a different liquidity distribution function. Such amendment also</span>
  737 |     | <span class='neutral'>//    leads to a new AMM diagram with the following properties:</span>
  738 |     | <span class='neutral'>//</span>
  739 |     | <span class='neutral'>//    - The new diagram intersects with the old one at the point &#39;pTarget&#39;.</span>
  740 |     | <span class='neutral'>//      This is due to the conservation of interval reserves.</span>
  741 |     | <span class='neutral'>//</span>
  742 |     | <span class='neutral'>//    - The new diagram is tangent to the old one at point &#39;pTarget&#39;. This is</span>
  743 |     | <span class='neutral'>//      because our transition to a new AMM diagram should not change the price</span>
  744 |     | <span class='neutral'>//      of the pool, i.e., the slopes of the new diagrams should be the same as</span>
  745 |     | <span class='neutral'>//      the old diagrams at the intersection point which means that the two are</span>
  746 |     | <span class='neutral'>//      tangent.</span>
  747 |     | <span class='neutral'>//</span>
  748 |     | <span class='neutral'>//    The proposed structure for the kernel function enables the pool creators</span>
  749 |     | <span class='neutral'>//    to build custom AMM diagrams. Additionally, the proposed structure for</span>
  750 |     | <span class='neutral'>//    the curve sequence allows the protocol to keep track of AMM diagrams,</span>
  751 |     | <span class='neutral'>//    efficiently. In other words, the curve sequence and the kernel function</span>
  752 |     | <span class='neutral'>//    provide us with an efficient method to store the geometry of AMM diagrams</span>
  753 |     | <span class='neutral'>//    and to transform them into new ones.</span>
  754 |     | <span class='neutral'>//</span>
  755 |     | <span class='neutral'>//    Now, in order to derive the outgoing and incoming amounts from the</span>
  756 |     | <span class='neutral'>//    integral values &#39;currentToTarget&#39; and &#39;incomingCurrentToTarget&#39; we need</span>
  757 |     | <span class='neutral'>//    to access the static parameters that are explained next.</span>
  758 |     | <span class='neutral'>//</span>
  759 |     | <span class='neutral'>//  - The static parameters of the pool are read from the same storage smart </span>
  760 |     | <span class='neutral'>//    contract whose address is calculated using the dynamic parameter</span>
  761 |     | <span class='neutral'>//    &#39;staticParamsStoragePointer&#39;. This includes the following parameters:</span>
  762 |     | <span class='neutral'>//</span>
  763 |     | <span class='neutral'>//    - &#39;sqrtOffset&#39;: This is the square root of &#39;pOffset&#39; in &#39;X127&#39;</span>
  764 |     | <span class='neutral'>//      representation, i.e.,</span>
  765 |     | <span class='neutral'>//</span>
  766 |     | <span class='neutral'>//        &#39;sqrtOffset := (2 ** 127) * sqrt(pOffset)&#39;.</span>
  767 |     | <span class='neutral'>//</span>
  768 |     | <span class='neutral'>//      This value is used frequently for calculating any amount of &#39;tag1&#39;.</span>
  769 |     | <span class='neutral'>//      Because of this, we calculate it at the time of initialization and</span>
  770 |     | <span class='neutral'>//      store it among the static parameters.</span>
  771 |     | <span class='neutral'>//</span>
  772 |     | <span class='neutral'>//    - &#39;sqrtInverseOffset&#39;: This is the square root of &#39;1 / pOffset&#39; in &#39;X127&#39;</span>
  773 |     | <span class='neutral'>//      representation, i.e.,</span>
  774 |     | <span class='neutral'>//</span>
  775 |     | <span class='neutral'>//        &#39;sqrtInverseOffset := (2 ** 127) / sqrt(pOffset)&#39;</span>
  776 |     | <span class='neutral'>//</span>
  777 |     | <span class='neutral'>//      This value is used frequently for calculating any amount of &#39;tag0&#39;.</span>
  778 |     | <span class='neutral'>//      Because of this, we calculate it at the time of initialization and</span>
  779 |     | <span class='neutral'>//      store it among the static parameters.</span>
  780 |     | <span class='neutral'>//</span>
  781 |     | <span class='neutral'>//    - &#39;outgoingMax&#39;: This value is a kernel parameter in &#39;X216&#39;</span>
  782 |     | <span class='neutral'>//      representation which is defined as follows:</span>
  783 |     | <span class='neutral'>//</span>
  784 |     | <span class='neutral'>//                             - 8     / qSpacing</span>
  785 |     | <span class='neutral'>//          outgoingMax      e        |    - h / 2</span>
  786 |     | <span class='neutral'>//        &#39;------------- := ------- * |  e         k(h) dh&#39;.</span>
  787 |     | <span class='neutral'>//           2 ** 216          2      |</span>
  788 |     | <span class='neutral'>//                                   / 0</span>
  789 |     | <span class='neutral'>//</span>
  790 |     | <span class='neutral'>//      &#39;outgoingMax&#39; is used frequently for calculating any amount of &#39;tag0&#39;</span>
  791 |     | <span class='neutral'>//      and &#39;tag1&#39;. Because of this, we calculate &#39;outgoingMax&#39; and its modular</span>
  792 |     | <span class='neutral'>//      inverse at the time of initialization or anytime that the kernel</span>
  793 |     | <span class='neutral'>//      function is modified and then we store the resulting values among the</span>
  794 |     | <span class='neutral'>//      static parameters.</span>
  795 |     | <span class='neutral'>//</span>
  796 |     | <span class='neutral'>//      Now, we have all of the parameters that are needed to calculate the</span>
  797 |     | <span class='neutral'>//      outgoing amount from the pool and the incoming amount to the pool as</span>
  798 |     | <span class='neutral'>//      long as we remain within the current active liquidity interval.</span>
  799 |     | <span class='neutral'>//</span>
  800 |     | <span class='neutral'>//      For a price increasing swap we have:</span>
  801 |     | <span class='neutral'>//                                                               growth</span>
  802 |     | <span class='neutral'>//        &#39;amount0Partial := sqrtInverseOffset * sharesTotal * ---------- * </span>
  803 |     | <span class='neutral'>//                                                              2 ** 111</span>
  804 |     | <span class='neutral'>//                            currentToTarget</span>
  805 |     | <span class='neutral'>//                           -----------------&#39;,</span>
  806 |     | <span class='neutral'>//                              outgoingMax</span>
  807 |     | <span class='neutral'>//                                                        growth</span>
  808 |     | <span class='neutral'>//        &#39;amount1Partial := sqrtOffset * sharesTotal * ---------- * </span>
  809 |     | <span class='neutral'>//                                                       2 ** 111</span>
  810 |     | <span class='neutral'>//                            incomingCurrentToTarget</span>
  811 |     | <span class='neutral'>//                           -------------------------&#39;,</span>
  812 |     | <span class='neutral'>//                                  outgoingMax</span>
  813 |     | <span class='neutral'>//</span>
  814 |     | <span class='neutral'>//      where &#39;amount0Partial&#39; denotes the amount of outgoing &#39;tag0&#39; from the</span>
  815 |     | <span class='neutral'>//      pool and &#39;amount1Partial&#39; denotes the amount of incoming &#39;tag1&#39; to the</span>
  816 |     | <span class='neutral'>//      pool, as a result of swapping within the active liquidity interval,</span>
  817 |     | <span class='neutral'>//      where both of the amounts are in &#39;X127&#39; representation.</span>
  818 |     | <span class='neutral'>//</span>
  819 |     | <span class='neutral'>//      Similarly, for a price decreasing swap we have:</span>
  820 |     | <span class='neutral'>//                                                               growth</span>
  821 |     | <span class='neutral'>//        &#39;amount0Partial := sqrtInverseOffset * sharesTotal * ---------- * </span>
  822 |     | <span class='neutral'>//                                                              2 ** 111</span>
  823 |     | <span class='neutral'>//                            incomingCurrentToTarget</span>
  824 |     | <span class='neutral'>//                           -------------------------&#39;,</span>
  825 |     | <span class='neutral'>//                                  outgoingMax</span>
  826 |     | <span class='neutral'>//                                                        growth</span>
  827 |     | <span class='neutral'>//        &#39;amount1Partial := sqrtOffset * sharesTotal * ---------- * </span>
  828 |     | <span class='neutral'>//                                                       2 ** 111</span>
  829 |     | <span class='neutral'>//                            currentToTarget</span>
  830 |     | <span class='neutral'>//                           -----------------&#39;,</span>
  831 |     | <span class='neutral'>//                              outgoingMax</span>
  832 |     | <span class='neutral'>//</span>
  833 |     | <span class='neutral'>//      where &#39;amount0Partial&#39; denotes the amount of incoming &#39;tag0&#39; to the</span>
  834 |     | <span class='neutral'>//      pool and &#39;amount1Partial&#39; denotes the amount of outgoing &#39;tag1&#39; from</span>
  835 |     | <span class='neutral'>//      the pool, as a result of swapping within the active liquidity interval,</span>
  836 |     | <span class='neutral'>//      where both of the amounts are in &#39;X127&#39; representation.</span>
  837 |     | <span class='neutral'>//</span>
  838 |     | <span class='neutral'>//    - &#39;incomingMax&#39;: This value is a kernel parameter in &#39;X216&#39;</span>
  839 |     | <span class='neutral'>//      representation which is defined as follows:</span>
  840 |     | <span class='neutral'>//</span>
  841 |     | <span class='neutral'>//                             - 8 - qSpacing / 2     / qSpacing</span>
  842 |     | <span class='neutral'>//          incomingMax      e                       |    + h / 2</span>
  843 |     | <span class='neutral'>//        &#39;------------- := ---------------------- * |  e         k(h) dh&#39;.</span>
  844 |     | <span class='neutral'>//           2 ** 216                  2             |</span>
  845 |     | <span class='neutral'>//                                                  / 0</span>
  846 |     | <span class='neutral'>//</span>
  847 |     | <span class='neutral'>//      Consider a scenario where the price of the pool is moved all the way</span>
  848 |     | <span class='neutral'>//      from the left interval boundary &#39;qLower&#39;, to the right interval</span>
  849 |     | <span class='neutral'>//      boundary &#39;qUpper&#39;, as part of a swap. In this case, let </span>
  850 |     | <span class='neutral'>//      &#39;amount0Partial&#39; denote the amount of outgoing &#39;tag0&#39; from the pool and</span>
  851 |     | <span class='neutral'>//      let &#39;amount1Partial&#39; denote the amount of incoming &#39;tag1&#39; to the pool,</span>
  852 |     | <span class='neutral'>//      as a result of swapping within the entire interval, &#39;[qLower, qUpper]&#39;</span>
  853 |     | <span class='neutral'>//      where both of the amounts are in &#39;X127&#39; representation. Then, we have:</span>
  854 |     | <span class='neutral'>//</span>
  855 |     | <span class='neutral'>//        &#39;amount0Partial ==</span>
  856 |     | <span class='neutral'>//                                             growth</span>
  857 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * ---------- *</span>
  858 |     | <span class='neutral'>//                                            2 ** 111</span>
  859 |     | <span class='neutral'>//</span>
  860 |     | <span class='neutral'>//                            - 8     / qUpper</span>
  861 |     | <span class='neutral'>//           2 ** 216       e        |                     - h / 2</span>
  862 |     | <span class='neutral'>//         ------------- * ------- * |   k(h - qLower) * e         dh ==</span>
  863 |     | <span class='neutral'>//          outgoingMax       2      |</span>
  864 |     | <span class='neutral'>//                                  / qLower</span>
  865 |     | <span class='neutral'>//</span>
  866 |     | <span class='neutral'>//                                             growth</span>
  867 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * ---------- *</span>
  868 |     | <span class='neutral'>//                                            2 ** 111</span>
  869 |     | <span class='neutral'>//</span>
  870 |     | <span class='neutral'>//                            - 8 - qLower / 2     / qSpacing</span>
  871 |     | <span class='neutral'>//           2 ** 216       e                     |            - h / 2</span>
  872 |     | <span class='neutral'>//         ------------- * -------------------- * |   k(h) * e         dh ==</span>
  873 |     | <span class='neutral'>//          outgoingMax              2            |</span>
  874 |     | <span class='neutral'>//                                               / 0</span>
  875 |     | <span class='neutral'>//</span>
  876 |     | <span class='neutral'>//                                             growth       - qLower / 2</span>
  877 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * ---------- * e              &#39;</span>
  878 |     | <span class='neutral'>//                                            2 ** 111</span>
  879 |     | <span class='neutral'>//</span>
  880 |     | <span class='neutral'>//      and</span>
  881 |     | <span class='neutral'>//</span>
  882 |     | <span class='neutral'>//        &#39;amount1Partial ==</span>
  883 |     | <span class='neutral'>//                                      growth</span>
  884 |     | <span class='neutral'>//         sqrtOffset * sharesTotal * ---------- *</span>
  885 |     | <span class='neutral'>//                                     2 ** 111</span>
  886 |     | <span class='neutral'>//</span>
  887 |     | <span class='neutral'>//                            - 8     / qUpper</span>
  888 |     | <span class='neutral'>//           2 ** 216       e        |                     + h / 2</span>
  889 |     | <span class='neutral'>//         ------------- * ------- * |   k(h - qLower) * e         dh ==</span>
  890 |     | <span class='neutral'>//          outgoingMax       2      |</span>
  891 |     | <span class='neutral'>//                                  / qLower</span>
  892 |     | <span class='neutral'>//</span>
  893 |     | <span class='neutral'>//                                      growth       2 ** 216</span>
  894 |     | <span class='neutral'>//         sqrtOffset * sharesTotal * ---------- * ------------- * </span>
  895 |     | <span class='neutral'>//                                     2 ** 111     outgoingMax</span>
  896 |     | <span class='neutral'>//</span>
  897 |     | <span class='neutral'>//            - 8 + (qUpper - qSpacing) / 2     / qSpacing</span>
  898 |     | <span class='neutral'>//          e                                  |            + h / 2</span>
  899 |     | <span class='neutral'>//         --------------------------------- * |   k(h) * e         dh ==</span>
  900 |     | <span class='neutral'>//                         2                   |</span>
  901 |     | <span class='neutral'>//                                            / 0</span>
  902 |     | <span class='neutral'>//</span>
  903 |     | <span class='neutral'>//                                      growth</span>
  904 |     | <span class='neutral'>//         sqrtOffset * sharesTotal * ---------- * </span>
  905 |     | <span class='neutral'>//                                     2 ** 111</span>
  906 |     | <span class='neutral'>//</span>
  907 |     | <span class='neutral'>//          incomingMax      + qUpper / 2</span>
  908 |     | <span class='neutral'>//         ------------- * e              &#39;.</span>
  909 |     | <span class='neutral'>//          outgoingMax</span>
  910 |     | <span class='neutral'>//</span>
  911 |     | <span class='neutral'>//      Consider another scenario where the price of the pool is moved all the</span>
  912 |     | <span class='neutral'>//      way from the right interval boundary &#39;qUpper&#39;, to the left interval</span>
  913 |     | <span class='neutral'>//      boundary &#39;qLower&#39;, as part of a swap. In this case, let</span>
  914 |     | <span class='neutral'>//      &#39;amount1Partial&#39; denote the amount of outgoing &#39;tag1&#39; from the pool and</span>
  915 |     | <span class='neutral'>//      let &#39;amount0Partial&#39; denote the amount of incoming &#39;tag0&#39; to the</span>
  916 |     | <span class='neutral'>//      pool, as a result of swapping within the the entire interval,</span>
  917 |     | <span class='neutral'>//      &#39;[qLower, qUpper]&#39; where both of the amounts are in &#39;X127&#39;</span>
  918 |     | <span class='neutral'>//      representation. Then, we have:</span>
  919 |     | <span class='neutral'>//</span>
  920 |     | <span class='neutral'>//        &#39;amount1Partial ==</span>
  921 |     | <span class='neutral'>//                                      growth</span>
  922 |     | <span class='neutral'>//         sqrtOffset * sharesTotal * ---------- *</span>
  923 |     | <span class='neutral'>//                                     2 ** 111</span>
  924 |     | <span class='neutral'>//</span>
  925 |     | <span class='neutral'>//                            - 8     / qUpper</span>
  926 |     | <span class='neutral'>//           2 ** 216       e        |                     + h / 2</span>
  927 |     | <span class='neutral'>//         ------------- * ------- * |   k(qUpper - h) * e         dh ==</span>
  928 |     | <span class='neutral'>//          outgoingMax       2      |</span>
  929 |     | <span class='neutral'>//                                  / qLower</span>
  930 |     | <span class='neutral'>//</span>
  931 |     | <span class='neutral'>//                                      growth</span>
  932 |     | <span class='neutral'>//         sqrtOffset * sharesTotal * ---------- *</span>
  933 |     | <span class='neutral'>//                                     2 ** 111</span>
  934 |     | <span class='neutral'>//</span>
  935 |     | <span class='neutral'>//                            - 8 + qUpper / 2     / qSpacing</span>
  936 |     | <span class='neutral'>//           2 ** 216       e                     |            - h / 2</span>
  937 |     | <span class='neutral'>//         ------------- * -------------------- * |   k(h) * e         dh ==</span>
  938 |     | <span class='neutral'>//          outgoingMax              2            |</span>
  939 |     | <span class='neutral'>//                                               / 0</span>
  940 |     | <span class='neutral'>//</span>
  941 |     | <span class='neutral'>//                                      growth       + qUpper / 2</span>
  942 |     | <span class='neutral'>//         sqrtOffset * sharesTotal * ---------- * e              &#39;.</span>
  943 |     | <span class='neutral'>//                                     2 ** 111</span>
  944 |     | <span class='neutral'>//</span>
  945 |     | <span class='neutral'>//      and</span>
  946 |     | <span class='neutral'>//</span>
  947 |     | <span class='neutral'>//        &#39;amount0Partial ==</span>
  948 |     | <span class='neutral'>//                                             growth</span>
  949 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * ---------- *</span>
  950 |     | <span class='neutral'>//                                            2 ** 111</span>
  951 |     | <span class='neutral'>//</span>
  952 |     | <span class='neutral'>//                            - 8     / qUpper</span>
  953 |     | <span class='neutral'>//           2 ** 216       e        |                     - h / 2</span>
  954 |     | <span class='neutral'>//         ------------- * ------- * |   k(qUpper - h) * e         dh ==</span>
  955 |     | <span class='neutral'>//          outgoingMax       2      |</span>
  956 |     | <span class='neutral'>//                                  / qLower</span>
  957 |     | <span class='neutral'>//</span>
  958 |     | <span class='neutral'>//                                             growth       2 ** 216</span>
  959 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * ---------- * ------------- * </span>
  960 |     | <span class='neutral'>//                                            2 ** 111     outgoingMax</span>
  961 |     | <span class='neutral'>//</span>
  962 |     | <span class='neutral'>//            - 8 - (qLower + qSpacing) / 2     / qSpacing</span>
  963 |     | <span class='neutral'>//          e                                  |            + h / 2</span>
  964 |     | <span class='neutral'>//         --------------------------------- * |   k(h) * e         dh ==</span>
  965 |     | <span class='neutral'>//                          2                  |</span>
  966 |     | <span class='neutral'>//                                            / 0</span>
  967 |     | <span class='neutral'>//</span>
  968 |     | <span class='neutral'>//                                             growth</span>
  969 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * ---------- * </span>
  970 |     | <span class='neutral'>//                                            2 ** 111</span>
  971 |     | <span class='neutral'>//</span>
  972 |     | <span class='neutral'>//          incomingMax      - qLower / 2</span>
  973 |     | <span class='neutral'>//         ------------- * e              &#39;.</span>
  974 |     | <span class='neutral'>//          outgoingMax</span>
  975 |     | <span class='neutral'>//</span>
  976 |     | <span class='neutral'>//      Hence, in order to facilitate the calculation of &#39;amount0Partial&#39; and</span>
  977 |     | <span class='neutral'>//      &#39;amount1Partial&#39; in such scenarios, we calculate &#39;incomingMax&#39; at the</span>
  978 |     | <span class='neutral'>//      time of initialization or anytime that the kernel function is modified</span>
  979 |     | <span class='neutral'>//      and then we store the resulting value among the static parameters.</span>
  980 |     | <span class='neutral'>//</span>
  981 |     | <span class='neutral'>//      Lastly, we are going to prove the inequality</span>
  982 |     | <span class='neutral'>//</span>
  983 |     | <span class='neutral'>//        &#39;incomingMax &gt;= outgoingMax&#39;</span>
  984 |     | <span class='neutral'>//</span>
  985 |     | <span class='neutral'>//      which will be used later in this script. According to the definitions</span>
  986 |     | <span class='neutral'>//      for &#39;outgoingMax&#39; and &#39;incomingMax&#39;, we have:</span>
  987 |     | <span class='neutral'>//</span>
  988 |     | <span class='neutral'>//                             - 8 - qSpacing / 2     / qSpacing</span>
  989 |     | <span class='neutral'>//          incomingMax      e                       |    + h / 2</span>
  990 |     | <span class='neutral'>//        &#39;------------- := ---------------------- * |  e         k(h) dh</span>
  991 |     | <span class='neutral'>//           2 ** 216                  2             |</span>
  992 |     | <span class='neutral'>//                                                  / 0</span>
  993 |     | <span class='neutral'>//</span>
  994 |     | <span class='neutral'>//                             - 8     / qSpacing</span>
  995 |     | <span class='neutral'>//                           e        |             - (qSpacing - h) / 2</span>
  996 |     | <span class='neutral'>//                       == ------- * |    k(h) * e                      dh</span>
  997 |     | <span class='neutral'>//                             2      |</span>
  998 |     | <span class='neutral'>//                                   / 0</span>
  999 |     | <span class='neutral'>//</span>
 1000 |     | <span class='neutral'>//                             - 8     / qSpacing</span>
 1001 |     | <span class='neutral'>//                           e        |           - h / 2        outgoingMax</span>
 1002 |     | <span class='neutral'>//                       &gt;= ------- * |  k(h) * e         dh == -------------&#39;.</span>
 1003 |     | <span class='neutral'>//                             2      |                           2 ** 216</span>
 1004 |     | <span class='neutral'>//                                   / 0</span>
 1005 |     | <span class='neutral'>//</span>
 1006 |     | <span class='neutral'>//      which is concluded from HardyLittlewood inequality and the fact that</span>
 1007 |     | <span class='neutral'>//      &#39;exp(- (qSpacing - h) / 2)&#39; is an increasing rearrangement of</span>
 1008 |     | <span class='neutral'>//      &#39;exp(- h / 2)&#39;.</span>
 1009 |     | <span class='neutral'>//  </span>
 1010 |     | <span class='neutral'>//  - In the previous steps we read the dynamic parameters, the curve sequence,</span>
 1011 |     | <span class='neutral'>//    the kernel function, and the static parameters. The next step is to move</span>
 1012 |     | <span class='neutral'>//    the price towards &#39;qNext&#39; until any of the following conditions are met:</span>
 1013 |     | <span class='neutral'>//</span>
 1014 |     | <span class='neutral'>//    (a) &#39;amountSpecified&#39; is fulfilled, after which the swap is halted.</span>
 1015 |     | <span class='neutral'>//</span>
 1016 |     | <span class='neutral'>//    (b) &#39;qLimit&#39; is reached, after which the swap is halted.</span>
 1017 |     | <span class='neutral'>//</span>
 1018 |     | <span class='neutral'>//    (c) &#39;qNext&#39; is reached, after which we transition to a new interval.</span>
 1019 |     | <span class='neutral'>//</span>
 1020 |     | <span class='neutral'>//    Before doing so, we need to verify the condition,</span>
 1021 |     | <span class='neutral'>//</span>
 1022 |     | <span class='neutral'>//      &#39;sharesTotal &gt;= crossThreshold&#39;.</span>
 1023 |     | <span class='neutral'>//</span>
 1024 |     | <span class='neutral'>//    If true, we move the price within the current interval, if not we halt</span>
 1025 |     | <span class='neutral'>//    the swap.</span>
 1026 |     | <span class='neutral'>//</span>
 1027 |     | <span class='neutral'>//    As we move the price from &#39;qCurrent&#39; towards &#39;qNext&#39;, the integrals</span>
 1028 |     | <span class='neutral'>//    &#39;currentToTarget&#39; and &#39;incomingCurrentToTarget&#39; are continuously</span>
 1029 |     | <span class='neutral'>//    incremented as they are cumulatively calculated piece by piece. This</span>
 1030 |     | <span class='neutral'>//    process involves exploring the liquidity distribution function &#39;k(w(h))&#39;</span>
 1031 |     | <span class='neutral'>//    within the active liquidity interval. Since &#39;k(w(.))&#39; is a piecewise</span>
 1032 |     | <span class='neutral'>//    linear function, we proceed piece by piece and we increment both</span>
 1033 |     | <span class='neutral'>//    &#39;currentToTarget&#39; and &#39;incomingCurrentToTarget&#39; as we move forward. The</span>
 1034 |     | <span class='neutral'>//    process of exploring &#39;k(w(.))&#39; is explained later in this script and in</span>
 1035 |     | <span class='neutral'>//    &#39;Interval.sol&#39;.</span>
 1036 |     | <span class='neutral'>//</span>
 1037 |     | <span class='neutral'>//    In the present example, since &#39;zeroForOne == True&#39; and</span>
 1038 |     | <span class='neutral'>//    &#39;amountSpecified == +oo &gt; 0&#39;, we have:</span>
 1039 |     | <span class='neutral'>//</span>
 1040 |     | <span class='neutral'>//      &#39;zeroForOne == exactInput&#39;</span>
 1041 |     | <span class='neutral'>//</span>
 1042 |     | <span class='neutral'>//    which indicates that &#39;amountSpecified&#39; is with respect to &#39;tag0&#39;.</span>
 1043 |     | <span class='neutral'>//</span>
 1044 |     | <span class='neutral'>//    Remember that for price decreasing swaps (as is the case in this</span>
 1045 |     | <span class='neutral'>//    example), as long as we remain within the current active liquidity</span>
 1046 |     | <span class='neutral'>//    interval, the amount of incoming &#39;tag0&#39; is calculated as:</span>
 1047 |     | <span class='neutral'>//</span>
 1048 |     | <span class='neutral'>//                                                             growth</span>
 1049 |     | <span class='neutral'>//      &#39;amount0Partial == sqrtInverseOffset * sharesTotal * ---------- * </span>
 1050 |     | <span class='neutral'>//                                                            2 ** 111</span>
 1051 |     | <span class='neutral'>//                          incomingCurrentToTarget</span>
 1052 |     | <span class='neutral'>//                         -------------------------&#39;,</span>
 1053 |     | <span class='neutral'>//                                outgoingMax</span>
 1054 |     | <span class='neutral'>//</span>
 1055 |     | <span class='neutral'>//    which means that in order for us to meet the stopping criteria (a), we</span>
 1056 |     | <span class='neutral'>//    should have:</span>
 1057 |     | <span class='neutral'>//                                                                growth</span>
 1058 |     | <span class='neutral'>//      &#39;|amountSpecified| == sqrtInverseOffset * sharesTotal * ---------- * </span>
 1059 |     | <span class='neutral'>//                                                               2 ** 111</span>
 1060 |     | <span class='neutral'>//                             incomingCurrentToTarget</span>
 1061 |     | <span class='neutral'>//                            -------------------------&#39;,</span>
 1062 |     | <span class='neutral'>//                                   outgoingMax</span>
 1063 |     | <span class='neutral'>//    or equivalently,</span>
 1064 |     | <span class='neutral'>//</span>
 1065 |     | <span class='neutral'>//      &#39;incomingCurrentToTarget == </span>
 1066 |     | <span class='neutral'>//</span>
 1067 |     | <span class='neutral'>//                      |amountSpecified|          1          2 ** 111</span>
 1068 |     | <span class='neutral'>//       outgoingMax * ------------------- * ------------- * ----------&#39;.</span>
 1069 |     | <span class='neutral'>//                      sqrtInverseOffset     sharesTotal      growth</span>
 1070 |     | <span class='neutral'>//</span>
 1071 |     | <span class='neutral'>//    As we increment &#39;currentToTarget&#39; and &#39;incomingCurrentToTarget&#39; by</span>
 1072 |     | <span class='neutral'>//    moving towards &#39;qNext&#39;, at every step (i.e., with each piece of the</span>
 1073 |     | <span class='neutral'>//    liquidity distribution function &#39;k(w(.))&#39;) we need to determine whether</span>
 1074 |     | <span class='neutral'>//    &#39;amountSpecified&#39; is fulfilled or not. To that end, before starting the</span>
 1075 |     | <span class='neutral'>//    exploration, the protocol calculates the right hand side of the above</span>
 1076 |     | <span class='neutral'>//    equation, i.e.,</span>
 1077 |     | <span class='neutral'>//</span>
 1078 |     | <span class='neutral'>//                      |amountSpecified|          1          2 ** 111</span>
 1079 |     | <span class='neutral'>//       outgoingMax * ------------------- * ------------- * ----------&#39;.</span>
 1080 |     | <span class='neutral'>//                      sqrtInverseOffset     sharesTotal      growth</span>
 1081 |     | <span class='neutral'>//</span>
 1082 |     | <span class='neutral'>//    which is regarded as &#39;integralLimit&#39;, and stores its &#39;X216&#39;</span>
 1083 |     | <span class='neutral'>//    representation in the memory space which is pointed to by</span>
 1084 |     | <span class='neutral'>//    &#39;_integralLimit_&#39;.</span>
 1085 |     | <span class='neutral'>//</span>
 1086 |     | <span class='neutral'>//    Consider a hypothetical swap for which &#39;exactInput == false&#39;. Then, every</span>
 1087 |     | <span class='neutral'>//    time that we increment &#39;currentToTarget&#39;, we check whether it has</span>
 1088 |     | <span class='neutral'>//    exceeded &#39;integralLimit&#39;. Once it has, we use the method</span>
 1089 |     | <span class='neutral'>//    &#39;searchOutgoingTarget&#39; in &#39;Interval.sol&#39; to find the precise value</span>
 1090 |     | <span class='neutral'>//</span>
 1091 |     | <span class='neutral'>//      &#39;qTarget := log(pTarget / pOffset)&#39;</span>
 1092 |     | <span class='neutral'>//</span>
 1093 |     | <span class='neutral'>//    in order to have</span>
 1094 |     | <span class='neutral'>//</span>
 1095 |     | <span class='neutral'>//      &#39;currentToTarget == integralLimit&#39;</span>
 1096 |     | <span class='neutral'>//</span>
 1097 |     | <span class='neutral'>//    which guarantees that &#39;amountSpecified&#39; is fulfilled.</span>
 1098 |     | <span class='neutral'>//</span>
 1099 |     | <span class='neutral'>//    If &#39;exactInput == true&#39;, as is the case in our current example, every</span>
 1100 |     | <span class='neutral'>//    time that we increment &#39;incomingCurrentToTarget&#39;, we check whether it has</span>
 1101 |     | <span class='neutral'>//    exceeded &#39;integralLimit&#39;. Once it has, we use the method</span>
 1102 |     | <span class='neutral'>//    &#39;searchIncomingTarget&#39; in &#39;Interval.sol&#39; to find the precise value</span>
 1103 |     | <span class='neutral'>//</span>
 1104 |     | <span class='neutral'>//      &#39;qTarget := log(pTarget / pOffset)&#39;</span>
 1105 |     | <span class='neutral'>//</span>
 1106 |     | <span class='neutral'>//    in order to have</span>
 1107 |     | <span class='neutral'>//</span>
 1108 |     | <span class='neutral'>//      &#39;incomingCurrentToTarget == integralLimit&#39;</span>
 1109 |     | <span class='neutral'>//</span>
 1110 |     | <span class='neutral'>//    which guarantees that &#39;amountSpecified&#39; is fulfilled.</span>
 1111 |     | <span class='neutral'>//</span>
 1112 |     | <span class='neutral'>//    After either of the above searches, the price of the pool is moved to</span>
 1113 |     | <span class='neutral'>//    &#39;qTarget&#39; and the corresponding outgoing and incoming amounts are</span>
 1114 |     | <span class='neutral'>//    calculated.</span>
 1115 |     | <span class='neutral'>//</span>
 1116 |     | <span class='neutral'>//    Throughout the execution of the swap, whenever we enter a new liquidity</span>
 1117 |     | <span class='neutral'>//    interval, both &#39;amountSpecified&#39; and &#39;integralLimit&#39; are updated. This is</span>
 1118 |     | <span class='neutral'>//    further explained in the next step.</span>
 1119 |     | <span class='neutral'>//</span>
 1120 |     | <span class='neutral'>//    However, remember that in the present example, we have</span>
 1121 |     | <span class='neutral'>//    &#39;amountSpecified == +oo&#39; which means that:</span>
 1122 |     | <span class='neutral'>//</span>
 1123 |     | <span class='neutral'>//      &#39;integralLimit := outgoingMax * </span>
 1124 |     | <span class='neutral'>//</span>
 1125 |     | <span class='neutral'>//        |amountSpecified|          1          2 ** 111</span>
 1126 |     | <span class='neutral'>//       ------------------- * ------------- * ---------- == +oo&#39;.</span>
 1127 |     | <span class='neutral'>//        sqrtInverseOffset     sharesTotal      growth</span>
 1128 |     | <span class='neutral'>//</span>
 1129 |     | <span class='neutral'>//    Hence, &#39;incomingCurrentToTarget&#39; may never exceed &#39;integralLimit&#39; and the</span>
 1130 |     | <span class='neutral'>//    stopping criteria (a) is not reachable. Put simply, since</span>
 1131 |     | <span class='neutral'>//    &#39;amountSpecified&#39; is equal to infinity, we may never reach it and we only</span>
 1132 |     | <span class='neutral'>//    need to worry about &#39;qLimit&#39; and &#39;qNext&#39;.</span>
 1133 |     | <span class='neutral'>//</span>
 1134 |     | <span class='neutral'>//    In order to keep track of (b) and (c) concurrently, the protocol</span>
 1135 |     | <span class='neutral'>//    calculates</span>
 1136 |     | <span class='neutral'>//</span>
 1137 |     | <span class='neutral'>//      &#39;qLimitWithinInterval := min(max(qLower, qLimit), qUpper)&#39;</span>
 1138 |     | <span class='neutral'>//</span>
 1139 |     | <span class='neutral'>//    and stores it in the memory space which is referred to by</span>
 1140 |     | <span class='neutral'>//    &#39;_logPriceLimitOffsettedWithinInterval_&#39;. As we move forward with pieces</span>
 1141 |     | <span class='neutral'>//    of the liquidity distribution function, we continuously check whether</span>
 1142 |     | <span class='neutral'>//    &#39;qLimitWithinInterval&#39; is reached. If so, we either need to halt the swap</span>
 1143 |     | <span class='neutral'>//    (stopping criteria (b)) or transition to a new interval (stopping</span>
 1144 |     | <span class='neutral'>//    criteria (c)).</span>
 1145 |     | <span class='neutral'>//</span>
 1146 |     | <span class='neutral'>//    In our example, it can be easily observed that</span>
 1147 |     | <span class='neutral'>//</span>
 1148 |     | <span class='neutral'>//      &#39;qLimitWithinInterval == qNext&#39;</span>
 1149 |     | <span class='neutral'>//</span>
 1150 |     | <span class='neutral'>//    as illustrated below:</span>
 1151 |     | <span class='neutral'>//</span>
 1152 |     | <span class='neutral'>//                                             qLimitWithinInterval</span>
 1153 |     | <span class='neutral'>//                                                      |</span>
 1154 |     | <span class='neutral'>//                  qLimit                              |  qCurrent</span>
 1155 |     | <span class='neutral'>//                     |                                |     |</span>
 1156 |     | <span class='neutral'>//     ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
 1157 |     | <span class='neutral'>//                                                      |             |</span>
 1158 |     | <span class='neutral'>//                                                    qNext         qBack</span>
 1159 |     | <span class='neutral'>//</span>
 1160 |     | <span class='neutral'>//    Hence, in the present active liquidity interval, we do not need to worry</span>
 1161 |     | <span class='neutral'>//    about &#39;qLimit&#39; either and we can move forward until we reach &#39;qNext&#39;.</span>
 1162 |     | <span class='neutral'>//    After that, we need to update a number of parameters, including:</span>
 1163 |     | <span class='neutral'>//</span>
 1164 |     | <span class='neutral'>//    - &#39;amount0&#39;: This is the total amount of &#39;tag0&#39; which is traded as a</span>
 1165 |     | <span class='neutral'>//      result of this swap. In this example, since our swap is price</span>
 1166 |     | <span class='neutral'>//      decreasing, we should have &#39;amount0 &gt; 0&#39; which indicates that &#39;amount0&#39;</span>
 1167 |     | <span class='neutral'>//      is incoming to the pool. Hence, according to the above formulas, with</span>
 1168 |     | <span class='neutral'>//      each interval that we transact in, &#39;amount0&#39; should be incremented by:</span>
 1169 |     | <span class='neutral'>//</span>
 1170 |     | <span class='neutral'>//                                                               growth</span>
 1171 |     | <span class='neutral'>//        &#39;amount0Partial := sqrtInverseOffset * sharesTotal * ---------- *</span>
 1172 |     | <span class='neutral'>//                                                              2 ** 111</span>
 1173 |     | <span class='neutral'>//                            incomingCurrentToTarget</span>
 1174 |     | <span class='neutral'>//                           -------------------------&#39;</span>
 1175 |     | <span class='neutral'>//                                  outgoingMax</span>
 1176 |     | <span class='neutral'>//</span>
 1177 |     | <span class='neutral'>//    - &#39;amount1&#39;: This is the total amount of &#39;tag1&#39; which is traded as a</span>
 1178 |     | <span class='neutral'>//      result of this swap. In this example, since our swap is price</span>
 1179 |     | <span class='neutral'>//      decreasing, we should have &#39;amount1 &lt; 0&#39; which indicates that &#39;amount1&#39;</span>
 1180 |     | <span class='neutral'>//      is outgoing from the pool. Hence, according to the above formulas, with</span>
 1181 |     | <span class='neutral'>//      each interval that we transact in, &#39;amount1&#39; should be decremented by:</span>
 1182 |     | <span class='neutral'>//</span>
 1183 |     | <span class='neutral'>//                                                        growth</span>
 1184 |     | <span class='neutral'>//        &#39;amount1Partial := sqrtOffset * sharesTotal * ---------- *</span>
 1185 |     | <span class='neutral'>//                                                       2 ** 111</span>
 1186 |     | <span class='neutral'>//                            currentToTarget</span>
 1187 |     | <span class='neutral'>//                           -----------------&#39;</span>
 1188 |     | <span class='neutral'>//                              outgoingMax</span>
 1189 |     | <span class='neutral'>//</span>
 1190 |     | <span class='neutral'>//    - &#39;amountSpecified&#39;: Since the swap is partially fulfilled, we should</span>
 1191 |     | <span class='neutral'>//      decrement &#39;amountSpecified&#39; by &#39;amount0Partial&#39; to reflect this:</span>
 1192 |     | <span class='neutral'>//</span>
 1193 |     | <span class='neutral'>//        &#39;amountSpecified -= amount0Partial&#39;.</span>
 1194 |     | <span class='neutral'>//</span>
 1195 |     | <span class='neutral'>//    - &#39;curve&#39;: As explained before, when we transact in a liquidity interval,</span>
 1196 |     | <span class='neutral'>//      as part of a swap, we then need to amend the curve sequence for that</span>
 1197 |     | <span class='neutral'>//      interval in preparation for the next swap. In this example, the</span>
 1198 |     | <span class='neutral'>//      amendment is straightforward. Since we are about to transition out of</span>
 1199 |     | <span class='neutral'>//      the interval &#39;[qLower, qUpper]&#39;, it should turn into an inactive</span>
 1200 |     | <span class='neutral'>//      interval. Hence, the corresponding curve sequence for this interval</span>
 1201 |     | <span class='neutral'>//      should transform into a sequence of length two as is the case for every</span>
 1202 |     | <span class='neutral'>//      inactive liquidity interval. Following the pattern that was introduced</span>
 1203 |     | <span class='neutral'>//      earlier for inactive liquidity intervals, the amended curve sequence</span>
 1204 |     | <span class='neutral'>//      for &#39;[qLower, qUpper]&#39; should be:</span>
 1205 |     | <span class='neutral'>//</span>
 1206 |     | <span class='neutral'>//        &#39;q[0] := qUpper&#39;,</span>
 1207 |     | <span class='neutral'>//        &#39;q[1] := qLower&#39;.</span>
 1208 |     | <span class='neutral'>//</span>
 1209 |     | <span class='neutral'>//      This amendment, transforms the function &#39;w&#39; associated with</span>
 1210 |     | <span class='neutral'>//      &#39;[qLower, qUpper]&#39; from the following:</span>
 1211 |     | <span class='neutral'>//</span>
 1212 |     | <span class='neutral'>//            w(q)</span>
 1213 |     | <span class='neutral'>//              ^</span>
 1214 |     | <span class='neutral'>//      spacing |                /</span>
 1215 |     | <span class='neutral'>//              |               /</span>
 1216 |     | <span class='neutral'>//              |              /</span>
 1217 |     | <span class='neutral'>//              |             /</span>
 1218 |     | <span class='neutral'>//              |            /</span>
 1219 |     | <span class='neutral'>//              |           /</span>
 1220 |     | <span class='neutral'>//              |          /</span>
 1221 |     | <span class='neutral'>//              |\</span>
 1222 |     | <span class='neutral'>//              | \</span>
 1223 |     | <span class='neutral'>//              |  \</span>
 1224 |     | <span class='neutral'>//              |   \</span>
 1225 |     | <span class='neutral'>//              |        /</span>
 1226 |     | <span class='neutral'>//              |       /</span>
 1227 |     | <span class='neutral'>//              |      /</span>
 1228 |     | <span class='neutral'>//              |     /</span>
 1229 |     | <span class='neutral'>//            0 +----+----+-------+-&gt; q</span>
 1230 |     | <span class='neutral'>//           qLower  |    |       |</span>
 1231 |     | <span class='neutral'>//                   |   q[2]  qUpper</span>
 1232 |     | <span class='neutral'>//                   |</span>
 1233 |     | <span class='neutral'>//               qCurrent</span>
 1234 |     | <span class='neutral'>//</span>
 1235 |     | <span class='neutral'>//      to a new function:</span>
 1236 |     | <span class='neutral'>//</span>
 1237 |     | <span class='neutral'>//        &#39;wAmended(q) := q - qLower&#39;</span>
 1238 |     | <span class='neutral'>//</span>
 1239 |     | <span class='neutral'>//      which can be plotted as follows:</span>
 1240 |     | <span class='neutral'>//</span>
 1241 |     | <span class='neutral'>//          wAmended(q)</span>
 1242 |     | <span class='neutral'>//              ^</span>
 1243 |     | <span class='neutral'>//      spacing |                /</span>
 1244 |     | <span class='neutral'>//              |               /</span>
 1245 |     | <span class='neutral'>//              |              /</span>
 1246 |     | <span class='neutral'>//              |             /</span>
 1247 |     | <span class='neutral'>//              |            /</span>
 1248 |     | <span class='neutral'>//              |           /</span>
 1249 |     | <span class='neutral'>//              |          /</span>
 1250 |     | <span class='neutral'>//              |         /</span>
 1251 |     | <span class='neutral'>//              |        /</span>
 1252 |     | <span class='neutral'>//              |       /</span>
 1253 |     | <span class='neutral'>//              |      /</span>
 1254 |     | <span class='neutral'>//              |     /</span>
 1255 |     | <span class='neutral'>//              |    /</span>
 1256 |     | <span class='neutral'>//              |   /</span>
 1257 |     | <span class='neutral'>//              |  /</span>
 1258 |     | <span class='neutral'>//              | /</span>
 1259 |     | <span class='neutral'>//              |/</span>
 1260 |     | <span class='neutral'>//            0 +-----------------+-&gt; q</span>
 1261 |     | <span class='neutral'>//           qLower               |</span>
 1262 |     | <span class='neutral'>//                             qUpper</span>
 1263 |     | <span class='neutral'>//</span>
 1264 |     | <span class='neutral'>//      As we will demonstrate next, this procedure results in positive growth</span>
 1265 |     | <span class='neutral'>//      for liquidity providers.</span>
 1266 |     | <span class='neutral'>//</span>
 1267 |     | <span class='neutral'>//    - &#39;growth&#39;: As discussed earlier, before transitioning out of the</span>
 1268 |     | <span class='neutral'>//      interval &#39;[qLower, qUpper]&#39;, the curve sequence for this interval is</span>
 1269 |     | <span class='neutral'>//      amended. This action, changes the function &#39;w&#39; to &#39;wAmended&#39; which in</span>
 1270 |     | <span class='neutral'>//      turn changes the liquidity distribution function from &#39;k(w(.))&#39; to</span>
 1271 |     | <span class='neutral'>//      &#39;k(wAmended(.))&#39;. However, the amount of reserve for &#39;tag0&#39; within</span>
 1272 |     | <span class='neutral'>//      &#39;[qLower, qUpper]&#39; should stay the same before and after the amendment</span>
 1273 |     | <span class='neutral'>//      of the curve sequence. This is because modifying the curve sequence is</span>
 1274 |     | <span class='neutral'>//      a change in our trading policy and it does not introduce or remove any</span>
 1275 |     | <span class='neutral'>//      amount of liquidity. Hence, in order to conserve the amount of &#39;tag0&#39;</span>
 1276 |     | <span class='neutral'>//      within &#39;[qLower, qUpper]&#39; despite the transformation of &#39;w&#39; to</span>
 1277 |     | <span class='neutral'>//      &#39;wAmended&#39;, we need to make an adjustment to the &#39;growth&#39; value and</span>
 1278 |     | <span class='neutral'>//      turn it into &#39;growthAmended&#39;. In order to determine &#39;growthAmended&#39;,</span>
 1279 |     | <span class='neutral'>//      the following equation is solved:</span>
 1280 |     | <span class='neutral'>//</span>
 1281 |     | <span class='neutral'>//        &#39;totalReserveOfTag0Before == totalReserveOfTag0After&#39;</span>
 1282 |     | <span class='neutral'>//</span>
 1283 |     | <span class='neutral'>//      where &#39;totalReserveOfTag0Before&#39; is the total amount of &#39;tag0&#39; within</span>
 1284 |     | <span class='neutral'>//      &#39;[qLower, qUpper]&#39; which is calculated based on &#39;k(w(.))&#39;, whereas</span>
 1285 |     | <span class='neutral'>//      &#39;totalReserveOfTag0After&#39; is the same value calculated based on</span>
 1286 |     | <span class='neutral'>//      &#39;k(wAmended(.))&#39;. The two sides of the equation can be derived as:</span>
 1287 |     | <span class='neutral'>//</span>
 1288 |     | <span class='neutral'>//        &#39;totalReserveOfTag0Before = sqrtInverseOffset * sharesTotal * </span>
 1289 |     | <span class='neutral'>//</span>
 1290 |     | <span class='neutral'>//                                         - 8     / qUpper</span>
 1291 |     | <span class='neutral'>//           growth       2 ** 216       e        |    - h / 2</span>
 1292 |     | <span class='neutral'>//         ---------- * ------------- * ------- * |  e         k(w(h)) dh&#39;,</span>
 1293 |     | <span class='neutral'>//          2 ** 111     outgoingMax       2      |</span>
 1294 |     | <span class='neutral'>//                                               / qLower</span>
 1295 |     | <span class='neutral'>//</span>
 1296 |     | <span class='neutral'>//        &#39;totalReserveOfTag0After = sqrtInverseOffset * sharesTotal * </span>
 1297 |     | <span class='neutral'>//</span>
 1298 |     | <span class='neutral'>//          growthAmended       2 ** 216</span>
 1299 |     | <span class='neutral'>//         --------------- * ------------- *</span>
 1300 |     | <span class='neutral'>//             2 ** 111       outgoingMax</span>
 1301 |     | <span class='neutral'>//</span>
 1302 |     | <span class='neutral'>//            - 8     / qUpper</span>
 1303 |     | <span class='neutral'>//          e        |    - h / 2</span>
 1304 |     | <span class='neutral'>//         ------- * |  e         k(wAmended(h)) dh&#39;,</span>
 1305 |     | <span class='neutral'>//            2      |</span>
 1306 |     | <span class='neutral'>//                  / qLower</span>
 1307 |     | <span class='neutral'>//</span>
 1308 |     | <span class='neutral'>//      Hence, &#39;growthAmended&#39; can be derived as:</span>
 1309 |     | <span class='neutral'>//</span>
 1310 |     | <span class='neutral'>//                                           / qUpper</span>
 1311 |     | <span class='neutral'>//                                          |    - h / 2</span>
 1312 |     | <span class='neutral'>//                                          |  e         k(w(h)) dh</span>
 1313 |     | <span class='neutral'>//                                          |</span>
 1314 |     | <span class='neutral'>//                                         / qLower</span>
 1315 |     | <span class='neutral'>//        &#39;growthAmended == growth * ---------------------------------&#39;.</span>
 1316 |     | <span class='neutral'>//                                       / qUpper</span>
 1317 |     | <span class='neutral'>//                                      |    - h / 2</span>
 1318 |     | <span class='neutral'>//                                      |  e         k(wAmended(h)) dh</span>
 1319 |     | <span class='neutral'>//                                      |</span>
 1320 |     | <span class='neutral'>//                                     / qLower</span>
 1321 |     | <span class='neutral'>//</span>
 1322 |     | <span class='neutral'>//      Observe that &#39;wAmended&#39; is a monotonically non-decreasing rearrangement</span>
 1323 |     | <span class='neutral'>//      of &#39;w&#39;. This is because pieces of &#39;wAmended&#39; can be flipped and</span>
 1324 |     | <span class='neutral'>//      rearranged in order to transform its diagram to the diagram of &#39;w&#39;. On</span>
 1325 |     | <span class='neutral'>//      the other hand, since &#39;k&#39; is a monotonically non-decreasing function,</span>
 1326 |     | <span class='neutral'>//      we can conclude that &#39;k(wAmended(.))&#39; is a monotonically non-decreasing</span>
 1327 |     | <span class='neutral'>//      rearrangement of &#39;k(w(.))&#39;. Hence, according to the HardyLittlewood</span>
 1328 |     | <span class='neutral'>//      inequality, we have:</span>
 1329 |     | <span class='neutral'>//</span>
 1330 |     | <span class='neutral'>//            / qUpper                             / qUpper</span>
 1331 |     | <span class='neutral'>//           |    - h / 2                         |    - h / 2</span>
 1332 |     | <span class='neutral'>//        &#39;  |  e         k(wAmended(h)) dh  &lt;=   |  e         k(w(h)) dh &#39;</span>
 1333 |     | <span class='neutral'>//           |                                    |</span>
 1334 |     | <span class='neutral'>//          / qLower                             / qLower</span>
 1335 |     | <span class='neutral'>//      </span>
 1336 |     | <span class='neutral'>//      which concludes that:</span>
 1337 |     | <span class='neutral'>//</span>
 1338 |     | <span class='neutral'>//        &#39;growthAmended &gt;= growth&#39;.</span>
 1339 |     | <span class='neutral'>//</span>
 1340 |     | <span class='neutral'>//      This is exactly what we want!</span>
 1341 |     | <span class='neutral'>//</span>
 1342 |     | <span class='neutral'>//      To summarize, when we transact in a liquidity interval as part of a</span>
 1343 |     | <span class='neutral'>//      swap, we then need to amend the curve sequence for that interval. After</span>
 1344 |     | <span class='neutral'>//      that, in order to make up for the transformation of &#39;w&#39; to &#39;wAmended&#39;,</span>
 1345 |     | <span class='neutral'>//      the &#39;growth&#39; value should be incremented according to the above formula</span>
 1346 |     | <span class='neutral'>//      for &#39;growthAmended&#39;.</span>
 1347 |     | <span class='neutral'>//</span>
 1348 |     | <span class='neutral'>//    - &#39;qCurrent&#39;: Lastly, as we move the price of the pool to &#39;qNext&#39;, the</span>
 1349 |     | <span class='neutral'>//      value for &#39;qCurrent&#39; should be updated to reflect this change. which is</span>
 1350 |     | <span class='neutral'>//      illustrated as follows:</span>
 1351 |     | <span class='neutral'>//</span>
 1352 |     | <span class='neutral'>//                qLimit                              qCurrent</span>
 1353 |     | <span class='neutral'>//                   |                                   |</span>
 1354 |     | <span class='neutral'>//      ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
 1355 |     | <span class='neutral'>//                                                       |             |</span>
 1356 |     | <span class='neutral'>//                                                     qNext         qBack</span>
 1357 |     | <span class='neutral'>//    </span>
 1358 |     | <span class='neutral'>//    Now, we are ready to transition out of the interval &#39;[qLower, qUpper]&#39;</span>
 1359 |     | <span class='neutral'>//    which is explained next.</span>
 1360 |     | <span class='neutral'>//</span>
 1361 |     | <span class='neutral'>//  - In the previous step we moved the price of the pool to &#39;qNext&#39; to</span>
 1362 |     | <span class='neutral'>//    partially fulfill the requested swap. In this step, we transition from</span>
 1363 |     | <span class='neutral'>//    the original liquidity interval &#39;[qLower, qUpper]&#39; to its adjacent</span>
 1364 |     | <span class='neutral'>//    interval &#39;[qLower - qSpacing, qUpper - qSpacing]&#39;. This transition</span>
 1365 |     | <span class='neutral'>//    involves updating the following parameters:</span>
 1366 |     | <span class='neutral'>//</span>
 1367 |     | <span class='neutral'>//    - &#39;sharesTotal&#39;: The current value of &#39;sharesTotal&#39; reflects the total</span>
 1368 |     | <span class='neutral'>//      number of shares within &#39;[qLower, qUpper]&#39;. As we are transitioning to</span>
 1369 |     | <span class='neutral'>//      &#39;[qLower - qSpacing, qUpper - qSpacing]&#39;, this value should be modified</span>
 1370 |     | <span class='neutral'>//      in order to reflect the total number of shares in the new active</span>
 1371 |     | <span class='neutral'>//      interval.</span>
 1372 |     | <span class='neutral'>//</span>
 1373 |     | <span class='neutral'>//      We keep track of the total share values in all of the liquidity</span>
 1374 |     | <span class='neutral'>//      intervals via the mapping &#39;sharesDelta&#39; within protocol&#39;s storage. Let</span>
 1375 |     | <span class='neutral'>//      &#39;qBoundary&#39; denote an arbitrary boundary for a liquidity interval,</span>
 1376 |     | <span class='neutral'>//      i.e.,</span>
 1377 |     | <span class='neutral'>//</span>
 1378 |     | <span class='neutral'>//        &#39;qBoundary == qLower + j * qSpacing&#39;</span>
 1379 |     | <span class='neutral'>//</span>
 1380 |     | <span class='neutral'>//      for some integer &#39;j&#39;. Let &#39;sharesTotalLeft&#39; and &#39;sharesTotalRight&#39;</span>
 1381 |     | <span class='neutral'>//      denote the total number of shares within the intervals</span>
 1382 |     | <span class='neutral'>//</span>
 1383 |     | <span class='neutral'>//        &#39;[qBoundary - qSpacing, qBoundary]&#39; and</span>
 1384 |     | <span class='neutral'>//        &#39;[qBoundary, qBoundary + qSpacing]&#39;,</span>
 1385 |     | <span class='neutral'>//</span>
 1386 |     | <span class='neutral'>//      respectively. Define:</span>
 1387 |     | <span class='neutral'>//</span>
 1388 |     | <span class='neutral'>//        &#39;sharesDelta[qBoundary] := sharesTotalRight - sharesTotalLeft&#39;.</span>
 1389 |     | <span class='neutral'>//</span>
 1390 |     | <span class='neutral'>//      In other words, &#39;sharesDelta[qBoundary]&#39; is defined as the difference</span>
 1391 |     | <span class='neutral'>//      between the total number of shares within the two liquidity intervals</span>
 1392 |     | <span class='neutral'>//      that contain &#39;qBoundary&#39;.</span>
 1393 |     | <span class='neutral'>//</span>
 1394 |     | <span class='neutral'>//      Hence, for price increasing swaps, as we transition to a new interval,</span>
 1395 |     | <span class='neutral'>//      &#39;sharesTotal&#39; should be modified as follows:</span>
 1396 |     | <span class='neutral'>//</span>
 1397 |     | <span class='neutral'>//        &#39;sharesTotal += sharesDelta[qNext]&#39;,</span>
 1398 |     | <span class='neutral'>//</span>
 1399 |     | <span class='neutral'>//      and for price decreasing swaps, as we transition to a new interval,</span>
 1400 |     | <span class='neutral'>//      &#39;sharesTotal&#39; should be modified as follows:</span>
 1401 |     | <span class='neutral'>//</span>
 1402 |     | <span class='neutral'>//        &#39;sharesTotal -= sharesDelta[qNext]&#39;.</span>
 1403 |     | <span class='neutral'>//</span>
 1404 |     | <span class='neutral'>//      This way of accounting for the total shares makes liquidity deposit or</span>
 1405 |     | <span class='neutral'>//      withdrawal by LPs more efficient. Imagine an example where an LP</span>
 1406 |     | <span class='neutral'>//      intends to deposit &#39;100&#39; shares in every interval within the range</span>
 1407 |     | <span class='neutral'>//      &#39;qLower - i * qSpacing&#39; to &#39;qUpper + j * qSpacing&#39;, where &#39;i&#39; and &#39;j&#39;</span>
 1408 |     | <span class='neutral'>//      are arbitrary non-negative integers. In this case, we need to add &#39;100&#39;</span>
 1409 |     | <span class='neutral'>//      shares to every one of the following intervals:</span>
 1410 |     | <span class='neutral'>//</span>
 1411 |     | <span class='neutral'>//        &#39;[qLower - i * qSpacing, qUpper - i * qSpacing]&#39;,</span>
 1412 |     | <span class='neutral'>//          .</span>
 1413 |     | <span class='neutral'>//          .</span>
 1414 |     | <span class='neutral'>//          .</span>
 1415 |     | <span class='neutral'>//        &#39;[qLower - 1 * qSpacing, qUpper - 1 * qSpacing]&#39;,</span>
 1416 |     | <span class='neutral'>//        &#39;[qLower               , qUpper               ]&#39;,</span>
 1417 |     | <span class='neutral'>//        &#39;[qLower + 1 * qSpacing, qUpper + 1 * qSpacing]&#39;,</span>
 1418 |     | <span class='neutral'>//          .</span>
 1419 |     | <span class='neutral'>//          .</span>
 1420 |     | <span class='neutral'>//          .</span>
 1421 |     | <span class='neutral'>//        &#39;[qLower + j * qSpacing, qUpper + j * qSpacing]&#39;.</span>
 1422 |     | <span class='neutral'>//</span>
 1423 |     | <span class='neutral'>//      However, it may not be efficient or even possible to enumerated every</span>
 1424 |     | <span class='neutral'>//      single one of the &#39;i + j + 1&#39; intervals and thanks to &#39;sharesDelta&#39;, we</span>
 1425 |     | <span class='neutral'>//      do not need to do that! Alternatively, in order to account for the</span>
 1426 |     | <span class='neutral'>//      additional &#39;100&#39; shares, the protocol:</span>
 1427 |     | <span class='neutral'>//</span>
 1428 |     | <span class='neutral'>//      - increments &#39;sharesDelta[qLower - i * qSpacing]&#39; by &#39;100&#39;,</span>
 1429 |     | <span class='neutral'>//</span>
 1430 |     | <span class='neutral'>//      - increments &#39;sharesTotal&#39; by &#39;100&#39;,</span>
 1431 |     | <span class='neutral'>//</span>
 1432 |     | <span class='neutral'>//      - decrements &#39;sharesDelta[qUpper + j * qSpacing]&#39; by &#39;100&#39;,</span>
 1433 |     | <span class='neutral'>//</span>
 1434 |     | <span class='neutral'>//      which is sufficient to updated the total number of shares in every</span>
 1435 |     | <span class='neutral'>//      liquidity interval within the intended range.</span>
 1436 |     | <span class='neutral'>//</span>
 1437 |     | <span class='neutral'>//    - &#39;growth&#39;: In the prior step, we updated the content of the memory space</span>
 1438 |     | <span class='neutral'>//      which is pointed to by &#39;_growth_&#39;, according to the following formula:</span>
 1439 |     | <span class='neutral'>//</span>
 1440 |     | <span class='neutral'>//                                          / qUpper</span>
 1441 |     | <span class='neutral'>//                                         |    - h / 2</span>
 1442 |     | <span class='neutral'>//                                         |  e         k(w(h)) dh</span>
 1443 |     | <span class='neutral'>//                                         |</span>
 1444 |     | <span class='neutral'>//                                        / qLower</span>
 1445 |     | <span class='neutral'>//        &#39;growthAmended == growth * ----------------------------------&#39;.</span>
 1446 |     | <span class='neutral'>//                                       / qUpper</span>
 1447 |     | <span class='neutral'>//                                      |    - h / 2</span>
 1448 |     | <span class='neutral'>//                                      |  e         k(wAmended(h)) dh</span>
 1449 |     | <span class='neutral'>//                                      |</span>
 1450 |     | <span class='neutral'>//                                     / qLower</span>
 1451 |     | <span class='neutral'>//</span>
 1452 |     | <span class='neutral'>//      Hence, the current value stored in this memory space reflects the</span>
 1453 |     | <span class='neutral'>//      updated liquidity growth within &#39;[qLower, qUpper]&#39; (as a result of the</span>
 1454 |     | <span class='neutral'>//      partial swap that moved the price to &#39;qNext&#39;).</span>
 1455 |     | <span class='neutral'>//</span>
 1456 |     | <span class='neutral'>//      Now, as we are transitioning out of &#39;[qLower, qUpper]&#39;, &#39;growthAmended&#39;</span>
 1457 |     | <span class='neutral'>//      which currently resides in the memory has to be written somewhere in</span>
 1458 |     | <span class='neutral'>//      the protocol&#39;s storage, and then the amount of liquidity growth within</span>
 1459 |     | <span class='neutral'>//</span>
 1460 |     | <span class='neutral'>//        &#39;[qLower - qSpacing, qUpper - qSpacing]&#39;</span>
 1461 |     | <span class='neutral'>//</span>
 1462 |     | <span class='neutral'>//      should be loaded in the memory so that we can transact within this new</span>
 1463 |     | <span class='neutral'>//      interval.</span>
 1464 |     | <span class='neutral'>//</span>
 1465 |     | <span class='neutral'>//      We keep track of these &#39;growth&#39; values for all of the liquidity</span>
 1466 |     | <span class='neutral'>//      intervals, via the mapping &#39;growthMultiplier&#39;. For every integer &#39;m&#39;,</span>
 1467 |     | <span class='neutral'>//      let &#39;growth(m)&#39; denote the &#39;growth&#39; value for the interval</span>
 1468 |     | <span class='neutral'>//</span>
 1469 |     | <span class='neutral'>//        &#39;[qLower + m * qSpacing, qUpper + m * qSpacing]&#39;.</span>
 1470 |     | <span class='neutral'>//</span>
 1471 |     | <span class='neutral'>//      Hence, &#39;growth(0)&#39; corresponds to &#39;[qLower, qUpper]&#39; which is the</span>
 1472 |     | <span class='neutral'>//      current value stored in memory. </span>
 1473 |     | <span class='neutral'>//</span>
 1474 |     | <span class='neutral'>//      Now, for every integer &#39;m &gt;= 1&#39; define:</span>
 1475 |     | <span class='neutral'>//</span>
 1476 |     | <span class='neutral'>//          growthMultiplier[qLower + m * qSpacing]</span>
 1477 |     | <span class='neutral'>//        &#39;----------------------------------------- := </span>
 1478 |     | <span class='neutral'>//                         2 ** 208</span>
 1479 |     | <span class='neutral'>//         ---- +oo</span>
 1480 |     | <span class='neutral'>//         \            growth(+j)      (- qLower - j * qSpacing) / 2</span>
 1481 |     | <span class='neutral'>//         /           ------------ * e                               &#39;.</span>
 1482 |     | <span class='neutral'>//         ---- j = m    2 ** 111</span>
 1483 |     | <span class='neutral'>//</span>
 1484 |     | <span class='neutral'>//      According to the above definition, for every integer &#39;m &gt;= 1&#39;,</span>
 1485 |     | <span class='neutral'>//</span>
 1486 |     | <span class='neutral'>//          sqrtInverseOffset     growthMultiplier[qLower + m * qSpacing]</span>
 1487 |     | <span class='neutral'>//        &#39;------------------- * -----------------------------------------&#39;</span>
 1488 |     | <span class='neutral'>//              2 ** 127                         2 ** 208</span>
 1489 |     | <span class='neutral'>//</span>
 1490 |     | <span class='neutral'>//      is equal to the total amount of &#39;tag0&#39; corresponding to a single</span>
 1491 |     | <span class='neutral'>//      liquidity provider&#39;s share in every interval spanning from</span>
 1492 |     | <span class='neutral'>//      &#39;qLower + m * qSpacing&#39; to &#39;+oo&#39;.</span>
 1493 |     | <span class='neutral'>//</span>
 1494 |     | <span class='neutral'>//      Similarly, for every integer &#39;m &gt;= 1&#39; define:</span>
 1495 |     | <span class='neutral'>//</span>
 1496 |     | <span class='neutral'>//          growthMultiplier[qUpper - m * qSpacing]</span>
 1497 |     | <span class='neutral'>//        &#39;----------------------------------------- := </span>
 1498 |     | <span class='neutral'>//                         2 ** 208</span>
 1499 |     | <span class='neutral'>//         ---- +oo</span>
 1500 |     | <span class='neutral'>//         \            growth(-j)      (+ qUpper - j * qSpacing) / 2</span>
 1501 |     | <span class='neutral'>//         /           ------------ * e                               &#39;.</span>
 1502 |     | <span class='neutral'>//         ---- j = m    2 ** 111</span>
 1503 |     | <span class='neutral'>//</span>
 1504 |     | <span class='neutral'>//      According to the above definition, for every integer &#39;m &gt;= 1&#39;,</span>
 1505 |     | <span class='neutral'>//</span>
 1506 |     | <span class='neutral'>//          sqrtOffset     growthMultiplier[qUpper - m * qSpacing]</span>
 1507 |     | <span class='neutral'>//        &#39;------------ * -----------------------------------------&#39;</span>
 1508 |     | <span class='neutral'>//           2 ** 127                     2 ** 208</span>
 1509 |     | <span class='neutral'>//</span>
 1510 |     | <span class='neutral'>//      is equal to the total amount of &#39;tag1&#39; corresponding to a single</span>
 1511 |     | <span class='neutral'>//      liquidity provider&#39;s share in every interval spanning from &#39;-oo&#39; to</span>
 1512 |     | <span class='neutral'>//      &#39;qUpper - m * qSpacing&#39;.</span>
 1513 |     | <span class='neutral'>//</span>
 1514 |     | <span class='neutral'>//      The following illustration further elaborates the notion of </span>
 1515 |     | <span class='neutral'>//      &#39;growthMultiplier&#39;:</span>
 1516 |     | <span class='neutral'>//</span>
 1517 |     | <span class='neutral'>//                                         growthMultiplier[qUpper + qSpacing]</span>
 1518 |     | <span class='neutral'>//                                                                    |--&gt;</span>
 1519 |     | <span class='neutral'>//       growthMultiplier[qLower - qSpacing]                          |</span>
 1520 |     | <span class='neutral'>//           &lt;--|                                                     |</span>
 1521 |     | <span class='neutral'>//              |                        growthMultiplier[qUpper]     |</span>
 1522 |     | <span class='neutral'>//              |                                   |--&gt;              |</span>
 1523 |     | <span class='neutral'>//              |      growthMultiplier[qLower]     |                 |</span>
 1524 |     | <span class='neutral'>//              |              &lt;--|                 |                 |</span>
 1525 |     | <span class='neutral'>//              |                 |     growth      |                 |</span>
 1526 |     | <span class='neutral'>//              |                 |       ==        |                 |</span>
 1527 |     | <span class='neutral'>//              |    growth(-1)   |    growth(0)    |    growth(+1)   |</span>
 1528 |     | <span class='neutral'>//       ... &lt;--+-----------------+-----------------+-----------------+--&gt; ...</span>
 1529 |     | <span class='neutral'>//                                |                 |</span>
 1530 |     | <span class='neutral'>//                              qLower           qUpper</span>
 1531 |     | <span class='neutral'>//</span>
 1532 |     | <span class='neutral'>//      In the above figure, &#39;growthMultiplier[qUpper]&#39; and</span>
 1533 |     | <span class='neutral'>//      &#39;growthMultiplier[qUpper + qSpacing]&#39; point towards &#39;+oo&#39;. This is</span>
 1534 |     | <span class='neutral'>//      because these two values are proportional to the the amount of &#39;tag0&#39;</span>
 1535 |     | <span class='neutral'>//      for a single share in every interval within &#39;[qUpper, +oo]&#39; and</span>
 1536 |     | <span class='neutral'>//      &#39;[qUpper + qSpacing, +oo]&#39;, respectively. This is also the case for</span>
 1537 |     | <span class='neutral'>//      every &#39;growthMultiplier[qBoundary]&#39; where &#39;qBoundary&#39; is on the right</span>
 1538 |     | <span class='neutral'>//      side of the active liquidity interval as it is proportional to the</span>
 1539 |     | <span class='neutral'>//      amount of &#39;tag0&#39; for a single share in every interval within</span>
 1540 |     | <span class='neutral'>//      &#39;[qBoundary, +oo]&#39;.</span>
 1541 |     | <span class='neutral'>//</span>
 1542 |     | <span class='neutral'>//      On the contrary, &#39;growthMultiplier[qLower]&#39; and</span>
 1543 |     | <span class='neutral'>//      &#39;growthMultiplier[qLower - qSpacing]&#39; point towards &#39;-oo&#39;. This is</span>
 1544 |     | <span class='neutral'>//      because these two values are proportional to the the amount of &#39;tag1&#39;</span>
 1545 |     | <span class='neutral'>//      for a single share in every interval within &#39;[-oo, qLower]&#39; and</span>
 1546 |     | <span class='neutral'>//      &#39;[-oo, qLower - qSpacing]&#39;, respectively. This is also the case for</span>
 1547 |     | <span class='neutral'>//      every &#39;growthMultiplier[qBoundary]&#39; where &#39;qBoundary&#39; is on the left</span>
 1548 |     | <span class='neutral'>//      side of the active liquidity interval as it is proportional to the</span>
 1549 |     | <span class='neutral'>//      amount of &#39;tag1&#39; for a single share in every interval whithin</span>
 1550 |     | <span class='neutral'>//      &#39;[-oo, qBoundary]&#39;.</span>
 1551 |     | <span class='neutral'>//</span>
 1552 |     | <span class='neutral'>//      Instead of storing the growth value for each inactive interval, the</span>
 1553 |     | <span class='neutral'>//      protocol stores the mapping &#39;growthMultiplier&#39;.</span>
 1554 |     | <span class='neutral'>//</span>
 1555 |     | <span class='neutral'>//      This way of accounting for the growth values makes liquidity deposit or</span>
 1556 |     | <span class='neutral'>//      withdrawal by LPs more efficient. Imagine an example where an LP</span>
 1557 |     | <span class='neutral'>//      intends to deposit &#39;100&#39; shares in every interval within the range</span>
 1558 |     | <span class='neutral'>//      &#39;qLower + i * qSpacing&#39; to &#39;qUpper + j * qSpacing&#39;, where &#39;i&#39; and &#39;j&#39;</span>
 1559 |     | <span class='neutral'>//      are arbitrary positive integers. In this case, we need to calculate the</span>
 1560 |     | <span class='neutral'>//      amount of &#39;tag0&#39; corresponding to &#39;100&#39; shares in every one of the</span>
 1561 |     | <span class='neutral'>//      following intervals:</span>
 1562 |     | <span class='neutral'>//</span>
 1563 |     | <span class='neutral'>//        &#39;[qLower + i       * qSpacing, qUpper + i       * qSpacing]&#39;,</span>
 1564 |     | <span class='neutral'>//        &#39;[qLower + (i + 1) * qSpacing, qUpper + (i + 1) * qSpacing]&#39;,</span>
 1565 |     | <span class='neutral'>//          .</span>
 1566 |     | <span class='neutral'>//          .</span>
 1567 |     | <span class='neutral'>//          .</span>
 1568 |     | <span class='neutral'>//        &#39;[qLower + (j - 1) * qSpacing, qUpper + (j - 1) * qSpacing]&#39;,</span>
 1569 |     | <span class='neutral'>//        &#39;[qLower + j       * qSpacing, qUpper + j       * qSpacing]&#39;.</span>
 1570 |     | <span class='neutral'>//</span>
 1571 |     | <span class='neutral'>//      However, it may not be efficient or even possible to enumerated every</span>
 1572 |     | <span class='neutral'>//      single one of the &#39;j - i + 1&#39; intervals and thanks to</span>
 1573 |     | <span class='neutral'>//      &#39;growthMultiplier&#39;, we do not need to do that! Alternatively, the</span>
 1574 |     | <span class='neutral'>//      protocol calculates the amount of &#39;tag0&#39; that needs to be deposited</span>
 1575 |     | <span class='neutral'>//      using the following formula:</span>
 1576 |     | <span class='neutral'>//</span>
 1577 |     | <span class='neutral'>//                sqrtInverseOffset</span>
 1578 |     | <span class='neutral'>//        &#39;100 * ------------------- * (</span>
 1579 |     | <span class='neutral'>//                    2 ** 127</span>
 1580 |     | <span class='neutral'>//</span>
 1581 |     | <span class='neutral'>//                          growthMultiplier[qLower + i * qSpacing]</span>
 1582 |     | <span class='neutral'>//                         ----------------------------------------- - </span>
 1583 |     | <span class='neutral'>//                                          2 ** 208</span>
 1584 |     | <span class='neutral'>//</span>
 1585 |     | <span class='neutral'>//                          growthMultiplier[qUpper + j * qSpacing]</span>
 1586 |     | <span class='neutral'>//                         -----------------------------------------</span>
 1587 |     | <span class='neutral'>//                                          2 ** 208</span>
 1588 |     | <span class='neutral'>//         )&#39;.</span>
 1589 |     | <span class='neutral'>//</span>
 1590 |     | <span class='neutral'>//      The following figure visualizes the direction of the growth multipliers</span>
 1591 |     | <span class='neutral'>//      prior to the transition from &#39;[qLower, qUpper]&#39; to the new interval</span>
 1592 |     | <span class='neutral'>//      &#39;[qLower - qSpacing, qUpper - qSpacing]&#39;:</span>
 1593 |     | <span class='neutral'>//</span>
 1594 |     | <span class='neutral'>//                           growthMultiplier[qCurrent - qSpacing]</span>
 1595 |     | <span class='neutral'>//                                      &lt;--|</span>
 1596 |     | <span class='neutral'>//                                         |            growthMultiplier[qBack]</span>
 1597 |     | <span class='neutral'>//                                         |                           |--&gt;</span>
 1598 |     | <span class='neutral'>//                                         | growthMultiplier[qCurrent]|</span>
 1599 |     | <span class='neutral'>//                                         |          &lt;--|             |</span>
 1600 |     | <span class='neutral'>//                qLimit                   |             |             |</span>
 1601 |     | <span class='neutral'>//                   |                     |  growth(-1) |  growth(0)  |</span>
 1602 |     | <span class='neutral'>//      ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
 1603 |     | <span class='neutral'>//                                                       |             |</span>
 1604 |     | <span class='neutral'>//                                                     qNext         qBack</span>
 1605 |     | <span class='neutral'>//                                                       |</span>
 1606 |     | <span class='neutral'>//                                                    qCurrent</span>
 1607 |     | <span class='neutral'>//</span>
 1608 |     | <span class='neutral'>//      where &#39;growth(0) := growthAmended&#39;. As shown in the above figure,</span>
 1609 |     | <span class='neutral'>//      &#39;growthMultiplier[qBack]&#39; points towards &#39;+oo&#39; because it is on the</span>
 1610 |     | <span class='neutral'>//      right side of the active liquidity interval whereas</span>
 1611 |     | <span class='neutral'>//      &#39;growthMultiplier[qCurrent]&#39; and &#39;growthMultiplier[qCurrent - qSpacing]&#39;</span>
 1612 |     | <span class='neutral'>//      point towards &#39;-oo&#39; because they are on the left side of the active</span>
 1613 |     | <span class='neutral'>//      liquidity interval.</span>
 1614 |     | <span class='neutral'>//</span>
 1615 |     | <span class='neutral'>//      As part of this interval transition, we need to take the following</span>
 1616 |     | <span class='neutral'>//      steps:</span>
 1617 |     | <span class='neutral'>//      </span>
 1618 |     | <span class='neutral'>//      - &#39;growth(-1)&#39; is the value which is supposed to replace</span>
 1619 |     | <span class='neutral'>//        &#39;growthAmended&#39; in the memory space which is pointed to by</span>
 1620 |     | <span class='neutral'>//        &#39;_growth_&#39;. However, since the protocol does not store growth values</span>
 1621 |     | <span class='neutral'>//        for inactive intervals, we do not have direct access to &#39;growth(-1)&#39;.</span>
 1622 |     | <span class='neutral'>//        Because of this, we calculate it via the following formula:</span>
 1623 |     | <span class='neutral'>//</span>
 1624 |     | <span class='neutral'>//            growth(-1)       - qCurrent / 2</span>
 1625 |     | <span class='neutral'>//          &#39;------------ == e                * ( </span>
 1626 |     | <span class='neutral'>//             2 ** 111</span>
 1627 |     | <span class='neutral'>//</span>
 1628 |     | <span class='neutral'>//             growthMultiplier[qCurrent]</span>
 1629 |     | <span class='neutral'>//            ---------------------------- - </span>
 1630 |     | <span class='neutral'>//                      2 ** 208</span>
 1631 |     | <span class='neutral'>//</span>
 1632 |     | <span class='neutral'>//             growthMultiplier[qCurrent - qSpacing]</span>
 1633 |     | <span class='neutral'>//            ---------------------------------------</span>
 1634 |     | <span class='neutral'>//                           2 ** 208</span>
 1635 |     | <span class='neutral'>//           )&#39;</span>
 1636 |     | <span class='neutral'>//</span>
 1637 |     | <span class='neutral'>//      - Next, we need to recalculate &#39;growthMultiplier[qCurrent]&#39; because it</span>
 1638 |     | <span class='neutral'>//        is currently pointing to &#39;-oo&#39; since &#39;qCurrent&#39; is on the left side</span>
 1639 |     | <span class='neutral'>//        of &#39;[qLower, qUpper]&#39;. However, once we transition, &#39;qCurrent&#39; would</span>
 1640 |     | <span class='neutral'>//        be on the right side of the active liquidity interval</span>
 1641 |     | <span class='neutral'>//</span>
 1642 |     | <span class='neutral'>//          &#39;[qLower - qSpacing, qUpper - qSpacing]&#39;</span>
 1643 |     | <span class='neutral'>//</span>
 1644 |     | <span class='neutral'>//        which means that it should point to &#39;+oo&#39;. Hence,</span>
 1645 |     | <span class='neutral'>//        &#39;growthMultiplier[qCurrent]&#39; is recalculated via the following</span>
 1646 |     | <span class='neutral'>//        formula:</span>
 1647 |     | <span class='neutral'>//</span>
 1648 |     | <span class='neutral'>//            growthMultiplier[qCurrent]      growthMultiplier[qBack]</span>
 1649 |     | <span class='neutral'>//          &#39;---------------------------- := ------------------------- +</span>
 1650 |     | <span class='neutral'>//                    2 ** 208                       2 ** 208</span>
 1651 |     | <span class='neutral'>//</span>
 1652 |     | <span class='neutral'>//            growthAmended      - qCurrent / 2</span>
 1653 |     | <span class='neutral'>//           --------------- * e                &#39;.</span>
 1654 |     | <span class='neutral'>//              2 ** 111</span>
 1655 |     | <span class='neutral'>//</span>
 1656 |     | <span class='neutral'>//        Observe that according to the above formula, &#39;growthAmended&#39; is</span>
 1657 |     | <span class='neutral'>//        incorporated into &#39;growthMultiplier[qCurrent]&#39; which is where it is</span>
 1658 |     | <span class='neutral'>//        kept track of.</span>
 1659 |     | <span class='neutral'>//</span>
 1660 |     | <span class='neutral'>//      The following figure illustrates the above modification of the</span>
 1661 |     | <span class='neutral'>//      &#39;growthMultiplier&#39; mapping:</span>
 1662 |     | <span class='neutral'>//</span>
 1663 |     | <span class='neutral'>//                           growthMultiplier[qCurrent - qSpacing]</span>
 1664 |     | <span class='neutral'>//                                      &lt;--|</span>
 1665 |     | <span class='neutral'>//                                         |            growthMultiplier[qBack]</span>
 1666 |     | <span class='neutral'>//                                         |                           |--&gt;</span>
 1667 |     | <span class='neutral'>//                                         | growthMultiplier[qCurrent]|</span>
 1668 |     | <span class='neutral'>//                                         |             |--&gt;          |</span>
 1669 |     | <span class='neutral'>//                qLimit                   |             |             |</span>
 1670 |     | <span class='neutral'>//                   |                     |             |             |</span>
 1671 |     | <span class='neutral'>//      ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
 1672 |     | <span class='neutral'>//                                                       |             |</span>
 1673 |     | <span class='neutral'>//                                                     qNext         qBack</span>
 1674 |     | <span class='neutral'>//                                                       |</span>
 1675 |     | <span class='neutral'>//                                                    qCurrent</span>
 1676 |     | <span class='neutral'>//</span>
 1677 |     | <span class='neutral'>//    - &#39;qBack&#39; and &#39;qNext&#39;: Since we are dealing with a price decreasing swap,</span>
 1678 |     | <span class='neutral'>//      the values &#39;qBack&#39; and &#39;qNext&#39; should be modified as follows in order</span>
 1679 |     | <span class='neutral'>//      to represent the new liquidity interval that we are transitioning to:</span>
 1680 |     | <span class='neutral'>//</span>
 1681 |     | <span class='neutral'>//        &#39;qBack -= qSpacing&#39;,</span>
 1682 |     | <span class='neutral'>//        &#39;qNext -= qSpacing&#39;.</span>
 1683 |     | <span class='neutral'>//</span>
 1684 |     | <span class='neutral'>//      which is illustrated below:</span>
 1685 |     | <span class='neutral'>//</span>
 1686 |     | <span class='neutral'>//                qLimit                              qCurrent</span>
 1687 |     | <span class='neutral'>//                   |                                   |</span>
 1688 |     | <span class='neutral'>//      ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
 1689 |     | <span class='neutral'>//                                         |             |</span>
 1690 |     | <span class='neutral'>//                                       qNext         qBack</span>
 1691 |     | <span class='neutral'>//    </span>
 1692 |     | <span class='neutral'>//    - &#39;curve&#39;: As we discussed before, since</span>
 1693 |     | <span class='neutral'>//</span>
 1694 |     | <span class='neutral'>//          &#39;[qLower - qSpacing, qUpper - qSpacing]&#39;</span>
 1695 |     | <span class='neutral'>//</span>
 1696 |     | <span class='neutral'>//      is currently inactive, its corresponding curve sequence is composed of</span>
 1697 |     | <span class='neutral'>//      only two members:</span>
 1698 |     | <span class='neutral'>//</span>
 1699 |     | <span class='neutral'>//      &#39;q[0] := qUpper - qSpacing&#39;,</span>
 1700 |     | <span class='neutral'>//      &#39;q[1] := qLower - qSpacing&#39;.</span>
 1701 |     | <span class='neutral'>//</span>
 1702 |     | <span class='neutral'>//      As part of the transition, we discard the previous curve sequence and</span>
 1703 |     | <span class='neutral'>//      initiate this above curve sequence in memory.</span>
 1704 |     | <span class='neutral'>//</span>
 1705 |     | <span class='neutral'>//    Now, the transition to &#39;[qLower - qSpacing, qUpper - qSpacing]&#39; is</span>
 1706 |     | <span class='neutral'>//    complete and throughout the remainder of this example, we refer to this</span>
 1707 |     | <span class='neutral'>//    interval as the active liquidity interval. Additionally, we redefine:</span>
 1708 |     | <span class='neutral'>//</span>
 1709 |     | <span class='neutral'>//      &#39;qUpper := qUpper - qSpacing&#39;, </span>
 1710 |     | <span class='neutral'>//      &#39;qLower := qLower - qSpacing&#39;</span>
 1711 |     | <span class='neutral'>//</span>
 1712 |     | <span class='neutral'>//    which allows us to continue using the notation &#39;[qLower, qUpper]&#39; in</span>
 1713 |     | <span class='neutral'>//    order to refer to the active liquidity interval.</span>
 1714 |     | <span class='neutral'>//</span>
 1715 |     | <span class='neutral'>//  - In this step, we need to determine whether we should explore the active</span>
 1716 |     | <span class='neutral'>//    interval &#39;[qLower, qUpper]&#39; or to cross it entirely, i.e., all the way</span>
 1717 |     | <span class='neutral'>//    from &#39;qBack&#39; to &#39;qNext&#39;. In the former case, we need to integrate the</span>
 1718 |     | <span class='neutral'>//    liquidity distribution function &#39;k(w(.))&#39; piece by piece through which</span>
 1719 |     | <span class='neutral'>//    the &#39;incomingCurrentToTarget&#39; and &#39;currentToTarget&#39; are calculated. As we</span>
 1720 |     | <span class='neutral'>//    discussed before, the calculation of these integrals leads to</span>
 1721 |     | <span class='neutral'>//    &#39;amount0Partial&#39; and &#39;amount1Partial&#39;, respectively. However, the latter</span>
 1722 |     | <span class='neutral'>//    case is more efficient because if the active interval is crossed </span>
 1723 |     | <span class='neutral'>//    entirely, then the precalculated integrals &#39;incomingMax&#39; and</span>
 1724 |     | <span class='neutral'>//    &#39;outgoingMax&#39; can be used to determine &#39;amount0Partial&#39; and</span>
 1725 |     | <span class='neutral'>//    &#39;amount1Partial&#39;. In order for the protocol to be able to cross the</span>
 1726 |     | <span class='neutral'>//    active interval entirely the following two criteria should be met:</span>
 1727 |     | <span class='neutral'>//</span>
 1728 |     | <span class='neutral'>//    (a) The cross must not violate &#39;qLimit&#39;. In other words, for price</span>
 1729 |     | <span class='neutral'>//        increasing swaps we should have</span>
 1730 |     | <span class='neutral'>//</span>
 1731 |     | <span class='neutral'>//          &#39;qNext &lt;= qLimit&#39;</span>
 1732 |     | <span class='neutral'>//</span>
 1733 |     | <span class='neutral'>//        and for price decreasing swaps, we should have</span>
 1734 |     | <span class='neutral'>//</span>
 1735 |     | <span class='neutral'>//          &#39;qLimit &lt;= qNext&#39;.</span>
 1736 |     | <span class='neutral'>//</span>
 1737 |     | <span class='neutral'>//        which is the case in the present example.</span>
 1738 |     | <span class='neutral'>//</span>
 1739 |     | <span class='neutral'>//    (b) The cross must not violate &#39;amountSpecified&#39;. In order words, if</span>
 1740 |     | <span class='neutral'>//        &#39;exactInput == false&#39;, then the outgoing amount from the pool as a</span>
 1741 |     | <span class='neutral'>//        result of crossing all the way from &#39;qBack&#39; to &#39;qNext&#39; must not</span>
 1742 |     | <span class='neutral'>//        exceed the remaining absolute value &#39;0 - amountSpecified&#39;. Similarly,</span>
 1743 |     | <span class='neutral'>//        if &#39;exactInput == true&#39;, then the incoming amount to the pool as a</span>
 1744 |     | <span class='neutral'>//        result of crossing all the way from &#39;qBack&#39; to &#39;qNext&#39; must not</span>
 1745 |     | <span class='neutral'>//        exceed the remaining value &#39;amountSpecified&#39;.</span>
 1746 |     | <span class='neutral'>//</span>
 1747 |     | <span class='neutral'>//        In order to verify this, we first need to recalculate &#39;integralLimit&#39;</span>
 1748 |     | <span class='neutral'>//        based on the decremented value for &#39;|amountSpecified|&#39;:</span>
 1749 |     | <span class='neutral'>//        </span>
 1750 |     | <span class='neutral'>//          &#39;integralLimit :=</span>
 1751 |     | <span class='neutral'>//</span>
 1752 |     | <span class='neutral'>//                          |amountSpecified|          1          2 ** 111</span>
 1753 |     | <span class='neutral'>//           outgoingMax * ------------------- * ------------- * ----------</span>
 1754 |     | <span class='neutral'>//                          sqrtInverseOffset     sharesTotal      growth</span>
 1755 |     | <span class='neutral'>//</span>
 1756 |     | <span class='neutral'>//           == +oo&#39;.</span>
 1757 |     | <span class='neutral'>//</span>
 1758 |     | <span class='neutral'>//        which remains equal to &#39;+oo&#39; for this example.</span>
 1759 |     | <span class='neutral'>//</span>
 1760 |     | <span class='neutral'>//        Next, we need to define the notion of &#39;integralLimitInterval&#39; which</span>
 1761 |     | <span class='neutral'>//        is compared with &#39;integralLimit&#39; in order to determine if</span>
 1762 |     | <span class='neutral'>//        &#39;amountSpecified&#39; is violated or not. Consider the following four</span>
 1763 |     | <span class='neutral'>//        scenarios:</span>
 1764 |     | <span class='neutral'>//</span>
 1765 |     | <span class='neutral'>//        - If the swap is price increasing and &#39;exactInput == false&#39;, define:</span>
 1766 |     | <span class='neutral'>//</span>
 1767 |     | <span class='neutral'>//                                         - 8     / qUpper</span>
 1768 |     | <span class='neutral'>//            integralLimitInterval      e        |    - h / 2</span>
 1769 |     | <span class='neutral'>//          &#39;----------------------- := ------- * |  e         k(h - qLower) dh</span>
 1770 |     | <span class='neutral'>//                   2 ** 216              2      |</span>
 1771 |     | <span class='neutral'>//                                               / qLower</span>
 1772 |     | <span class='neutral'>//</span>
 1773 |     | <span class='neutral'>//                - qLower / 2    outgoingMax</span>
 1774 |     | <span class='neutral'>//           == e              * -------------&#39;</span>
 1775 |     | <span class='neutral'>//                                 2 ** 216</span>
 1776 |     | <span class='neutral'>//</span>
 1777 |     | <span class='neutral'>//        - If the swap is price increasing and &#39;exactInput == true&#39;, define:</span>
 1778 |     | <span class='neutral'>//</span>
 1779 |     | <span class='neutral'>//                                         - 8     / qUpper</span>
 1780 |     | <span class='neutral'>//            integralLimitInterval      e        |    + h / 2</span>
 1781 |     | <span class='neutral'>//          &#39;----------------------- := ------- * |  e         k(h - qLower) dh</span>
 1782 |     | <span class='neutral'>//                   2 ** 216              2      |</span>
 1783 |     | <span class='neutral'>//                                               / qLower</span>
 1784 |     | <span class='neutral'>//</span>
 1785 |     | <span class='neutral'>//                + qUpper / 2    incomingMax</span>
 1786 |     | <span class='neutral'>//           == e              * -------------&#39;</span>
 1787 |     | <span class='neutral'>//                                 2 ** 216</span>
 1788 |     | <span class='neutral'>//</span>
 1789 |     | <span class='neutral'>//        - If the swap is price decreasing and &#39;exactInput == false&#39;, define:</span>
 1790 |     | <span class='neutral'>//</span>
 1791 |     | <span class='neutral'>//                                         - 8     / qUpper</span>
 1792 |     | <span class='neutral'>//            integralLimitInterval      e        |    + h / 2</span>
 1793 |     | <span class='neutral'>//          &#39;----------------------- := ------- * |  e         k(qUpper - h) dh</span>
 1794 |     | <span class='neutral'>//                   2 ** 216              2      |</span>
 1795 |     | <span class='neutral'>//                                               / qLower</span>
 1796 |     | <span class='neutral'>//</span>
 1797 |     | <span class='neutral'>//                + qUpper / 2    outgoingMax</span>
 1798 |     | <span class='neutral'>//           == e              * -------------&#39;</span>
 1799 |     | <span class='neutral'>//                                 2 ** 216</span>
 1800 |     | <span class='neutral'>//</span>
 1801 |     | <span class='neutral'>//        - If the swap is price decreasing and &#39;exactInput == true&#39;, define:</span>
 1802 |     | <span class='neutral'>//</span>
 1803 |     | <span class='neutral'>//                                         - 8     / qUpper</span>
 1804 |     | <span class='neutral'>//            integralLimitInterval      e        |    - h / 2</span>
 1805 |     | <span class='neutral'>//          &#39;----------------------- := ------- * |  e         k(qUpper - h) dh</span>
 1806 |     | <span class='neutral'>//                   2 ** 216              2      |</span>
 1807 |     | <span class='neutral'>//                                               / qLower</span>
 1808 |     | <span class='neutral'>//</span>
 1809 |     | <span class='neutral'>//                - qLower / 2    incomingMax</span>
 1810 |     | <span class='neutral'>//           == e              * -------------&#39;</span>
 1811 |     | <span class='neutral'>//                                 2 ** 216</span>
 1812 |     | <span class='neutral'>// </span>
 1813 |     | <span class='neutral'>//        In the first and the fourth cases above, &#39;amountSpecified&#39; is in</span>
 1814 |     | <span class='neutral'>//        &#39;tag0&#39;. By crossing the active interval entirely, the absolute value</span>
 1815 |     | <span class='neutral'>//        &#39;|amountSpecified|&#39; is decremented by:</span>
 1816 |     | <span class='neutral'>//</span>
 1817 |     | <span class='neutral'>//                                               growth</span>
 1818 |     | <span class='neutral'>//          &#39;sqrtInverseOffset * sharesTotal * ---------- * </span>
 1819 |     | <span class='neutral'>//                                              2 ** 111</span>
 1820 |     | <span class='neutral'>//            integralLimitInterval</span>
 1821 |     | <span class='neutral'>//           -----------------------&#39;,</span>
 1822 |     | <span class='neutral'>//                 outgoingMax</span>
 1823 |     | <span class='neutral'>// </span>
 1824 |     | <span class='neutral'>//        In the second and the third cases above, &#39;amountSpecified&#39; is in</span>
 1825 |     | <span class='neutral'>//        &#39;tag1&#39;. By crossing the active interval entirely, the absolute value</span>
 1826 |     | <span class='neutral'>//        &#39;|amountSpecified|&#39; is decremented by:</span>
 1827 |     | <span class='neutral'>//</span>
 1828 |     | <span class='neutral'>//                                        growth      integralLimitInterval</span>
 1829 |     | <span class='neutral'>//          &#39;sqrtOffset * sharesTotal * ---------- * -----------------------&#39;,</span>
 1830 |     | <span class='neutral'>//                                       2 ** 111          outgoingMax</span>
 1831 |     | <span class='neutral'>//</span>
 1832 |     | <span class='neutral'>//        Hence, in both cases, by crossing the active interval, the limit</span>
 1833 |     | <span class='neutral'>//        imposed by &#39;amountSpecified&#39; is not violated if and only if:</span>
 1834 |     | <span class='neutral'>//        </span>
 1835 |     | <span class='neutral'>//          &#39;integralLimitInterval &lt;= integralLimit&#39;.</span>
 1836 |     | <span class='neutral'>//</span>
 1837 |     | <span class='neutral'>//    In the present example, since &#39;integralLimit == +oo&#39; and</span>
 1838 |     | <span class='neutral'>//    &#39;qLimit &lt;= qNext&#39; both (a) and (b) are satisfied which means that we can</span>
 1839 |     | <span class='neutral'>//    cross the active interval and move the price to &#39;qNext&#39; directly, while</span>
 1840 |     | <span class='neutral'>//    determining the outgoing and incoming amounts based on the precalculated</span>
 1841 |     | <span class='neutral'>//    parameters of the pool.</span>
 1842 |     | <span class='neutral'>//</span>
 1843 |     | <span class='neutral'>//    Once again, before the execution of this cross, we need to verify the</span>
 1844 |     | <span class='neutral'>//    condition, &#39;sharesTotal &gt;= crossThreshold&#39;. If not met, the swap call is</span>
 1845 |     | <span class='neutral'>//    halted and the current values accumulated as &#39;amount0&#39; and &#39;amount1&#39; are</span>
 1846 |     | <span class='neutral'>//    exchanged.</span>
 1847 |     | <span class='neutral'>//</span>
 1848 |     | <span class='neutral'>//  - In order to move the price from &#39;qBack&#39; to &#39;qNext&#39;, we need to update a</span>
 1849 |     | <span class='neutral'>//    number of parameters, including:</span>
 1850 |     | <span class='neutral'>//</span>
 1851 |     | <span class='neutral'>//    - &#39;amount0&#39;: According to the above formulas, as we move the price all</span>
 1852 |     | <span class='neutral'>//      the way from &#39;qBack&#39; to &#39;qNext&#39;, &#39;amount0&#39; should be incremented by:</span>
 1853 |     | <span class='neutral'>//</span>
 1854 |     | <span class='neutral'>//                                                               growth</span>
 1855 |     | <span class='neutral'>//        &#39;amount0Partial == sqrtInverseOffset * sharesTotal * ---------- *</span>
 1856 |     | <span class='neutral'>//                                                              2 ** 111</span>
 1857 |     | <span class='neutral'>//          incomingMax      - qLower / 2</span>
 1858 |     | <span class='neutral'>//         ------------- * e              &#39;.</span>
 1859 |     | <span class='neutral'>//          outgoingMax</span>
 1860 |     | <span class='neutral'>//</span>
 1861 |     | <span class='neutral'>//    - &#39;amount1&#39;: According to the above formulas, as we move the price all</span>
 1862 |     | <span class='neutral'>//      the way from &#39;qBack&#39; to &#39;qNext&#39;, &#39;amount1&#39; should be decremented by:</span>
 1863 |     | <span class='neutral'>//</span>
 1864 |     | <span class='neutral'>//                                                        growth</span>
 1865 |     | <span class='neutral'>//        &#39;amount1Partial == sqrtOffset * sharesTotal * ---------- * </span>
 1866 |     | <span class='neutral'>//                                                       2 ** 111</span>
 1867 |     | <span class='neutral'>//                             + qUpper / 2</span>
 1868 |     | <span class='neutral'>//                           e              &#39;.</span>
 1869 |     | <span class='neutral'>//</span>
 1870 |     | <span class='neutral'>//    - &#39;amountSpecified&#39;: Since the swap is partially fulfilled, we should</span>
 1871 |     | <span class='neutral'>//      decrement &#39;amountSpecified&#39; by &#39;amount0Partial&#39; to reflect this:</span>
 1872 |     | <span class='neutral'>//</span>
 1873 |     | <span class='neutral'>//        &#39;amountSpecified -= amount0Partial&#39;.</span>
 1874 |     | <span class='neutral'>//</span>
 1875 |     | <span class='neutral'>//    - &#39;curve&#39;: Following the pattern that was introduced earlier, for</span>
 1876 |     | <span class='neutral'>//      inactive liquidity intervals, the amended curve sequence for</span>
 1877 |     | <span class='neutral'>//      &#39;[qLower, qUpper]&#39; should be:</span>
 1878 |     | <span class='neutral'>//</span>
 1879 |     | <span class='neutral'>//        &#39;q[0] := qUpper&#39;,</span>
 1880 |     | <span class='neutral'>//        &#39;q[1] := qLower&#39;.</span>
 1881 |     | <span class='neutral'>//</span>
 1882 |     | <span class='neutral'>//      This amendment, transforms the function &#39;w&#39; associated with</span>
 1883 |     | <span class='neutral'>//      &#39;[qLower, qUpper]&#39; from the following:</span>
 1884 |     | <span class='neutral'>//</span>
 1885 |     | <span class='neutral'>//            w(q)</span>
 1886 |     | <span class='neutral'>//              ^</span>
 1887 |     | <span class='neutral'>//      spacing |\</span>
 1888 |     | <span class='neutral'>//              | \</span>
 1889 |     | <span class='neutral'>//              |  \</span>
 1890 |     | <span class='neutral'>//              |   \</span>
 1891 |     | <span class='neutral'>//              |    \</span>
 1892 |     | <span class='neutral'>//              |     \</span>
 1893 |     | <span class='neutral'>//              |      \</span>
 1894 |     | <span class='neutral'>//              |       \</span>
 1895 |     | <span class='neutral'>//              |        \</span>
 1896 |     | <span class='neutral'>//              |         \</span>
 1897 |     | <span class='neutral'>//              |          \</span>
 1898 |     | <span class='neutral'>//              |           \</span>
 1899 |     | <span class='neutral'>//              |            \</span>
 1900 |     | <span class='neutral'>//              |             \</span>
 1901 |     | <span class='neutral'>//              |              \</span>
 1902 |     | <span class='neutral'>//              |               \</span>
 1903 |     | <span class='neutral'>//              |                \</span>
 1904 |     | <span class='neutral'>//            0 +-----------------+-&gt; q</span>
 1905 |     | <span class='neutral'>//           qLower               |</span>
 1906 |     | <span class='neutral'>//                              qUpper</span>
 1907 |     | <span class='neutral'>//                                |</span>
 1908 |     | <span class='neutral'>//                            qCurrent</span>
 1909 |     | <span class='neutral'>//</span>
 1910 |     | <span class='neutral'>//      to a new function:</span>
 1911 |     | <span class='neutral'>//</span>
 1912 |     | <span class='neutral'>//        &#39;wAmended(q) := q - qLower&#39;</span>
 1913 |     | <span class='neutral'>//</span>
 1914 |     | <span class='neutral'>//      which can be plotted as follows:</span>
 1915 |     | <span class='neutral'>//</span>
 1916 |     | <span class='neutral'>//          wAmended(q)</span>
 1917 |     | <span class='neutral'>//              ^</span>
 1918 |     | <span class='neutral'>//      spacing |                /</span>
 1919 |     | <span class='neutral'>//              |               /</span>
 1920 |     | <span class='neutral'>//              |              /</span>
 1921 |     | <span class='neutral'>//              |             /</span>
 1922 |     | <span class='neutral'>//              |            /</span>
 1923 |     | <span class='neutral'>//              |           /</span>
 1924 |     | <span class='neutral'>//              |          /</span>
 1925 |     | <span class='neutral'>//              |         /</span>
 1926 |     | <span class='neutral'>//              |        /</span>
 1927 |     | <span class='neutral'>//              |       /</span>
 1928 |     | <span class='neutral'>//              |      /</span>
 1929 |     | <span class='neutral'>//              |     /</span>
 1930 |     | <span class='neutral'>//              |    /</span>
 1931 |     | <span class='neutral'>//              |   /</span>
 1932 |     | <span class='neutral'>//              |  /</span>
 1933 |     | <span class='neutral'>//              | /</span>
 1934 |     | <span class='neutral'>//              |/</span>
 1935 |     | <span class='neutral'>//            0 +-----------------+-&gt; q</span>
 1936 |     | <span class='neutral'>//           qLower               |</span>
 1937 |     | <span class='neutral'>//                              qUpper</span>
 1938 |     | <span class='neutral'>//</span>
 1939 |     | <span class='neutral'>//      As we will demonstrate next, this procedure results in growth for</span>
 1940 |     | <span class='neutral'>//      liquidity providers.</span>
 1941 |     | <span class='neutral'>//</span>
 1942 |     | <span class='neutral'>//    - &#39;growth&#39;: As discussed earlier, since the liquidity distribution</span>
 1943 |     | <span class='neutral'>//      function &#39;k(w(.))&#39; is modified to &#39;k(wAmended(.))&#39;, we need to make an</span>
 1944 |     | <span class='neutral'>//      adjustment to the &#39;growth&#39; value and turn it into &#39;growthAmended&#39;.</span>
 1945 |     | <span class='neutral'>//      In order to determine &#39;growthAmended&#39;, the following equation is</span>
 1946 |     | <span class='neutral'>//      solved:</span>
 1947 |     | <span class='neutral'>//</span>
 1948 |     | <span class='neutral'>//        &#39;totalReserveOfTag0Before == totalReserveOfTag0After&#39;</span>
 1949 |     | <span class='neutral'>//</span>
 1950 |     | <span class='neutral'>//      where &#39;totalReserveOfTag0Before&#39; is the total amount of &#39;tag0&#39; within</span>
 1951 |     | <span class='neutral'>//      &#39;[qLower, qUpper]&#39; which is calculated based on &#39;k(w(.))&#39;, whereas</span>
 1952 |     | <span class='neutral'>//      &#39;totalReserveOfTag0After&#39; is the same value calculated based on</span>
 1953 |     | <span class='neutral'>//      &#39;k(wAmended(.))&#39;. The two sides of the equation can be derived as:</span>
 1954 |     | <span class='neutral'>//</span>
 1955 |     | <span class='neutral'>//        &#39;totalReserveOfTag0Before == sqrtInverseOffset * sharesTotal * </span>
 1956 |     | <span class='neutral'>//</span>
 1957 |     | <span class='neutral'>//                                         - 8     / qUpper</span>
 1958 |     | <span class='neutral'>//           growth       2 ** 216       e        |    - h / 2</span>
 1959 |     | <span class='neutral'>//         ---------- * ------------- * ------- * |  e         k(w(h)) dh ==</span>
 1960 |     | <span class='neutral'>//          2 ** 111     outgoingMax       2      |</span>
 1961 |     | <span class='neutral'>//                                               / qLower</span>
 1962 |     | <span class='neutral'>//</span>
 1963 |     | <span class='neutral'>//                                             growth       2 ** 216</span>
 1964 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * ---------- * ------------- *</span>
 1965 |     | <span class='neutral'>//                                            2 ** 111     outgoingMax</span>
 1966 |     | <span class='neutral'>//</span>
 1967 |     | <span class='neutral'>//            - 8     / qUpper</span>
 1968 |     | <span class='neutral'>//          e        |    - h / 2</span>
 1969 |     | <span class='neutral'>//         ------- * |  e         k(qUpper - h) dh ==</span>
 1970 |     | <span class='neutral'>//            2      |</span>
 1971 |     | <span class='neutral'>//                  / qLower</span>
 1972 |     | <span class='neutral'>//</span>
 1973 |     | <span class='neutral'>//                                             growth</span>
 1974 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * ---------- * </span>
 1975 |     | <span class='neutral'>//                                            2 ** 111</span>
 1976 |     | <span class='neutral'>//</span>
 1977 |     | <span class='neutral'>//          incomingMax      - qLower / 2</span>
 1978 |     | <span class='neutral'>//         ------------- * e              &#39;.</span>
 1979 |     | <span class='neutral'>//          outgoingMax</span>
 1980 |     | <span class='neutral'>//</span>
 1981 |     | <span class='neutral'>//      and</span>
 1982 |     | <span class='neutral'>//</span>
 1983 |     | <span class='neutral'>//        &#39;totalReserveOfTag0After ==</span>
 1984 |     | <span class='neutral'>//</span>
 1985 |     | <span class='neutral'>//                                            growthAmended</span>
 1986 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * --------------- * </span>
 1987 |     | <span class='neutral'>//                                              2 ** 111</span>
 1988 |     | <span class='neutral'>//</span>
 1989 |     | <span class='neutral'>//                            - 8     / qUpper</span>
 1990 |     | <span class='neutral'>//            2 ** 216      e        |    - h / 2</span>
 1991 |     | <span class='neutral'>//         ------------- * ------- * |  e         k(h - qLower) dh&#39; == </span>
 1992 |     | <span class='neutral'>//          outgoingMax       2      |</span>
 1993 |     | <span class='neutral'>//                                  / qLower</span>
 1994 |     | <span class='neutral'>//</span>
 1995 |     | <span class='neutral'>//                                            growthAmended</span>
 1996 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * --------------- *</span>
 1997 |     | <span class='neutral'>//                                              2 ** 111</span>
 1998 |     | <span class='neutral'>//</span>
 1999 |     | <span class='neutral'>//           - qLower / 2</span>
 2000 |     | <span class='neutral'>//         e              &#39;.</span>
 2001 |     | <span class='neutral'>//</span>
 2002 |     | <span class='neutral'>//</span>
 2003 |     | <span class='neutral'>//      Hence, &#39;growthAmended&#39; is given by the following formula:</span>
 2004 |     | <span class='neutral'>//</span>
 2005 |     | <span class='neutral'>//                                    incomingMax</span>
 2006 |     | <span class='neutral'>//        &#39;growthAmended == growth * -------------&#39;.</span>
 2007 |     | <span class='neutral'>//                                    outgoingMax</span>
 2008 |     | <span class='neutral'>//</span>
 2009 |     | <span class='neutral'>//      As proven earlier, &#39;incomingMax&#39; is always greater than or equal to</span>
 2010 |     | <span class='neutral'>//      &#39;outgoingMax&#39;. Hence, crossing the active interval results in growth.</span>
 2011 |     | <span class='neutral'>//</span>
 2012 |     | <span class='neutral'>//    - &#39;qCurrent&#39;: Lastly, as we move the price of the pool to &#39;qNext&#39;, the</span>
 2013 |     | <span class='neutral'>//      value for &#39;qCurrent&#39; should be updated to reflect this change., which</span>
 2014 |     | <span class='neutral'>//      is illustrated as follows:</span>
 2015 |     | <span class='neutral'>//</span>
 2016 |     | <span class='neutral'>//                qLimit                qCurrent</span>
 2017 |     | <span class='neutral'>//                   |                     |</span>
 2018 |     | <span class='neutral'>//      ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
 2019 |     | <span class='neutral'>//                                         |             |</span>
 2020 |     | <span class='neutral'>//                                       qNext         qBack</span>
 2021 |     | <span class='neutral'>//</span>
 2022 |     | <span class='neutral'>//  - Similar to the prior steps, as we reach &#39;qNext&#39;, we transition from the</span>
 2023 |     | <span class='neutral'>//    original liquidity interval &#39;[qLower, qUpper]&#39; to its adjacent interval</span>
 2024 |     | <span class='neutral'>//    &#39;[qLower - qSpacing, qUpper - qSpacing]&#39;. This transition involves the</span>
 2025 |     | <span class='neutral'>//    adjustment of growth multipliers. In addition we need to update &#39;growth&#39;</span>
 2026 |     | <span class='neutral'>//    &#39;sharesTotal&#39;, &#39;qBack&#39;, &#39;qNext&#39;, as well as the curve sequence. The new</span>
 2027 |     | <span class='neutral'>//    status of the pool following this transition is illustrated as follows:</span>
 2028 |     | <span class='neutral'>//</span>
 2029 |     | <span class='neutral'>//                qLimit                qCurrent</span>
 2030 |     | <span class='neutral'>//                   |                     |</span>
 2031 |     | <span class='neutral'>//      ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
 2032 |     | <span class='neutral'>//                           |             |</span>
 2033 |     | <span class='neutral'>//                         qNext         qBack</span>
 2034 |     | <span class='neutral'>//</span>
 2035 |     | <span class='neutral'>//  - Similar to the prior steps, as we transition to a new liquidity interval,</span>
 2036 |     | <span class='neutral'>//    we determine whether we should cross this new active interval entirely or</span>
 2037 |     | <span class='neutral'>//    not. In the present example, since &#39;qLimit &lt;= qNext&#39; and </span>
 2038 |     | <span class='neutral'>//    &#39;amountSpecified == +oo&#39;, we need to cross one more time. This action</span>
 2039 |     | <span class='neutral'>//    will modify &#39;amount0&#39;, &#39;amount1&#39;, &#39;growth&#39;, as well as the curve</span>
 2040 |     | <span class='neutral'>//    sequence. Additionally, crossing the active interval moves &#39;qCurrent&#39; to</span>
 2041 |     | <span class='neutral'>//    &#39;qNext&#39; which is illustrated below:</span>
 2042 |     | <span class='neutral'>//</span>
 2043 |     | <span class='neutral'>//                        qCurrent</span>
 2044 |     | <span class='neutral'>//                qLimit     |</span>
 2045 |     | <span class='neutral'>//                   |       |</span>
 2046 |     | <span class='neutral'>//      ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
 2047 |     | <span class='neutral'>//                           |             |</span>
 2048 |     | <span class='neutral'>//                         qNext         qBack</span>
 2049 |     | <span class='neutral'>//</span>
 2050 |     | <span class='neutral'>//  - Next, we need to perform another transition in order to enter the</span>
 2051 |     | <span class='neutral'>//    liquidity interval that contains &#39;qLimit&#39;. The new status of the pool</span>
 2052 |     | <span class='neutral'>//    following this transition is illustrated as follows:</span>
 2053 |     | <span class='neutral'>//</span>
 2054 |     | <span class='neutral'>//                        qCurrent</span>
 2055 |     | <span class='neutral'>//                qLimit     |</span>
 2056 |     | <span class='neutral'>//                   |       |</span>
 2057 |     | <span class='neutral'>//      ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
 2058 |     | <span class='neutral'>//             |             |</span>
 2059 |     | <span class='neutral'>//           qNext         qBack</span>
 2060 |     | <span class='neutral'>//  </span>
 2061 |     | <span class='neutral'>//  - Once again, as we transition to a new liquidity interval, we determine</span>
 2062 |     | <span class='neutral'>//    whether we should cross this new active interval entirely or not. This,</span>
 2063 |     | <span class='neutral'>//    time, since &#39;qNext &lt; qLimit&#39;, we should transact within the active</span>
 2064 |     | <span class='neutral'>//    interval as opposed to crossing it. To this end, we move the price</span>
 2065 |     | <span class='neutral'>//    towards &#39;qNext&#39; until either of the following conditions are met:</span>
 2066 |     | <span class='neutral'>//</span>
 2067 |     | <span class='neutral'>//    (a) &#39;amountSpecified&#39; is fulfilled.</span>
 2068 |     | <span class='neutral'>//</span>
 2069 |     | <span class='neutral'>//    (b) &#39;qLimit&#39; is reached.</span>
 2070 |     | <span class='neutral'>//</span>
 2071 |     | <span class='neutral'>//    We move the price from &#39;qCurrent&#39; towards &#39;qNext&#39; by enumerating pieces</span>
 2072 |     | <span class='neutral'>//    of the present liquidity distribution function &#39;k(w(.))&#39;. To this end,</span>
 2073 |     | <span class='neutral'>//    the memory pointers &#39;_begin_&#39; and &#39;_target_&#39; are used in order to keep</span>
 2074 |     | <span class='neutral'>//    track of the two endpoints for the current piece under exploration. Here,</span>
 2075 |     | <span class='neutral'>//    we refer to these endpoints as &#39;qBegin&#39; and &#39;qTarget&#39;.</span>
 2076 |     | <span class='neutral'>//</span>
 2077 |     | <span class='neutral'>//    We start with &#39;qBegin == qCurrent&#39; and move forward by continuously</span>
 2078 |     | <span class='neutral'>//    updating &#39;qBegin&#39; and &#39;qTarget&#39;. In each step, the integrals</span>
 2079 |     | <span class='neutral'>//    &#39;currentToTarget&#39; and &#39;incomingCurrentToTarget&#39; are incremented to</span>
 2080 |     | <span class='neutral'>//    account for the outgoing amount from the pool and the incoming amount to</span>
 2081 |     | <span class='neutral'>//    the pool.</span>
 2082 |     | <span class='neutral'>//</span>
 2083 |     | <span class='neutral'>//    While incrementing the two integrals, we need to continuously monitor</span>
 2084 |     | <span class='neutral'>//    condition (a). To that end, we once again calculate &#39;integralLimit&#39;</span>
 2085 |     | <span class='neutral'>//</span>
 2086 |     | <span class='neutral'>//      &#39;integralLimit := outgoingMax * </span>
 2087 |     | <span class='neutral'>//</span>
 2088 |     | <span class='neutral'>//        |amountSpecified|          1          2 ** 111</span>
 2089 |     | <span class='neutral'>//       ------------------- * ------------- * ---------- == +oo&#39;.</span>
 2090 |     | <span class='neutral'>//        sqrtInverseOffset     sharesTotal      growth</span>
 2091 |     | <span class='neutral'>//</span>
 2092 |     | <span class='neutral'>//    With each increment of &#39;incomingCurrentToTarget&#39; we check whether it has</span>
 2093 |     | <span class='neutral'>//    exceeded &#39;integralLimit&#39; in which case the swap is halted (alternatively,</span>
 2094 |     | <span class='neutral'>//    in the case where &#39;exactInput == false&#39;, we need to continuously check</span>
 2095 |     | <span class='neutral'>//    whether &#39;currentToTarget&#39; has exceeded &#39;integralLimit&#39; or not). However,</span>
 2096 |     | <span class='neutral'>//    this stopping criteria does not apply to this example because</span>
 2097 |     | <span class='neutral'>//    &#39;integralLimit == +oo&#39;.</span>
 2098 |     | <span class='neutral'>//</span>
 2099 |     | <span class='neutral'>//    Hence, we can move forward until the stopping criteria (b) is met, i.e.,</span>
 2100 |     | <span class='neutral'>//    until</span>
 2101 |     | <span class='neutral'>//</span>
 2102 |     | <span class='neutral'>//      &#39;qTarget == qLimit&#39;.</span>
 2103 |     | <span class='neutral'>//</span>
 2104 |     | <span class='neutral'>//    Once the above condition is met, we need to update a number of</span>
 2105 |     | <span class='neutral'>//    parameters, including:</span>
 2106 |     | <span class='neutral'>//</span>
 2107 |     | <span class='neutral'>//    - &#39;amount0&#39;: As discussed in the prior steps, the following increment</span>
 2108 |     | <span class='neutral'>//      should be applied to &#39;amount0&#39;:</span>
 2109 |     | <span class='neutral'>//                                                               growth</span>
 2110 |     | <span class='neutral'>//        &#39;amount0Partial := sqrtInverseOffset * sharesTotal * ---------- *</span>
 2111 |     | <span class='neutral'>//                                                              2 ** 111</span>
 2112 |     | <span class='neutral'>//                            incomingCurrentToTarget</span>
 2113 |     | <span class='neutral'>//                           -------------------------&#39;</span>
 2114 |     | <span class='neutral'>//                                  outgoingMax</span>
 2115 |     | <span class='neutral'>//</span>
 2116 |     | <span class='neutral'>//    - &#39;amount1&#39;: As discussed in the prior steps, the following decrement</span>
 2117 |     | <span class='neutral'>//      should be applied to &#39;amount1&#39;:</span>
 2118 |     | <span class='neutral'>//                                                        growth</span>
 2119 |     | <span class='neutral'>//        &#39;amount1Partial := sqrtOffset * sharesTotal * ---------- *</span>
 2120 |     | <span class='neutral'>//                                                       2 ** 111</span>
 2121 |     | <span class='neutral'>//                            currentToTarget</span>
 2122 |     | <span class='neutral'>//                           -----------------&#39;</span>
 2123 |     | <span class='neutral'>//                              outgoingMax</span>
 2124 |     | <span class='neutral'>//</span>
 2125 |     | <span class='neutral'>//    - &#39;amountSpecified&#39;: Since the swap is partially fulfilled, we should</span>
 2126 |     | <span class='neutral'>//      decrement &#39;amountSpecified&#39; by &#39;amount0Partial&#39; to reflect this:</span>
 2127 |     | <span class='neutral'>//</span>
 2128 |     | <span class='neutral'>//        &#39;amountSpecified -= amount0Partial&#39;.</span>
 2129 |     | <span class='neutral'>//</span>
 2130 |     | <span class='neutral'>//    - &#39;qCurrent&#39;: Since we moved the price of the pool to &#39;qLimit&#39;, the value</span>
 2131 |     | <span class='neutral'>//      for &#39;qCurrent&#39; in memory (i.e., the content of the memory space which</span>
 2132 |     | <span class='neutral'>//      is pointed to by &#39;_logPriceCurrent_&#39;) should be updated to</span>
 2133 |     | <span class='neutral'>//</span>
 2134 |     | <span class='neutral'>//        &#39;qCurrent := qTarget&#39;.</span>
 2135 |     | <span class='neutral'>//</span>
 2136 |     | <span class='neutral'>//      This is illustrated as follows:</span>
 2137 |     | <span class='neutral'>//</span>
 2138 |     | <span class='neutral'>//                qTarget</span>
 2139 |     | <span class='neutral'>//                   |</span>
 2140 |     | <span class='neutral'>//                qLimit</span>
 2141 |     | <span class='neutral'>//                   |</span>
 2142 |     | <span class='neutral'>//      ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
 2143 |     | <span class='neutral'>//             |     |       |</span>
 2144 |     | <span class='neutral'>//           qNext   |     qBack</span>
 2145 |     | <span class='neutral'>//                   |</span>
 2146 |     | <span class='neutral'>//               qCurrent</span>
 2147 |     | <span class='neutral'>//</span>
 2148 |     | <span class='neutral'>//    - &#39;curve&#39; and &#39;growth&#39;: Now that the target price is determined as well</span>
 2149 |     | <span class='neutral'>//      as the outgoing and incoming amounts, we need to update the AMM curve </span>
 2150 |     | <span class='neutral'>//      in preparation for the next swap. To this end, the curve sequence</span>
 2151 |     | <span class='neutral'>//      should be amended. In doing so, we need to respect certain</span>
 2152 |     | <span class='neutral'>//      requirements:</span>
 2153 |     | <span class='neutral'>//</span>
 2154 |     | <span class='neutral'>//      Firstly, remember that the last member of the curve sequence should</span>
 2155 |     | <span class='neutral'>//      always correspond to the current price of the pool, i.e., &#39;qCurrent&#39;.</span>
 2156 |     | <span class='neutral'>//      Now that we have set &#39;qCurrent&#39; to &#39;qTarget&#39; the curve sequence should</span>
 2157 |     | <span class='neutral'>//      be amended with this new value in preparation for the next swap.</span>
 2158 |     | <span class='neutral'>//</span>
 2159 |     | <span class='neutral'>//      Secondly, we should be mindful of the fact that amending the curve</span>
 2160 |     | <span class='neutral'>//      sequence changes the liquidity distribution function from &#39;k(w(.))&#39; to</span>
 2161 |     | <span class='neutral'>//      &#39;k(wAmended(.))&#39; and we need to make sure that this change does not</span>
 2162 |     | <span class='neutral'>//      affect our accounting of the total interval reserves with respect to</span>
 2163 |     | <span class='neutral'>//      both tags. More precisely, the curve sequence must be amended subject</span>
 2164 |     | <span class='neutral'>//      to the following constraints:</span>
 2165 |     | <span class='neutral'>//</span>
 2166 |     | <span class='neutral'>//        &#39;totalReserveOfTag0Before == totalReserveOfTag0After&#39;</span>
 2167 |     | <span class='neutral'>//</span>
 2168 |     | <span class='neutral'>//        &#39;totalReserveOfTag1Before == totalReserveOfTag1After&#39;</span>
 2169 |     | <span class='neutral'>//</span>
 2170 |     | <span class='neutral'>//      where &#39;totalReserveOfTag0Before&#39; and &#39;totalReserveOfTag1Before&#39;,</span>
 2171 |     | <span class='neutral'>//      respectively, are the total reserves of &#39;tag0&#39; and &#39;tag1&#39; within</span>
 2172 |     | <span class='neutral'>//      &#39;[qLower, qUpper]&#39; that are calculated based on &#39;k(w(.))&#39;, whereas</span>
 2173 |     | <span class='neutral'>//      &#39;totalReserveOfTag0After&#39; and &#39;totalReserveOfTag1After&#39; are the same</span>
 2174 |     | <span class='neutral'>//      amounts that are calculated based on &#39;k(wAmended(.))&#39;.</span>
 2175 |     | <span class='neutral'>//</span>
 2176 |     | <span class='neutral'>//      The two sides of the first equation can be derived as:</span>
 2177 |     | <span class='neutral'>//</span>
 2178 |     | <span class='neutral'>//        &#39;totalReserveOfTag0Before := sqrtInverseOffset * sharesTotal * </span>
 2179 |     | <span class='neutral'>//</span>
 2180 |     | <span class='neutral'>//                                         - 8     / qUpper</span>
 2181 |     | <span class='neutral'>//           growth       2 ** 216       e        |    - h / 2</span>
 2182 |     | <span class='neutral'>//         ---------- * ------------- * ------- * |  e         k(w(h)) dh&#39;,</span>
 2183 |     | <span class='neutral'>//          2 ** 111     outgoingMax       2      |</span>
 2184 |     | <span class='neutral'>//                                               / qTarget</span>
 2185 |     | <span class='neutral'>//      and</span>
 2186 |     | <span class='neutral'>//</span>
 2187 |     | <span class='neutral'>//        &#39;totalReserveOfTag0After := </span>
 2188 |     | <span class='neutral'>//</span>
 2189 |     | <span class='neutral'>//                                            growthAmended</span>
 2190 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * --------------- *</span>
 2191 |     | <span class='neutral'>//                                               2 ** 111</span>
 2192 |     | <span class='neutral'>//</span>
 2193 |     | <span class='neutral'>//                            - 8     / qUpper</span>
 2194 |     | <span class='neutral'>//           2 ** 216       e        |    - h / 2</span>
 2195 |     | <span class='neutral'>//         ------------- * ------- * |  e         k(wAmended(h)) dh&#39;,</span>
 2196 |     | <span class='neutral'>//          outgoingMax       2      |</span>
 2197 |     | <span class='neutral'>//                                  / qTarget</span>
 2198 |     | <span class='neutral'>//</span>
 2199 |     | <span class='neutral'>//      which simplify the first equation to:</span>
 2200 |     | <span class='neutral'>//</span>
 2201 |     | <span class='neutral'>//                               / qUpper</span>
 2202 |     | <span class='neutral'>//                              |    - h / 2</span>
 2203 |     | <span class='neutral'>//                              |  e         k(wAmended(h)) dh</span>
 2204 |     | <span class='neutral'>//                              |</span>
 2205 |     | <span class='neutral'>//              growth         / qTarget</span>
 2206 |     | <span class='neutral'>//        &#39;--------------- == ---------------------------------&#39;.</span>
 2207 |     | <span class='neutral'>//          growthAmended           / qUpper</span>
 2208 |     | <span class='neutral'>//                                 |    - h / 2</span>
 2209 |     | <span class='neutral'>//                                 |  e         k(w(h)) dh</span>
 2210 |     | <span class='neutral'>//                                 |</span>
 2211 |     | <span class='neutral'>//                                / qTarget</span>
 2212 |     | <span class='neutral'>//</span>
 2213 |     | <span class='neutral'>//      The two sides of the second equation can be derived as:</span>
 2214 |     | <span class='neutral'>//</span>
 2215 |     | <span class='neutral'>//        &#39;totalReserveOfTag1Before := sqrtOffset * sharesTotal * </span>
 2216 |     | <span class='neutral'>//</span>
 2217 |     | <span class='neutral'>//                                         - 8     / qTarget</span>
 2218 |     | <span class='neutral'>//           growth       2 ** 216       e        |    + h / 2</span>
 2219 |     | <span class='neutral'>//         ---------- * ------------- * ------- * |  e         k(w(h)) dh&#39;,</span>
 2220 |     | <span class='neutral'>//          2 ** 111     outgoingMax       2      |</span>
 2221 |     | <span class='neutral'>//                                               / qLower</span>
 2222 |     | <span class='neutral'>//      and</span>
 2223 |     | <span class='neutral'>//</span>
 2224 |     | <span class='neutral'>//        &#39;totalReserveOfTag1After := </span>
 2225 |     | <span class='neutral'>//</span>
 2226 |     | <span class='neutral'>//                                     growthAmended      2 ** 216</span>
 2227 |     | <span class='neutral'>//         sqrtOffset * sharesTotal * --------------- * ------------- *</span>
 2228 |     | <span class='neutral'>//                                        2 ** 111       outgoingMax</span>
 2229 |     | <span class='neutral'>//</span>
 2230 |     | <span class='neutral'>//            - 8     / qTarget</span>
 2231 |     | <span class='neutral'>//          e        |    + h / 2</span>
 2232 |     | <span class='neutral'>//         ------- * |  e         k(wAmended(h)) dh&#39;,</span>
 2233 |     | <span class='neutral'>//            2      |</span>
 2234 |     | <span class='neutral'>//                  / qLower</span>
 2235 |     | <span class='neutral'>//</span>
 2236 |     | <span class='neutral'>//      which simplifies the second equation to:</span>
 2237 |     | <span class='neutral'>//</span>
 2238 |     | <span class='neutral'>//                               / qTarget</span>
 2239 |     | <span class='neutral'>//                              |    + h / 2</span>
 2240 |     | <span class='neutral'>//                              |  e         k(wAmended(h)) dh</span>
 2241 |     | <span class='neutral'>//                              |</span>
 2242 |     | <span class='neutral'>//            growth           / qLower</span>
 2243 |     | <span class='neutral'>//        &#39;--------------- == ---------------------------------&#39;.</span>
 2244 |     | <span class='neutral'>//          growthAmended           / qTarget</span>
 2245 |     | <span class='neutral'>//                                 |    + h / 2</span>
 2246 |     | <span class='neutral'>//                                 |  e         k(w(h)) dh</span>
 2247 |     | <span class='neutral'>//                                 |</span>
 2248 |     | <span class='neutral'>//                                / qLower</span>
 2249 |     | <span class='neutral'>//</span>
 2250 |     | <span class='neutral'>//      Based on the above equations, finding &#39;growthAmended&#39; with respect to</span>
 2251 |     | <span class='neutral'>//      &#39;k(w(.))&#39; and &#39;k(wAmended(.))&#39; is straightforward.</span>
 2252 |     | <span class='neutral'>//</span>
 2253 |     | <span class='neutral'>//      However, in order to satisfy both of the equations, we should have:</span>
 2254 |     | <span class='neutral'>//</span>
 2255 |     | <span class='neutral'>//            / qTarget                         / qUpper</span>
 2256 |     | <span class='neutral'>//           |   + h/2                         |   - h/2</span>
 2257 |     | <span class='neutral'>//           |  e      k(wAmended(h)) dh       |  e      k(wAmended(h)) dh</span>
 2258 |     | <span class='neutral'>//           |                                 |</span>
 2259 |     | <span class='neutral'>//          / qLower                          / qTarget</span>
 2260 |     | <span class='neutral'>//        &#39;------------------------------ == ------------------------------&#39;.</span>
 2261 |     | <span class='neutral'>//               / qTarget                         / qUpper</span>
 2262 |     | <span class='neutral'>//              |    + h/2                        |    - h/2</span>
 2263 |     | <span class='neutral'>//              |  e       k(w(h)) dh             |  e       k(w(h)) dh</span>
 2264 |     | <span class='neutral'>//              |                                 |</span>
 2265 |     | <span class='neutral'>//             / qLower                          / qTarget</span>
 2266 |     | <span class='neutral'>//</span>
 2267 |     | <span class='neutral'>//      Because of the above constraint, we need to take an additional step</span>
 2268 |     | <span class='neutral'>//      prior to amending the curve sequence with &#39;qTarget&#39;.</span>
 2269 |     | <span class='neutral'>//</span>
 2270 |     | <span class='neutral'>//      Observe that the current curve sequence is last updated when we</span>
 2271 |     | <span class='neutral'>//      transitioned into &#39;[qLower, qUpper]&#39; and it is composed of the</span>
 2272 |     | <span class='neutral'>//      following two points:</span>
 2273 |     | <span class='neutral'>//</span>
 2274 |     | <span class='neutral'>//        &#39;q[0] := qLower&#39;,</span>
 2275 |     | <span class='neutral'>//        &#39;q[1] := qUpper&#39;.</span>
 2276 |     | <span class='neutral'>//</span>
 2277 |     | <span class='neutral'>//      The corresponding diagram for the current curve sequence is illustrated</span>
 2278 |     | <span class='neutral'>//      as follows:</span>
 2279 |     | <span class='neutral'>//</span>
 2280 |     | <span class='neutral'>//            w(q)</span>
 2281 |     | <span class='neutral'>//              ^</span>
 2282 |     | <span class='neutral'>//      spacing |                /</span>
 2283 |     | <span class='neutral'>//              |               /</span>
 2284 |     | <span class='neutral'>//              |              /</span>
 2285 |     | <span class='neutral'>//              |             /</span>
 2286 |     | <span class='neutral'>//              |            /</span>
 2287 |     | <span class='neutral'>//              |           /</span>
 2288 |     | <span class='neutral'>//              |          /</span>
 2289 |     | <span class='neutral'>//              |\</span>
 2290 |     | <span class='neutral'>//              | \</span>
 2291 |     | <span class='neutral'>//              |  \</span>
 2292 |     | <span class='neutral'>//              |   \</span>
 2293 |     | <span class='neutral'>//              |        /</span>
 2294 |     | <span class='neutral'>//              |       /</span>
 2295 |     | <span class='neutral'>//              |      /</span>
 2296 |     | <span class='neutral'>//              |     /</span>
 2297 |     | <span class='neutral'>//            0 +----+----+-------+-&gt; q</span>
 2298 |     | <span class='neutral'>//           qLower  |    |       |</span>
 2299 |     | <span class='neutral'>//                   |   q[2]  qUpper</span>
 2300 |     | <span class='neutral'>//                   |</span>
 2301 |     | <span class='neutral'>//               qCurrent</span>
 2302 |     | <span class='neutral'>//</span>
 2303 |     | <span class='neutral'>//            w(q)</span>
 2304 |     | <span class='neutral'>//              ^</span>
 2305 |     | <span class='neutral'>//      spacing |\</span>
 2306 |     | <span class='neutral'>//              | \</span>
 2307 |     | <span class='neutral'>//              |  \</span>
 2308 |     | <span class='neutral'>//              |   \</span>
 2309 |     | <span class='neutral'>//              |    \</span>
 2310 |     | <span class='neutral'>//              |     \</span>
 2311 |     | <span class='neutral'>//              |      \</span>
 2312 |     | <span class='neutral'>//              |       \</span>
 2313 |     | <span class='neutral'>//              |        \</span>
 2314 |     | <span class='neutral'>//              |         \</span>
 2315 |     | <span class='neutral'>//              |          \</span>
 2316 |     | <span class='neutral'>//              |           \</span>
 2317 |     | <span class='neutral'>//              |            \</span>
 2318 |     | <span class='neutral'>//              |             \</span>
 2319 |     | <span class='neutral'>//              |              \</span>
 2320 |     | <span class='neutral'>//            0 +-------+------+-&gt; q</span>
 2321 |     | <span class='neutral'>//           qLower     |      |</span>
 2322 |     | <span class='neutral'>//                      |    qUpper</span>
 2323 |     | <span class='neutral'>//                      |</span>
 2324 |     | <span class='neutral'>//                   qTarget</span>
 2325 |     | <span class='neutral'>//</span>
 2326 |     | <span class='neutral'>//      Before amending the curve sequence with &#39;qTarget&#39;, we first determine a</span>
 2327 |     | <span class='neutral'>//      point between &#39;qTarget&#39; and &#39;qNext == qLower&#39; which is regarded as</span>
 2328 |     | <span class='neutral'>//      &#39;qOvershoot&#39;:</span>
 2329 |     | <span class='neutral'>//</span>
 2330 |     | <span class='neutral'>//            w(q)</span>
 2331 |     | <span class='neutral'>//              ^</span>
 2332 |     | <span class='neutral'>//      spacing |\</span>
 2333 |     | <span class='neutral'>//              | \</span>
 2334 |     | <span class='neutral'>//              |  \</span>
 2335 |     | <span class='neutral'>//              |   \</span>
 2336 |     | <span class='neutral'>//              |    \</span>
 2337 |     | <span class='neutral'>//              |     \</span>
 2338 |     | <span class='neutral'>//              |      \</span>
 2339 |     | <span class='neutral'>//              |       \</span>
 2340 |     | <span class='neutral'>//              |        \</span>
 2341 |     | <span class='neutral'>//              |         \</span>
 2342 |     | <span class='neutral'>//              |          \</span>
 2343 |     | <span class='neutral'>//              |           \</span>
 2344 |     | <span class='neutral'>//              |            \</span>
 2345 |     | <span class='neutral'>//              |             \</span>
 2346 |     | <span class='neutral'>//              |              \</span>
 2347 |     | <span class='neutral'>//              |               \</span>
 2348 |     | <span class='neutral'>//              |                \</span>
 2349 |     | <span class='neutral'>//            0 +----+----+-------+-&gt; q</span>
 2350 |     | <span class='neutral'>//           qLower  |    |       |</span>
 2351 |     | <span class='neutral'>//                   |    |     qUpper</span>
 2352 |     | <span class='neutral'>//                   |    |</span>
 2353 |     | <span class='neutral'>//                   | qTarget</span>
 2354 |     | <span class='neutral'>//                   |</span>
 2355 |     | <span class='neutral'>//               qOvershoot</span>
 2356 |     | <span class='neutral'>//</span>
 2357 |     | <span class='neutral'>//      Then, the curve sequence is amended with &#39;qOvershoot&#39; which leads to</span>
 2358 |     | <span class='neutral'>//      the following sequence:</span>
 2359 |     | <span class='neutral'>//</span>
 2360 |     | <span class='neutral'>//        &#39;q[0] := qUpper&#39;,</span>
 2361 |     | <span class='neutral'>//        &#39;q[1] := qLower&#39;,</span>
 2362 |     | <span class='neutral'>//        &#39;q[2] := qOvershoot&#39;.</span>
 2363 |     | <span class='neutral'>//</span>
 2364 |     | <span class='neutral'>//      and the following diagram:</span>
 2365 |     | <span class='neutral'>//</span>
 2366 |     | <span class='neutral'>//              ^</span>
 2367 |     | <span class='neutral'>//      spacing |\</span>
 2368 |     | <span class='neutral'>//              | \</span>
 2369 |     | <span class='neutral'>//              |  \</span>
 2370 |     | <span class='neutral'>//              |                /</span>
 2371 |     | <span class='neutral'>//              |               /</span>
 2372 |     | <span class='neutral'>//              |              /</span>
 2373 |     | <span class='neutral'>//              |             /</span>
 2374 |     | <span class='neutral'>//              |            /</span>
 2375 |     | <span class='neutral'>//              |           /</span>
 2376 |     | <span class='neutral'>//              |          /</span>
 2377 |     | <span class='neutral'>//              |         /</span>
 2378 |     | <span class='neutral'>//              |        /</span>
 2379 |     | <span class='neutral'>//              |       /</span>
 2380 |     | <span class='neutral'>//              |      /</span>
 2381 |     | <span class='neutral'>//              |     /</span>
 2382 |     | <span class='neutral'>//            0 +----+----+-------+-&gt; q</span>
 2383 |     | <span class='neutral'>//           qLower  |    |       |</span>
 2384 |     | <span class='neutral'>//                   |    |     qUpper</span>
 2385 |     | <span class='neutral'>//                   |    |</span>
 2386 |     | <span class='neutral'>//                   |  qTarget</span>
 2387 |     | <span class='neutral'>//                   |</span>
 2388 |     | <span class='neutral'>//               qOvershoot</span>
 2389 |     | <span class='neutral'>//</span>
 2390 |     | <span class='neutral'>//      In this case, amending the curve sequence has increased its length.</span>
 2391 |     | <span class='neutral'>//      However, this is not always the case. As explained in &#39;Curve.sol&#39;, this</span>
 2392 |     | <span class='neutral'>//      process may involve clearing a number of members from the end of the</span>
 2393 |     | <span class='neutral'>//      curve sequence and then inserting the new member.</span>
 2394 |     | <span class='neutral'>//</span>
 2395 |     | <span class='neutral'>//      After the amendment with &#39;qOvershoot&#39;, the resulting curve sequence is</span>
 2396 |     | <span class='neutral'>//      then amended with &#39;qTarget&#39; which leads to the following sequence:</span>
 2397 |     | <span class='neutral'>//</span>
 2398 |     | <span class='neutral'>//        &#39;q[0] := qUpper&#39;,</span>
 2399 |     | <span class='neutral'>//        &#39;q[1] := qLower&#39;,</span>
 2400 |     | <span class='neutral'>//        &#39;q[2] := qOvershoot&#39;,</span>
 2401 |     | <span class='neutral'>//        &#39;q[3] := qTarget&#39;.</span>
 2402 |     | <span class='neutral'>//</span>
 2403 |     | <span class='neutral'>//      and the following diagram:</span>
 2404 |     | <span class='neutral'>//</span>
 2405 |     | <span class='neutral'>//          wAmended(q)</span>
 2406 |     | <span class='neutral'>//              ^</span>
 2407 |     | <span class='neutral'>//      spacing |\</span>
 2408 |     | <span class='neutral'>//              | \</span>
 2409 |     | <span class='neutral'>//              |  \</span>
 2410 |     | <span class='neutral'>//              |   \</span>
 2411 |     | <span class='neutral'>//              |                /</span>
 2412 |     | <span class='neutral'>//              |               /</span>
 2413 |     | <span class='neutral'>//              |              /</span>
 2414 |     | <span class='neutral'>//              |             /</span>
 2415 |     | <span class='neutral'>//              |            /</span>
 2416 |     | <span class='neutral'>//              |           /</span>
 2417 |     | <span class='neutral'>//              |          /</span>
 2418 |     | <span class='neutral'>//              |     \</span>
 2419 |     | <span class='neutral'>//              |      \</span>
 2420 |     | <span class='neutral'>//              |       \</span>
 2421 |     | <span class='neutral'>//              |        \</span>
 2422 |     | <span class='neutral'>//            0 +----+----+-------+-&gt; q</span>
 2423 |     | <span class='neutral'>//           qLower  |    |       |</span>
 2424 |     | <span class='neutral'>//                   |    |     qUpper</span>
 2425 |     | <span class='neutral'>//                   |    |</span>
 2426 |     | <span class='neutral'>//                   | qTarget</span>
 2427 |     | <span class='neutral'>//                   |</span>
 2428 |     | <span class='neutral'>//               qOvershoot</span>
 2429 |     | <span class='neutral'>//</span>
 2430 |     | <span class='neutral'>//      The purpose of first amending with &#39;qOvershoot&#39; is to have an</span>
 2431 |     | <span class='neutral'>//      additional degree of freedom in order to satisfy the equation:</span>
 2432 |     | <span class='neutral'>//</span>
 2433 |     | <span class='neutral'>//        &#39;f(qOvershoot) == 0&#39;</span>
 2434 |     | <span class='neutral'>//</span>
 2435 |     | <span class='neutral'>//      where</span>
 2436 |     | <span class='neutral'>//</span>
 2437 |     | <span class='neutral'>//        &#39;f(qOvershoot) :=</span>
 2438 |     | <span class='neutral'>//</span>
 2439 |     | <span class='neutral'>//            / qUpper                         / qTarget</span>
 2440 |     | <span class='neutral'>//           |   - h/2                        |   + h/2</span>
 2441 |     | <span class='neutral'>//           |  e      k(wAmended(h)) dh      |  e      k(wAmended(h)) dh</span>
 2442 |     | <span class='neutral'>//           |                                |</span>
 2443 |     | <span class='neutral'>//          / qTarget                        / qLower</span>
 2444 |     | <span class='neutral'>//         ------------------------------ - ------------------------------&#39;.</span>
 2445 |     | <span class='neutral'>//               / qUpper                         / qTarget</span>
 2446 |     | <span class='neutral'>//              |    - h/2                       |    + h/2</span>
 2447 |     | <span class='neutral'>//              |  e       k(w(h)) dh            |  e       k(w(h)) dh</span>
 2448 |     | <span class='neutral'>//              |                                |</span>
 2449 |     | <span class='neutral'>//             / qTarget                        / qLower</span>
 2450 |     | <span class='neutral'>//</span>
 2451 |     | <span class='neutral'>//      By investigating the above equation, we can observe that:</span>
 2452 |     | <span class='neutral'>//</span>
 2453 |     | <span class='neutral'>//        - Both of the denominators are fixed. This is because at this stage,</span>
 2454 |     | <span class='neutral'>//          &#39;qTarget&#39; is fully determined either through &#39;qLimit&#39; or</span>
 2455 |     | <span class='neutral'>//          &#39;amountSpecified&#39;. Additionally, the current curve sequence is</span>
 2456 |     | <span class='neutral'>//          fixed which dictates the shape of &#39;w(.)&#39;.</span>
 2457 |     | <span class='neutral'>//</span>
 2458 |     | <span class='neutral'>//        - Both of the numerators are functions of &#39;qOvershoot&#39;. This is</span>
 2459 |     | <span class='neutral'>//          because &#39;wAmended(.)&#39; can be fully characterized by</span>
 2460 |     | <span class='neutral'>//</span>
 2461 |     | <span class='neutral'>//            - the current curve sequence which is fixed,</span>
 2462 |     | <span class='neutral'>//</span>
 2463 |     | <span class='neutral'>//            - &#39;qTarget&#39; which is also fixed,</span>
 2464 |     | <span class='neutral'>//</span>
 2465 |     | <span class='neutral'>//            - and &#39;qOvershoot&#39; which is the only unknown value that we are</span>
 2466 |     | <span class='neutral'>//              trying to determine.</span>
 2467 |     | <span class='neutral'>//</span>
 2468 |     | <span class='neutral'>//      Hence, in order to update the liquidity distribution function from</span>
 2469 |     | <span class='neutral'>//      &#39;k(w(.))&#39; to &#39;k(wAmended(.))&#39;, which updates the AMM diagram of the</span>
 2470 |     | <span class='neutral'>//      active interval, we need to solve the above equation with respect to</span>
 2471 |     | <span class='neutral'>//      &#39;qOvershoot&#39;. As proven in nofeeswap&#39;s yellowpaper, there always exist</span>
 2472 |     | <span class='neutral'>//      a root between &#39;qTarget&#39; and &#39;qNext&#39; that satisfies:</span>
 2473 |     | <span class='neutral'>//</span>
 2474 |     | <span class='neutral'>//        &#39;growthAmended &gt;= growth&#39;.</span>
 2475 |     | <span class='neutral'>//</span>
 2476 |     | <span class='neutral'>//      This root is found via numerical search by running the methods</span>
 2477 |     | <span class='neutral'>//      &#39;moveOvershoot&#39; and &#39;searchOvershoot&#39; from &#39;Interval.sol&#39;.</span>
 2478 |     | <span class='neutral'>//</span>
 2479 |     | <span class='neutral'>//      Remember that &#39;k(w(.))&#39; and &#39;k(wAmended(.))&#39; are piecewise linear</span>
 2480 |     | <span class='neutral'>//      functions whose domains cover the entire active interval. The method</span>
 2481 |     | <span class='neutral'>//      &#39;moveOvershoot&#39; from &#39;Interval.sol&#39; identifies a range within</span>
 2482 |     | <span class='neutral'>//      &#39;[qLower, qUpper]&#39;:</span>
 2483 |     | <span class='neutral'>//</span>
 2484 |     | <span class='neutral'>//        - in which &#39;k(w(.))&#39; is linear,</span>
 2485 |     | <span class='neutral'>//</span>
 2486 |     | <span class='neutral'>//        - in which &#39;k(wAmended(.))&#39; is linear, and</span>
 2487 |     | <span class='neutral'>//</span>
 2488 |     | <span class='neutral'>//        - to which &#39;qOvershoot&#39; belongs.</span>
 2489 |     | <span class='neutral'>//</span>
 2490 |     | <span class='neutral'>//      Since &#39;f(.)&#39; is a continuous function, the membership of a root (i.e.,</span>
 2491 |     | <span class='neutral'>//      &#39;qOvershoot&#39;) to a particular range can be verified by evaluating the</span>
 2492 |     | <span class='neutral'>//      sign of &#39;f(.)&#39; at the two ends of the range. Hence, in light of the</span>
 2493 |     | <span class='neutral'>//      intermediate value theorem, if the signs at the two ends of the range</span>
 2494 |     | <span class='neutral'>//      are different, then there has to be a root somewhere within this</span>
 2495 |     | <span class='neutral'>//      range.</span>
 2496 |     | <span class='neutral'>//</span>
 2497 |     | <span class='neutral'>//      Next, the method &#39;searchOvershoot&#39; from &#39;Interval.sol&#39; performs a</span>
 2498 |     | <span class='neutral'>//      Newton search in order to pinpoint the precise value of &#39;qOvershoot&#39;</span>
 2499 |     | <span class='neutral'>//      within the range that is identified by &#39;moveOvershoot&#39;.</span>
 2500 |     | <span class='neutral'>//</span>
 2501 |     | <span class='neutral'>//      Once &#39;qOvershoot&#39; is calculated, we proceed with the two amendments to</span>
 2502 |     | <span class='neutral'>//      the curve sequence via &#39;qOvershoot&#39; and &#39;qTarget&#39;.</span>
 2503 |     | <span class='neutral'>//</span>
 2504 |     | <span class='neutral'>//      After that, we derive &#39;growthAmended&#39; based on the following formula:</span>
 2505 |     | <span class='neutral'>//</span>
 2506 |     | <span class='neutral'>//                                          / qTarget</span>
 2507 |     | <span class='neutral'>//                                         |    + h / 2</span>
 2508 |     | <span class='neutral'>//                                         |  e         k(w(h)) dh</span>
 2509 |     | <span class='neutral'>//                                         |</span>
 2510 |     | <span class='neutral'>//                                        / qLower</span>
 2511 |     | <span class='neutral'>//        &#39;growthAmended == growth * ---------------------------------&#39;.</span>
 2512 |     | <span class='neutral'>//                                      / qTarget</span>
 2513 |     | <span class='neutral'>//                                     |    + h / 2</span>
 2514 |     | <span class='neutral'>//                                     |  e         k(wAmended(h)) dh</span>
 2515 |     | <span class='neutral'>//                                     |</span>
 2516 |     | <span class='neutral'>//                                    / qLower</span>
 2517 |     | <span class='neutral'>//</span>
 2518 |     | <span class='neutral'>//      This concludes the update of our liquidity distribution function (or</span>
 2519 |     | <span class='neutral'>//      equivalently, the update of our AMM diagram) for the next swap.</span>
 2520 |     | <span class='neutral'>//</span>
 2521 |     | <span class='neutral'>//  - The last step involves writing the dynamic parameters of the pool as well</span>
 2522 |     | <span class='neutral'>//    as the amended curve sequence in the protocol&#39;s storage which concludes</span>
 2523 |     | <span class='neutral'>//    this example.</span>
 2524 |     | <span class='neutral'></span>
 2525 |     | <span class='neutral'>// Swap Inputs</span>
 2526 |     | <span class='neutral'>// ----------------------------------------------------------------------------</span>
 2527 |     | <span class='neutral'>// The following memory pointers correspond to the inputs of the method &#39;swap&#39;</span>
 2528 |     | <span class='neutral'>// from &#39;Nofeeswap.sol&#39;. Each parameter is read from calldata via the method</span>
 2529 |     | <span class='neutral'>// &#39;readSwapInput&#39; from &#39;Calldata.sol&#39;. Then, the parameters are transformed to</span>
 2530 |     | <span class='neutral'>// appropriate formats and stored in their dedicated memory locations as listed</span>
 2531 |     | <span class='neutral'>// below. Throughout the execution of the swap, the following memory pointers</span>
 2532 |     | <span class='neutral'>// as well as the corresponding getter functions can be used to access each</span>
 2533 |     | <span class='neutral'>// parameter. Moreover, when invoking an applicable hook these input parameters</span>
 2534 |     | <span class='neutral'>// are passed to the hook as calldata and they can be accessed via the</span>
 2535 |     | <span class='neutral'>// corresponding calldata pointers and getter functions that are listed in</span>
 2536 |     | <span class='neutral'>// &#39;HookCalldata.sol&#39;.</span>
 2537 |     | <span class='neutral'>uint16 constant _swapInput_ = 248;</span>
 2538 |     | <span class='neutral'></span>
 2539 |     | <span class='neutral'>// &#39;crossThreshold&#39; refers to a minimum limit on the total number of shares</span>
 2540 |     | <span class='neutral'>// that should be available in any interval for the &#39;swap&#39; method to transact</span>
 2541 |     | <span class='neutral'>// in that interval.</span>
 2542 |     | <span class='neutral'>//</span>
 2543 |     | <span class='neutral'>// For example, if &#39;crossThreshold == 50&#39;, then there has to be a minimum of</span>
 2544 |     | <span class='neutral'>// 50 shares present in an interval so that the algorithm either enters that</span>
 2545 |     | <span class='neutral'>// interval or crosses it entirely. Once we encounter an interval with the</span>
 2546 |     | <span class='neutral'>// total number of shares less than 50, the &#39;swap&#39; call is halted and the price</span>
 2547 |     | <span class='neutral'>// of the pool does not go beyond that point.</span>
 2548 |     | <span class='neutral'>//</span>
 2549 |     | <span class='neutral'>// However, if &#39;crossThreshold == 0&#39;, which is the default, no minimum number</span>
 2550 |     | <span class='neutral'>// of shares is imposed.</span>
 2551 |     | <span class='neutral'>//</span>
 2552 |     | <span class='neutral'>// The calldata layout of the method &#39;swap&#39; in &#39;Nofeeswap.sol&#39; does not have a</span>
 2553 |     | <span class='neutral'>// slot dedicated to &#39;crossThreshold&#39;. Instead, the two inputs &#39;crossThreshold&#39;</span>
 2554 |     | <span class='neutral'>// and &#39;zeroForOne&#39; share the same slot in calldata as illustrated below:</span>
 2555 |     | <span class='neutral'>//</span>
 2556 |     | <span class='neutral'>//     +---------------------------+---------------------------+</span>
 2557 |     | <span class='neutral'>//     | crossThreshold (128 bits) |   zeroForOne (128 bits)   |</span>
 2558 |     | <span class='neutral'>//     +---------------------------+---------------------------+</span>
 2559 |     | <span class='neutral'>//</span>
 2560 |     | <span class='neutral'>// &#39;crossThreshold&#39; occupies the most significant 128 bits and &#39;zeroForOne&#39;</span>
 2561 |     | <span class='neutral'>// occupies the least significant 128 bits. Hence, 16 bytes are reserved for</span>
 2562 |     | <span class='neutral'>// &#39;crossThreshold&#39; in memory.</span>
 2563 |     | <span class='neutral'>uint16 constant _crossThreshold_ = 248;</span>
 2564 |     | <span class='neutral'></span>
 2565 |     | <span class='neutral'>// The input &#39;amountSpecified&#39; of the &#39;swap&#39; method in &#39;Nofeeswap.sol&#39; is a</span>
 2566 |     | <span class='neutral'>// signed integer. If positive (&#39;exactInput == true&#39;), this value represents</span>
 2567 |     | <span class='neutral'>// the requested incoming amount to be given to the pool as a result of the</span>
 2568 |     | <span class='neutral'>// swap call. If negative (&#39;exactInput == false&#39;), this value represents the</span>
 2569 |     | <span class='neutral'>// requested outgoing amount to be taken from the pool as a result of the swap</span>
 2570 |     | <span class='neutral'>// call. As an initial step of the swap algorithm, the method &#39;readSwapInput&#39;</span>
 2571 |     | <span class='neutral'>// from &#39;Calldata.sol&#39; performs the following actions:</span>
 2572 |     | <span class='neutral'>//</span>
 2573 |     | <span class='neutral'>//  - Reads the integer representation of &#39;amountSpecified&#39; from the dedicated</span>
 2574 |     | <span class='neutral'>//    calldata slot.</span>
 2575 |     | <span class='neutral'>//</span>
 2576 |     | <span class='neutral'>//  - Caps it by &#39;2 ** 127 - 1&#39; from above and by &#39;1 - 2 ** 127&#39; from below.</span>
 2577 |     | <span class='neutral'>//</span>
 2578 |     | <span class='neutral'>//  - Transforms it to the &#39;X127&#39; format.</span>
 2579 |     | <span class='neutral'>//</span>
 2580 |     | <span class='neutral'>//  - Stores the resulting value in the 32 byte memory space which is referred</span>
 2581 |     | <span class='neutral'>//    to by &#39;_amountSpecified_&#39;.</span>
 2582 |     | <span class='neutral'>//</span>
 2583 |     | <span class='neutral'>// Throughout the execution of the swap, &#39;amountSpecified&#39; is partially</span>
 2584 |     | <span class='neutral'>// fulfilled with each interval that we visit and because of this, the content</span>
 2585 |     | <span class='neutral'>// of this memory space is continuously updated.</span>
 2586 |     | <span class='neutral'>//</span>
 2587 |     | <span class='neutral'>// Due to limited granularity of logarithmic price in &#39;X59&#39; representation, a</span>
 2588 |     | <span class='neutral'>// requested amount may not be fulfilled. However,</span>
 2589 |     | <span class='neutral'>//</span>
 2590 |     | <span class='neutral'>//  - if &#39;amountSpecified &gt; 0&#39;, the incoming amount to be given to the pool as</span>
 2591 |     | <span class='neutral'>//    a result of the swap call must not exceed &#39;amountSpecified&#39;.</span>
 2592 |     | <span class='neutral'>//</span>
 2593 |     | <span class='neutral'>//  - if &#39;amountSpecified &lt; 0&#39;, the outgoing amount to be taken from the pool</span>
 2594 |     | <span class='neutral'>//    as a result of the swap call must be greater than or equal to</span>
 2595 |     | <span class='neutral'>//    &#39;0 - amountSpecified&#39;.</span>
 2596 |     | <span class='neutral'>//</span>
 2597 |     | <span class='neutral'>// 32 bytes are reserved for the &#39;X127&#39; representation of &#39;amountSpecified&#39; in</span>
 2598 |     | <span class='neutral'>// memory.</span>
 2599 |     | <span class='neutral'>uint16 constant _amountSpecified_ = 264;</span>
 2600 |     | <span class='neutral'></span>
 2601 |     | <span class='neutral'>// The input &#39;logPriceLimit&#39; of the &#39;swap&#39; method in &#39;Nofeeswap.sol&#39; is a</span>
 2602 |     | <span class='neutral'>// signed value in &#39;X59&#39; format. Define</span>
 2603 |     | <span class='neutral'>//</span>
 2604 |     | <span class='neutral'>//  &#39;pLimit := exp(logPriceLimit / (2 ** 59))&#39;.</span>
 2605 |     | <span class='neutral'>//</span>
 2606 |     | <span class='neutral'>// The input &#39;logPriceLimit&#39; imposes a limit on the price of the pool post</span>
 2607 |     | <span class='neutral'>// execution of the swap call.</span>
 2608 |     | <span class='neutral'>//</span>
 2609 |     | <span class='neutral'>//  - For price increasing swaps, &#39;logPriceLimit&#39; serves as an upper bound, in</span>
 2610 |     | <span class='neutral'>//    which case the price of the pool must not exceed &#39;pLimit&#39;.</span>
 2611 |     | <span class='neutral'>//</span>
 2612 |     | <span class='neutral'>//  - For price decreasing swaps, &#39;logPriceLimit&#39; serves as a lower bound, in</span>
 2613 |     | <span class='neutral'>//    which case the price of the pool must not subceed &#39;pLimit&#39;.</span>
 2614 |     | <span class='neutral'>//</span>
 2615 |     | <span class='neutral'>// In both cases, once the price of the pool reaches &#39;pLimit&#39;, the execution of</span>
 2616 |     | <span class='neutral'>// the swap is halted. Put simply, no amount of tags are traded with any price</span>
 2617 |     | <span class='neutral'>// worst than &#39;pLimit&#39; for the swapper.</span>
 2618 |     | <span class='neutral'>//</span>
 2619 |     | <span class='neutral'>// 32 bytes are reserved for &#39;logPriceLimit&#39; in memory.</span>
 2620 |     | <span class='neutral'>uint16 constant _logPriceLimit_ = 296;</span>
 2621 |     | <span class='neutral'></span>
 2622 |     | <span class='neutral'>// Let &#39;pLower&#39; and &#39;pUpper&#39;, respectively, denote the minimum and maximum</span>
 2623 |     | <span class='neutral'>// price in the current active liquidity interval and define</span>
 2624 |     | <span class='neutral'>//</span>
 2625 |     | <span class='neutral'>//  &#39;qLower := log(pLower / pOffset)&#39;</span>
 2626 |     | <span class='neutral'>//  &#39;qUpper := log(pUpper / pOffset)&#39;</span>
 2627 |     | <span class='neutral'>//  &#39;qSpacing := log(pUpper / pLower)&#39;,</span>
 2628 |     | <span class='neutral'>//  &#39;qMost  := + 16 - 1 / (2 ** 59) - qSpacing&#39;.</span>
 2629 |     | <span class='neutral'>//  &#39;qLeast := - 16 + 1 / (2 ** 59) + qSpacing&#39;.</span>
 2630 |     | <span class='neutral'>//</span>
 2631 |     | <span class='neutral'>// As previously argued, for every integer &#39;j&#39;, the interval</span>
 2632 |     | <span class='neutral'>//</span>
 2633 |     | <span class='neutral'>//  &#39;[qLower + j * qSpacing, qUpper + j * qSpacing]&#39;</span>
 2634 |     | <span class='neutral'>//</span>
 2635 |     | <span class='neutral'>// is a valid liquidity interval if and only if:</span>
 2636 |     | <span class='neutral'>//</span>
 2637 |     | <span class='neutral'>//  &#39;- qMost &lt;= qLower + j * qSpacing&#39;</span>
 2638 |     | <span class='neutral'>//</span>
 2639 |     | <span class='neutral'>// and</span>
 2640 |     | <span class='neutral'>//</span>
 2641 |     | <span class='neutral'>//  &#39;qUpper + j * qSpacing &lt;= + qMost.</span>
 2642 |     | <span class='neutral'>//</span>
 2643 |     | <span class='neutral'>// This includes the current active liquidity interval &#39;[qLower, qUpper]&#39;</span>
 2644 |     | <span class='neutral'>// which corresponds to &#39;j == 0&#39;.</span>
 2645 |     | <span class='neutral'>//</span>
 2646 |     | <span class='neutral'>// Because of this,</span>
 2647 |     | <span class='neutral'>//</span>
 2648 |     | <span class='neutral'>//  &#39;qCurrent := log(pCurrent / pOffset)&#39;</span>
 2649 |     | <span class='neutral'>//</span>
 2650 |     | <span class='neutral'>// always satisfies</span>
 2651 |     | <span class='neutral'>//</span>
 2652 |     | <span class='neutral'>//  &#39;qCurrent &gt;= qLeast + ((qLower - qLeast) % qSpacing)&#39;</span>
 2653 |     | <span class='neutral'>//</span>
 2654 |     | <span class='neutral'>// and</span>
 2655 |     | <span class='neutral'>//</span>
 2656 |     | <span class='neutral'>//  &#39;qCurrent &lt;= qMost - ((qMost - qLower) % qSpacing)&#39;</span>
 2657 |     | <span class='neutral'>//</span>
 2658 |     | <span class='neutral'>// where &#39;pCurrent&#39; is the current price of the pool.</span>
 2659 |     | <span class='neutral'>//</span>
 2660 |     | <span class='neutral'>// In order to enforce the above inequalities, the following value is</span>
 2661 |     | <span class='neutral'>// calculated in the method &#39;setSwapParams&#39; of &#39;swap.sol&#39;:</span>
 2662 |     | <span class='neutral'>//</span>
 2663 |     | <span class='neutral'>//  &#39;qLimit := min(</span>
 2664 |     | <span class='neutral'>//     max(</span>
 2665 |     | <span class='neutral'>//       qLeast + ((qLower - qLeast) % qSpacing),</span>
 2666 |     | <span class='neutral'>//       log(pLimit / pOffset)</span>
 2667 |     | <span class='neutral'>//     ),</span>
 2668 |     | <span class='neutral'>//     qMost - ((qMost - qLower) % qSpacing)</span>
 2669 |     | <span class='neutral'>//   )&#39;</span>
 2670 |     | <span class='neutral'>//</span>
 2671 |     | <span class='neutral'>// based on &#39;qLower&#39;, &#39;qUpper&#39;, and &#39;logPriceLimit&#39;. Then, the offset binary</span>
 2672 |     | <span class='neutral'>// &#39;X59&#39; representation of &#39;qLimit&#39;, i.e.,</span>
 2673 |     | <span class='neutral'>//</span>
 2674 |     | <span class='neutral'>//  &#39;logPriceLimitOffsetted := (2 ** 59) * (16 + qLimit)&#39;</span>
 2675 |     | <span class='neutral'>//</span>
 2676 |     | <span class='neutral'>// is stored in the memory space which is pointed to by</span>
 2677 |     | <span class='neutral'>// &#39;_logPriceLimitOffsetted_&#39;.</span>
 2678 |     | <span class='neutral'>//</span>
 2679 |     | <span class='neutral'>// Because</span>
 2680 |     | <span class='neutral'>// </span>
 2681 |     | <span class='neutral'>//  &#39;- 16 + 1 / (2 ** 59) &lt;= qLimit &lt;= + 16 - 1 / (2 ** 59)&#39;,</span>
 2682 |     | <span class='neutral'>//</span>
 2683 |     | <span class='neutral'>// we have</span>
 2684 |     | <span class='neutral'>//</span>
 2685 |     | <span class='neutral'>//  &#39;1 &lt;= logPriceLimitOffsetted &lt;= (2 ** 64) - 1&#39;,</span>
 2686 |     | <span class='neutral'>//</span>
 2687 |     | <span class='neutral'>// which is why 8 bytes are reserved for &#39;logPriceLimitOffsetted&#39; in memory.</span>
 2688 |     | <span class='neutral'>uint16 constant _logPriceLimitOffsetted_ = 328;</span>
 2689 |     | <span class='neutral'></span>
 2690 |     | <span class='neutral'>// Swap Parameters</span>
 2691 |     | <span class='neutral'>// ----------------------------------------------------------------------------</span>
 2692 |     | <span class='neutral'>// The following memory pointers correspond to a number of secondary parameters</span>
 2693 |     | <span class='neutral'>// that are derived and stored in memory in order to facilitate the execution</span>
 2694 |     | <span class='neutral'>// of each &#39;swap&#39; call. The following memory pointers as well as the</span>
 2695 |     | <span class='neutral'>// corresponding getter functions can be used to access each parameter.</span>
 2696 |     | <span class='neutral'>// Moreover, when invoking either of the &#39;midSwap&#39; and &#39;postSwap&#39; hooks, if</span>
 2697 |     | <span class='neutral'>// applicable, these parameters are included in memory snapshot that is passed</span>
 2698 |     | <span class='neutral'>// to the hook as calldata. Hence they can be accessed via the corresponding</span>
 2699 |     | <span class='neutral'>// calldata pointers and getter functions that are listed in</span>
 2700 |     | <span class='neutral'>// &#39;HookCalldata.sol&#39;.</span>
 2701 |     | <span class='neutral'>uint16 constant _swapParams_ = 336;</span>
 2702 |     | <span class='neutral'></span>
 2703 |     | <span class='neutral'>// As discussed before, the calldata layout of the method &#39;swap&#39; in</span>
 2704 |     | <span class='neutral'>// &#39;Nofeeswap.sol&#39; does not have a slot dedicated to &#39;crossThreshold&#39; or</span>
 2705 |     | <span class='neutral'>// &#39;zeroForOne&#39;. Instead, the two inputs &#39;crossThreshold&#39; and &#39;zeroForOne&#39;</span>
 2706 |     | <span class='neutral'>// share the same slot in calldata as illustrated below:</span>
 2707 |     | <span class='neutral'>//</span>
 2708 |     | <span class='neutral'>//     +---------------------------+---------------------------+</span>
 2709 |     | <span class='neutral'>//     | crossThreshold (128 bits) |   zeroForOne (128 bits)   |</span>
 2710 |     | <span class='neutral'>//     +---------------------------+---------------------------+</span>
 2711 |     | <span class='neutral'>//</span>
 2712 |     | <span class='neutral'>// &#39;crossThreshold&#39; occupies the most significant 128 bits and &#39;zeroForOne&#39;</span>
 2713 |     | <span class='neutral'>// occupies the least significant 128 bits.</span>
 2714 |     | <span class='neutral'>//</span>
 2715 |     | <span class='neutral'>//  - If the given &#39;zeroForOne&#39; input is equal to &#39;0&#39;, then the swap is price</span>
 2716 |     | <span class='neutral'>//    increasing in which case &#39;tag0&#39; is outgoing from the pool and &#39;tag1&#39; is</span>
 2717 |     | <span class='neutral'>//    incoming to the pool.</span>
 2718 |     | <span class='neutral'>//</span>
 2719 |     | <span class='neutral'>//  - If the given &#39;zeroForOne&#39; input is equal to &#39;1&#39;, then the swap is price</span>
 2720 |     | <span class='neutral'>//    decreasing in which case &#39;tag0&#39; is incoming to the pool and &#39;tag1&#39; is</span>
 2721 |     | <span class='neutral'>//    outgoing from the pool.</span>
 2722 |     | <span class='neutral'>//</span>
 2723 |     | <span class='neutral'>//  - If the given &#39;zeroForOne&#39; input is equal to any other value, then the</span>
 2724 |     | <span class='neutral'>//    movement of the price is towards &#39;logPriceLimit&#39;, i.e., the swap is price</span>
 2725 |     | <span class='neutral'>//    increasing if</span>
 2726 |     | <span class='neutral'>//</span>
 2727 |     | <span class='neutral'>//      &#39;pCurrent &lt; pLimit&#39;</span>
 2728 |     | <span class='neutral'>//</span>
 2729 |     | <span class='neutral'>//    and the swap is price decreasing if</span>
 2730 |     | <span class='neutral'>//</span>
 2731 |     | <span class='neutral'>//      &#39;pLimit &lt; pCurrent&#39;</span>
 2732 |     | <span class='neutral'>//</span>
 2733 |     | <span class='neutral'>//    where</span>
 2734 |     | <span class='neutral'>//</span>
 2735 |     | <span class='neutral'>//      &#39;pLimit := exp(logPriceLimit / (2 ** 59))&#39;.</span>
 2736 |     | <span class='neutral'>//</span>
 2737 |     | <span class='neutral'>//    and &#39;pCurrent&#39; represents the current price of the pool.</span>
 2738 |     | <span class='neutral'>//</span>
 2739 |     | <span class='neutral'>// A single byte is reserved for this memory space. After the investigation of</span>
 2740 |     | <span class='neutral'>// calldata and comparing &#39;pCurrent&#39; with &#39;pLimit&#39;,</span>
 2741 |     | <span class='neutral'>//</span>
 2742 |     | <span class='neutral'>//   - If the swap is deemed to be price increasing, then the byte which is</span>
 2743 |     | <span class='neutral'>//     pointed to by &#39;_zeroForOne_&#39; is left as &#39;0x00&#39;.</span>
 2744 |     | <span class='neutral'>//</span>
 2745 |     | <span class='neutral'>//   - If the swap is price decreasing, then this byte is populated with</span>
 2746 |     | <span class='neutral'>//     &#39;0xFF&#39;.</span>
 2747 |     | <span class='neutral'>//</span>
 2748 |     | <span class='neutral'>// The getter function &#39;getZeroForOne&#39; in this script and the getter function</span>
 2749 |     | <span class='neutral'>// &#39;getZeroForOneFromCalldata&#39; in &#39;HookCalldata.sol&#39; give access to the content</span>
 2750 |     | <span class='neutral'>// of this memory space (or calldata in the context of the hook contract) as a</span>
 2751 |     | <span class='neutral'>// boolean with &#39;false&#39; and &#39;true&#39; representing price increasing and price</span>
 2752 |     | <span class='neutral'>// decreasing swaps, respectively.</span>
 2753 |     | <span class='neutral'>uint16 constant _zeroForOne_ = 336;</span>
 2754 |     | <span class='neutral'></span>
 2755 |     | <span class='neutral'>// The input &#39;amountSpecified&#39; of the &#39;swap&#39; method in &#39;Nofeeswap.sol&#39; is a</span>
 2756 |     | <span class='neutral'>// signed integer. The following memory spaces contains the sign of</span>
 2757 |     | <span class='neutral'>// &#39;amountSpecified&#39; which can be accessed as a boolean. To this end, a single</span>
 2758 |     | <span class='neutral'>// byte is reserved in memory which is pointed to by &#39;_exactInput_&#39;.</span>
 2759 |     | <span class='neutral'>//</span>
 2760 |     | <span class='neutral'>//   - If &#39;amountSpecified &gt; 0&#39;, then &#39;amountSpecified&#39; represents the</span>
 2761 |     | <span class='neutral'>//     requested incoming amount to be given to the pool as a result of the</span>
 2762 |     | <span class='neutral'>//     swap call. In this case the byte which is pointed to by &#39;_exactInput_&#39;</span>
 2763 |     | <span class='neutral'>//     is left as &#39;0x00&#39;.</span>
 2764 |     | <span class='neutral'>//</span>
 2765 |     | <span class='neutral'>//   - If &#39;amountSpecified &lt; 0&#39;, then &#39;0 - amountSpecified&#39; represents the</span>
 2766 |     | <span class='neutral'>//     requested outgoing amount to be taken from the pool as a result of the</span>
 2767 |     | <span class='neutral'>//     swap call. In this case the byte which is pointed to by &#39;_exactInput_&#39;</span>
 2768 |     | <span class='neutral'>//     is populated with &#39;0xFF&#39;.</span>
 2769 |     | <span class='neutral'>//</span>
 2770 |     | <span class='neutral'>// The getter function &#39;getExactInput&#39; in this script and the getter function</span>
 2771 |     | <span class='neutral'>// &#39;getExactInputFromCalldata&#39; in &#39;HookCalldata.sol&#39; give access to the content</span>
 2772 |     | <span class='neutral'>// of this memory space (or calldata in the context of the hook contract) as a</span>
 2773 |     | <span class='neutral'>// boolean with &#39;false&#39; and &#39;true&#39; representing exact output and exact input </span>
 2774 |     | <span class='neutral'>// swaps, respectively.</span>
 2775 |     | <span class='neutral'>uint16 constant _exactInput_ = 337;</span>
 2776 |     | <span class='neutral'></span>
 2777 |     | <span class='neutral'>// The execution of a swap call may involve transacting in a single liquidity</span>
 2778 |     | <span class='neutral'>// interval, or it may require visits to multiple intervals.</span>
 2779 |     | <span class='neutral'>//</span>
 2780 |     | <span class='neutral'>// If &#39;crossThreshold&#39; and &#39;logPriceLimitOffsetted&#39; are not binding, and in the</span>
 2781 |     | <span class='neutral'>// presence of sufficient liquidity, the protocol should be able to fulfill</span>
 2782 |     | <span class='neutral'>// &#39;amountSpecified&#39; in the current active interval. This process involves a</span>
 2783 |     | <span class='neutral'>// movement of price from</span>
 2784 |     | <span class='neutral'>//</span>
 2785 |     | <span class='neutral'>//  &#39;qCurrent := log(pCurrent / pOffset)&#39;</span>
 2786 |     | <span class='neutral'>//</span>
 2787 |     | <span class='neutral'>// to</span>
 2788 |     | <span class='neutral'>//</span>
 2789 |     | <span class='neutral'>//  &#39;qTarget := log(pTarget / pOffset)&#39;</span>
 2790 |     | <span class='neutral'>//</span>
 2791 |     | <span class='neutral'>// within the same active liquidity interval, i.e.,</span>
 2792 |     | <span class='neutral'>//</span>
 2793 |     | <span class='neutral'>//   &#39;qLower &lt;= qTarget &lt;= qUpper&#39;.</span>
 2794 |     | <span class='neutral'>//</span>
 2795 |     | <span class='neutral'>// In order to accomplish this, we need to solve the equation:</span>
 2796 |     | <span class='neutral'>//</span>
 2797 |     | <span class='neutral'>//  &#39;|amountSpecified| == </span>
 2798 |     | <span class='neutral'>//</span>
 2799 |     | <span class='neutral'>//      (getZeroForOne() != getExactInput() ? sqrtOffset : sqrtInverseOffset) * </span>
 2800 |     | <span class='neutral'>//</span>
 2801 |     | <span class='neutral'>//                      growth</span>
 2802 |     | <span class='neutral'>//      sharesTotal * ---------- * </span>
 2803 |     | <span class='neutral'>//                     2 ** 111</span>
 2804 |     | <span class='neutral'>//</span>
 2805 |     | <span class='neutral'>//       getExactInput() ? incomingCurrentToTarget : currentToTarget</span>
 2806 |     | <span class='neutral'>//      -------------------------------------------------------------&#39;,</span>
 2807 |     | <span class='neutral'>//                                outgoingMax</span>
 2808 |     | <span class='neutral'>//</span>
 2809 |     | <span class='neutral'>// where &#39;|amountSpecified|&#39;, &#39;sqrtOffset&#39;, &#39;sqrtInverseOffset&#39;, &#39;outgoingMax&#39;,</span>
 2810 |     | <span class='neutral'>// &#39;sharesTotal&#39;, and &#39;growth&#39; remain fixed as long as we are in the same</span>
 2811 |     | <span class='neutral'>// interval.</span>
 2812 |     | <span class='neutral'>//</span>
 2813 |     | <span class='neutral'>// Hence, as an initial step of a swap call&#39;s execution and with each visit to</span>
 2814 |     | <span class='neutral'>// a new interval, the following value is calculated in &#39;X216&#39; format:</span>
 2815 |     | <span class='neutral'>//</span>
 2816 |     | <span class='neutral'>//  &#39;integralLimit := min(</span>
 2817 |     | <span class='neutral'>//</span>
 2818 |     | <span class='neutral'>//      oneX216 - epsilonX216,</span>
 2819 |     | <span class='neutral'>//</span>
 2820 |     | <span class='neutral'>//                           1          2 ** 111</span>
 2821 |     | <span class='neutral'>//      outgoingMax *  ------------- * ---------- *</span>
 2822 |     | <span class='neutral'>//                      sharesTotal      growth</span>
 2823 |     | <span class='neutral'>//</span>
 2824 |     | <span class='neutral'>//                                |amountSpecified|</span>
 2825 |     | <span class='neutral'>//      -----------------------------------------------------------------------</span>
 2826 |     | <span class='neutral'>//       (getZeroForOne() != getExactInput()) ? sqrtOffset : sqrtInverseOffset</span>
 2827 |     | <span class='neutral'>//</span>
 2828 |     | <span class='neutral'>//   )&#39;.</span>
 2829 |     | <span class='neutral'>//</span>
 2830 |     | <span class='neutral'>// Based on the above equations, it is straightforward to verify that</span>
 2831 |     | <span class='neutral'>// &#39;amountSpecified&#39; is fulfilled if and only if:</span>
 2832 |     | <span class='neutral'>//</span>
 2833 |     | <span class='neutral'>//   &#39;getExactInput() ? incomingCurrentToTarget : currentToTarget</span>
 2834 |     | <span class='neutral'>//     == </span>
 2835 |     | <span class='neutral'>//    integralLimit&#39;.</span>
 2836 |     | <span class='neutral'>//</span>
 2837 |     | <span class='neutral'>// Since the left-hand side is a function of &#39;qTarget&#39;, the above equation is</span>
 2838 |     | <span class='neutral'>// solved by methods &#39;searchOutgoingTarget&#39; and &#39;searchIncomingTarget&#39; in</span>
 2839 |     | <span class='neutral'>// &#39;Interval.sol&#39; in order to calculate the precise value of &#39;qTarget&#39; that</span>
 2840 |     | <span class='neutral'>// fulfills &#39;amountSpecified&#39;. These two methods work with &#39;integralLimit&#39;.</span>
 2841 |     | <span class='neutral'>//</span>
 2842 |     | <span class='neutral'>// &#39;integralLimit&#39; is less than &#39;oneX216&#39; and does not exceed 216 bits. Hence,</span>
 2843 |     | <span class='neutral'>// 27 bytes are reserved for the memory space that stores &#39;integralLimit&#39;.</span>
 2844 |     | <span class='neutral'>uint16 constant _integralLimit_ = 338;</span>
 2845 |     | <span class='neutral'></span>
 2846 |     | <span class='neutral'>// Let &#39;pLower&#39; and &#39;pUpper&#39;, respectively, denote the minimum and maximum</span>
 2847 |     | <span class='neutral'>// price in the current active liquidity interval and define</span>
 2848 |     | <span class='neutral'>//</span>
 2849 |     | <span class='neutral'>//  &#39;qLower := log(pLower / pOffset)&#39;,</span>
 2850 |     | <span class='neutral'>//  &#39;qUpper := log(pUpper / pOffset)&#39;.</span>
 2851 |     | <span class='neutral'>//</span>
 2852 |     | <span class='neutral'>// By crossing the active interval entirely from one end to the other end, the</span>
 2853 |     | <span class='neutral'>// absolute value &#39;|amountSpecified|&#39; is decremented by</span>
 2854 |     | <span class='neutral'>//</span>
 2855 |     | <span class='neutral'>//  &#39;(getZeroForOne() != getExactInput() ? sqrtOffset : sqrtInverseOffset) * </span>
 2856 |     | <span class='neutral'>//</span>
 2857 |     | <span class='neutral'>//                   growth      integralLimitInterval</span>
 2858 |     | <span class='neutral'>//   sharesTotal * ---------- * -----------------------&#39;,</span>
 2859 |     | <span class='neutral'>//                  2 ** 111          outgoingMax</span>
 2860 |     | <span class='neutral'>//</span>
 2861 |     | <span class='neutral'>// where &#39;integralLimitInterval&#39; for the present interval is defined as</span>
 2862 |     | <span class='neutral'>//</span>
 2863 |     | <span class='neutral'>//  &#39;integralLimitInterval := (getExactInput() ? incomingMax : outgoingMax)</span>
 2864 |     | <span class='neutral'>//</span>
 2865 |     | <span class='neutral'>//           (getZeroForOne() != getExactInput() ? - qLower : + qUpper) / 2</span>
 2866 |     | <span class='neutral'>//       * e                                                               &#39;.</span>
 2867 |     | <span class='neutral'>//</span>
 2868 |     | <span class='neutral'>// By crossing the active interval, the limit imposed by &#39;amountSpecified&#39; is</span>
 2869 |     | <span class='neutral'>// not violated if and only if:</span>
 2870 |     | <span class='neutral'>//        </span>
 2871 |     | <span class='neutral'>//  &#39;integralLimitInterval &lt;= integralLimit&#39;.</span>
 2872 |     | <span class='neutral'>//</span>
 2873 |     | <span class='neutral'>// Hence, &#39;integralLimitInterval&#39; can be used to determined whether we should</span>
 2874 |     | <span class='neutral'>// cross a new active interval entirely or not.</span>
 2875 |     | <span class='neutral'>//</span>
 2876 |     | <span class='neutral'>// &#39;integralLimitInterval&#39; is calculated with each visit to a new interval and</span>
 2877 |     | <span class='neutral'>// stored in the 27 bytes memory space which is pointed to by</span>
 2878 |     | <span class='neutral'>// &#39;_integralLimitInterval_&#39;.</span>
 2879 |     | <span class='neutral'>uint16 constant _integralLimitInterval_ = 365;</span>
 2880 |     | <span class='neutral'></span>
 2881 |     | <span class='neutral'>// Throughout the execution of a swap, this 32 bytes memory space hosts the</span>
 2882 |     | <span class='neutral'>// &#39;X127&#39; representation of &#39;amount0&#39; which is the total amount of &#39;tag0&#39; that</span>
 2883 |     | <span class='neutral'>// is traded so far. Concluding the visit to each interval involves</span>
 2884 |     | <span class='neutral'>// incrementing the absolute value &#39;|amount0|&#39; with</span>
 2885 |     | <span class='neutral'>//                                                         growth</span>
 2886 |     | <span class='neutral'>//  &#39;amount0Partial := sqrtInverseOffset * sharesTotal * ---------- *</span>
 2887 |     | <span class='neutral'>//                                                        2 ** 111</span>
 2888 |     | <span class='neutral'>//</span>
 2889 |     | <span class='neutral'>//   (getZeroForOne() ? incomingCurrentToTarget : currentToTarget)&#39;.</span>
 2890 |     | <span class='neutral'>//</span>
 2891 |     | <span class='neutral'>// If positive, &#39;amount0&#39; is incoming to the pool and if negative it is</span>
 2892 |     | <span class='neutral'>// outgoing from the pool.</span>
 2893 |     | <span class='neutral'>uint16 constant _amount0_ = 392;</span>
 2894 |     | <span class='neutral'></span>
 2895 |     | <span class='neutral'>// Throughout the execution of a swap, this 32 bytes memory space hosts the</span>
 2896 |     | <span class='neutral'>// &#39;X127&#39; representation of &#39;amount1&#39; which is the total amount of &#39;tag1&#39; that</span>
 2897 |     | <span class='neutral'>// is traded so far. Concluding the visit to each interval involves</span>
 2898 |     | <span class='neutral'>// incrementing the absolute value &#39;|amount1|&#39; with</span>
 2899 |     | <span class='neutral'>//                                                  growth</span>
 2900 |     | <span class='neutral'>//  &#39;amount1Partial := sqrtOffset * sharesTotal * ---------- *</span>
 2901 |     | <span class='neutral'>//                                                 2 ** 111</span>
 2902 |     | <span class='neutral'>//</span>
 2903 |     | <span class='neutral'>//   (getZeroForOne() ? currentToTarget : incomingCurrentToTarget)&#39;.</span>
 2904 |     | <span class='neutral'>//</span>
 2905 |     | <span class='neutral'>// If positive, &#39;amount1&#39; is incoming to the pool and if negative it is</span>
 2906 |     | <span class='neutral'>// outgoing from the pool.</span>
 2907 |     | <span class='neutral'>uint16 constant _amount1_ = 424;</span>
 2908 |     | <span class='neutral'></span>
 2909 |     | <span class='neutral'>// At each point throughout the execution of a swap, as we transition from</span>
 2910 |     | <span class='neutral'>// each interval to the next one, the memory pointer &#39;_back_&#39; is used in order</span>
 2911 |     | <span class='neutral'>// to keep track of the active interval boundary in the opposite direction of</span>
 2912 |     | <span class='neutral'>// the swap.</span>
 2913 |     | <span class='neutral'>//</span>
 2914 |     | <span class='neutral'>// Let &#39;pLower&#39; and &#39;pUpper&#39;, respectively, denote the minimum and maximum</span>
 2915 |     | <span class='neutral'>// price in the current active liquidity interval and define</span>
 2916 |     | <span class='neutral'>//</span>
 2917 |     | <span class='neutral'>//  &#39;qBack := log((getZeroForOne() ? pUpper : pLower) / pOffset)&#39;.</span>
 2918 |     | <span class='neutral'>//</span>
 2919 |     | <span class='neutral'>// The 62 bytes memory space which is pointed to by &#39;_back_&#39; hosts the</span>
 2920 |     | <span class='neutral'>// following values:</span>
 2921 |     | <span class='neutral'>//</span>
 2922 |     | <span class='neutral'>//  &#39;_back_.log() := (2 ** 59) * (16 + qBack)&#39;,</span>
 2923 |     | <span class='neutral'>//  &#39;_back_.sqrt(false) := (2 ** 216) * exp(- 8 - qBack / 2)&#39;,</span>
 2924 |     | <span class='neutral'>//  &#39;_back_.sqrt(true) := (2 ** 216) * exp(- 8 + qBack / 2)&#39;.</span>
 2925 |     | <span class='neutral'>//</span>
 2926 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The logarithmic price</span>
 2927 |     | <span class='neutral'>// &#39;_back_.log()&#39; occupies 64 bits, whereas &#39;_back_.sqrt(false)&#39; and</span>
 2928 |     | <span class='neutral'>// &#39;_back_.sqrt(true)&#39; occupy 216 bits each.</span>
 2929 |     | <span class='neutral'>uint16 constant _back_ = 456;</span>
 2930 |     | <span class='neutral'></span>
 2931 |     | <span class='neutral'>// At each point throughout the execution of a swap, as we transition from</span>
 2932 |     | <span class='neutral'>// each interval to the next one, the memory pointer &#39;_next_&#39; is used in order</span>
 2933 |     | <span class='neutral'>// to keep track of the active interval boundary in the direction of the swap.</span>
 2934 |     | <span class='neutral'>//</span>
 2935 |     | <span class='neutral'>// Let &#39;pLower&#39; and &#39;pUpper&#39;, respectively, denote the minimum and maximum</span>
 2936 |     | <span class='neutral'>// price in the current active liquidity interval and define</span>
 2937 |     | <span class='neutral'>//</span>
 2938 |     | <span class='neutral'>//  &#39;qNext := log((getZeroForOne() ? pLower : pUpper) / pOffset)&#39;.</span>
 2939 |     | <span class='neutral'>//</span>
 2940 |     | <span class='neutral'>// The 62 bytes memory space which is pointed to by &#39;_next_&#39; hosts the</span>
 2941 |     | <span class='neutral'>// following values:</span>
 2942 |     | <span class='neutral'>//</span>
 2943 |     | <span class='neutral'>//  &#39;_next_.log() := (2 ** 59) * (16 + qNext)&#39;,</span>
 2944 |     | <span class='neutral'>//  &#39;_next_.sqrt(false) := (2 ** 216) * exp(- 8 - qNext / 2)&#39;,</span>
 2945 |     | <span class='neutral'>//  &#39;_next_.sqrt(true) := (2 ** 216) * exp(- 8 + qNext / 2)&#39;.</span>
 2946 |     | <span class='neutral'>//</span>
 2947 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The logarithmic price</span>
 2948 |     | <span class='neutral'>// &#39;_next_.log()&#39; occupies 64 bits, whereas &#39;_next_.sqrt(false)&#39; and</span>
 2949 |     | <span class='neutral'>// &#39;_next_.sqrt(true)&#39; occupy 216 bits each.</span>
 2950 |     | <span class='neutral'>uint16 constant _next_ = 518;</span>
 2951 |     | <span class='neutral'></span>
 2952 |     | <span class='neutral'>// An LP may choose any consecutive range of liquidity intervals to deposit</span>
 2953 |     | <span class='neutral'>// their liquidity. By doing so, the LP acquires a number of shares in every</span>
 2954 |     | <span class='neutral'>// liquidity interval that belongs to the given range.</span>
 2955 |     | <span class='neutral'>//</span>
 2956 |     | <span class='neutral'>// Let &#39;pLower&#39; and &#39;pUpper&#39;, respectively, denote the minimum and maximum</span>
 2957 |     | <span class='neutral'>// price in the current active liquidity interval and define</span>
 2958 |     | <span class='neutral'>//</span>
 2959 |     | <span class='neutral'>//  &#39;qLower := log(pLower / pOffset)&#39;,</span>
 2960 |     | <span class='neutral'>//  &#39;qUpper := log(pUpper / pOffset)&#39;.</span>
 2961 |     | <span class='neutral'>//</span>
 2962 |     | <span class='neutral'>// Additionally, let</span>
 2963 |     | <span class='neutral'>// </span>
 2964 |     | <span class='neutral'>//    sqrtInverseOffset     growthMultiplier[qUpper]</span>
 2965 |     | <span class='neutral'>//  &#39;------------------- * --------------------------&#39;</span>
 2966 |     | <span class='neutral'>//         2 ** 127                 2 ** 208</span>
 2967 |     | <span class='neutral'>//</span>
 2968 |     | <span class='neutral'>// represent the total amount of &#39;tag0&#39; corresponding to a single liquidity</span>
 2969 |     | <span class='neutral'>// provider&#39;s share from &#39;qUpper&#39; to &#39;+oo&#39; and</span>
 2970 |     | <span class='neutral'>//</span>
 2971 |     | <span class='neutral'>//    sqrtOffset     growthMultiplier[qLower]</span>
 2972 |     | <span class='neutral'>//  &#39;------------ * --------------------------&#39;</span>
 2973 |     | <span class='neutral'>//     2 ** 127             2 ** 208</span>
 2974 |     | <span class='neutral'>//</span>
 2975 |     | <span class='neutral'>// represent the total amount of &#39;tag1&#39; corresponding to a single liquidity</span>
 2976 |     | <span class='neutral'>// provider&#39;s share from &#39;-oo&#39; to &#39;qLower&#39;.</span>
 2977 |     | <span class='neutral'>//</span>
 2978 |     | <span class='neutral'>// The 32 bytes memory space which is pointed to by &#39;_backGrowthMultiplier_&#39;</span>
 2979 |     | <span class='neutral'>// hosts the &#39;X208&#39; representation of</span>
 2980 |     | <span class='neutral'>// &#39;growthMultiplier[getZeroForOne() ? qUpper : qLower]&#39;.</span>
 2981 |     | <span class='neutral'>//</span>
 2982 |     | <span class='neutral'>// The 32 bytes memory space which is pointed to by &#39;_nextGrowthMultiplier_&#39;</span>
 2983 |     | <span class='neutral'>// hosts the &#39;X208&#39; representation of</span>
 2984 |     | <span class='neutral'>// &#39;growthMultiplier[getZeroForOne() ? qLower : qUpper]&#39;.</span>
 2985 |     | <span class='neutral'>uint16 constant _backGrowthMultiplier_ = 580;</span>
 2986 |     | <span class='neutral'>uint16 constant _nextGrowthMultiplier_ = 612;</span>
 2987 |     | <span class='neutral'></span>
 2988 |     | <span class='neutral'>// Interval Parameters</span>
 2989 |     | <span class='neutral'>// ----------------------------------------------------------------------------</span>
 2990 |     | <span class='neutral'>// The following memory pointers correspond to the main variables that are used</span>
 2991 |     | <span class='neutral'>// to calculate swaps within the active liquidity interval.</span>
 2992 |     | <span class='neutral'>//</span>
 2993 |     | <span class='neutral'>// Let &#39;pCurrent&#39; denote the current price of the pool and let &#39;pLower&#39; and</span>
 2994 |     | <span class='neutral'>// &#39;pUpper&#39;, respectively, denote the minimum and maximum price in the current</span>
 2995 |     | <span class='neutral'>// active liquidity interval. Define:</span>
 2996 |     | <span class='neutral'>//</span>
 2997 |     | <span class='neutral'>//  &#39;qLower := log(pLower / pOffset)&#39;,</span>
 2998 |     | <span class='neutral'>//  &#39;qUpper := log(pUpper / pOffset)&#39;,</span>
 2999 |     | <span class='neutral'>//  &#39;qSpacing := log(pUpper / pLower)&#39;,</span>
 3000 |     | <span class='neutral'>//  &#39;qCurrent := log(pCurrent / pOffset)&#39;.</span>
 3001 |     | <span class='neutral'>//</span>
 3002 |     | <span class='neutral'>// Then we have:</span>
 3003 |     | <span class='neutral'>//</span>
 3004 |     | <span class='neutral'>//  &#39;qLower &lt;= qCurrent &lt;= qUpper&#39;,</span>
 3005 |     | <span class='neutral'>//</span>
 3006 |     | <span class='neutral'>// Consider a swap that involves a movement of price from &#39;qCurrent&#39; to</span>
 3007 |     | <span class='neutral'>//</span>
 3008 |     | <span class='neutral'>//  &#39;qTarget := log(pTarget / pOffset)&#39;</span>
 3009 |     | <span class='neutral'>//</span>
 3010 |     | <span class='neutral'>// within the same active liquidity interval, i.e.,</span>
 3011 |     | <span class='neutral'>//</span>
 3012 |     | <span class='neutral'>//  &#39;qLower &lt;= qTarget &lt;= qUpper&#39;.</span>
 3013 |     | <span class='neutral'>//</span>
 3014 |     | <span class='neutral'>// Notice that &#39;qTarget&#39; is an unknown value which will be determined based on</span>
 3015 |     | <span class='neutral'>// one of the followings:</span>
 3016 |     | <span class='neutral'>//</span>
 3017 |     | <span class='neutral'>//  - &#39;qLimitWithinInterval&#39;, which is calculated based on the input</span>
 3018 |     | <span class='neutral'>//    &#39;logPriceLimit&#39; as well as &#39;qLower&#39; and &#39;qUpper&#39;. It is stored in the</span>
 3019 |     | <span class='neutral'>//    memory space which is pointed to by</span>
 3020 |     | <span class='neutral'>//    &#39;_logPriceLimitOffsettedWithinInterval_&#39;.</span>
 3021 |     | <span class='neutral'>//</span>
 3022 |     | <span class='neutral'>//  - &#39;integralLimit&#39;, which is calculated based on the input &#39;amountSpecified&#39;</span>
 3023 |     | <span class='neutral'>//    and is stored in the memory space which is pointed to by</span>
 3024 |     | <span class='neutral'>//    &#39;_integralLimit_&#39;.</span>
 3025 |     | <span class='neutral'>//</span>
 3026 |     | <span class='neutral'>// After determination of &#39;qTarget&#39;, the amounts of &#39;tag0&#39; and &#39;tag1&#39; to be</span>
 3027 |     | <span class='neutral'>// exchanged as a result of the movement within &#39;[qLower, qUpper]&#39; are equal</span>
 3028 |     | <span class='neutral'>// to:</span>
 3029 |     | <span class='neutral'>//</span>
 3030 |     | <span class='neutral'>//                                                         growth</span>
 3031 |     | <span class='neutral'>//  &#39;amount0Partial := sqrtInverseOffset * sharesTotal * ---------- *</span>
 3032 |     | <span class='neutral'>//                                                        2 ** 111</span>
 3033 |     | <span class='neutral'>//</span>
 3034 |     | <span class='neutral'>//    getZeroForOne() ? incomingCurrentToTarget : currentToTarget</span>
 3035 |     | <span class='neutral'>//   -------------------------------------------------------------&#39;,</span>
 3036 |     | <span class='neutral'>//                            outgoingMax</span>
 3037 |     | <span class='neutral'>// and</span>
 3038 |     | <span class='neutral'>//                                                  growth</span>
 3039 |     | <span class='neutral'>//  &#39;amount1Partial := sqrtOffset * sharesTotal * ---------- *</span>
 3040 |     | <span class='neutral'>//                                                 2 ** 111</span>
 3041 |     | <span class='neutral'>//</span>
 3042 |     | <span class='neutral'>//    getZeroForOne() ? currentToTarget : incomingCurrentToTarget</span>
 3043 |     | <span class='neutral'>//   -------------------------------------------------------------&#39;,</span>
 3044 |     | <span class='neutral'>//                            outgoingMax</span>
 3045 |     | <span class='neutral'>//</span>
 3046 |     | <span class='neutral'>// where the parameters &#39;sqrtInverseOffset&#39;, &#39;sqrtOffset&#39;, &#39;sharesTotal&#39;,</span>
 3047 |     | <span class='neutral'>// &#39;growth&#39;, and &#39;outgoingMax&#39; remain fixed throughout the movement from</span>
 3048 |     | <span class='neutral'>// &#39;qCurrent&#39; to &#39;qTarget&#39;.</span>
 3049 |     | <span class='neutral'>//</span>
 3050 |     | <span class='neutral'>// While searching for &#39;qTarget&#39;, the two integrals &#39;currentToTarget&#39; and</span>
 3051 |     | <span class='neutral'>// &#39;incomingCurrentToTarget&#39; are calculated. These two integrals are defined as</span>
 3052 |     | <span class='neutral'>// follows:</span>
 3053 |     | <span class='neutral'>//</span>
 3054 |     | <span class='neutral'>//                           - 8</span>
 3055 |     | <span class='neutral'>//    currentToTarget      e</span>
 3056 |     | <span class='neutral'>//  &#39;----------------- := ------- * (</span>
 3057 |     | <span class='neutral'>//       2 ** 216            2</span>
 3058 |     | <span class='neutral'>//</span>
 3059 |     | <span class='neutral'>//                         / qCurrent                 / qTarget</span>
 3060 |     | <span class='neutral'>//                        |    + h / 2               |    - h / 2</span>
 3061 |     | <span class='neutral'>//     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh</span>
 3062 |     | <span class='neutral'>//                        |                          |</span>
 3063 |     | <span class='neutral'>//                       / qTarget                  / qCurrent</span>
 3064 |     | <span class='neutral'>//</span>
 3065 |     | <span class='neutral'>//   )&#39;</span>
 3066 |     | <span class='neutral'>//</span>
 3067 |     | <span class='neutral'>// and</span>
 3068 |     | <span class='neutral'>//                                   - 8</span>
 3069 |     | <span class='neutral'>//    incomingCurrentToTarget      e</span>
 3070 |     | <span class='neutral'>//  &#39;------------------------- := ------- * (</span>
 3071 |     | <span class='neutral'>//           2 ** 216                2</span>
 3072 |     | <span class='neutral'>//</span>
 3073 |     | <span class='neutral'>//                         / qCurrent                 / qTarget</span>
 3074 |     | <span class='neutral'>//                        |    - h / 2               |    + h / 2</span>
 3075 |     | <span class='neutral'>//     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh</span>
 3076 |     | <span class='neutral'>//                        |                          |</span>
 3077 |     | <span class='neutral'>//                       / qTarget                  / qCurrent</span>
 3078 |     | <span class='neutral'>//</span>
 3079 |     | <span class='neutral'>//   )&#39;.</span>
 3080 |     | <span class='neutral'>//</span>
 3081 |     | <span class='neutral'>// To further clarify the above definitions, we first need to define the</span>
 3082 |     | <span class='neutral'>// function &#39;w(.)&#39; which is constructed based on the curve sequence.</span>
 3083 |     | <span class='neutral'>//</span>
 3084 |     | <span class='neutral'>// The curve sequence comprises 64 bit logarithmic prices in the form of</span>
 3085 |     | <span class='neutral'>//</span>
 3086 |     | <span class='neutral'>//  &#39;(2 ** 59) * (16 + qHistorical)&#39;</span>
 3087 |     | <span class='neutral'>//</span>
 3088 |     | <span class='neutral'>// where every &#39;qHistorical&#39; satisfies:</span>
 3089 |     | <span class='neutral'>//</span>
 3090 |     | <span class='neutral'>//  &#39;qLower &lt;= qHistorical &lt;= qUpper&#39;.</span>
 3091 |     | <span class='neutral'>//</span>
 3092 |     | <span class='neutral'>// Hence, each slot of the curve sequence consists of up to four members. The</span>
 3093 |     | <span class='neutral'>// curve sequence should have at least two members. The first and the second</span>
 3094 |     | <span class='neutral'>// members are &#39;qLower&#39; and &#39;qUpper&#39; with the order depending on the pool&#39;s</span>
 3095 |     | <span class='neutral'>// history. The last member is always &#39;qCurrent&#39;. Consider the following curve</span>
 3096 |     | <span class='neutral'>// sequence:</span>
 3097 |     | <span class='neutral'>// </span>
 3098 |     | <span class='neutral'>//  &#39;q[0], q[1], q[2], ..., q[l - 1]&#39;</span>
 3099 |     | <span class='neutral'>//</span>
 3100 |     | <span class='neutral'>// where &#39;l&#39; is the number of members. Additionally, to simplify the notations,</span>
 3101 |     | <span class='neutral'>// the out-of-range member &#39;q[l]&#39; is assigned the same value as &#39;q[l - 1]&#39;. In</span>
 3102 |     | <span class='neutral'>// order for the above sequence to be considered valid, we should have:</span>
 3103 |     | <span class='neutral'>//</span>
 3104 |     | <span class='neutral'>//  &#39;min(q[i - 1], q[i - 2]) &lt; q[i] &lt; max(q[i - 1], q[i - 2])&#39;.</span>
 3105 |     | <span class='neutral'>//</span>
 3106 |     | <span class='neutral'>// for every &#39;2 &lt;= i &lt; l&#39;. Define</span>
 3107 |     | <span class='neutral'>// </span>
 3108 |     | <span class='neutral'>//  &#39;w : [qLower, qUpper] -&gt; [0, qSpacing]&#39;</span>
 3109 |     | <span class='neutral'>//</span>
 3110 |     | <span class='neutral'>// as</span>
 3111 |     | <span class='neutral'>//           l - 2</span>
 3112 |     | <span class='neutral'>//           -----</span>
 3113 |     | <span class='neutral'>//           \</span>
 3114 |     | <span class='neutral'>//  &#39;w(q) := /     w_i(q)&#39;.</span>
 3115 |     | <span class='neutral'>//           -----</span>
 3116 |     | <span class='neutral'>//           i = 0</span>
 3117 |     | <span class='neutral'>//</span>
 3118 |     | <span class='neutral'>// where for every &#39;0 &lt;= i &lt;= l - 2&#39;, the function</span>
 3119 |     | <span class='neutral'>//</span>
 3120 |     | <span class='neutral'>//  &#39;w_i : [qLower, qUpper] -&gt; [0, qSpacing]&#39;</span>
 3121 |     | <span class='neutral'>//</span>
 3122 |     | <span class='neutral'>// is regarded as a phase which is defined as</span>
 3123 |     | <span class='neutral'>//</span>
 3124 |     | <span class='neutral'>//  &#39;w_i(q) :=</span>
 3125 |     | <span class='neutral'>//</span>
 3126 |     | <span class='neutral'>//    /</span>
 3127 |     | <span class='neutral'>//   |  |q - q[i + 1]|  if  min(q[i], q[i + 2]) &lt; q &lt; max(q[i], q[i + 2])</span>
 3128 |     | <span class='neutral'>//   |                                                                    &#39;.</span>
 3129 |     | <span class='neutral'>//   |  0               otherwise</span>
 3130 |     | <span class='neutral'>//    \</span>
 3131 |     | <span class='neutral'>//</span>
 3132 |     | <span class='neutral'>// Observe that for each &#39;0 &lt;= i &lt;= l - 2&#39;, the phase &#39;w_i&#39; can be</span>
 3133 |     | <span class='neutral'>// characterized via the following three consecutive members of the curve</span>
 3134 |     | <span class='neutral'>// sequence:</span>
 3135 |     | <span class='neutral'>//</span>
 3136 |     | <span class='neutral'>//  &#39;q[i], q[i + 1], q[i + 2]&#39;</span>
 3137 |     | <span class='neutral'>//</span>
 3138 |     | <span class='neutral'>// Next, we need to define the function &#39;k(.)&#39; which is constructed from the</span>
 3139 |     | <span class='neutral'>// kernel. The kernel is composed of breakpoints. Let &#39;m + 1&#39; denote the number</span>
 3140 |     | <span class='neutral'>// of these breakpoints. For every integer &#39;0 &lt;= i &lt;= m&#39; the i-th breakpoint of</span>
 3141 |     | <span class='neutral'>// the kernel represents the pair &#39;(b[i], c[i])&#39; where</span>
 3142 |     | <span class='neutral'>//</span>
 3143 |     | <span class='neutral'>//  &#39;0 == b[0] &lt;  b[1] &lt;= b[2] &lt;= ... &lt;= b[m - 1] &lt;  b[m] == qSpacing&#39;,</span>
 3144 |     | <span class='neutral'>//  &#39;0 == c[0] &lt;= c[1] &lt;= c[2] &lt;= ... &lt;= c[m - 1] &lt;= c[m] == 1&#39;.</span>
 3145 |     | <span class='neutral'>// </span>
 3146 |     | <span class='neutral'>// Each breakpoint occupies 64 bytes, in which:</span>
 3147 |     | <span class='neutral'>//</span>
 3148 |     | <span class='neutral'>//  - the &#39;X15&#39; representation of &#39;(2 ** 15) * c[i]&#39; occupies 2 bytes,</span>
 3149 |     | <span class='neutral'>//</span>
 3150 |     | <span class='neutral'>//  - the &#39;X59&#39; representation of &#39;(2 ** 59) * b[i]&#39; occupies 8 bytes,</span>
 3151 |     | <span class='neutral'>//</span>
 3152 |     | <span class='neutral'>//  - the &#39;X216&#39; representation of &#39;(2 ** 216) * exp(- b[i] / 2)&#39; occupies 27</span>
 3153 |     | <span class='neutral'>//    bytes,</span>
 3154 |     | <span class='neutral'>//</span>
 3155 |     | <span class='neutral'>//  - the &#39;X216&#39; representation of &#39;(2 ** 216) * exp(- 16 + b[i] / 2)&#39; occupies</span>
 3156 |     | <span class='neutral'>//    27 bytes.</span>
 3157 |     | <span class='neutral'>//</span>
 3158 |     | <span class='neutral'>// The above-mentioned layout is illustrated as follows:</span>
 3159 |     | <span class='neutral'>//</span>
 3160 |     | <span class='neutral'>//                      A 512 bit kernel breakpoint</span>
 3161 |     | <span class='neutral'>//  +--+--------+---------------------------+---------------------------+</span>
 3162 |     | <span class='neutral'>//  |  | 8 byte |          27 byte          |          27 byte          |</span>
 3163 |     | <span class='neutral'>//  +--+--------+---------------------------+---------------------------+</span>
 3164 |     | <span class='neutral'>//  |  |        |                           |</span>
 3165 |     | <span class='neutral'>//  |  |        |                            \</span>
 3166 |     | <span class='neutral'>//  |  |        |                             (2 ** 216) * exp(- 16 + b[i] / 2)</span>
 3167 |     | <span class='neutral'>//  |  |         \</span>
 3168 |     | <span class='neutral'>//  |  |          (2 ** 216) * exp(- b[i] / 2)</span>
 3169 |     | <span class='neutral'>//  |   \</span>
 3170 |     | <span class='neutral'>//  |    (2 ** 59) * b[i]</span>
 3171 |     | <span class='neutral'>//   \</span>
 3172 |     | <span class='neutral'>//    (2 ** 15) * c[i]</span>
 3173 |     | <span class='neutral'>//</span>
 3174 |     | <span class='neutral'>// Consider the following list of kernel breakpoints:</span>
 3175 |     | <span class='neutral'>//</span>
 3176 |     | <span class='neutral'>//  &#39;(b[0], c[0]), (b[1], c[1]), (b[2], c[2]), ..., (b[m], c[m])&#39;</span>
 3177 |     | <span class='neutral'>//</span>
 3178 |     | <span class='neutral'>// and for every integer &#39;0 &lt; i &lt;= m&#39;, define</span>
 3179 |     | <span class='neutral'>//</span>
 3180 |     | <span class='neutral'>//  &#39;k_i : [0, qSpacing] -&gt; [0, 1]&#39;</span>
 3181 |     | <span class='neutral'>//</span>
 3182 |     | <span class='neutral'>// as</span>
 3183 |     | <span class='neutral'>//</span>
 3184 |     | <span class='neutral'>//  &#39;k_i(q) :=</span>
 3185 |     | <span class='neutral'>//</span>
 3186 |     | <span class='neutral'>//    /            c[i] - c[i - 1]</span>
 3187 |     | <span class='neutral'>//   | c[i - 1] + ----------------- * (q - b[i - 1])  if  b[i - 1] &lt; q &lt; b[i]</span>
 3188 |     | <span class='neutral'>//   |             b[i] - b[i - 1]                                           &#39;,</span>
 3189 |     | <span class='neutral'>//   | 0                                              otherwise</span>
 3190 |     | <span class='neutral'>//    \</span>
 3191 |     | <span class='neutral'>//</span>
 3192 |     | <span class='neutral'>// which means that if &#39;b[i - 1] == b[i]&#39;, then &#39;k_i(q) := 0&#39;. Now, the kernel</span>
 3193 |     | <span class='neutral'>// function</span>
 3194 |     | <span class='neutral'>// </span>
 3195 |     | <span class='neutral'>//  &#39;k : [0, qSpacing] -&gt; [0, 1]&#39;</span>
 3196 |     | <span class='neutral'>//</span>
 3197 |     | <span class='neutral'>// is defined as</span>
 3198 |     | <span class='neutral'>//</span>
 3199 |     | <span class='neutral'>//             m</span>
 3200 |     | <span class='neutral'>//           -----</span>
 3201 |     | <span class='neutral'>//           \</span>
 3202 |     | <span class='neutral'>//  &#39;k(q) := /     k_i(q)&#39;.</span>
 3203 |     | <span class='neutral'>//           -----</span>
 3204 |     | <span class='neutral'>//           i = 1</span>
 3205 |     | <span class='neutral'>//</span>
 3206 |     | <span class='neutral'>// Define the liquidity distribution function</span>
 3207 |     | <span class='neutral'>//</span>
 3208 |     | <span class='neutral'>//  &#39;k(w(.)) : [qLower, qUpper] -&gt; [0, 1]&#39;</span>
 3209 |     | <span class='neutral'>//</span>
 3210 |     | <span class='neutral'>// for the active interval as the composition of &#39;k(.)&#39; with &#39;w(.)&#39;.</span>
 3211 |     | <span class='neutral'>//</span>
 3212 |     | <span class='neutral'>// As argued above, while searching for &#39;qTarget&#39;, the integrals</span>
 3213 |     | <span class='neutral'>// &#39;currentToTarget&#39; and &#39;incomingCurrentToTarget&#39; are calculated based on</span>
 3214 |     | <span class='neutral'>// &#39;k(w(.))&#39; which enables the protocol to determine &#39;amount0Partial&#39; and</span>
 3215 |     | <span class='neutral'>// &#39;amount1Partial&#39; when moving the price from &#39;qCurrent&#39; to &#39;qTarget&#39;. In</span>
 3216 |     | <span class='neutral'>// addition, we need to calculate two other integrals that are referred to as</span>
 3217 |     | <span class='neutral'>// &#39;currentToOrigin&#39; and &#39;originToOvershoot&#39; which will be defined later in</span>
 3218 |     | <span class='neutral'>// this script. Next, we explain how this search is conducted.</span>
 3219 |     | <span class='neutral'>//</span>
 3220 |     | <span class='neutral'>// Remember that both &#39;w(.)&#39; and &#39;k(.)&#39; are piecewise linear functions. As a</span>
 3221 |     | <span class='neutral'>// result, &#39;k(w(.))&#39; is also piecewise linear. In search for &#39;qTarget&#39;, we</span>
 3222 |     | <span class='neutral'>// enumerate the pieces of &#39;k(w(.))&#39;, one by one, until we discover the piece</span>
 3223 |     | <span class='neutral'>// to which &#39;qTarget&#39; belongs. To this end, the two indices &#39;indexCurve&#39; and</span>
 3224 |     | <span class='neutral'>// &#39;indexKernelTotal&#39; are employed:</span>
 3225 |     | <span class='neutral'>//</span>
 3226 |     | <span class='neutral'>//  - &#39;indexCurve&#39; keeps track of the current phase under exploration (i.e.,</span>
 3227 |     | <span class='neutral'>//    the piece of &#39;w(.)&#39;). Remember, that &#39;w_indexCurve&#39; can be characterized</span>
 3228 |     | <span class='neutral'>//    via the following three consecutive members of the curve sequence:</span>
 3229 |     | <span class='neutral'>//</span>
 3230 |     | <span class='neutral'>//      &#39;q[indexCurve], q[indexCurve + 1], q[indexCurve + 2]&#39;.</span>
 3231 |     | <span class='neutral'>//</span>
 3232 |     | <span class='neutral'>//    Here, we refer to &#39;q[indexCurve + 1]&#39; and &#39;q[indexCurve]&#39; as &#39;qOrigin&#39;</span>
 3233 |     | <span class='neutral'>//    and &#39;qEnd&#39;, respectively. Throughout the search, &#39;qOrigin&#39; and &#39;qEnd&#39;</span>
 3234 |     | <span class='neutral'>//    are stored, respectively, in the memory spaces which are pointed to by</span>
 3235 |     | <span class='neutral'>//    &#39;_origin_&#39; and &#39;_end_&#39;, and they are updated with each transition to a</span>
 3236 |     | <span class='neutral'>//    new phase.</span>
 3237 |     | <span class='neutral'>//</span>
 3238 |     | <span class='neutral'>//    Additionally, the memory space which is pointed to by &#39;_direction_&#39; keeps</span>
 3239 |     | <span class='neutral'>//    track of the boolean:</span>
 3240 |     | <span class='neutral'>//</span>
 3241 |     | <span class='neutral'>//      &#39;qEnd &lt; q[indexCurve + 2]&#39;.</span>
 3242 |     | <span class='neutral'>//</span>
 3243 |     | <span class='neutral'>//    Hence, &#39;getDirection() == false&#39; means that we are currently searching</span>
 3244 |     | <span class='neutral'>//    within the range</span>
 3245 |     | <span class='neutral'>//    </span>
 3246 |     | <span class='neutral'>//      &#39;q[indexCurve + 2] &lt; q &lt; qEnd&#39;</span>
 3247 |     | <span class='neutral'>//</span>
 3248 |     | <span class='neutral'>//    in which</span>
 3249 |     | <span class='neutral'>//</span>
 3250 |     | <span class='neutral'>//      &#39;w(q) == w_indexCurve(q) == q - qOrigin&#39;.</span>
 3251 |     | <span class='neutral'>//</span>
 3252 |     | <span class='neutral'>//    Whereas, &#39;getDirection() == true&#39; means that we are currently searching</span>
 3253 |     | <span class='neutral'>//    within the range</span>
 3254 |     | <span class='neutral'>//    </span>
 3255 |     | <span class='neutral'>//      &#39;qEnd &lt; q &lt; q[indexCurve + 2]&#39;</span>
 3256 |     | <span class='neutral'>//</span>
 3257 |     | <span class='neutral'>//    in which</span>
 3258 |     | <span class='neutral'>//</span>
 3259 |     | <span class='neutral'>//      &#39;w(q) == w_indexCurve(q) == qOrigin - q&#39;.</span>
 3260 |     | <span class='neutral'>//</span>
 3261 |     | <span class='neutral'>//    In order to determine whether &#39;qTarget&#39; belongs to the current range</span>
 3262 |     | <span class='neutral'>//    under exploration, i.e., the range between</span>
 3263 |     | <span class='neutral'>//</span>
 3264 |     | <span class='neutral'>//      &#39;min(qEnd, q[indexCurve + 2])&#39;</span>
 3265 |     | <span class='neutral'>//</span>
 3266 |     | <span class='neutral'>//    and</span>
 3267 |     | <span class='neutral'>//</span>
 3268 |     | <span class='neutral'>//      &#39;max(qEnd, q[indexCurve + 2])&#39;</span>
 3269 |     | <span class='neutral'>//</span>
 3270 |     | <span class='neutral'>//    we start from the price &#39;q[indexCurve + 2]&#39; and proceed towards the price</span>
 3271 |     | <span class='neutral'>//    &#39;qEnd&#39; by enumerating the pieces of</span>
 3272 |     | <span class='neutral'>//</span>
 3273 |     | <span class='neutral'>//      &#39;k(w(q)) == getDirection() ? k(qOrigin - q) : k(q - qOrigin)&#39;</span>
 3274 |     | <span class='neutral'>//</span>
 3275 |     | <span class='neutral'>//    one by one. The fact that &#39;w(.)&#39; is a linear function throughout the</span>
 3276 |     | <span class='neutral'>//    above range, means that we only need to worry about the pieces of either</span>
 3277 |     | <span class='neutral'>//    &#39;k(qOrigin - q)&#39; or &#39;k(q - qOrigin)&#39;, depending on the direction.</span>
 3278 |     | <span class='neutral'>//</span>
 3279 |     | <span class='neutral'>//    The process of enumerating phases starts with the following initial</span>
 3280 |     | <span class='neutral'>//    state:</span>
 3281 |     | <span class='neutral'>//</span>
 3282 |     | <span class='neutral'>//      - &#39;indexCurve := l - 2&#39;,</span>
 3283 |     | <span class='neutral'>//</span>
 3284 |     | <span class='neutral'>//      - &#39;qOrigin := q[indexCurve + 1] == q[l - 1] == qCurrent&#39;,</span>
 3285 |     | <span class='neutral'>//</span>
 3286 |     | <span class='neutral'>//      - &#39;qEnd := q[indexCurve] == q[l - 2]&#39;.</span>
 3287 |     | <span class='neutral'>//</span>
 3288 |     | <span class='neutral'>//    Once we reach &#39;qEnd&#39;, we transition to a new phase by</span>
 3289 |     | <span class='neutral'>//</span>
 3290 |     | <span class='neutral'>//      - decrementing &#39;indexCurve&#39; by one,</span>
 3291 |     | <span class='neutral'>//</span>
 3292 |     | <span class='neutral'>//      - updating &#39;qOrigin&#39; and &#39;qEnd&#39;,</span>
 3293 |     | <span class='neutral'>//</span>
 3294 |     | <span class='neutral'>//      - updating the direction flag,</span>
 3295 |     | <span class='neutral'>//</span>
 3296 |     | <span class='neutral'>//    and the cycle continues until we reach the phase to which &#39;qTarget&#39;</span>
 3297 |     | <span class='neutral'>//    belongs.</span>
 3298 |     | <span class='neutral'>//</span>
 3299 |     | <span class='neutral'>//  - &#39;indexKernelTotal&#39; keeps track of the pieces of the kernel function that</span>
 3300 |     | <span class='neutral'>//    we enumerate as we explore the current phase. As defined earlier, let:</span>
 3301 |     | <span class='neutral'>//</span>
 3302 |     | <span class='neutral'>//      - &#39;qOrigin := q[indexCurve + 1]&#39;</span>
 3303 |     | <span class='neutral'>//</span>
 3304 |     | <span class='neutral'>//      - &#39;qEnd := q[indexCurve]&#39;</span>
 3305 |     | <span class='neutral'>//</span>
 3306 |     | <span class='neutral'>//      - &#39;getDirection() := qEnd &lt; q[indexCurve + 2]&#39;</span>
 3307 |     | <span class='neutral'>//</span>
 3308 |     | <span class='neutral'>//    correspond to the current phase under exploration which leads to the</span>
 3309 |     | <span class='neutral'>//    following simplification of the liquidity distribution function:</span>
 3310 |     | <span class='neutral'>//</span>
 3311 |     | <span class='neutral'>//      &#39;k(w(q)) == getDirection() ? k(qOrigin - q) : k(q - qOrigin)&#39;</span>
 3312 |     | <span class='neutral'>//</span>
 3313 |     | <span class='neutral'>//    within the range</span>
 3314 |     | <span class='neutral'>//</span>
 3315 |     | <span class='neutral'>//      &#39;min(q[indexCurve + 2], qEnd) &lt; q &lt; max(q[indexCurve + 2], qEnd)&#39;.</span>
 3316 |     | <span class='neutral'>//</span>
 3317 |     | <span class='neutral'>//    Hence, as we move from &#39;q[indexCurve + 2]&#39; to &#39;qEnd&#39;, each piece of</span>
 3318 |     | <span class='neutral'>//    &#39;k(w(.))&#39; can be characterized via the following four vertical and</span>
 3319 |     | <span class='neutral'>//    horizontal coordinates:</span>
 3320 |     | <span class='neutral'>//</span>
 3321 |     | <span class='neutral'>//      &#39;cTotal0 := c[indexKernelTotal - 1]&#39;,</span>
 3322 |     | <span class='neutral'>//</span>
 3323 |     | <span class='neutral'>//      &#39;qTotal0 := getDirection() ? </span>
 3324 |     | <span class='neutral'>//                  qOrigin - b[indexKernelTotal - 1] : </span>
 3325 |     | <span class='neutral'>//                  qOrigin + b[indexKernelTotal - 1]&#39;,</span>
 3326 |     | <span class='neutral'>//</span>
 3327 |     | <span class='neutral'>//      &#39;cTotal1 := c[indexKernelTotal]&#39;,</span>
 3328 |     | <span class='neutral'>//</span>
 3329 |     | <span class='neutral'>//      &#39;qTotal1 := getDirection() ? </span>
 3330 |     | <span class='neutral'>//                  qOrigin - b[indexKernelTotal] : </span>
 3331 |     | <span class='neutral'>//                  qOrigin + b[indexKernelTotal]&#39;.</span>
 3332 |     | <span class='neutral'>//</span>
 3333 |     | <span class='neutral'>//    The pair &#39;(cTotal0, qTotal0)&#39; is stored in the memory space which is</span>
 3334 |     | <span class='neutral'>//    pointed to by &#39;_total0_&#39; and similarly, the pair &#39;(cTotal1, qTotal1)&#39; is</span>
 3335 |     | <span class='neutral'>//    stored in the memory space which is pointed to by &#39;_total1_&#39;.</span>
 3336 |     | <span class='neutral'>//</span>
 3337 |     | <span class='neutral'>//    Hence, the function &#39;k(w(.))&#39; is linear within the intersection of the</span>
 3338 |     | <span class='neutral'>//    two ranges:</span>
 3339 |     | <span class='neutral'>//</span>
 3340 |     | <span class='neutral'>//      &#39;min(q[indexCurve + 2], qEnd) &lt; q &lt; max(q[indexCurve + 2], qEnd)&#39;,</span>
 3341 |     | <span class='neutral'>//</span>
 3342 |     | <span class='neutral'>//    and</span>
 3343 |     | <span class='neutral'>//</span>
 3344 |     | <span class='neutral'>//      &#39;min(qTotal0, qTotal1) &lt; q &lt; max(qTotal0, qTotal1)&#39;.</span>
 3345 |     | <span class='neutral'>//</span>
 3346 |     | <span class='neutral'>//    As long as &#39;k(w(.))&#39; is linear, we have closed-forms for all of the</span>
 3347 |     | <span class='neutral'>//    integrals that we intend to calculate. Hence, it is important to keep</span>
 3348 |     | <span class='neutral'>//    track of the domain in which &#39;k(w(.))&#39; is linear and to update it as we</span>
 3349 |     | <span class='neutral'>//    move forward in our search. Moreover, we need to make sure that &#39;qTarget&#39;</span>
 3350 |     | <span class='neutral'>//    does not go beyond &#39;qLimitWithinInterval&#39;. Hence, with each transition to</span>
 3351 |     | <span class='neutral'>//    a new phase or a new piece of the kernel function, we make the following</span>
 3352 |     | <span class='neutral'>//    two updates:</span>
 3353 |     | <span class='neutral'>//</span>
 3354 |     | <span class='neutral'>//      &#39;qBegin := getDirection() ? </span>
 3355 |     | <span class='neutral'>//                 min(q[indexCurve + 2], qTotal0) : </span>
 3356 |     | <span class='neutral'>//                 max(q[indexCurve + 2], qTotal0)&#39;,</span>
 3357 |     | <span class='neutral'>//</span>
 3358 |     | <span class='neutral'>//      &#39;qTarget := (</span>
 3359 |     | <span class='neutral'>//                    getDirection() == getZeroForOne()</span>
 3360 |     | <span class='neutral'>//                  ) ? (</span>
 3361 |     | <span class='neutral'>//                    getDirection() ? </span>
 3362 |     | <span class='neutral'>//                    max(max(qEnd, qTotal1), qLimitWithinInterval) : </span>
 3363 |     | <span class='neutral'>//                    min(min(qEnd, qTotal1), qLimitWithinInterval)</span>
 3364 |     | <span class='neutral'>//                  ) : (</span>
 3365 |     | <span class='neutral'>//                    getDirection() ? </span>
 3366 |     | <span class='neutral'>//                    max(qEnd, qTotal1) : </span>
 3367 |     | <span class='neutral'>//                    min(qEnd, qTotal1)</span>
 3368 |     | <span class='neutral'>//                  )&#39;,</span>
 3369 |     | <span class='neutral'>//</span>
 3370 |     | <span class='neutral'>//    where &#39;qBegin&#39; and &#39;qTarget&#39; are stored, respectively, in the memory</span>
 3371 |     | <span class='neutral'>//    spaces that are pointed to by &#39;_begin_&#39; and &#39;_target_&#39;. Both values are</span>
 3372 |     | <span class='neutral'>//    updated with each transition to a new phase or a new piece of &#39;k(w(.))&#39;.</span>
 3373 |     | <span class='neutral'>//</span>
 3374 |     | <span class='neutral'>//    The process of enumerating the pieces of the kernel function starts with</span>
 3375 |     | <span class='neutral'>//    the initial state &#39;indexKernelTotal := 1&#39;.</span>
 3376 |     | <span class='neutral'>//</span>
 3377 |     | <span class='neutral'>// While searching for &#39;qTarget&#39;, we need to calculate the following two</span>
 3378 |     | <span class='neutral'>// integrals, in addition to &#39;currentToTarget&#39; and &#39;incomingCurrentToTarget&#39;:</span>
 3379 |     | <span class='neutral'>//</span>
 3380 |     | <span class='neutral'>//                           - 8</span>
 3381 |     | <span class='neutral'>//    currentToOrigin      e</span>
 3382 |     | <span class='neutral'>//  &#39;----------------- := ------- * (</span>
 3383 |     | <span class='neutral'>//       2 ** 216            2</span>
 3384 |     | <span class='neutral'>//</span>
 3385 |     | <span class='neutral'>//                         / qOrigin                  / qCurrent</span>
 3386 |     | <span class='neutral'>//                        |    - h / 2               |    + h / 2</span>
 3387 |     | <span class='neutral'>//     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh</span>
 3388 |     | <span class='neutral'>//                        |                          |</span>
 3389 |     | <span class='neutral'>//                       / qCurrent                 / qOrigin</span>
 3390 |     | <span class='neutral'>//</span>
 3391 |     | <span class='neutral'>//   )&#39;</span>
 3392 |     | <span class='neutral'>//</span>
 3393 |     | <span class='neutral'>// and</span>
 3394 |     | <span class='neutral'>//                             - 8</span>
 3395 |     | <span class='neutral'>//    originToOvershoot      e</span>
 3396 |     | <span class='neutral'>//  &#39;------------------- := ------- * (</span>
 3397 |     | <span class='neutral'>//        2 ** 216             2</span>
 3398 |     | <span class='neutral'>//</span>
 3399 |     | <span class='neutral'>//     getZeroForOne() ? </span>
 3400 |     | <span class='neutral'>//</span>
 3401 |     | <span class='neutral'>//       / qOrigin</span>
 3402 |     | <span class='neutral'>//      |    + h / 2</span>
 3403 |     | <span class='neutral'>//      |  e         k(qOrigin - h) dh :</span>
 3404 |     | <span class='neutral'>//      |</span>
 3405 |     | <span class='neutral'>//     / qTarget</span>
 3406 |     | <span class='neutral'>//</span>
 3407 |     | <span class='neutral'>//       / qTarget</span>
 3408 |     | <span class='neutral'>//      |    - h / 2</span>
 3409 |     | <span class='neutral'>//      |  e         k(h - qOrigin) dh</span>
 3410 |     | <span class='neutral'>//      |</span>
 3411 |     | <span class='neutral'>//     / qOrigin</span>
 3412 |     | <span class='neutral'>//</span>
 3413 |     | <span class='neutral'>//   )&#39;.</span>
 3414 |     | <span class='neutral'>//</span>
 3415 |     | <span class='neutral'>// To summarize, the four integrals:</span>
 3416 |     | <span class='neutral'>//</span>
 3417 |     | <span class='neutral'>//  - &#39;currentToTarget&#39;,</span>
 3418 |     | <span class='neutral'>//</span>
 3419 |     | <span class='neutral'>//  - &#39;incomingCurrentToTarget&#39;,</span>
 3420 |     | <span class='neutral'>//</span>
 3421 |     | <span class='neutral'>//  - &#39;currentToOrigin&#39;, and</span>
 3422 |     | <span class='neutral'>//</span>
 3423 |     | <span class='neutral'>//  - &#39;originToOvershoot&#39;,</span>
 3424 |     | <span class='neutral'>//</span>
 3425 |     | <span class='neutral'>// are incremented with each decrement of &#39;indexCurve&#39; or increment of</span>
 3426 |     | <span class='neutral'>// &#39;indexKernelTotal&#39;.</span>
 3427 |     | <span class='neutral'>//</span>
 3428 |     | <span class='neutral'>// The following figure illustrates the ranges covered by the above integrals</span>
 3429 |     | <span class='neutral'>// in the case of &#39;getZeroForOne() == false&#39;, i.e., &#39;qCurrent &lt; qTarget&#39;:</span>
 3430 |     | <span class='neutral'>//</span>
 3431 |     | <span class='neutral'>//                                                currentToTarget</span>
 3432 |     | <span class='neutral'>//                                                exp(- h / 2) * k(w(h))</span>
 3433 |     | <span class='neutral'>//           currentToOrigin                    / </span>
 3434 |     | <span class='neutral'>//    exp(+ h / 2) * k(w(h))                   /\ </span>
 3435 |     | <span class='neutral'>//                          \                 /   incomingCurrentToTarget</span>
 3436 |     | <span class='neutral'>//                           \               /    exp(+ h / 2) * k(w(h))</span>
 3437 |     | <span class='neutral'>//                            \             /</span>
 3438 |     | <span class='neutral'>//                     |&lt;------------&gt;|&lt;--------&gt;|</span>
 3439 |     | <span class='neutral'>//                     |              |          |</span>
 3440 |     | <span class='neutral'>//      +--------------+--------------+----------+------------------+</span>
 3441 |     | <span class='neutral'>//      |              |              |          |                  |</span>
 3442 |     | <span class='neutral'>//    qLower           |          qCurrent       |                qUpper</span>
 3443 |     | <span class='neutral'>//                     |                         |</span>
 3444 |     | <span class='neutral'>//                     |&lt;-----------------------&gt;|</span>
 3445 |     | <span class='neutral'>//                     |            \            |</span>
 3446 |     | <span class='neutral'>//                  qOrigin          \        qTarget == qOvershoot</span>
 3447 |     | <span class='neutral'>//                                    \</span>
 3448 |     | <span class='neutral'>//                             originToOvershoot</span>
 3449 |     | <span class='neutral'>//                             exp(- h / 2) * k(h - qOrigin)</span>
 3450 |     | <span class='neutral'>//</span>
 3451 |     | <span class='neutral'>// The search for &#39;qTarget&#39; is conducted by calling the method &#39;moveTarget()&#39;</span>
 3452 |     | <span class='neutral'>// from &#39;Interval.sol&#39; in a loop until either of the following condition are</span>
 3453 |     | <span class='neutral'>// met:</span>
 3454 |     | <span class='neutral'>//</span>
 3455 |     | <span class='neutral'>//  - &#39;qLimitWithinInterval == qTarget&#39;, or</span>
 3456 |     | <span class='neutral'>//</span>
 3457 |     | <span class='neutral'>//  - &#39;integralLimit == (</span>
 3458 |     | <span class='neutral'>//       getExactInput() ? incomingCurrentToTarget : currentToTarget</span>
 3459 |     | <span class='neutral'>//     )&#39;.</span>
 3460 |     | <span class='neutral'>//</span>
 3461 |     | <span class='neutral'>// Define:</span>
 3462 |     | <span class='neutral'>//</span>
 3463 |     | <span class='neutral'>//                                - 8     / qUpper</span>
 3464 |     | <span class='neutral'>//    integral0Incremented      e        |    - h / 2</span>
 3465 |     | <span class='neutral'>//  &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;,</span>
 3466 |     | <span class='neutral'>//          2 ** 216              2      |</span>
 3467 |     | <span class='neutral'>//                                      / qTarget</span>
 3468 |     | <span class='neutral'>//</span>
 3469 |     | <span class='neutral'>//                                - 8     / qTarget</span>
 3470 |     | <span class='neutral'>//    integral1Incremented      e        |    + h / 2</span>
 3471 |     | <span class='neutral'>//  &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;.</span>
 3472 |     | <span class='neutral'>//          2 ** 216              2      |</span>
 3473 |     | <span class='neutral'>//                                      / qLower</span>
 3474 |     | <span class='neutral'>//</span>
 3475 |     | <span class='neutral'>// Now, the total reserves of &#39;tag0&#39; and &#39;tag1&#39; within &#39;[qLower, qUpper]&#39; after</span>
 3476 |     | <span class='neutral'>// the movement of price from &#39;qCurrent&#39; to &#39;qTarget&#39; (i.e., after the exchange</span>
 3477 |     | <span class='neutral'>// of &#39;amount0Partial&#39; and &#39;amount1Partial&#39;) are equal to </span>
 3478 |     | <span class='neutral'>//</span>
 3479 |     | <span class='neutral'>//                                       growth      integral0Incremented</span>
 3480 |     | <span class='neutral'>//  &#39;sqrtInverseOffset * sharesTotal * ---------- * ----------------------&#39;</span>
 3481 |     | <span class='neutral'>//                                      2 ** 111         outgoingMax</span>
 3482 |     | <span class='neutral'>//</span>
 3483 |     | <span class='neutral'>// and</span>
 3484 |     | <span class='neutral'>//</span>
 3485 |     | <span class='neutral'>//                                growth      integral1Incremented</span>
 3486 |     | <span class='neutral'>//  &#39;sqrtOffset * sharesTotal * ---------- * ----------------------&#39;,</span>
 3487 |     | <span class='neutral'>//                               2 ** 111         outgoingMax</span>
 3488 |     | <span class='neutral'>//</span>
 3489 |     | <span class='neutral'>// respectively. The ranges covered by &#39;integral0Incremented&#39; and</span>
 3490 |     | <span class='neutral'>// &#39;integral1Incremented&#39; are illustrated as follows:</span>
 3491 |     | <span class='neutral'>//</span>
 3492 |     | <span class='neutral'>//                                                    integral0Incremented</span>
 3493 |     | <span class='neutral'>//                                                    exp(- h / 2) * k(w(h))</span>
 3494 |     | <span class='neutral'>//                integral1Incremented               /</span>
 3495 |     | <span class='neutral'>//                exp(+ h / 2) * k(w(h))            /</span>
 3496 |     | <span class='neutral'>//      |&lt;--------------------------------------&gt;|&lt;----------------&gt;|</span>
 3497 |     | <span class='neutral'>//      |                                        |                  |</span>
 3498 |     | <span class='neutral'>//      +----------------------------------------+------------------+</span>
 3499 |     | <span class='neutral'>//      |                                        |                  |</span>
 3500 |     | <span class='neutral'>//    qLower                                  qTarget             qUpper</span>
 3501 |     | <span class='neutral'>//</span>
 3502 |     | <span class='neutral'>// After the search for &#39;qTarget&#39; is concluded, and &#39;amount0Partial&#39; and</span>
 3503 |     | <span class='neutral'>// &#39;amount1Partial&#39; are calculated, we need to determine &#39;qOvershoot&#39;. If</span>
 3504 |     | <span class='neutral'>// &#39;getZeroForOne() == false&#39;, we have</span>
 3505 |     | <span class='neutral'>//</span>
 3506 |     | <span class='neutral'>//  &#39;qTarget &lt;= qOvershoot &lt;= qUpper&#39;</span>
 3507 |     | <span class='neutral'>//</span>
 3508 |     | <span class='neutral'>// and if &#39;getZeroForOne() == true&#39;, we have</span>
 3509 |     | <span class='neutral'>//</span>
 3510 |     | <span class='neutral'>//  &#39;qLower &lt;= qOvershoot &lt;= qTarget&#39;.</span>
 3511 |     | <span class='neutral'>//</span>
 3512 |     | <span class='neutral'>// The curve sequence is first amended with &#39;qOvershoot&#39; and then &#39;qTarget&#39;, in</span>
 3513 |     | <span class='neutral'>// preparation for the next swap.</span>
 3514 |     | <span class='neutral'>//</span>
 3515 |     | <span class='neutral'>// To this end, define:</span>
 3516 |     | <span class='neutral'>//                              - 8</span>
 3517 |     | <span class='neutral'>//    currentToOvershoot      e</span>
 3518 |     | <span class='neutral'>//  &#39;-------------------- := ------- * (</span>
 3519 |     | <span class='neutral'>//         2 ** 216             2</span>
 3520 |     | <span class='neutral'>//</span>
 3521 |     | <span class='neutral'>//                         / qCurrent                 / qOvershoot</span>
 3522 |     | <span class='neutral'>//                        |    + h / 2               |    - h / 2</span>
 3523 |     | <span class='neutral'>//     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh</span>
 3524 |     | <span class='neutral'>//                        |                          |</span>
 3525 |     | <span class='neutral'>//                       / qOvershoot               / qCurrent</span>
 3526 |     | <span class='neutral'>//</span>
 3527 |     | <span class='neutral'>//   )&#39;</span>
 3528 |     | <span class='neutral'>//</span>
 3529 |     | <span class='neutral'>// and</span>
 3530 |     | <span class='neutral'>//                             - 8</span>
 3531 |     | <span class='neutral'>//    targetToOvershoot      e</span>
 3532 |     | <span class='neutral'>//  &#39;------------------- := ------- * (</span>
 3533 |     | <span class='neutral'>//         2 ** 216            2</span>
 3534 |     | <span class='neutral'>//</span>
 3535 |     | <span class='neutral'>//     getZeroForOne()</span>
 3536 |     | <span class='neutral'>//</span>
 3537 |     | <span class='neutral'>//         / qTarget</span>
 3538 |     | <span class='neutral'>//        |    + h / 2</span>
 3539 |     | <span class='neutral'>//     ?  |  e         k(qTarget - h) dh</span>
 3540 |     | <span class='neutral'>//        |</span>
 3541 |     | <span class='neutral'>//       / qOvershoot</span>
 3542 |     | <span class='neutral'>//</span>
 3543 |     | <span class='neutral'>//         / qOvershoot</span>
 3544 |     | <span class='neutral'>//        |    - h / 2</span>
 3545 |     | <span class='neutral'>//     :  |  e         k(h - qTarget) dh</span>
 3546 |     | <span class='neutral'>//        |</span>
 3547 |     | <span class='neutral'>//       / qTarget</span>
 3548 |     | <span class='neutral'>//</span>
 3549 |     | <span class='neutral'>//   )&#39;</span>
 3550 |     | <span class='neutral'>//</span>
 3551 |     | <span class='neutral'>// While searching for &#39;qOvershoot&#39;, the four integrals:</span>
 3552 |     | <span class='neutral'>//</span>
 3553 |     | <span class='neutral'>//  - &#39;currentToOvershoot&#39;,</span>
 3554 |     | <span class='neutral'>//</span>
 3555 |     | <span class='neutral'>//  - &#39;targetToOvershoot&#39;,</span>
 3556 |     | <span class='neutral'>//</span>
 3557 |     | <span class='neutral'>//  - &#39;originToOvershoot&#39;, and</span>
 3558 |     | <span class='neutral'>//</span>
 3559 |     | <span class='neutral'>//  - &#39;currentToOrigin&#39;,</span>
 3560 |     | <span class='neutral'>//</span>
 3561 |     | <span class='neutral'>// are kept track of. The following figure illustrates the ranges covered by</span>
 3562 |     | <span class='neutral'>// the above integrals in the case of &#39;getZeroForOne() == false&#39;, i.e.,</span>
 3563 |     | <span class='neutral'>// &#39;qCurrent &lt; qTarget&#39;:</span>
 3564 |     | <span class='neutral'>//</span>
 3565 |     | <span class='neutral'>//           currentToOrigin                      currentToOvershoot</span>
 3566 |     | <span class='neutral'>//    exp(+ h / 2) * k(w(h))                      exp(- h / 2) * k(w(h))</span>
 3567 |     | <span class='neutral'>//                          \                    /</span>
 3568 |     | <span class='neutral'>//                           \                  /</span>
 3569 |     | <span class='neutral'>//                            \                /</span>
 3570 |     | <span class='neutral'>//              |&lt;-------------------&gt;|&lt;---------------&gt;|</span>
 3571 |     | <span class='neutral'>//              |                     |                 |</span>
 3572 |     | <span class='neutral'>//              |                     |    qTarget      |</span>
 3573 |     | <span class='neutral'>//              |                     |       |         |</span>
 3574 |     | <span class='neutral'>//      +-------+---------------------+-------+---------+-----------+</span>
 3575 |     | <span class='neutral'>//      |       |                     |       |         |           |</span>
 3576 |     | <span class='neutral'>//    qLower    |                 qCurrent    |&lt;-------&gt;|         qUpper</span>
 3577 |     | <span class='neutral'>//              |                                  /    |</span>
 3578 |     | <span class='neutral'>//              |                                 /     |</span>
 3579 |     | <span class='neutral'>//              |                targetToOvershoot      |</span>
 3580 |     | <span class='neutral'>//              |    exp(- h / 2) * k(h - qTarget)      |</span>
 3581 |     | <span class='neutral'>//              |                                       |</span>
 3582 |     | <span class='neutral'>//              |                                       |</span>
 3583 |     | <span class='neutral'>//              |&lt;-------------------------------------&gt;|</span>
 3584 |     | <span class='neutral'>//              |                     /                 |</span>
 3585 |     | <span class='neutral'>//           qOrigin                 /              qOvershoot</span>
 3586 |     | <span class='neutral'>//                                  /</span>
 3587 |     | <span class='neutral'>//                                 /</span>
 3588 |     | <span class='neutral'>//                originToOvershoot</span>
 3589 |     | <span class='neutral'>//    exp(- h / 2) * k(h - qOrigin)</span>
 3590 |     | <span class='neutral'>//</span>
 3591 |     | <span class='neutral'>// Now, in order to find &#39;qOvershoot&#39;, we need to solve the equation:</span>
 3592 |     | <span class='neutral'>//</span>
 3593 |     | <span class='neutral'>//   &#39;f(qOvershoot) == 0&#39;</span>
 3594 |     | <span class='neutral'>//</span>
 3595 |     | <span class='neutral'>// where</span>
 3596 |     | <span class='neutral'>//</span>
 3597 |     | <span class='neutral'>//   &#39;f(qOvershoot) := getZeroForOne() ? </span>
 3598 |     | <span class='neutral'>//                     s0(qOvershoot) - s1(qOvershoot) : </span>
 3599 |     | <span class='neutral'>//                     s1(qOvershoot) - s0(qOvershoot)&#39;,</span>
 3600 |     | <span class='neutral'>//</span>
 3601 |     | <span class='neutral'>// and the two functions &#39;s0&#39; and &#39;s1&#39; are defined as:</span>
 3602 |     | <span class='neutral'>//</span>
 3603 |     | <span class='neutral'>//                          - 8      / qTarget</span>
 3604 |     | <span class='neutral'>//                        e         |   + h / 2</span>
 3605 |     | <span class='neutral'>//                       ------- *  |  e        k(wAmended(h)) dh</span>
 3606 |     | <span class='neutral'>//                          2       |</span>
 3607 |     | <span class='neutral'>//                                 / qLower</span>
 3608 |     | <span class='neutral'>//   &#39;s1(qOvershoot) := ------------------------------------------&#39;,</span>
 3609 |     | <span class='neutral'>//                                integral1Incremented</span>
 3610 |     | <span class='neutral'>//</span>
 3611 |     | <span class='neutral'>//                          - 8      / qUpper</span>
 3612 |     | <span class='neutral'>//                        e         |   - h / 2</span>
 3613 |     | <span class='neutral'>//                       ------- *  |  e        k(wAmended(h)) dh</span>
 3614 |     | <span class='neutral'>//                          2       |</span>
 3615 |     | <span class='neutral'>//                                 / qTarget</span>
 3616 |     | <span class='neutral'>//   &#39;s0(qOvershoot) := ------------------------------------------&#39;.</span>
 3617 |     | <span class='neutral'>//                                integral0Incremented</span>
 3618 |     | <span class='neutral'>//</span>
 3619 |     | <span class='neutral'>// Now, according to the amendement procedure which is described in</span>
 3620 |     | <span class='neutral'>// &#39;Curve.sol&#39;, if &#39;getZeroForOne() == false&#39;, we have:</span>
 3621 |     | <span class='neutral'>//</span>
 3622 |     | <span class='neutral'>//                       / k(w(h))            if  qOvershoot &lt; h &lt; qUpper</span>
 3623 |     | <span class='neutral'>//   &#39;k(wAmended(h)) == |  k(h - qTarget)     if  qTarget &lt; h &lt; qOvershoot &#39;</span>
 3624 |     | <span class='neutral'>//                      |  k(qOvershoot - h)  if  qOrigin &lt; h &lt; qTarget</span>
 3625 |     | <span class='neutral'>//                       \ k(w(h))            if  qLower &lt; h &lt; qOrigin</span>
 3626 |     | <span class='neutral'>//</span>
 3627 |     | <span class='neutral'>// and if &#39;getZeroForOne() == true&#39;, we have:</span>
 3628 |     | <span class='neutral'>//</span>
 3629 |     | <span class='neutral'>//                       / k(w(h))            if  qLower &lt; h &lt; qOvershoot</span>
 3630 |     | <span class='neutral'>//   &#39;k(wAmended(h)) == |  k(qTarget - h)     if  qOvershoot &lt; h &lt; qTarget &#39;.</span>
 3631 |     | <span class='neutral'>//                      |  k(h - qOvershoot)  if  qTarget &lt; h &lt; qOrigin</span>
 3632 |     | <span class='neutral'>//                       \ k(w(h))            if  qOrigin &lt; h &lt; qUpper</span>
 3633 |     | <span class='neutral'>//</span>
 3634 |     | <span class='neutral'>// For the case &#39;getZeroForOne() == false&#39;, the above formulas conclude that:</span>
 3635 |     | <span class='neutral'>//</span>
 3636 |     | <span class='neutral'>//  - the numerator of &#39;s1&#39; is equal to:</span>
 3637 |     | <span class='neutral'>//</span>
 3638 |     | <span class='neutral'>//        - 8     / qTarget</span>
 3639 |     | <span class='neutral'>//      e        |    + h / 2</span>
 3640 |     | <span class='neutral'>//    &#39;------- * |  e         k(wAmended(h)) dh == </span>
 3641 |     | <span class='neutral'>//        2      |</span>
 3642 |     | <span class='neutral'>//              / qLower</span>
 3643 |     | <span class='neutral'>//</span>
 3644 |     | <span class='neutral'>//        - 8     / qOrigin</span>
 3645 |     | <span class='neutral'>//      e        |    + h / 2</span>
 3646 |     | <span class='neutral'>//     ------- * |  e         k(wAmended(h)) dh +</span>
 3647 |     | <span class='neutral'>//        2      |</span>
 3648 |     | <span class='neutral'>//              / qLower</span>
 3649 |     | <span class='neutral'>//</span>
 3650 |     | <span class='neutral'>//                                - 8     / qTarget</span>
 3651 |     | <span class='neutral'>//                              e        |    + h / 2</span>
 3652 |     | <span class='neutral'>//                             ------- * |  e         k(wAmended(h)) dh ==</span>
 3653 |     | <span class='neutral'>//                                2      |</span>
 3654 |     | <span class='neutral'>//                                      / qOrigin</span>
 3655 |     | <span class='neutral'>//</span>
 3656 |     | <span class='neutral'>//        - 8     / qOrigin</span>
 3657 |     | <span class='neutral'>//      e        |    + h / 2</span>
 3658 |     | <span class='neutral'>//     ------- * |  e         k(w(h)) dh +</span>
 3659 |     | <span class='neutral'>//        2      |</span>
 3660 |     | <span class='neutral'>//              / qLower</span>
 3661 |     | <span class='neutral'>//</span>
 3662 |     | <span class='neutral'>//                                - 8     / qTarget</span>
 3663 |     | <span class='neutral'>//                              e        |    + h / 2</span>
 3664 |     | <span class='neutral'>//                             ------- * |  e         k(qOvershoot - h) dh ==</span>
 3665 |     | <span class='neutral'>//                                2      |</span>
 3666 |     | <span class='neutral'>//                                      / qOrigin</span>
 3667 |     | <span class='neutral'>//</span>
 3668 |     | <span class='neutral'>//        - 8     / qOrigin</span>
 3669 |     | <span class='neutral'>//      e        |    + h / 2</span>
 3670 |     | <span class='neutral'>//     ------- * |  e         k(w(h)) dh +</span>
 3671 |     | <span class='neutral'>//        2      |</span>
 3672 |     | <span class='neutral'>//              / qLower</span>
 3673 |     | <span class='neutral'>//</span>
 3674 |     | <span class='neutral'>//                                - 8     / qOvershoot</span>
 3675 |     | <span class='neutral'>//                              e        |    + h / 2</span>
 3676 |     | <span class='neutral'>//                             ------- * |  e         k(qOvershoot - h) dh -</span>
 3677 |     | <span class='neutral'>//                                2      |</span>
 3678 |     | <span class='neutral'>//                                      / qOrigin</span>
 3679 |     | <span class='neutral'>//</span>
 3680 |     | <span class='neutral'>//                                - 8     / qOvershoot</span>
 3681 |     | <span class='neutral'>//                              e        |    + h / 2</span>
 3682 |     | <span class='neutral'>//                             ------- * |  e         k(qOvershoot - h) dh ==</span>
 3683 |     | <span class='neutral'>//                                2      |</span>
 3684 |     | <span class='neutral'>//                                      / qTarget</span>
 3685 |     | <span class='neutral'>//</span>
 3686 |     | <span class='neutral'>//        - 8     / qTarget</span>
 3687 |     | <span class='neutral'>//      e        |    + h / 2</span>
 3688 |     | <span class='neutral'>//     ------- * |  e         k(w(h)) dh - </span>
 3689 |     | <span class='neutral'>//        2      |</span>
 3690 |     | <span class='neutral'>//              / qLower</span>
 3691 |     | <span class='neutral'>//</span>
 3692 |     | <span class='neutral'>//        - 8     / qTarget                   - 8     / qCurrent</span>
 3693 |     | <span class='neutral'>//      e        |    + h / 2               e        |    + h / 2</span>
 3694 |     | <span class='neutral'>//     ------- * |  e         k(w(h)) dh - ------- * |  e         k(w(h)) dh +</span>
 3695 |     | <span class='neutral'>//        2      |                            2      |</span>
 3696 |     | <span class='neutral'>//              / qCurrent                          / qOrigin</span>
 3697 |     | <span class='neutral'>//</span>
 3698 |     | <span class='neutral'>//        - 8 + (qOrigin + qOvershoot) / 2     / qOvershoot</span>
 3699 |     | <span class='neutral'>//      e                                     |    - h / 2</span>
 3700 |     | <span class='neutral'>//     ------------------------------------ * |  e         k(h - qOrigin) dh -</span>
 3701 |     | <span class='neutral'>//                        2                   |</span>
 3702 |     | <span class='neutral'>//                                           / qOrigin</span>
 3703 |     | <span class='neutral'>//</span>
 3704 |     | <span class='neutral'>//        - 8 + (qTarget + qOvershoot) / 2     / qOvershoot</span>
 3705 |     | <span class='neutral'>//      e                                     |    - h / 2</span>
 3706 |     | <span class='neutral'>//     ------------------------------------ * |  e         k(h - qTarget) dh ==</span>
 3707 |     | <span class='neutral'>//                        2                   |</span>
 3708 |     | <span class='neutral'>//                                           / qTarget</span>
 3709 |     | <span class='neutral'>//</span>
 3710 |     | <span class='neutral'>//      integral1Incremented - incomingCurrentToTarget - currentToOrigin</span>
 3711 |     | <span class='neutral'>//     ------------------------------------------------------------------ + </span>
 3712 |     | <span class='neutral'>//                                  2 ** 216</span>
 3713 |     | <span class='neutral'>//</span>
 3714 |     | <span class='neutral'>//      exp((qOrigin + qOvershoot) / 2) * originToOvershoot</span>
 3715 |     | <span class='neutral'>//     ----------------------------------------------------- - </span>
 3716 |     | <span class='neutral'>//                            2 ** 216</span>
 3717 |     | <span class='neutral'>//</span>
 3718 |     | <span class='neutral'>//      exp((qTarget + qOvershoot) / 2) * targetToOvershoot</span>
 3719 |     | <span class='neutral'>//     -----------------------------------------------------&#39;.</span>
 3720 |     | <span class='neutral'>//                            2 ** 216</span>
 3721 |     | <span class='neutral'>//</span>
 3722 |     | <span class='neutral'>//  - the numerator of &#39;s0&#39; is equal to:</span>
 3723 |     | <span class='neutral'>//</span>
 3724 |     | <span class='neutral'>//        - 8     / qUpper</span>
 3725 |     | <span class='neutral'>//      e        |    - h / 2</span>
 3726 |     | <span class='neutral'>//    &#39;------- * |  e         k(wAmended(h)) dh == </span>
 3727 |     | <span class='neutral'>//        2      |</span>
 3728 |     | <span class='neutral'>//              / qTarget</span>
 3729 |     | <span class='neutral'>//</span>
 3730 |     | <span class='neutral'>//        - 8     / qOvershoot</span>
 3731 |     | <span class='neutral'>//      e        |    - h / 2</span>
 3732 |     | <span class='neutral'>//     ------- * |  e         k(wAmended(h)) dh +</span>
 3733 |     | <span class='neutral'>//        2      |</span>
 3734 |     | <span class='neutral'>//              / qTarget</span>
 3735 |     | <span class='neutral'>//</span>
 3736 |     | <span class='neutral'>//                                - 8     / qUpper</span>
 3737 |     | <span class='neutral'>//                              e        |    - h / 2</span>
 3738 |     | <span class='neutral'>//                             ------- * |  e         k(wAmended(h)) dh == </span>
 3739 |     | <span class='neutral'>//                                2      |</span>
 3740 |     | <span class='neutral'>//                                      / qOvershoot</span>
 3741 |     | <span class='neutral'>//</span>
 3742 |     | <span class='neutral'>//        - 8     / qOvershoot</span>
 3743 |     | <span class='neutral'>//      e        |    - h / 2</span>
 3744 |     | <span class='neutral'>//     ------- * |  e         k(h - qTarget) dh +</span>
 3745 |     | <span class='neutral'>//        2      |</span>
 3746 |     | <span class='neutral'>//              / qTarget</span>
 3747 |     | <span class='neutral'>//</span>
 3748 |     | <span class='neutral'>//                                - 8     / qUpper</span>
 3749 |     | <span class='neutral'>//                              e        |    - h / 2</span>
 3750 |     | <span class='neutral'>//                             ------- * |  e         k(w(h)) dh == </span>
 3751 |     | <span class='neutral'>//                                2      |</span>
 3752 |     | <span class='neutral'>//                                      / qOvershoot</span>
 3753 |     | <span class='neutral'>//</span>
 3754 |     | <span class='neutral'>//        - 8     / qOvershoot</span>
 3755 |     | <span class='neutral'>//      e        |    - h / 2</span>
 3756 |     | <span class='neutral'>//     ------- * |  e         k(h - qTarget) dh +</span>
 3757 |     | <span class='neutral'>//        2      |</span>
 3758 |     | <span class='neutral'>//              / qTarget</span>
 3759 |     | <span class='neutral'>//</span>
 3760 |     | <span class='neutral'>//        - 8     / qTarget                   - 8     / qUpper</span>
 3761 |     | <span class='neutral'>//      e        |    - h / 2               e        |    - h / 2</span>
 3762 |     | <span class='neutral'>//     ------- * |  e         k(w(h)) dh + ------- * |  e         k(w(h)) dh -</span>
 3763 |     | <span class='neutral'>//        2      |                            2      |</span>
 3764 |     | <span class='neutral'>//              / qCurrent                          / qTarget</span>
 3765 |     | <span class='neutral'>//</span>
 3766 |     | <span class='neutral'>//        - 8     / qOvershoot</span>
 3767 |     | <span class='neutral'>//      e        |</span>
 3768 |     | <span class='neutral'>//     ------- * |  e         k(w(h)) dh == </span>
 3769 |     | <span class='neutral'>//        2      |</span>
 3770 |     | <span class='neutral'>//              / qCurrent</span>
 3771 |     | <span class='neutral'>//</span>
 3772 |     | <span class='neutral'>//      targetToOvershoot + currentToTarget</span>
 3773 |     | <span class='neutral'>//     ------------------------------------- + </span>
 3774 |     | <span class='neutral'>//                    2 ** 216</span>
 3775 |     | <span class='neutral'>//</span>
 3776 |     | <span class='neutral'>//      integral0Incremented - currentToOvershoot</span>
 3777 |     | <span class='neutral'>//     -------------------------------------------&#39;.</span>
 3778 |     | <span class='neutral'>//                       2 ** 216</span>
 3779 |     | <span class='neutral'>//</span>
 3780 |     | <span class='neutral'>// Similar arguments can be made for the case &#39;getZeroForOne() == true&#39; and for</span>
 3781 |     | <span class='neutral'>// both cases, we have:</span>
 3782 |     | <span class='neutral'>//</span>
 3783 |     | <span class='neutral'>//   &#39;f(qOvershoot) := getZeroForOne() ? (</span>
 3784 |     | <span class='neutral'>//</span>
 3785 |     | <span class='neutral'>//      (</span>
 3786 |     | <span class='neutral'>//</span>
 3787 |     | <span class='neutral'>//        exp(- (qOrigin + qOvershoot) / 2) * originToOvershoot -</span>
 3788 |     | <span class='neutral'>//</span>
 3789 |     | <span class='neutral'>//        exp(- (qTarget + qOvershoot) / 2) * targetToOvershoot - </span>
 3790 |     | <span class='neutral'>//</span>
 3791 |     | <span class='neutral'>//        incomingCurrentToTarget - currentToOrigin</span>
 3792 |     | <span class='neutral'>//</span>
 3793 |     | <span class='neutral'>//      ) / integral0Incremented - (</span>
 3794 |     | <span class='neutral'>//</span>
 3795 |     | <span class='neutral'>//        targetToOvershoot + currentToTarget - currentToOvershoot</span>
 3796 |     | <span class='neutral'>//      </span>
 3797 |     | <span class='neutral'>//      ) / integral1Incremented</span>
 3798 |     | <span class='neutral'>//</span>
 3799 |     | <span class='neutral'>//    ) : (</span>
 3800 |     | <span class='neutral'>//</span>
 3801 |     | <span class='neutral'>//      (</span>
 3802 |     | <span class='neutral'>//</span>
 3803 |     | <span class='neutral'>//        exp(+ (qOrigin + qOvershoot) / 2) * originToOvershoot -</span>
 3804 |     | <span class='neutral'>//</span>
 3805 |     | <span class='neutral'>//        exp(+ (qTarget + qOvershoot) / 2) * targetToOvershoot - </span>
 3806 |     | <span class='neutral'>//</span>
 3807 |     | <span class='neutral'>//        incomingCurrentToTarget - currentToOrigin</span>
 3808 |     | <span class='neutral'>//</span>
 3809 |     | <span class='neutral'>//      ) / integral1Incremented - (</span>
 3810 |     | <span class='neutral'>//</span>
 3811 |     | <span class='neutral'>//        targetToOvershoot + currentToTarget - currentToOvershoot</span>
 3812 |     | <span class='neutral'>//      </span>
 3813 |     | <span class='neutral'>//      ) / integral0Incremented</span>
 3814 |     | <span class='neutral'>//</span>
 3815 |     | <span class='neutral'>//    )&#39;.</span>
 3816 |     | <span class='neutral'>//</span>
 3817 |     | <span class='neutral'>// We use Newton&#39;s method in order to pinpoint the precise value for</span>
 3818 |     | <span class='neutral'>// &#39;qOvershoot&#39; which satisfies:</span>
 3819 |     | <span class='neutral'>//</span>
 3820 |     | <span class='neutral'>//   &#39;f(qOvershoot) == 0&#39;.</span>
 3821 |     | <span class='neutral'>//</span>
 3822 |     | <span class='neutral'>// To this end, we need access to a simple and closed-form expression for all</span>
 3823 |     | <span class='neutral'>// of the above integrals. Hence, we first need to restrict our search to a</span>
 3824 |     | <span class='neutral'>// domain in which both &#39;k(w(.))&#39; and &#39;k(|h - qTarget|)&#39; are linear.</span>
 3825 |     | <span class='neutral'>//</span>
 3826 |     | <span class='neutral'>// Hence, prior to the above-mentioned numerical search, we first need to move</span>
 3827 |     | <span class='neutral'>// &#39;qOvershoot&#39; from &#39;qTarget&#39; towards &#39;qNext&#39; until we determine the</span>
 3828 |     | <span class='neutral'>// followings:</span>
 3829 |     | <span class='neutral'>//</span>
 3830 |     | <span class='neutral'>//   - The piece of &#39;k(w(.))&#39; to which &#39;qOvershoot&#39; belongs.</span>
 3831 |     | <span class='neutral'>//</span>
 3832 |     | <span class='neutral'>//   - The piece of &#39;k(|h - qTarget|)&#39; to which &#39;qOvershoot&#39; belongs.</span>
 3833 |     | <span class='neutral'>//</span>
 3834 |     | <span class='neutral'>// The former is accomplished via a similar procedure as we delineated before</span>
 3835 |     | <span class='neutral'>// in search for &#39;qTarget&#39;. Put simply, we start with</span>
 3836 |     | <span class='neutral'>//</span>
 3837 |     | <span class='neutral'>//   &#39;qOvershoot := qTarget&#39;</span>
 3838 |     | <span class='neutral'>//</span>
 3839 |     | <span class='neutral'>// because</span>
 3840 |     | <span class='neutral'>//</span>
 3841 |     | <span class='neutral'>//   &#39;f(qTarget) &lt; 0&#39;,</span>
 3842 |     | <span class='neutral'>//</span>
 3843 |     | <span class='neutral'>// and we keep moving &#39;qOvershoot&#39; forward until we encounter a point that</span>
 3844 |     | <span class='neutral'>// satisfies:</span>
 3845 |     | <span class='neutral'>//</span>
 3846 |     | <span class='neutral'>//   &#39;f(qOvershoot) &gt; 0&#39;.</span>
 3847 |     | <span class='neutral'>//</span>
 3848 |     | <span class='neutral'>// Throughout the movement from &#39;qTarget&#39; towards &#39;qNext&#39;, we keep track of the</span>
 3849 |     | <span class='neutral'>// current phase under exploration using the variables:</span>
 3850 |     | <span class='neutral'>//</span>
 3851 |     | <span class='neutral'>//   - &#39;indexCurve&#39;, &#39;qOrigin&#39;, &#39;qEnd&#39;, &#39;direction&#39;,</span>
 3852 |     | <span class='neutral'>//</span>
 3853 |     | <span class='neutral'>// and we keep track of the current piece of the kernel function using the</span>
 3854 |     | <span class='neutral'>// variables:</span>
 3855 |     | <span class='neutral'>//</span>
 3856 |     | <span class='neutral'>//   - &#39;indexKernelTotal&#39;, &#39;cTotal0&#39;, &#39;cTotal1&#39;, &#39;qTotal0&#39;, &#39;qTotal1&#39;</span>
 3857 |     | <span class='neutral'>//</span>
 3858 |     | <span class='neutral'>// Throughout the search for &#39;qOvershoot&#39;, the piece of &#39;k(|h - qTarget|)&#39; to</span>
 3859 |     | <span class='neutral'>// which &#39;qOvershoot&#39; belongs is determined using an additional index:</span>
 3860 |     | <span class='neutral'>//</span>
 3861 |     | <span class='neutral'>//  - &#39;indexKernelForward&#39; keeps track of the pieces of the function</span>
 3862 |     | <span class='neutral'>//    &#39;k(|h - qTarget|)&#39; that we enumerate as we move from &#39;qTarget&#39; to</span>
 3863 |     | <span class='neutral'>//    &#39;qOvershoot&#39;. Each piece of &#39;k(|h - qTarget|)&#39; can be characterized via</span>
 3864 |     | <span class='neutral'>//    the following four vertical and horizontal coordinates:</span>
 3865 |     | <span class='neutral'>//</span>
 3866 |     | <span class='neutral'>//      &#39;cForward0 := c[indexKernelForward - 1]&#39;,</span>
 3867 |     | <span class='neutral'>//</span>
 3868 |     | <span class='neutral'>//      &#39;qForward0 := getZeroForOne() ? </span>
 3869 |     | <span class='neutral'>//                    qTarget - b[indexKernelForward - 1] : </span>
 3870 |     | <span class='neutral'>//                    qTarget + b[indexKernelForward - 1]&#39;,</span>
 3871 |     | <span class='neutral'>//</span>
 3872 |     | <span class='neutral'>//      &#39;cForward1 := c[indexKernelForward]&#39;,</span>
 3873 |     | <span class='neutral'>//</span>
 3874 |     | <span class='neutral'>//      &#39;qForward1 := getZeroForOne() ? </span>
 3875 |     | <span class='neutral'>//                    qTarget - b[indexKernelForward] : </span>
 3876 |     | <span class='neutral'>//                    qTarget + b[indexKernelForward]&#39;.</span>
 3877 |     | <span class='neutral'>//</span>
 3878 |     | <span class='neutral'>//    The pair &#39;(cForward0, qForward0)&#39; is stored in the memory space which is</span>
 3879 |     | <span class='neutral'>//    pointed to by &#39;_forward0_&#39; and similarly, the pair</span>
 3880 |     | <span class='neutral'>//    &#39;(cForward1, qForward1)&#39; is stored in the memory space which is pointed</span>
 3881 |     | <span class='neutral'>//    to by &#39;_forward1_&#39;.</span>
 3882 |     | <span class='neutral'>//</span>
 3883 |     | <span class='neutral'>//    Hence, the function &#39;k(|. - qTarget|)&#39; is linear within the range:</span>
 3884 |     | <span class='neutral'>//</span>
 3885 |     | <span class='neutral'>//      &#39;min(qForward0, qForward1) &lt; q &lt; max(qForward0, qForward1)&#39;.</span>
 3886 |     | <span class='neutral'>//</span>
 3887 |     | <span class='neutral'>//    and the function &#39;k(w(.))&#39; is linear within the intersection of the two</span>
 3888 |     | <span class='neutral'>//    ranges:</span>
 3889 |     | <span class='neutral'>//</span>
 3890 |     | <span class='neutral'>//      &#39;min(q[indexCurve + 2], qEnd) &lt; q &lt; max(q[indexCurve + 2], qEnd)&#39;,</span>
 3891 |     | <span class='neutral'>//</span>
 3892 |     | <span class='neutral'>//    and</span>
 3893 |     | <span class='neutral'>//</span>
 3894 |     | <span class='neutral'>//      &#39;min(qTotal0, qTotal1) &lt; q &lt; max(qTotal0, qTotal1)&#39;.</span>
 3895 |     | <span class='neutral'>//</span>
 3896 |     | <span class='neutral'>//    Now, in order to have closed-forms for all of the integrals that the</span>
 3897 |     | <span class='neutral'>//    formula for &#39;f(qOvershoot)&#39; comprises, at each step, we keep track of the</span>
 3898 |     | <span class='neutral'>//    domain in which both &#39;k(w(.))&#39; and &#39;k(|. - qTarget|)&#39; are linear and we</span>
 3899 |     | <span class='neutral'>//    update this domain as we move forward in our search. Hence, with every</span>
 3900 |     | <span class='neutral'>//    update of &#39;indexCurve&#39;, &#39;indexKernelTotal&#39;, and &#39;indexKernelForward&#39;, we</span>
 3901 |     | <span class='neutral'>//    make the following two updates:</span>
 3902 |     | <span class='neutral'>//</span>
 3903 |     | <span class='neutral'>//      &#39;qBegin := (</span>
 3904 |     | <span class='neutral'>//                   direction == getZeroForOne()</span>
 3905 |     | <span class='neutral'>//                 ) ? (</span>
 3906 |     | <span class='neutral'>//                   direction ? </span>
 3907 |     | <span class='neutral'>//                   max(max(q[indexCurve + 2], qTotal0), qForward0) : </span>
 3908 |     | <span class='neutral'>//                   min(min(q[indexCurve + 2], qTotal0), qForward0)</span>
 3909 |     | <span class='neutral'>//                 ) : (</span>
 3910 |     | <span class='neutral'>//                   direction ? </span>
 3911 |     | <span class='neutral'>//                   max(q[indexCurve + 2], qTotal0) : </span>
 3912 |     | <span class='neutral'>//                   min(q[indexCurve + 2], qTotal0)</span>
 3913 |     | <span class='neutral'>//                 )&#39;,</span>
 3914 |     | <span class='neutral'>//</span>
 3915 |     | <span class='neutral'>//      &#39;qOvershoot := (</span>
 3916 |     | <span class='neutral'>//                       direction == getZeroForOne()</span>
 3917 |     | <span class='neutral'>//                     ) ? (</span>
 3918 |     | <span class='neutral'>//                       direction ? </span>
 3919 |     | <span class='neutral'>//                       max(max(qEnd, qTotal1), qForward1) : </span>
 3920 |     | <span class='neutral'>//                       min(min(qEnd, qTotal1), qForward1)</span>
 3921 |     | <span class='neutral'>//                     ) : (</span>
 3922 |     | <span class='neutral'>//                       direction ? </span>
 3923 |     | <span class='neutral'>//                       max(qEnd, qTotal1) : </span>
 3924 |     | <span class='neutral'>//                       min(qEnd, qTotal1)</span>
 3925 |     | <span class='neutral'>//                     )&#39;,</span>
 3926 |     | <span class='neutral'>//</span>
 3927 |     | <span class='neutral'>//    where &#39;qBegin&#39; and &#39;qOvershoot&#39; are stored, respectively, in the memory</span>
 3928 |     | <span class='neutral'>//    spaces that are pointed to by &#39;_begin_&#39; and &#39;_overshoot_&#39;. Both values</span>
 3929 |     | <span class='neutral'>//    are updated with each transition to a new phase, a new piece of</span>
 3930 |     | <span class='neutral'>//    &#39;k(w(.))&#39;, or a new piece of &#39;k(|. - qTarget|)&#39;.</span>
 3931 |     | <span class='neutral'>//</span>
 3932 |     | <span class='neutral'>//    The process of enumerating the pieces of &#39;k(|. - qTarget|)&#39; starts with</span>
 3933 |     | <span class='neutral'>//    the initial state &#39;indexKernelForward := 1&#39;.</span>
 3934 |     | <span class='neutral'>//</span>
 3935 |     | <span class='neutral'>// Determining the search domain to which &#39;qOvershoot&#39; belongs and in which</span>
 3936 |     | <span class='neutral'>// both &#39;k(w(.))&#39; and &#39;k(|. - qTarget|)&#39; are linear, is conducted by calling</span>
 3937 |     | <span class='neutral'>// the method &#39;moveOvershoot&#39; from &#39;Interval.sol&#39; in a loop until the following</span>
 3938 |     | <span class='neutral'>// condition is met:</span>
 3939 |     | <span class='neutral'>//</span>
 3940 |     | <span class='neutral'>//   &#39;f(qBegin) &lt;= 0&#39; and &#39;f(qOvershoot) &gt;  0&#39;.</span>
 3941 |     | <span class='neutral'>//</span>
 3942 |     | <span class='neutral'>// Then, according to the intermediate value theorem, there exists a solution</span>
 3943 |     | <span class='neutral'>// in this search domain which satisfies:</span>
 3944 |     | <span class='neutral'>//</span>
 3945 |     | <span class='neutral'>//   &#39;f(qOvershoot) == 0&#39;.</span>
 3946 |     | <span class='neutral'>//</span>
 3947 |     | <span class='neutral'>// Then, this solution is found by calling the method &#39;searchOvershoot&#39; from</span>
 3948 |     | <span class='neutral'>// &#39;Interval.sol&#39;.</span>
 3949 |     | <span class='neutral'>//</span>
 3950 |     | <span class='neutral'>// In order to calculate the Newton step at each stage, we need to find the</span>
 3951 |     | <span class='neutral'>// derivative of &#39;f(.)&#39;. If &#39;getZeroForOne() == false&#39;, then we have:</span>
 3952 |     | <span class='neutral'>//</span>
 3953 |     | <span class='neutral'>//          d f</span>
 3954 |     | <span class='neutral'>//   &#39;-------------- ==</span>
 3955 |     | <span class='neutral'>//     d qOvershoot</span>
 3956 |     | <span class='neutral'>//</span>
 3957 |     | <span class='neutral'>//    (</span>
 3958 |     | <span class='neutral'>//</span>
 3959 |     | <span class='neutral'>//        + (qOrigin + qOvershoot) / 2    originToOvershoot</span>
 3960 |     | <span class='neutral'>//      e                              * ------------------- -</span>
 3961 |     | <span class='neutral'>//                                              2</span>
 3962 |     | <span class='neutral'>//</span>
 3963 |     | <span class='neutral'>//        + (qTarget + qOvershoot) / 2    targetToOvershoot</span>
 3964 |     | <span class='neutral'>//      e                              * ------------------- +</span>
 3965 |     | <span class='neutral'>//                                              2</span>
 3966 |     | <span class='neutral'>//         - 8 + qOrigin / 2</span>
 3967 |     | <span class='neutral'>//       e</span>
 3968 |     | <span class='neutral'>//      --------------------- * k(qOvershoot - qOrigin) -</span>
 3969 |     | <span class='neutral'>//                2</span>
 3970 |     | <span class='neutral'>//</span>
 3971 |     | <span class='neutral'>//         - 8 + qTarget / 2</span>
 3972 |     | <span class='neutral'>//       e</span>
 3973 |     | <span class='neutral'>//      --------------------- * k(qOvershoot - qTarget)</span>
 3974 |     | <span class='neutral'>//                2</span>
 3975 |     | <span class='neutral'>//</span>
 3976 |     | <span class='neutral'>//    ) / integral1Incremented - (</span>
 3977 |     | <span class='neutral'>//</span>
 3978 |     | <span class='neutral'>//         - 8 - qOvershoot / 2</span>
 3979 |     | <span class='neutral'>//       e</span>
 3980 |     | <span class='neutral'>//      ------------------------ * k(qOvershoot - qTarget) - </span>
 3981 |     | <span class='neutral'>//                  2</span>
 3982 |     | <span class='neutral'>//</span>
 3983 |     | <span class='neutral'>//         - 8 - qOvershoot / 2</span>
 3984 |     | <span class='neutral'>//       e</span>
 3985 |     | <span class='neutral'>//      ------------------------ * k(qOvershoot - qOrigin) </span>
 3986 |     | <span class='neutral'>//                  2</span>
 3987 |     | <span class='neutral'>//</span>
 3988 |     | <span class='neutral'>//    ) / integral0Incremented&#39;.</span>
 3989 |     | <span class='neutral'>//</span>
 3990 |     | <span class='neutral'>// If &#39;getZeroForOne() == true&#39;, then we have:</span>
 3991 |     | <span class='neutral'>//</span>
 3992 |     | <span class='neutral'>//          d f</span>
 3993 |     | <span class='neutral'>//   &#39;-------------- ==</span>
 3994 |     | <span class='neutral'>//     d qOvershoot</span>
 3995 |     | <span class='neutral'>//</span>
 3996 |     | <span class='neutral'>//    (</span>
 3997 |     | <span class='neutral'>//</span>
 3998 |     | <span class='neutral'>//         - 8 + qOvershoot / 2</span>
 3999 |     | <span class='neutral'>//       e</span>
 4000 |     | <span class='neutral'>//      ------------------------ * k(qTarget - qOvershoot) - </span>
 4001 |     | <span class='neutral'>//                  2</span>
 4002 |     | <span class='neutral'>//</span>
 4003 |     | <span class='neutral'>//         - 8 + qOvershoot / 2</span>
 4004 |     | <span class='neutral'>//       e</span>
 4005 |     | <span class='neutral'>//      ------------------------ * k(qOrigin - qOvershoot) </span>
 4006 |     | <span class='neutral'>//                  2</span>
 4007 |     | <span class='neutral'>//</span>
 4008 |     | <span class='neutral'>//    ) / integral1Incremented - (</span>
 4009 |     | <span class='neutral'>//</span>
 4010 |     | <span class='neutral'>//        - (qOrigin + qOvershoot) / 2    originToOvershoot</span>
 4011 |     | <span class='neutral'>//      e                              * ------------------- -</span>
 4012 |     | <span class='neutral'>//                                              2</span>
 4013 |     | <span class='neutral'>//</span>
 4014 |     | <span class='neutral'>//        - (qTarget + qOvershoot) / 2    targetToOvershoot</span>
 4015 |     | <span class='neutral'>//      e                              * ------------------- +</span>
 4016 |     | <span class='neutral'>//                                              2</span>
 4017 |     | <span class='neutral'>//         - 8 - qOrigin / 2</span>
 4018 |     | <span class='neutral'>//       e</span>
 4019 |     | <span class='neutral'>//      --------------------- * k(qOrigin - qOvershoot) - </span>
 4020 |     | <span class='neutral'>//                2</span>
 4021 |     | <span class='neutral'>//</span>
 4022 |     | <span class='neutral'>//         - 8 - qTarget / 2</span>
 4023 |     | <span class='neutral'>//       e</span>
 4024 |     | <span class='neutral'>//      --------------------- * k(qTarget - qOvershoot)</span>
 4025 |     | <span class='neutral'>//                2</span>
 4026 |     | <span class='neutral'>//</span>
 4027 |     | <span class='neutral'>//    ) / integral0Incremented&#39;.</span>
 4028 |     | <span class='neutral'>//</span>
 4029 |     | <span class='neutral'>// After the calulation of &#39;qOvershoot&#39;, the amended values &#39;growthAmended&#39;, </span>
 4030 |     | <span class='neutral'>// &#39;integral0Amended&#39; and &#39;integral1Amended&#39; are determined as follows:</span>
 4031 |     | <span class='neutral'>//</span>
 4032 |     | <span class='neutral'>//                         growth              growth</span>
 4033 |     | <span class='neutral'>//  &#39;growthAmended == ---------------- == ----------------&#39;,</span>
 4034 |     | <span class='neutral'>//                     s0(qOvershoot)      s1(qOvershoot)</span>
 4035 |     | <span class='neutral'>//</span>
 4036 |     | <span class='neutral'>//                            - 8     / qUpper</span>
 4037 |     | <span class='neutral'>//    integral0Amended      e        |    - h / 2</span>
 4038 |     | <span class='neutral'>//  &#39;------------------ := ------- * |  e         k(wAmended(h)) dh == </span>
 4039 |     | <span class='neutral'>//        2 ** 216            2      |</span>
 4040 |     | <span class='neutral'>//                                  / qTarget</span>
 4041 |     | <span class='neutral'>//</span>
 4042 |     | <span class='neutral'>//                              growth        integral0Incremented</span>
 4043 |     | <span class='neutral'>//                         --------------- * ----------------------&#39;,</span>
 4044 |     | <span class='neutral'>//                          growthAmended           2 ** 216</span>
 4045 |     | <span class='neutral'>//</span>
 4046 |     | <span class='neutral'>//                            - 8     / qTarget</span>
 4047 |     | <span class='neutral'>//    integral1Amended      e        |    + h / 2</span>
 4048 |     | <span class='neutral'>//  &#39;------------------ := ------- * |  e         k(wAmended(h)) dh == </span>
 4049 |     | <span class='neutral'>//        2 ** 216            2      |</span>
 4050 |     | <span class='neutral'>//                                  / qLower</span>
 4051 |     | <span class='neutral'>//</span>
 4052 |     | <span class='neutral'>//                              growth        integral0Incremented</span>
 4053 |     | <span class='neutral'>//                         --------------- * ----------------------&#39;,</span>
 4054 |     | <span class='neutral'>//                          growthAmended           2 ** 216</span>
 4055 |     | <span class='neutral'>//</span>
 4056 |     | <span class='neutral'>// where the ranges covered by &#39;integral0Amended&#39; and &#39;integral1Amended&#39; are</span>
 4057 |     | <span class='neutral'>// illustrated as follows:</span>
 4058 |     | <span class='neutral'>//</span>
 4059 |     | <span class='neutral'>//                         integral0Amended</span>
 4060 |     | <span class='neutral'>//                         exp(- h / 2) * k(wAmended(h))</span>
 4061 |     | <span class='neutral'>//                                                      \</span>
 4062 |     | <span class='neutral'>//             integral1Amended                          \</span>
 4063 |     | <span class='neutral'>//             exp(+ h / 2) * k(wAmended(h))              \</span>
 4064 |     | <span class='neutral'>//      |&lt;--------------------------------------&gt;|&lt;----------------&gt;|</span>
 4065 |     | <span class='neutral'>//      |                                        |                  |</span>
 4066 |     | <span class='neutral'>//      +----------------------------------------+------------------+</span>
 4067 |     | <span class='neutral'>//      |                                        |                  |</span>
 4068 |     | <span class='neutral'>//    qLower                                  qTarget             qUpper</span>
 4069 |     | <span class='neutral'>//</span>
 4070 |     | <span class='neutral'>// In the following section, the memory pointers that are used for the purpose</span>
 4071 |     | <span class='neutral'>// of the above calculations are introduced.</span>
 4072 |     | <span class='neutral'>uint16 constant _interval_ = 644;</span>
 4073 |     | <span class='neutral'></span>
 4074 |     | <span class='neutral'>// The direction of the current &#39;phase&#39; under exploration. Everytime that we</span>
 4075 |     | <span class='neutral'>// move from one &#39;phase&#39; to the next, by decrementing &#39;indexCurve&#39; this binary</span>
 4076 |     | <span class='neutral'>// value is flipped. &#39;direction&#39; should not be confused with &#39;zeroForOne&#39; which</span>
 4077 |     | <span class='neutral'>// does not change throughout a swap. Define:</span>
 4078 |     | <span class='neutral'>//</span>
 4079 |     | <span class='neutral'>//  &#39;qEnd := q[indexCurve]&#39;.</span>
 4080 |     | <span class='neutral'>//</span>
 4081 |     | <span class='neutral'>// &#39;direction = 0x00&#39; if &#39;q[indexCurve + 2] &lt; qEnd&#39;, i.e., when we are moving</span>
 4082 |     | <span class='neutral'>// towards &#39;+oo&#39;, in search for &#39;qTarget&#39; or &#39;qOvershoot&#39;. In this case, for</span>
 4083 |     | <span class='neutral'>// every &#39;q[indexCurve + 2] &lt; h &lt; qEnd&#39;, we have:</span>
 4084 |     | <span class='neutral'>//</span>
 4085 |     | <span class='neutral'>//  &#39;w(h) := h - qOrigin&#39;.</span>
 4086 |     | <span class='neutral'>//</span>
 4087 |     | <span class='neutral'>// &#39;direction = 0xFF&#39; if &#39;qEnd &lt; q[indexCurve + 2]&#39;, i.e., when we are moving</span>
 4088 |     | <span class='neutral'>// towards &#39;-oo&#39;, in search for &#39;qTarget&#39; or &#39;qOvershoot&#39;. In this case, for</span>
 4089 |     | <span class='neutral'>// every &#39;qEnd &lt; h &lt; q[indexCurve + 2]&#39;, we have:</span>
 4090 |     | <span class='neutral'>//</span>
 4091 |     | <span class='neutral'>//  &#39;w(h) := qOrigin - h&#39;.</span>
 4092 |     | <span class='neutral'>//</span>
 4093 |     | <span class='neutral'>uint16 constant _direction_ = 644;</span>
 4094 |     | <span class='neutral'></span>
 4095 |     | <span class='neutral'>// The index of &#39;qEnd&#39; among the members of the &#39;curve&#39;, i.e.,</span>
 4096 |     | <span class='neutral'>//</span>
 4097 |     | <span class='neutral'>//  &#39;qEnd == q[indexCurve]&#39;.</span>
 4098 |     | <span class='neutral'>//</span>
 4099 |     | <span class='neutral'>// While searching for &#39;qTarget&#39; and &#39;qOvershoot&#39;, the value of &#39;indexCurve&#39;</span>
 4100 |     | <span class='neutral'>// starts from &#39;curveLength - twoIndex&#39; and is decremented by &#39;oneIndex&#39; with</span>
 4101 |     | <span class='neutral'>// each run of the function &#39;movePhase()&#39; in &#39;Interval.sol&#39;.</span>
 4102 |     | <span class='neutral'>uint16 constant _indexCurve_ = 645;</span>
 4103 |     | <span class='neutral'></span>
 4104 |     | <span class='neutral'>// The index of &#39;qTotal1&#39; and &#39;cTotal1&#39; among the breakpoints of the &#39;kernel&#39;,</span>
 4105 |     | <span class='neutral'>// i.e.,</span>
 4106 |     | <span class='neutral'>//</span>
 4107 |     | <span class='neutral'>//  &#39;cTotal0 := c[indexKernelTotal - 1]&#39;,</span>
 4108 |     | <span class='neutral'>//</span>
 4109 |     | <span class='neutral'>//  &#39;qTotal0 := direction ? </span>
 4110 |     | <span class='neutral'>//              qOrigin - b[indexKernelTotal - 1] : </span>
 4111 |     | <span class='neutral'>//              qOrigin + b[indexKernelTotal - 1]&#39;,</span>
 4112 |     | <span class='neutral'>//</span>
 4113 |     | <span class='neutral'>//  &#39;cTotal1 == c[indexKernelTotal]&#39;,</span>
 4114 |     | <span class='neutral'>//</span>
 4115 |     | <span class='neutral'>//  &#39;qTotal1 == direction ? </span>
 4116 |     | <span class='neutral'>//              qOrigin - b[indexKernelTotal] : </span>
 4117 |     | <span class='neutral'>//              qOrigin + b[indexKernelTotal]&#39;.</span>
 4118 |     | <span class='neutral'>//</span>
 4119 |     | <span class='neutral'>// While searching for &#39;qTarget&#39; and &#39;qOvershoot&#39;, the value of</span>
 4120 |     | <span class='neutral'>// &#39;indexKernelTotal&#39; starts from &#39;oneIndex&#39; and is incremented by &#39;oneIndex&#39;</span>
 4121 |     | <span class='neutral'>// with each transition to a new piece of kernel as we explore &#39;k(w(h))&#39;.</span>
 4122 |     | <span class='neutral'>//</span>
 4123 |     | <span class='neutral'>// If &#39;getDirection() == false&#39;, then we have:</span>
 4124 |     | <span class='neutral'>//</span>
 4125 |     | <span class='neutral'>//  &#39;k(w(h)) == k(h - qOrigin) == k_indexKernelTotal(h - qOrigin) :=</span>
 4126 |     | <span class='neutral'>//</span>
 4127 |     | <span class='neutral'>//                         cTotal1 - cTotal0</span>
 4128 |     | <span class='neutral'>//              cTotal0 + ------------------- * (h - qTotal0)&#39;.</span>
 4129 |     | <span class='neutral'>//                         qTotal1 - qTotal0</span>
 4130 |     | <span class='neutral'>//</span>
 4131 |     | <span class='neutral'>// for every &#39;qBegin &lt; h &lt; qTarget&#39;.</span>
 4132 |     | <span class='neutral'>//</span>
 4133 |     | <span class='neutral'>// If &#39;getDirection() == true&#39;, then we have:</span>
 4134 |     | <span class='neutral'>//</span>
 4135 |     | <span class='neutral'>//  &#39;k(w(h)) == k(qOrigin - h) == k_indexKernelTotal(qOrigin - h) :=</span>
 4136 |     | <span class='neutral'>//</span>
 4137 |     | <span class='neutral'>//                         cTotal1 - cTotal0</span>
 4138 |     | <span class='neutral'>//              cTotal0 + ------------------- * (qTotal0 - h)&#39;.</span>
 4139 |     | <span class='neutral'>//                         qTotal0 - qTotal1</span>
 4140 |     | <span class='neutral'>//</span>
 4141 |     | <span class='neutral'>// for every &#39;qTarget &lt; h &lt; qBegin&#39;.</span>
 4142 |     | <span class='neutral'>uint16 constant _indexKernelTotal_ = 647;</span>
 4143 |     | <span class='neutral'></span>
 4144 |     | <span class='neutral'>// The index of &#39;qForward1&#39; and &#39;cForward1&#39; among the breakpoints of the</span>
 4145 |     | <span class='neutral'>// &#39;kernel&#39;, i.e.,</span>
 4146 |     | <span class='neutral'>//</span>
 4147 |     | <span class='neutral'>//  &#39;cForward0 := c[indexKernelForward - 1]&#39;,</span>
 4148 |     | <span class='neutral'>//</span>
 4149 |     | <span class='neutral'>//  &#39;qForward0 := getZeroForOne() ? </span>
 4150 |     | <span class='neutral'>//                qTarget - b[indexKernelForward - 1] : </span>
 4151 |     | <span class='neutral'>//                qTarget + b[indexKernelForward - 1]&#39;,</span>
 4152 |     | <span class='neutral'>//</span>
 4153 |     | <span class='neutral'>//  &#39;cForward1 := c[indexKernelForward]&#39;,</span>
 4154 |     | <span class='neutral'>//</span>
 4155 |     | <span class='neutral'>//  &#39;qForward1 := getZeroForOne() ? </span>
 4156 |     | <span class='neutral'>//                qTarget - b[indexKernelForward] : </span>
 4157 |     | <span class='neutral'>//                qTarget + b[indexKernelForward]&#39;.</span>
 4158 |     | <span class='neutral'>//</span>
 4159 |     | <span class='neutral'>// While searching for &#39;qOvershoot&#39;, the value of &#39;indexKernelForward&#39; starts</span>
 4160 |     | <span class='neutral'>// from &#39;oneIndex&#39; and is incremented by &#39;oneIndex&#39; with each transition to a</span>
 4161 |     | <span class='neutral'>// new piece of kernel.</span>
 4162 |     | <span class='neutral'>//</span>
 4163 |     | <span class='neutral'>// If &#39;getZeroForOne() == false&#39;, then we have:</span>
 4164 |     | <span class='neutral'>//</span>
 4165 |     | <span class='neutral'>//  &#39;k(h - qTarget) == k_indexKernelForward(h - qTarget) :=</span>
 4166 |     | <span class='neutral'>//</span>
 4167 |     | <span class='neutral'>//                                  cForward1 - cForward0</span>
 4168 |     | <span class='neutral'>//                     cForward0 + ----------------------- * (h - qForward0)&#39;.</span>
 4169 |     | <span class='neutral'>//                                  qForward1 - qForward0</span>
 4170 |     | <span class='neutral'>//</span>
 4171 |     | <span class='neutral'>// for every &#39;qBegin &lt; h &lt; qOvershoot&#39;.</span>
 4172 |     | <span class='neutral'>//</span>
 4173 |     | <span class='neutral'>// If &#39;getZeroForOne() == true&#39;, then we have:</span>
 4174 |     | <span class='neutral'>//</span>
 4175 |     | <span class='neutral'>//  &#39;k(qTarget - h) == k_indexKernelForward(qTarget - h) :=</span>
 4176 |     | <span class='neutral'>//</span>
 4177 |     | <span class='neutral'>//                                  cForward1 - cForward0</span>
 4178 |     | <span class='neutral'>//                     cForward0 + ----------------------- * (qForward0 - h)&#39;.</span>
 4179 |     | <span class='neutral'>//                                  qForward0 - qForward1</span>
 4180 |     | <span class='neutral'>//</span>
 4181 |     | <span class='neutral'>// for every &#39;qOvershoot &lt; h &lt; qBegin&#39;.</span>
 4182 |     | <span class='neutral'>uint16 constant _indexKernelForward_ = 649;</span>
 4183 |     | <span class='neutral'></span>
 4184 |     | <span class='neutral'>// Let &#39;pLower&#39; and &#39;pUpper&#39; be the minimum and maximum price in the active</span>
 4185 |     | <span class='neutral'>// liquidity interval and define</span>
 4186 |     | <span class='neutral'>//</span>
 4187 |     | <span class='neutral'>//  &#39;qLower := log(pLower / pOffset)&#39;,</span>
 4188 |     | <span class='neutral'>//  &#39;qUpper := log(pUpper / pOffset)&#39;.</span>
 4189 |     | <span class='neutral'>//  &#39;qLimitWithinInterval := min(max(qLower, qLimit), qUpper)&#39;</span>
 4190 |     | <span class='neutral'>//</span>
 4191 |     | <span class='neutral'>// The value set as &#39;logPriceLimitOffsetted&#39; may be outside of the current</span>
 4192 |     | <span class='neutral'>// active liquidity interval. In such cases, we first need to perform a swap</span>
 4193 |     | <span class='neutral'>// towards the current interval boundary and then we transition to a new</span>
 4194 |     | <span class='neutral'>// interval. In order to perform the former step, &#39;qLimitWithinInterval&#39; is</span>
 4195 |     | <span class='neutral'>// calculated and its offset binary &#39;X59&#39; representation, i.e.,</span>
 4196 |     | <span class='neutral'>//</span>
 4197 |     | <span class='neutral'>//  &#39;_origin_.log() := (2 ** 59) * (16 + qOrigin)&#39;</span>
 4198 |     | <span class='neutral'>//</span>
 4199 |     | <span class='neutral'>// is stored in the memory space which pointed to by</span>
 4200 |     | <span class='neutral'>// &#39;_logPriceLimitOffsettedWithinInterval_&#39;.</span>
 4201 |     | <span class='neutral'>uint16 constant _logPriceLimitOffsettedWithinInterval_ = 651;</span>
 4202 |     | <span class='neutral'></span>
 4203 |     | <span class='neutral'>// Let &#39;pCurrent&#39; represent the current price within the active liquidity</span>
 4204 |     | <span class='neutral'>// interval (prior to the movement to &#39;qTarget&#39; or &#39;qNext&#39;). This value</span>
 4205 |     | <span class='neutral'>// corresponds to the last member of the curve. Define:</span>
 4206 |     | <span class='neutral'>//</span>
 4207 |     | <span class='neutral'>//  &#39;qCurrent := log(pCurrent / pOffset)&#39;,</span>
 4208 |     | <span class='neutral'>//</span>
 4209 |     | <span class='neutral'>// The 62 bytes memory space which is pointed to by &#39;_current_&#39; hosts the</span>
 4210 |     | <span class='neutral'>// following values:</span>
 4211 |     | <span class='neutral'>//</span>
 4212 |     | <span class='neutral'>//  &#39;_current_.log() := (2 ** 59) * (16 + qCurrent)&#39;,</span>
 4213 |     | <span class='neutral'>//  &#39;_current_.sqrt(false) := (2 ** 216) * exp(- 8 - qCurrent / 2)&#39;,</span>
 4214 |     | <span class='neutral'>//  &#39;_current_.sqrt(true) := (2 ** 216) * exp(- 8 + qCurrent / 2)&#39;.</span>
 4215 |     | <span class='neutral'>//</span>
 4216 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The logarithmic price</span>
 4217 |     | <span class='neutral'>// &#39;_current_.log()&#39; occupies 64 bits, whereas &#39;_current_.sqrt(false)&#39; and</span>
 4218 |     | <span class='neutral'>// &#39;_current_.sqrt(true)&#39; occupy 216 bits each.</span>
 4219 |     | <span class='neutral'>uint16 constant _current_ = 659;</span>
 4220 |     | <span class='neutral'></span>
 4221 |     | <span class='neutral'>// Let &#39;indexCurve&#39; represent the index of the current phase under exploration.</span>
 4222 |     | <span class='neutral'>// Define:</span>
 4223 |     | <span class='neutral'>//</span>
 4224 |     | <span class='neutral'>//  &#39;qOrigin := q[indexCurve + 1]&#39;,</span>
 4225 |     | <span class='neutral'>//</span>
 4226 |     | <span class='neutral'>//  &#39;qEnd := q[indexCurve]&#39;.</span>
 4227 |     | <span class='neutral'>//</span>
 4228 |     | <span class='neutral'>// If &#39;getDirection() == false&#39;, for every &#39;q[indexCurve + 2] &lt; h &lt; qEnd&#39;, we</span>
 4229 |     | <span class='neutral'>// have:</span>
 4230 |     | <span class='neutral'>//</span>
 4231 |     | <span class='neutral'>//  &#39;w(h) := h - qOrigin&#39;.</span>
 4232 |     | <span class='neutral'>//</span>
 4233 |     | <span class='neutral'>// If &#39;getDirection() == true&#39;, for every &#39;qEnd &lt; h &lt; q[indexCurve + 2]&#39;, we</span>
 4234 |     | <span class='neutral'>// have:</span>
 4235 |     | <span class='neutral'>//</span>
 4236 |     | <span class='neutral'>//  &#39;w(h) := qOrigin - h&#39;.</span>
 4237 |     | <span class='neutral'>//</span>
 4238 |     | <span class='neutral'>// The 62 bytes memory space which is pointed to by &#39;_origin_&#39; hosts the</span>
 4239 |     | <span class='neutral'>// following values:</span>
 4240 |     | <span class='neutral'>//</span>
 4241 |     | <span class='neutral'>//  &#39;_origin_.log() := (2 ** 59) * (16 + qOrigin)&#39;,</span>
 4242 |     | <span class='neutral'>//  &#39;_origin_.sqrt(false) := (2 ** 216) * exp(- 8 - qOrigin / 2)&#39;,</span>
 4243 |     | <span class='neutral'>//  &#39;_origin_.sqrt(true) := (2 ** 216) * exp(- 8 + qOrigin / 2)&#39;.</span>
 4244 |     | <span class='neutral'>//</span>
 4245 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The logarithmic price</span>
 4246 |     | <span class='neutral'>// &#39;_origin_.log()&#39; occupies 64 bits, whereas &#39;_origin_.sqrt(false)&#39; and</span>
 4247 |     | <span class='neutral'>// &#39;_origin_.sqrt(true)&#39; occupy 216 bits each.</span>
 4248 |     | <span class='neutral'>uint16 constant _origin_ = 721;</span>
 4249 |     | <span class='neutral'></span>
 4250 |     | <span class='neutral'>// At every step of searching for &#39;qTarget&#39;, the range</span>
 4251 |     | <span class='neutral'>//</span>
 4252 |     | <span class='neutral'>//  &#39;min(qBegin, qTarget) &lt; h &lt; max(qBegin, qTarget)&#39;</span>
 4253 |     | <span class='neutral'>//</span>
 4254 |     | <span class='neutral'>// represents a piece of the liquidity distribution function &#39;k(w(.))&#39; in which</span>
 4255 |     | <span class='neutral'>// &#39;k(w(.))&#39; is linear. More precisely, if &#39;getDirection() == false&#39;, we have:</span>
 4256 |     | <span class='neutral'>//</span>
 4257 |     | <span class='neutral'>//  &#39;k(w(h)) == k(h - qOrigin) == k_indexKernelTotal(h - qOrigin) :=</span>
 4258 |     | <span class='neutral'>//</span>
 4259 |     | <span class='neutral'>//                         cTotal1 - cTotal0</span>
 4260 |     | <span class='neutral'>//              cTotal0 + ------------------- * (h - qTotal0)&#39;.</span>
 4261 |     | <span class='neutral'>//                         qTotal1 - qTotal0</span>
 4262 |     | <span class='neutral'>//</span>
 4263 |     | <span class='neutral'>// for every &#39;qBegin &lt; h &lt; qTarget&#39; and if &#39;getDirection() == true&#39;, we have:</span>
 4264 |     | <span class='neutral'>//</span>
 4265 |     | <span class='neutral'>//  &#39;k(w(h)) == k(qOrigin - h) == k_indexKernelTotal(qOrigin - h) :=</span>
 4266 |     | <span class='neutral'>//</span>
 4267 |     | <span class='neutral'>//                         cTotal1 - cTotal0</span>
 4268 |     | <span class='neutral'>//              cTotal0 + ------------------- * (qTotal0 - h)&#39;.</span>
 4269 |     | <span class='neutral'>//                         qTotal0 - qTotal1</span>
 4270 |     | <span class='neutral'>//</span>
 4271 |     | <span class='neutral'>// for every &#39;qTarget &lt; h &lt; qBegin&#39;.</span>
 4272 |     | <span class='neutral'>//</span>
 4273 |     | <span class='neutral'>// At the stage where we search for &#39;qTarget&#39;, we have</span>
 4274 |     | <span class='neutral'>//</span>
 4275 |     | <span class='neutral'>//  &#39;qBegin := direction ? </span>
 4276 |     | <span class='neutral'>//             min(q[indexCurve + 2], qTotal0) : </span>
 4277 |     | <span class='neutral'>//             max(q[indexCurve + 2], qTotal0)&#39;.</span>
 4278 |     | <span class='neutral'>//</span>
 4279 |     | <span class='neutral'>// At every step of searching for &#39;qOvershoot&#39;, the following inequality</span>
 4280 |     | <span class='neutral'>//</span>
 4281 |     | <span class='neutral'>//  &#39;min(qBegin, qOvershoot) &lt; h &lt; max(qBegin, qOvershoot)&#39;</span>
 4282 |     | <span class='neutral'>//</span>
 4283 |     | <span class='neutral'>// represents a range in which both &#39;k(w(.))&#39; and &#39;k(|. - qTarget|)&#39; are</span>
 4284 |     | <span class='neutral'>// linear. More precisely, if &#39;getZeroForOne() == false&#39;, we have:</span>
 4285 |     | <span class='neutral'>//</span>
 4286 |     | <span class='neutral'>//  &#39;k(h - qTarget) == k_indexKernelForward(h - qTarget) :=</span>
 4287 |     | <span class='neutral'>//</span>
 4288 |     | <span class='neutral'>//                                  cForward1 - cForward0</span>
 4289 |     | <span class='neutral'>//                     cForward0 + ----------------------- * (h - qForward0)&#39;.</span>
 4290 |     | <span class='neutral'>//                                  qForward1 - qForward0</span>
 4291 |     | <span class='neutral'>//</span>
 4292 |     | <span class='neutral'>// for every &#39;qBegin &lt; h &lt; qOvershoot&#39; and if &#39;getZeroForOne() == true&#39;, we</span>
 4293 |     | <span class='neutral'>// have:</span>
 4294 |     | <span class='neutral'>//</span>
 4295 |     | <span class='neutral'>//  &#39;k(qTarget - h) == k_indexKernelForward(qTarget - h) :=</span>
 4296 |     | <span class='neutral'>//</span>
 4297 |     | <span class='neutral'>//                                  cForward1 - cForward0</span>
 4298 |     | <span class='neutral'>//                     cForward0 + ----------------------- * (qForward0 - h)&#39;.</span>
 4299 |     | <span class='neutral'>//                                  qForward0 - qForward1</span>
 4300 |     | <span class='neutral'>//</span>
 4301 |     | <span class='neutral'>// for every &#39;qOvershoot &lt; h &lt; qBegin&#39;.</span>
 4302 |     | <span class='neutral'>//</span>
 4303 |     | <span class='neutral'>// At the stage where we search for &#39;qOvershoot&#39;, we have</span>
 4304 |     | <span class='neutral'>//</span>
 4305 |     | <span class='neutral'>//  &#39;qBegin := (</span>
 4306 |     | <span class='neutral'>//               direction == getZeroForOne()</span>
 4307 |     | <span class='neutral'>//             ) ? (</span>
 4308 |     | <span class='neutral'>//               direction ? </span>
 4309 |     | <span class='neutral'>//               max(max(q[indexCurve + 2], qTotal0), qForward0) : </span>
 4310 |     | <span class='neutral'>//               min(min(q[indexCurve + 2], qTotal0), qForward0)</span>
 4311 |     | <span class='neutral'>//             ) : (</span>
 4312 |     | <span class='neutral'>//               direction ? </span>
 4313 |     | <span class='neutral'>//               max(q[indexCurve + 2], qTotal0) : </span>
 4314 |     | <span class='neutral'>//               min(q[indexCurve + 2], qTotal0)</span>
 4315 |     | <span class='neutral'>//             )&#39;,</span>
 4316 |     | <span class='neutral'>//</span>
 4317 |     | <span class='neutral'>// The 62 bytes memory space which is pointed to by &#39;_begin_&#39; hosts the</span>
 4318 |     | <span class='neutral'>// following values:</span>
 4319 |     | <span class='neutral'>//</span>
 4320 |     | <span class='neutral'>//  &#39;_begin_.log() := (2 ** 59) * (16 + qBegin)&#39;,</span>
 4321 |     | <span class='neutral'>//  &#39;_begin_.sqrt(false) := (2 ** 216) * exp(- 8 - qBegin / 2)&#39;,</span>
 4322 |     | <span class='neutral'>//  &#39;_begin_.sqrt(true) := (2 ** 216) * exp(- 8 + qBegin / 2)&#39;.</span>
 4323 |     | <span class='neutral'>//</span>
 4324 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The logarithmic price</span>
 4325 |     | <span class='neutral'>// &#39;_begin_.log()&#39; occupies 64 bits, whereas &#39;_begin_.sqrt(false)&#39; and</span>
 4326 |     | <span class='neutral'>// &#39;_begin_.sqrt(true)&#39; occupy 216 bits each.</span>
 4327 |     | <span class='neutral'>uint16 constant _begin_ = 783;</span>
 4328 |     | <span class='neutral'></span>
 4329 |     | <span class='neutral'>// Let &#39;indexCurve&#39; represent the index of the current phase under exploration.</span>
 4330 |     | <span class='neutral'>// Define:</span>
 4331 |     | <span class='neutral'>//</span>
 4332 |     | <span class='neutral'>//  &#39;qOrigin := q[indexCurve + 1]&#39;,</span>
 4333 |     | <span class='neutral'>//</span>
 4334 |     | <span class='neutral'>//  &#39;qEnd := q[indexCurve]&#39;.</span>
 4335 |     | <span class='neutral'>//</span>
 4336 |     | <span class='neutral'>// If &#39;getDirection() == false&#39;, for every &#39;q[indexCurve + 2] &lt; h &lt; qEnd&#39;, we</span>
 4337 |     | <span class='neutral'>// have:</span>
 4338 |     | <span class='neutral'>//</span>
 4339 |     | <span class='neutral'>//  &#39;w(h) := h - qOrigin&#39;.</span>
 4340 |     | <span class='neutral'>//</span>
 4341 |     | <span class='neutral'>// If &#39;getDirection() == true&#39;, for every &#39;qEnd &lt; h &lt; q[indexCurve + 2]&#39;, we</span>
 4342 |     | <span class='neutral'>// have:</span>
 4343 |     | <span class='neutral'>//</span>
 4344 |     | <span class='neutral'>//  &#39;w(h) := qOrigin - h&#39;.</span>
 4345 |     | <span class='neutral'>//</span>
 4346 |     | <span class='neutral'>// The 62 bytes memory space which is pointed to by &#39;_end_&#39; hosts the following</span>
 4347 |     | <span class='neutral'>// values:</span>
 4348 |     | <span class='neutral'>//</span>
 4349 |     | <span class='neutral'>//  &#39;_end_.log() := (2 ** 59) * (16 + qEnd)&#39;,</span>
 4350 |     | <span class='neutral'>//  &#39;_end_.sqrt(false) := (2 ** 216) * exp(- 8 - qEnd / 2)&#39;,</span>
 4351 |     | <span class='neutral'>//  &#39;_end_.sqrt(true) := (2 ** 216) * exp(- 8 + qEnd / 2)&#39;.</span>
 4352 |     | <span class='neutral'>//</span>
 4353 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The logarithmic price</span>
 4354 |     | <span class='neutral'>// &#39;_end_.log()&#39; occupies 64 bits, whereas &#39;_end_.sqrt(false)&#39; and</span>
 4355 |     | <span class='neutral'>// &#39;_end_.sqrt(true)&#39; occupy 216 bits each.</span>
 4356 |     | <span class='neutral'>uint16 constant _end_ = 845;</span>
 4357 |     | <span class='neutral'></span>
 4358 |     | <span class='neutral'>// Every visit to a liquidity interval as part of a swap involves the movement</span>
 4359 |     | <span class='neutral'>// of price from &#39;pCurrent&#39; to &#39;pTarget&#39;. Define:</span>
 4360 |     | <span class='neutral'>//</span>
 4361 |     | <span class='neutral'>//  &#39;qCurrent := log(pCurrent / pOffset)&#39;,</span>
 4362 |     | <span class='neutral'>//  &#39;qTarget := log(pTarget / pOffset)&#39;,</span>
 4363 |     | <span class='neutral'>//</span>
 4364 |     | <span class='neutral'>// and assume that</span>
 4365 |     | <span class='neutral'>//</span>
 4366 |     | <span class='neutral'>//  &#39;qLower &lt;= qCurrent &lt;= qUpper&#39;,</span>
 4367 |     | <span class='neutral'>//  &#39;qLower &lt;= qTarget &lt;= qUpper&#39;,</span>
 4368 |     | <span class='neutral'>//</span>
 4369 |     | <span class='neutral'>// where &#39;[qLower, qUpper]&#39; represents the current active liquidity interval.</span>
 4370 |     | <span class='neutral'>//</span>
 4371 |     | <span class='neutral'>// At first &#39;qTarget&#39; is an unknown value which will be determined based on one</span>
 4372 |     | <span class='neutral'>// of the followings:</span>
 4373 |     | <span class='neutral'>//</span>
 4374 |     | <span class='neutral'>//  - &#39;qLimitWithinInterval&#39;, which is calculated based on the input</span>
 4375 |     | <span class='neutral'>//    &#39;logPriceLimit&#39; as well as &#39;qLower&#39; and &#39;qUpper&#39;. It is stored in the</span>
 4376 |     | <span class='neutral'>//    memory space which is pointed to by</span>
 4377 |     | <span class='neutral'>//    &#39;_logPriceLimitOffsettedWithinInterval_&#39;.</span>
 4378 |     | <span class='neutral'>//</span>
 4379 |     | <span class='neutral'>//  - &#39;integralLimit&#39;, which is calculated based on the input &#39;amountSpecified&#39;</span>
 4380 |     | <span class='neutral'>//    and is stored in the memory space which is pointed to by</span>
 4381 |     | <span class='neutral'>//    &#39;_integralLimit_&#39;.</span>
 4382 |     | <span class='neutral'>//</span>
 4383 |     | <span class='neutral'>// After determination of &#39;qTarget&#39;, the amounts of &#39;tag0&#39; and &#39;tag1&#39; to be</span>
 4384 |     | <span class='neutral'>// exchanged as a result of the movement within &#39;[qLower, qUpper]&#39; are equal</span>
 4385 |     | <span class='neutral'>// to:</span>
 4386 |     | <span class='neutral'>//</span>
 4387 |     | <span class='neutral'>//                                                         growth</span>
 4388 |     | <span class='neutral'>//  &#39;amount0Partial := sqrtInverseOffset * sharesTotal * ---------- *</span>
 4389 |     | <span class='neutral'>//                                                        2 ** 111</span>
 4390 |     | <span class='neutral'>//</span>
 4391 |     | <span class='neutral'>//                      - 8     / max(qCurrent, qTarget)</span>
 4392 |     | <span class='neutral'>//         1          e        |                         - h / 2</span>
 4393 |     | <span class='neutral'>//   ------------- * ------- * |                       e         k(w(h)) dh&#39;,</span>
 4394 |     | <span class='neutral'>//    outgoingMax       2      |</span>
 4395 |     | <span class='neutral'>//                            / min(qCurrent, qTarget)</span>
 4396 |     | <span class='neutral'>//</span>
 4397 |     | <span class='neutral'>// and</span>
 4398 |     | <span class='neutral'>//                                                  growth</span>
 4399 |     | <span class='neutral'>//  &#39;amount1Partial := sqrtOffset * sharesTotal * ---------- *</span>
 4400 |     | <span class='neutral'>//                                                 2 ** 111</span>
 4401 |     | <span class='neutral'>//</span>
 4402 |     | <span class='neutral'>//                      - 8     / max(qCurrent, qTarget)</span>
 4403 |     | <span class='neutral'>//         1          e        |                         + h / 2</span>
 4404 |     | <span class='neutral'>//   ------------- * ------- * |                       e         k(w(h)) dh&#39;,</span>
 4405 |     | <span class='neutral'>//    outgoingMax       2      |</span>
 4406 |     | <span class='neutral'>//                            / min(qCurrent, qTarget)</span>
 4407 |     | <span class='neutral'>//</span>
 4408 |     | <span class='neutral'>// where the parameters &#39;sqrtInverseOffset&#39;, &#39;sqrtOffset&#39;, &#39;sharesTotal&#39;,</span>
 4409 |     | <span class='neutral'>// &#39;growth&#39;, and &#39;outgoingMax&#39; remain fixed throughout the movement from</span>
 4410 |     | <span class='neutral'>// &#39;qCurrent&#39; to &#39;qTarget&#39;.</span>
 4411 |     | <span class='neutral'>//</span>
 4412 |     | <span class='neutral'>// In search for &#39;qTarget&#39;, we first need to enumerate the pieces of &#39;k(w(.))&#39;,</span>
 4413 |     | <span class='neutral'>// one by one, until we discover the piece to which &#39;qTarget&#39; belongs. While </span>
 4414 |     | <span class='neutral'>// enumerating the pieces of &#39;k(w(.))&#39;, one end of the current piece under</span>
 4415 |     | <span class='neutral'>// exploration is &#39;qBegin&#39; and the other end is temporarily referred to as:</span>
 4416 |     | <span class='neutral'>//</span>
 4417 |     | <span class='neutral'>//  &#39;qTarget := (</span>
 4418 |     | <span class='neutral'>//                direction == getZeroForOne()</span>
 4419 |     | <span class='neutral'>//              ) ? (</span>
 4420 |     | <span class='neutral'>//                direction ? </span>
 4421 |     | <span class='neutral'>//                max(max(qEnd, qTotal1), qLimitWithinInterval) : </span>
 4422 |     | <span class='neutral'>//                min(min(qEnd, qTotal1), qLimitWithinInterval)</span>
 4423 |     | <span class='neutral'>//              ) : (</span>
 4424 |     | <span class='neutral'>//                direction ? </span>
 4425 |     | <span class='neutral'>//                max(qEnd, qTotal1) : </span>
 4426 |     | <span class='neutral'>//                min(qEnd, qTotal1)</span>
 4427 |     | <span class='neutral'>//              )&#39;.</span>
 4428 |     | <span class='neutral'>//</span>
 4429 |     | <span class='neutral'>// After the correct piece is determined, we perform a numerical search via</span>
 4430 |     | <span class='neutral'>// either of the methods &#39;searchOutgoingTarget&#39; or &#39;searchIncomingTarget&#39; in</span>
 4431 |     | <span class='neutral'>// &#39;Interval.sol&#39; in order to pinpoint the precise value of &#39;qTarget&#39;.</span>
 4432 |     | <span class='neutral'>//</span>
 4433 |     | <span class='neutral'>// At every step of searching for the piece to which &#39;qTarget&#39; belongs, if </span>
 4434 |     | <span class='neutral'>// &#39;getDirection() == false&#39;, we have:</span>
 4435 |     | <span class='neutral'>//</span>
 4436 |     | <span class='neutral'>//  &#39;k(w(h)) == k(h - qOrigin) == k_indexKernelTotal(h - qOrigin) :=</span>
 4437 |     | <span class='neutral'>//</span>
 4438 |     | <span class='neutral'>//                         cTotal1 - cTotal0</span>
 4439 |     | <span class='neutral'>//              cTotal0 + ------------------- * (h - qTotal0)&#39;.</span>
 4440 |     | <span class='neutral'>//                         qTotal1 - qTotal0</span>
 4441 |     | <span class='neutral'>//</span>
 4442 |     | <span class='neutral'>// for every &#39;qBegin &lt; h &lt; qTarget&#39; and if &#39;getDirection() == true&#39;, we have:</span>
 4443 |     | <span class='neutral'>//</span>
 4444 |     | <span class='neutral'>//  &#39;k(w(h)) == k(qOrigin - h) == k_indexKernelTotal(qOrigin - h) :=</span>
 4445 |     | <span class='neutral'>//</span>
 4446 |     | <span class='neutral'>//                         cTotal1 - cTotal0</span>
 4447 |     | <span class='neutral'>//              cTotal0 + ------------------- * (qTotal0 - h)&#39;.</span>
 4448 |     | <span class='neutral'>//                         qTotal0 - qTotal1</span>
 4449 |     | <span class='neutral'>//</span>
 4450 |     | <span class='neutral'>// for every &#39;qTarget &lt; h &lt; qBegin&#39;.</span>
 4451 |     | <span class='neutral'>//</span>
 4452 |     | <span class='neutral'>// The 62 bytes memory space which is pointed to by &#39;_target_&#39; hosts the</span>
 4453 |     | <span class='neutral'>// following values:</span>
 4454 |     | <span class='neutral'>//</span>
 4455 |     | <span class='neutral'>//  &#39;_target_.log() := (2 ** 59) * (16 + qTarget)&#39;,</span>
 4456 |     | <span class='neutral'>//  &#39;_target_.sqrt(false) := (2 ** 216) * exp(- 8 - qTarget / 2)&#39;,</span>
 4457 |     | <span class='neutral'>//  &#39;_target_.sqrt(true) := (2 ** 216) * exp(- 8 + qTarget / 2)&#39;.</span>
 4458 |     | <span class='neutral'>//</span>
 4459 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The logarithmic price</span>
 4460 |     | <span class='neutral'>// &#39;_target_.log()&#39; occupies 64 bits, whereas &#39;_target_.sqrt(false)&#39; and</span>
 4461 |     | <span class='neutral'>// &#39;_target_.sqrt(true)&#39; occupy 216 bits each.</span>
 4462 |     | <span class='neutral'>uint16 constant _target_ = 907;</span>
 4463 |     | <span class='neutral'></span>
 4464 |     | <span class='neutral'>// Assume that we are in the process of doing a swap within an interval for</span>
 4465 |     | <span class='neutral'>// which &#39;qTarget&#39; as well as both &#39;amount0Partial&#39; and &#39;amount1Partial&#39; are</span>
 4466 |     | <span class='neutral'>// determined. Let &#39;[qLower, pUpper]&#39; represent the active liquidity interval</span>
 4467 |     | <span class='neutral'>// and define:</span>
 4468 |     | <span class='neutral'>//</span>
 4469 |     | <span class='neutral'>// Now we need to update the curve in preparation for the next swap. Before</span>
 4470 |     | <span class='neutral'>// doing so, define:</span>
 4471 |     | <span class='neutral'>//</span>
 4472 |     | <span class='neutral'>//                                - 8     / qUpper</span>
 4473 |     | <span class='neutral'>//    integral0Incremented      e        |    - h / 2</span>
 4474 |     | <span class='neutral'>//  &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;,</span>
 4475 |     | <span class='neutral'>//          2 ** 216              2      |</span>
 4476 |     | <span class='neutral'>//                                      / qTarget</span>
 4477 |     | <span class='neutral'>//</span>
 4478 |     | <span class='neutral'>//                                - 8     / qTarget</span>
 4479 |     | <span class='neutral'>//    integral1Incremented      e        |    + h / 2</span>
 4480 |     | <span class='neutral'>//  &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;.</span>
 4481 |     | <span class='neutral'>//          2 ** 216              2      |</span>
 4482 |     | <span class='neutral'>//                                      / qLower</span>
 4483 |     | <span class='neutral'>//</span>
 4484 |     | <span class='neutral'>// Then we have:</span>
 4485 |     | <span class='neutral'>//</span>
 4486 |     | <span class='neutral'>//                                                                   growth</span>
 4487 |     | <span class='neutral'>//  &#39;totalReserveOfTag0Before := sqrtInverseOffset * sharesTotal * ---------- * </span>
 4488 |     | <span class='neutral'>//                                                                  2 ** 111</span>
 4489 |     | <span class='neutral'>//    integral0Incremented</span>
 4490 |     | <span class='neutral'>//   ----------------------&#39;</span>
 4491 |     | <span class='neutral'>//        outgoingMax</span>
 4492 |     | <span class='neutral'>//</span>
 4493 |     | <span class='neutral'>//                                                            growth</span>
 4494 |     | <span class='neutral'>//  &#39;totalReserveOfTag1Before := sqrtOffset * sharesTotal * ---------- * </span>
 4495 |     | <span class='neutral'>//                                                           2 ** 111</span>
 4496 |     | <span class='neutral'>//    integral1Incremented</span>
 4497 |     | <span class='neutral'>//   ----------------------&#39;</span>
 4498 |     | <span class='neutral'>//        outgoingMax</span>
 4499 |     | <span class='neutral'>//</span>
 4500 |     | <span class='neutral'>// Now, assume that the curve sequence is updated and the function &#39;w&#39; is</span>
 4501 |     | <span class='neutral'>// transformed into a new function &#39;wAmended&#39; which is constructed based on the</span>
 4502 |     | <span class='neutral'>// updated curve sequence. Then, we can similarly define:</span>
 4503 |     | <span class='neutral'>//</span>
 4504 |     | <span class='neutral'>//                            - 8     / qUpper</span>
 4505 |     | <span class='neutral'>//    integral0Amended      e        |    - h / 2</span>
 4506 |     | <span class='neutral'>//  &#39;------------------ := ------- * |  e         k(wAmended(h)) dh&#39;,</span>
 4507 |     | <span class='neutral'>//        2 ** 216            2      |</span>
 4508 |     | <span class='neutral'>//                                  / qTarget</span>
 4509 |     | <span class='neutral'>//</span>
 4510 |     | <span class='neutral'>//                            - 8     / qTarget</span>
 4511 |     | <span class='neutral'>//    integral1Amended      e        |    + h / 2</span>
 4512 |     | <span class='neutral'>//  &#39;------------------ := ------- * |  e         k(wAmended(h)) dh&#39;.</span>
 4513 |     | <span class='neutral'>//        2 ** 216            2      |</span>
 4514 |     | <span class='neutral'>//                                  / qLower</span>
 4515 |     | <span class='neutral'>//</span>
 4516 |     | <span class='neutral'>// Then we have:</span>
 4517 |     | <span class='neutral'>//</span>
 4518 |     | <span class='neutral'>//  &#39;totalReserveOfTag0After := sqrtInverseOffset * sharesTotal *</span>
 4519 |     | <span class='neutral'>//</span>
 4520 |     | <span class='neutral'>//    growthAmended     integral0Amended</span>
 4521 |     | <span class='neutral'>//   --------------- * ------------------&#39;</span>
 4522 |     | <span class='neutral'>//      2 ** 111          outgoingMax</span>
 4523 |     | <span class='neutral'>//</span>
 4524 |     | <span class='neutral'>//  &#39;totalReserveOfTag1After := sqrtOffset * sharesTotal * </span>
 4525 |     | <span class='neutral'>//</span>
 4526 |     | <span class='neutral'>//    growthAmended     integral1Amended</span>
 4527 |     | <span class='neutral'>//   --------------- * ------------------&#39;</span>
 4528 |     | <span class='neutral'>//      2 ** 111          outgoingMax</span>
 4529 |     | <span class='neutral'>//</span>
 4530 |     | <span class='neutral'>// Now, we need to make sure that the reserve amounts before and after the</span>
 4531 |     | <span class='neutral'>// curve update are the same, which means that:</span>
 4532 |     | <span class='neutral'>//</span>
 4533 |     | <span class='neutral'>//  &#39;totalReserveOfTag0Before == totalReserveOfTag0After&#39;</span>
 4534 |     | <span class='neutral'>//  &#39;totalReserveOfTag1Before == totalReserveOfTag1After&#39;</span>
 4535 |     | <span class='neutral'>//</span>
 4536 |     | <span class='neutral'>// This leads to the following two equations:</span>
 4537 |     | <span class='neutral'>// </span>
 4538 |     | <span class='neutral'>//       growth            integral0Amended</span>
 4539 |     | <span class='neutral'>//  &#39;--------------- == ----------------------&#39;</span>
 4540 |     | <span class='neutral'>//    growthAmended      integral0Incremented</span>
 4541 |     | <span class='neutral'>// </span>
 4542 |     | <span class='neutral'>//       growth            integral1Amended</span>
 4543 |     | <span class='neutral'>//  &#39;--------------- == ----------------------&#39;</span>
 4544 |     | <span class='neutral'>//    growthAmended      integral1Incremented</span>
 4545 |     | <span class='neutral'>//</span>
 4546 |     | <span class='neutral'>// Hence, we must have:</span>
 4547 |     | <span class='neutral'>//</span>
 4548 |     | <span class='neutral'>//      integral0Amended          integral1Amended</span>
 4549 |     | <span class='neutral'>//  &#39;---------------------- == ----------------------&#39;</span>
 4550 |     | <span class='neutral'>//    integral0Incremented      integral1Incremented</span>
 4551 |     | <span class='neutral'>//</span>
 4552 |     | <span class='neutral'>// which means that:</span>
 4553 |     | <span class='neutral'>//</span>
 4554 |     | <span class='neutral'>//      / qUpper                          / qTarget</span>
 4555 |     | <span class='neutral'>//     |   - h/2                         |   + h/2</span>
 4556 |     | <span class='neutral'>//     |  e      k(wAmended(h)) dh       |  e      k(wAmended(h)) dh</span>
 4557 |     | <span class='neutral'>//     |                                 |</span>
 4558 |     | <span class='neutral'>//    / qTarget                         / qLower</span>
 4559 |     | <span class='neutral'>//  &#39;------------------------------ == ------------------------------&#39;.</span>
 4560 |     | <span class='neutral'>//         / qUpper                          / qTarget</span>
 4561 |     | <span class='neutral'>//        |    - h/2                        |    + h/2</span>
 4562 |     | <span class='neutral'>//        |  e       k(w(h)) dh             |  e       k(w(h)) dh</span>
 4563 |     | <span class='neutral'>//        |                                 |</span>
 4564 |     | <span class='neutral'>//       / qTarget                         / qLower</span>
 4565 |     | <span class='neutral'>//</span>
 4566 |     | <span class='neutral'>// As a result, we should update the curve in such a way that the above</span>
 4567 |     | <span class='neutral'>// equality is satisfied.</span>
 4568 |     | <span class='neutral'>//</span>
 4569 |     | <span class='neutral'>// To that end, once &#39;qOvershoot&#39; and both &#39;amount0Partial&#39; and</span>
 4570 |     | <span class='neutral'>// &#39;amount1Partial&#39; are determined, the curve sequence is amended with</span>
 4571 |     | <span class='neutral'>// &#39;qOvershoot&#39; and then &#39;qTarget&#39;.</span>
 4572 |     | <span class='neutral'>//</span>
 4573 |     | <span class='neutral'>// If &#39;getZeroForOne() == false&#39; then &#39;qTarget &lt;= qOvershoot&#39; and if</span>
 4574 |     | <span class='neutral'>// &#39;getZeroForOne() == true&#39; then &#39;qOvershoot &lt;= qTarget&#39;. Assume that</span>
 4575 |     | <span class='neutral'>// &#39;wAmended&#39; is constructed from the amended curve sequence. &#39;qOvershoot&#39; is</span>
 4576 |     | <span class='neutral'>// calculated in such a way that the above equality holds for the amended</span>
 4577 |     | <span class='neutral'>// curve. The process of searching for &#39;qOvershoot&#39; is further explained at</span>
 4578 |     | <span class='neutral'>// the beginning of this section.</span>
 4579 |     | <span class='neutral'>//</span>
 4580 |     | <span class='neutral'>// The 62 bytes memory space which is pointed to by &#39;_overshoot_&#39; hosts the</span>
 4581 |     | <span class='neutral'>// following values:</span>
 4582 |     | <span class='neutral'>//</span>
 4583 |     | <span class='neutral'>//  &#39;_overshoot_.log() := (2 ** 59) * (16 + qOvershoot)&#39;,</span>
 4584 |     | <span class='neutral'>//  &#39;_overshoot_.sqrt(false) := (2 ** 216) * exp(- 8 - qOvershoot / 2)&#39;,</span>
 4585 |     | <span class='neutral'>//  &#39;_overshoot_.sqrt(true) := (2 ** 216) * exp(- 8 + qOvershoot / 2)&#39;.</span>
 4586 |     | <span class='neutral'>//</span>
 4587 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The logarithmic price</span>
 4588 |     | <span class='neutral'>// &#39;_overshoot_.log()&#39; occupies 64 bits, whereas &#39;_overshoot_.sqrt(false)&#39; and</span>
 4589 |     | <span class='neutral'>// &#39;_overshoot_.sqrt(true)&#39; occupy 216 bits each.</span>
 4590 |     | <span class='neutral'>uint16 constant _overshoot_ = 969;</span>
 4591 |     | <span class='neutral'></span>
 4592 |     | <span class='neutral'>// At every step of searching for &#39;qTarget&#39;, the range</span>
 4593 |     | <span class='neutral'>//</span>
 4594 |     | <span class='neutral'>//  &#39;min(qBegin, qTarget) &lt; h &lt; max(qBegin, qTarget)&#39;</span>
 4595 |     | <span class='neutral'>//</span>
 4596 |     | <span class='neutral'>// represents a piece of the liquidity distribution function &#39;k(w(.))&#39; in which</span>
 4597 |     | <span class='neutral'>// &#39;k(w(.))&#39; is linear. More precisely, if &#39;getDirection() == false&#39;, we have:</span>
 4598 |     | <span class='neutral'>//</span>
 4599 |     | <span class='neutral'>//  &#39;k(w(h)) == k(h - qOrigin) == k_indexKernelTotal(h - qOrigin) :=</span>
 4600 |     | <span class='neutral'>//</span>
 4601 |     | <span class='neutral'>//                         cTotal1 - cTotal0</span>
 4602 |     | <span class='neutral'>//              cTotal0 + ------------------- * (h - qTotal0)&#39;.</span>
 4603 |     | <span class='neutral'>//                         qTotal1 - qTotal0</span>
 4604 |     | <span class='neutral'>//</span>
 4605 |     | <span class='neutral'>// for every &#39;qBegin &lt; h &lt; qTarget&#39; and if &#39;getDirection() == true&#39;, we have:</span>
 4606 |     | <span class='neutral'>//</span>
 4607 |     | <span class='neutral'>//  &#39;k(w(h)) == k(qOrigin - h) == k_indexKernelTotal(qOrigin - h) :=</span>
 4608 |     | <span class='neutral'>//</span>
 4609 |     | <span class='neutral'>//                         cTotal1 - cTotal0</span>
 4610 |     | <span class='neutral'>//              cTotal0 + ------------------- * (qTotal0 - h)&#39;.</span>
 4611 |     | <span class='neutral'>//                         qTotal0 - qTotal1</span>
 4612 |     | <span class='neutral'>//</span>
 4613 |     | <span class='neutral'>// for every &#39;qTarget &lt; h &lt; qBegin&#39;, where:</span>
 4614 |     | <span class='neutral'>//</span>
 4615 |     | <span class='neutral'>//  &#39;cTotal0 := c[indexKernelTotal - 1]&#39;,</span>
 4616 |     | <span class='neutral'>//</span>
 4617 |     | <span class='neutral'>//  &#39;qTotal0 := direction ? </span>
 4618 |     | <span class='neutral'>//              qOrigin - b[indexKernelTotal - 1] : </span>
 4619 |     | <span class='neutral'>//              qOrigin + b[indexKernelTotal - 1]&#39;,</span>
 4620 |     | <span class='neutral'>//</span>
 4621 |     | <span class='neutral'>//  &#39;cTotal1 := c[indexKernelTotal]&#39;,</span>
 4622 |     | <span class='neutral'>//</span>
 4623 |     | <span class='neutral'>//  &#39;qTotal1 := direction ? </span>
 4624 |     | <span class='neutral'>//              qOrigin - b[indexKernelTotal] : </span>
 4625 |     | <span class='neutral'>//              qOrigin + b[indexKernelTotal]&#39;.</span>
 4626 |     | <span class='neutral'>//</span>
 4627 |     | <span class='neutral'>// The pair &#39;(cTotal0, qTotal0)&#39; is stored in the memory space which is pointed</span>
 4628 |     | <span class='neutral'>// to by &#39;_total0_&#39; and similarly, the pair &#39;(cTotal1, qTotal1)&#39; is stored in</span>
 4629 |     | <span class='neutral'>// the memory space which is pointed to by &#39;_total1_&#39;.</span>
 4630 |     | <span class='neutral'>//</span>
 4631 |     | <span class='neutral'>// The 64 bytes memory space which is pointed to by &#39;_total0_&#39; hosts the</span>
 4632 |     | <span class='neutral'>// following values:</span>
 4633 |     | <span class='neutral'>//</span>
 4634 |     | <span class='neutral'>//  &#39;_total0_.height() := (2 ** 15) * cTotal0&#39;,</span>
 4635 |     | <span class='neutral'>//  &#39;_total0_.log() := (2 ** 59) * (16 + qTotal0)&#39;,</span>
 4636 |     | <span class='neutral'>//  &#39;_total0_.sqrt(false) := (2 ** 216) * exp(- 8 - qTotal0 / 2)&#39;,</span>
 4637 |     | <span class='neutral'>//  &#39;_total0_.sqrt(true) := (2 ** 216) * exp(- 8 + qTotal0 / 2)&#39;.</span>
 4638 |     | <span class='neutral'>//</span>
 4639 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The vertical coordinate</span>
 4640 |     | <span class='neutral'>// &#39;_total0_.height()&#39; occupies 16 bits, the logarithmic price &#39;_total0_.log()&#39;</span>
 4641 |     | <span class='neutral'>// occupies 64 bits, whereas &#39;_total0_.sqrt(false)&#39; and &#39;_total0_.sqrt(true)&#39;</span>
 4642 |     | <span class='neutral'>// occupy 216 bits each.</span>
 4643 |     | <span class='neutral'>//</span>
 4644 |     | <span class='neutral'>// The 64 bytes memory space which is pointed to by &#39;_total1_&#39; hosts the</span>
 4645 |     | <span class='neutral'>// following values:</span>
 4646 |     | <span class='neutral'>//</span>
 4647 |     | <span class='neutral'>//  &#39;_total1_.height() := (2 ** 15) * cTotal1&#39;,</span>
 4648 |     | <span class='neutral'>//  &#39;_total1_.log() := (2 ** 59) * (16 + qTotal1)&#39;,</span>
 4649 |     | <span class='neutral'>//  &#39;_total1_.sqrt(false) := (2 ** 216) * exp(- 8 - qTotal1 / 2)&#39;,</span>
 4650 |     | <span class='neutral'>//  &#39;_total1_.sqrt(true) := (2 ** 216) * exp(- 8 + qTotal1 / 2)&#39;.</span>
 4651 |     | <span class='neutral'>//</span>
 4652 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The vertical coordinate</span>
 4653 |     | <span class='neutral'>// &#39;_total1_.height()&#39; occupies 16 bits, the logarithmic price &#39;_total1_.log()&#39;</span>
 4654 |     | <span class='neutral'>// occupies 64 bits, whereas &#39;_total1_.sqrt(false)&#39; and &#39;_total1_.sqrt(true)&#39;</span>
 4655 |     | <span class='neutral'>// occupy 216 bits each.</span>
 4656 |     | <span class='neutral'>uint16 constant _total0_ = 1033;</span>
 4657 |     | <span class='neutral'>uint16 constant _total1_ = 1097;</span>
 4658 |     | <span class='neutral'></span>
 4659 |     | <span class='neutral'>// At every step of searching for &#39;qOvershoot&#39;, the range</span>
 4660 |     | <span class='neutral'>//</span>
 4661 |     | <span class='neutral'>//  &#39;min(qBegin, qOvershoot) &lt; h &lt; max(qBegin, qOvershoot)&#39;</span>
 4662 |     | <span class='neutral'>//</span>
 4663 |     | <span class='neutral'>// represents a piece of &#39;k(|. - qTarget|)&#39;. If &#39;getZeroForOne() == false&#39;,</span>
 4664 |     | <span class='neutral'>// then we have:</span>
 4665 |     | <span class='neutral'>//</span>
 4666 |     | <span class='neutral'>//  &#39;k(h - qTarget) == k_indexKernelForward(h - qTarget) :=</span>
 4667 |     | <span class='neutral'>//</span>
 4668 |     | <span class='neutral'>//                                  cForward1 - cForward0</span>
 4669 |     | <span class='neutral'>//                     cForward0 + ----------------------- * (h - qForward0)&#39;,</span>
 4670 |     | <span class='neutral'>//                                  qForward1 - qForward0</span>
 4671 |     | <span class='neutral'>//</span>
 4672 |     | <span class='neutral'>// for every &#39;qBegin &lt; h &lt; qOvershoot&#39; and if &#39;getZeroForOne() == true&#39;, then</span>
 4673 |     | <span class='neutral'>// we have:</span>
 4674 |     | <span class='neutral'>//</span>
 4675 |     | <span class='neutral'>//  &#39;k(qTarget - h) == k_indexKernelForward(qTarget - h) :=</span>
 4676 |     | <span class='neutral'>//</span>
 4677 |     | <span class='neutral'>//                                  cForward1 - cForward0</span>
 4678 |     | <span class='neutral'>//                     cForward0 + ----------------------- * (qForward0 - h)&#39;,</span>
 4679 |     | <span class='neutral'>//                                  qForward0 - qForward1</span>
 4680 |     | <span class='neutral'>//</span>
 4681 |     | <span class='neutral'>// for every &#39;qOvershoot &lt; h &lt; qBegin&#39; where</span>
 4682 |     | <span class='neutral'>//</span>
 4683 |     | <span class='neutral'>//  &#39;cForward0 := c[indexKernelForward - 1]&#39;,</span>
 4684 |     | <span class='neutral'>//</span>
 4685 |     | <span class='neutral'>//  &#39;qForward0 := getZeroForOne() ? </span>
 4686 |     | <span class='neutral'>//                qTarget - b[indexKernelForward - 1] : </span>
 4687 |     | <span class='neutral'>//                qTarget + b[indexKernelForward - 1]&#39;,</span>
 4688 |     | <span class='neutral'>//</span>
 4689 |     | <span class='neutral'>//  &#39;cForward1 := c[indexKernelForward]&#39;,</span>
 4690 |     | <span class='neutral'>//</span>
 4691 |     | <span class='neutral'>//  &#39;qForward1 := getZeroForOne() ? </span>
 4692 |     | <span class='neutral'>//                qTarget - b[indexKernelForward] : </span>
 4693 |     | <span class='neutral'>//                qTarget + b[indexKernelForward]&#39;.</span>
 4694 |     | <span class='neutral'>//</span>
 4695 |     | <span class='neutral'>// The pair &#39;(cForward0, qForward0)&#39; is stored in the memory space which is</span>
 4696 |     | <span class='neutral'>// pointed to by &#39;_forward0_&#39; and similarly, the pair &#39;(cForward1, qForward1)&#39;</span>
 4697 |     | <span class='neutral'>// is stored in the memory space which is pointed to by &#39;_forward1_&#39;.</span>
 4698 |     | <span class='neutral'>//</span>
 4699 |     | <span class='neutral'>// The 64 bytes memory space which is pointed to by &#39;_forward0_&#39; hosts the</span>
 4700 |     | <span class='neutral'>// following values:</span>
 4701 |     | <span class='neutral'>//</span>
 4702 |     | <span class='neutral'>//  &#39;_forward0_.height() := (2 ** 15) * cForward0&#39;,</span>
 4703 |     | <span class='neutral'>//  &#39;_forward0_.log() := (2 ** 59) * (16 + qForward0)&#39;,</span>
 4704 |     | <span class='neutral'>//  &#39;_forward0_.sqrt(false) := (2 ** 216) * exp(- 8 - qForward0 / 2)&#39;,</span>
 4705 |     | <span class='neutral'>//  &#39;_forward0_.sqrt(true) := (2 ** 216) * exp(- 8 + qForward0 / 2)&#39;.</span>
 4706 |     | <span class='neutral'>//</span>
 4707 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The vertical coordinate</span>
 4708 |     | <span class='neutral'>// &#39;_forward0_.height()&#39; occupies 16 bits, the logarithmic price</span>
 4709 |     | <span class='neutral'>// &#39;_forward0_.log()&#39; occupies 64 bits, whereas &#39;_forward0_.sqrt(false)&#39; and</span>
 4710 |     | <span class='neutral'>// &#39;_forward0_.sqrt(true)&#39; occupy 216 bits each.</span>
 4711 |     | <span class='neutral'>//</span>
 4712 |     | <span class='neutral'>// The 64 bytes memory space which is pointed to by &#39;_forward1_&#39; hosts the</span>
 4713 |     | <span class='neutral'>// following values:</span>
 4714 |     | <span class='neutral'>//</span>
 4715 |     | <span class='neutral'>//  &#39;_forward1_.height() := (2 ** 15) * cForward1&#39;,</span>
 4716 |     | <span class='neutral'>//  &#39;_forward1_.log() := (2 ** 59) * (16 + qForward1)&#39;,</span>
 4717 |     | <span class='neutral'>//  &#39;_forward1_.sqrt(false) := (2 ** 216) * exp(- 8 - qForward1 / 2)&#39;,</span>
 4718 |     | <span class='neutral'>//  &#39;_forward1_.sqrt(true) := (2 ** 216) * exp(- 8 + qForward1 / 2)&#39;.</span>
 4719 |     | <span class='neutral'>//</span>
 4720 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The vertical coordinate</span>
 4721 |     | <span class='neutral'>// &#39;_forward1_.height()&#39; occupies 16 bits, the logarithmic price</span>
 4722 |     | <span class='neutral'>// &#39;_forward1_.log()&#39; occupies 64 bits, whereas &#39;_forward1_.sqrt(false)&#39; and</span>
 4723 |     | <span class='neutral'>// &#39;_forward1_.sqrt(true)&#39; occupy 216 bits each.</span>
 4724 |     | <span class='neutral'>uint16 constant _forward0_ = 1161;</span>
 4725 |     | <span class='neutral'>uint16 constant _forward1_ = 1225;</span>
 4726 |     | <span class='neutral'></span>
 4727 |     | <span class='neutral'>// While searching for &#39;qTarget&#39;, the integral &#39;incomingCurrentToTarget&#39; is</span>
 4728 |     | <span class='neutral'>// calculated. This integral is defined as follows:</span>
 4729 |     | <span class='neutral'>//</span>
 4730 |     | <span class='neutral'>//                                   - 8</span>
 4731 |     | <span class='neutral'>//    incomingCurrentToTarget      e</span>
 4732 |     | <span class='neutral'>//  &#39;------------------------- := ------- * (</span>
 4733 |     | <span class='neutral'>//           2 ** 216                2</span>
 4734 |     | <span class='neutral'>//</span>
 4735 |     | <span class='neutral'>//                         / qCurrent                 / qTarget</span>
 4736 |     | <span class='neutral'>//                        |    - h / 2               |    + h / 2</span>
 4737 |     | <span class='neutral'>//     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh</span>
 4738 |     | <span class='neutral'>//                        |                          |</span>
 4739 |     | <span class='neutral'>//                       / qTarget                  / qCurrent</span>
 4740 |     | <span class='neutral'>//</span>
 4741 |     | <span class='neutral'>//   )&#39;.</span>
 4742 |     | <span class='neutral'>//</span>
 4743 |     | <span class='neutral'>// The pointer below refers to the above integral in &#39;X216&#39; representation</span>
 4744 |     | <span class='neutral'>// which takes up to 27 bytes.</span>
 4745 |     | <span class='neutral'>uint16 constant _incomingCurrentToTarget_ = 1287;</span>
 4746 |     | <span class='neutral'></span>
 4747 |     | <span class='neutral'>// While searching for &#39;qTarget&#39;, the integral &#39;currentToTarget&#39; is calculated.</span>
 4748 |     | <span class='neutral'>// This integral is defined as follows:</span>
 4749 |     | <span class='neutral'>//</span>
 4750 |     | <span class='neutral'>//                           - 8</span>
 4751 |     | <span class='neutral'>//    currentToTarget      e</span>
 4752 |     | <span class='neutral'>//  &#39;----------------- := ------- * (</span>
 4753 |     | <span class='neutral'>//       2 ** 216            2</span>
 4754 |     | <span class='neutral'>//</span>
 4755 |     | <span class='neutral'>//                         / qCurrent                 / qTarget</span>
 4756 |     | <span class='neutral'>//                        |    + h / 2               |    - h / 2</span>
 4757 |     | <span class='neutral'>//     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh</span>
 4758 |     | <span class='neutral'>//                        |                          |</span>
 4759 |     | <span class='neutral'>//                       / qTarget                  / qCurrent</span>
 4760 |     | <span class='neutral'>//</span>
 4761 |     | <span class='neutral'>//   )&#39;</span>
 4762 |     | <span class='neutral'>//</span>
 4763 |     | <span class='neutral'>// The pointer below refers to the above integral in &#39;X216&#39; representation</span>
 4764 |     | <span class='neutral'>// which takes up to 27 bytes.</span>
 4765 |     | <span class='neutral'>uint16 constant _currentToTarget_ = 1314;</span>
 4766 |     | <span class='neutral'></span>
 4767 |     | <span class='neutral'>// While searching for &#39;qTarget&#39; and &#39;qOvershoot&#39;, we need to calculate the</span>
 4768 |     | <span class='neutral'>// following integral:</span>
 4769 |     | <span class='neutral'>//</span>
 4770 |     | <span class='neutral'>//                           - 8</span>
 4771 |     | <span class='neutral'>//    currentToOrigin      e</span>
 4772 |     | <span class='neutral'>//  &#39;----------------- := ------- * (</span>
 4773 |     | <span class='neutral'>//       2 ** 216            2</span>
 4774 |     | <span class='neutral'>//</span>
 4775 |     | <span class='neutral'>//                         / qOrigin                  / qCurrent</span>
 4776 |     | <span class='neutral'>//                        |    - h / 2               |    + h / 2</span>
 4777 |     | <span class='neutral'>//     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh</span>
 4778 |     | <span class='neutral'>//                        |                          |</span>
 4779 |     | <span class='neutral'>//                       / qCurrent                 / qOrigin</span>
 4780 |     | <span class='neutral'>//</span>
 4781 |     | <span class='neutral'>//   )&#39;.</span>
 4782 |     | <span class='neutral'>//</span>
 4783 |     | <span class='neutral'>// &#39;currentToOrigin&#39; is used for the calculation of &#39;overshoot&#39; as discussed in</span>
 4784 |     | <span class='neutral'>// &#39;Interval.sol&#39;.</span>
 4785 |     | <span class='neutral'>//</span>
 4786 |     | <span class='neutral'>// The pointer below refers to the above integral in &#39;X216&#39; representation</span>
 4787 |     | <span class='neutral'>// which takes up to 27 bytes.</span>
 4788 |     | <span class='neutral'>uint16 constant _currentToOrigin_ = 1341;</span>
 4789 |     | <span class='neutral'></span>
 4790 |     | <span class='neutral'>// While searching for &#39;qTarget&#39; and &#39;qOvershoot&#39;, we need to calculate the</span>
 4791 |     | <span class='neutral'>// following integral:</span>
 4792 |     | <span class='neutral'>//</span>
 4793 |     | <span class='neutral'>//                              - 8</span>
 4794 |     | <span class='neutral'>//    currentToOvershoot      e</span>
 4795 |     | <span class='neutral'>//  &#39;-------------------- := ------- * (</span>
 4796 |     | <span class='neutral'>//         2 ** 216             2</span>
 4797 |     | <span class='neutral'>//</span>
 4798 |     | <span class='neutral'>//                         / qCurrent                 / qOvershoot</span>
 4799 |     | <span class='neutral'>//                        |    + h / 2               |    - h / 2</span>
 4800 |     | <span class='neutral'>//     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh</span>
 4801 |     | <span class='neutral'>//                        |                          |</span>
 4802 |     | <span class='neutral'>//                       / qOvershoot               / qCurrent</span>
 4803 |     | <span class='neutral'>//</span>
 4804 |     | <span class='neutral'>//   )&#39;</span>
 4805 |     | <span class='neutral'>//</span>
 4806 |     | <span class='neutral'>// &#39;currentToOvershoot&#39; is used for the calculation of &#39;overshoot&#39; as discussed</span>
 4807 |     | <span class='neutral'>// in &#39;Interval.sol&#39;.</span>
 4808 |     | <span class='neutral'>//</span>
 4809 |     | <span class='neutral'>// The pointer below refers to the above integral in &#39;X216&#39; representation</span>
 4810 |     | <span class='neutral'>// which takes up to 27 bytes.</span>
 4811 |     | <span class='neutral'>uint16 constant _currentToOvershoot_ = 1368;</span>
 4812 |     | <span class='neutral'></span>
 4813 |     | <span class='neutral'>// While searching for &#39;qOvershoot&#39;, we need to calculate the following</span>
 4814 |     | <span class='neutral'>// integral:</span>
 4815 |     | <span class='neutral'>//</span>
 4816 |     | <span class='neutral'>//                             - 8</span>
 4817 |     | <span class='neutral'>//    targetToOvershoot      e</span>
 4818 |     | <span class='neutral'>//  &#39;------------------- := ------- * (</span>
 4819 |     | <span class='neutral'>//         2 ** 216            2</span>
 4820 |     | <span class='neutral'>//</span>
 4821 |     | <span class='neutral'>//     getZeroForOne()</span>
 4822 |     | <span class='neutral'>//</span>
 4823 |     | <span class='neutral'>//         / qTarget</span>
 4824 |     | <span class='neutral'>//        |    + h / 2</span>
 4825 |     | <span class='neutral'>//     ?  |  e         k(qTarget - h) dh</span>
 4826 |     | <span class='neutral'>//        |</span>
 4827 |     | <span class='neutral'>//       / qOvershoot</span>
 4828 |     | <span class='neutral'>//</span>
 4829 |     | <span class='neutral'>//         / qOvershoot</span>
 4830 |     | <span class='neutral'>//        |    - h / 2</span>
 4831 |     | <span class='neutral'>//     :  |  e         k(h - qTarget) dh</span>
 4832 |     | <span class='neutral'>//        |</span>
 4833 |     | <span class='neutral'>//       / qTarget</span>
 4834 |     | <span class='neutral'>//</span>
 4835 |     | <span class='neutral'>//   )&#39;</span>
 4836 |     | <span class='neutral'>//</span>
 4837 |     | <span class='neutral'>// &#39;targetToOvershoot&#39; is used for the calculation of &#39;overshoot&#39; as discussed</span>
 4838 |     | <span class='neutral'>// in &#39;Interval.sol&#39;.</span>
 4839 |     | <span class='neutral'>//</span>
 4840 |     | <span class='neutral'>// The pointer below refers to the above integral in &#39;X216&#39; representation</span>
 4841 |     | <span class='neutral'>// which takes up to 27 bytes.</span>
 4842 |     | <span class='neutral'>uint16 constant _targetToOvershoot_ = 1395;</span>
 4843 |     | <span class='neutral'></span>
 4844 |     | <span class='neutral'>// While searching for &#39;qTarget&#39; and &#39;qOvershoot&#39;, we need to calculate the</span>
 4845 |     | <span class='neutral'>// following integral:</span>
 4846 |     | <span class='neutral'>//</span>
 4847 |     | <span class='neutral'>//                             - 8</span>
 4848 |     | <span class='neutral'>//    originToOvershoot      e</span>
 4849 |     | <span class='neutral'>//  &#39;------------------- := ------- * (</span>
 4850 |     | <span class='neutral'>//        2 ** 216             2</span>
 4851 |     | <span class='neutral'>//</span>
 4852 |     | <span class='neutral'>//     getZeroForOne() ? </span>
 4853 |     | <span class='neutral'>//</span>
 4854 |     | <span class='neutral'>//       / qOrigin</span>
 4855 |     | <span class='neutral'>//      |    + h / 2</span>
 4856 |     | <span class='neutral'>//      |  e         k(qOrigin - h) dh :</span>
 4857 |     | <span class='neutral'>//      |</span>
 4858 |     | <span class='neutral'>//     / qTarget</span>
 4859 |     | <span class='neutral'>//</span>
 4860 |     | <span class='neutral'>//       / qTarget</span>
 4861 |     | <span class='neutral'>//      |    - h / 2</span>
 4862 |     | <span class='neutral'>//      |  e         k(h - qOrigin) dh</span>
 4863 |     | <span class='neutral'>//      |</span>
 4864 |     | <span class='neutral'>//     / qOrigin</span>
 4865 |     | <span class='neutral'>//</span>
 4866 |     | <span class='neutral'>//   )&#39;</span>
 4867 |     | <span class='neutral'>//</span>
 4868 |     | <span class='neutral'>// &#39;originToOvershoot&#39; is used for the calculation of &#39;overshoot&#39; as discussed</span>
 4869 |     | <span class='neutral'>// in &#39;Interval.sol&#39;.</span>
 4870 |     | <span class='neutral'>//</span>
 4871 |     | <span class='neutral'>// The pointer below refers to the above integral in &#39;X216&#39; representation</span>
 4872 |     | <span class='neutral'>// which takes up to 27 bytes.</span>
 4873 |     | <span class='neutral'>uint16 constant _originToOvershoot_ = 1422;</span>
 4874 |     | <span class='neutral'></span>
 4875 |     | <span class='neutral'>uint16 constant _endOfInterval_ = 1449;</span>
 4876 |     | <span class='neutral'></span>
 4877 |     | <span class='neutral'>// Accrued Parameters</span>
 4878 |     | <span class='neutral'>// ----------------------------------------------------------------------------</span>
 4879 |     | <span class='neutral'>// The spaces that are pointed to by the following memory pointers contain</span>
 4880 |     | <span class='neutral'>// information about the accrued growth portions that are owed to the protocol</span>
 4881 |     | <span class='neutral'>// and the pool. After each swap or donate, the interval liquidity grows. A</span>
 4882 |     | <span class='neutral'>// portion of this growth goes to the protocol. A portion of the remaining</span>
 4883 |     | <span class='neutral'>// growth goes to the pool owner. These values are compactly written on</span>
 4884 |     | <span class='neutral'>// protocol&#39;s storage in which they occupy exactly one slot.</span>
 4885 |     | <span class='neutral'>uint16 constant _accruedParams_ = 1449;</span>
 4886 |     | <span class='neutral'></span>
 4887 |     | <span class='neutral'>// This 32 bytes memory space hosts the &#39;X127&#39; representation of &#39;accrued0&#39;</span>
 4888 |     | <span class='neutral'>// where</span>
 4889 |     | <span class='neutral'>//</span>
 4890 |     | <span class='neutral'>//    accrued0</span>
 4891 |     | <span class='neutral'>//  &#39;----------&#39;</span>
 4892 |     | <span class='neutral'>//    2 ** 127</span>
 4893 |     | <span class='neutral'>//</span>
 4894 |     | <span class='neutral'>// is the total unclaimed amount in &#39;tag0&#39; owed to both the protocol and the</span>
 4895 |     | <span class='neutral'>// pool owner.</span>
 4896 |     | <span class='neutral'>uint16 constant _accrued0_ = 1449;</span>
 4897 |     | <span class='neutral'></span>
 4898 |     | <span class='neutral'>// This 32 bytes memory space hosts the &#39;X127&#39; representation of &#39;accrued1&#39;</span>
 4899 |     | <span class='neutral'>// where</span>
 4900 |     | <span class='neutral'>//</span>
 4901 |     | <span class='neutral'>//    accrued1</span>
 4902 |     | <span class='neutral'>//  &#39;----------&#39;</span>
 4903 |     | <span class='neutral'>//    2 ** 127</span>
 4904 |     | <span class='neutral'>//</span>
 4905 |     | <span class='neutral'>// is the total unclaimed amount in &#39;tag1&#39; owed to both the protocol and the</span>
 4906 |     | <span class='neutral'>// pool owner.</span>
 4907 |     | <span class='neutral'>uint16 constant _accrued1_ = 1481;</span>
 4908 |     | <span class='neutral'></span>
 4909 |     | <span class='neutral'>// This 3 bytes memory space hosts the &#39;X23&#39; representation of &#39;poolRatio0&#39;</span>
 4910 |     | <span class='neutral'>// where</span>
 4911 |     | <span class='neutral'>//</span>
 4912 |     | <span class='neutral'>//    poolRatio0     accrued0</span>
 4913 |     | <span class='neutral'>//  &#39;------------ * ----------&#39;</span>
 4914 |     | <span class='neutral'>//     2 ** 23       2 ** 127</span>
 4915 |     | <span class='neutral'>//</span>
 4916 |     | <span class='neutral'>// is the accrued amount in &#39;tag0&#39; owed to the pool and</span>
 4917 |     | <span class='neutral'>//</span>
 4918 |     | <span class='neutral'>//    oneX23 - poolRatio0     accrued0</span>
 4919 |     | <span class='neutral'>//  &#39;--------------------- * ----------&#39;</span>
 4920 |     | <span class='neutral'>//          2 ** 23           2 ** 127</span>
 4921 |     | <span class='neutral'>//</span>
 4922 |     | <span class='neutral'>// is the accrued amount in &#39;tag0&#39; owed to the protocol.</span>
 4923 |     | <span class='neutral'>uint16 constant _poolRatio0_ = 1513;</span>
 4924 |     | <span class='neutral'></span>
 4925 |     | <span class='neutral'>// This 3 bytes memory space hosts the &#39;X23&#39; representation of &#39;poolRatio1&#39;</span>
 4926 |     | <span class='neutral'>// where</span>
 4927 |     | <span class='neutral'>//</span>
 4928 |     | <span class='neutral'>//    poolRatio1     accrued1</span>
 4929 |     | <span class='neutral'>//  &#39;------------ * ----------&#39;</span>
 4930 |     | <span class='neutral'>//     2 ** 23       2 ** 127</span>
 4931 |     | <span class='neutral'>//</span>
 4932 |     | <span class='neutral'>// is the accrued amount in &#39;tag1&#39; owed to the pool and</span>
 4933 |     | <span class='neutral'>//</span>
 4934 |     | <span class='neutral'>//    oneX23 - poolRatio1     accrued1</span>
 4935 |     | <span class='neutral'>//  &#39;--------------------- * ----------&#39;</span>
 4936 |     | <span class='neutral'>//          2 ** 23           2 ** 127</span>
 4937 |     | <span class='neutral'>//</span>
 4938 |     | <span class='neutral'>// is the accrued amount in &#39;tag1&#39; owed to the protocol.</span>
 4939 |     | <span class='neutral'>uint16 constant _poolRatio1_ = 1516;</span>
 4940 |     | <span class='neutral'></span>
 4941 |     | <span class='neutral'>// Pointers</span>
 4942 |     | <span class='neutral'>// ----------------------------------------------------------------------------</span>
 4943 |     | <span class='neutral'>// The following memory pointers give access to data with dynamic size.</span>
 4944 |     | <span class='neutral'>uint16 constant _pointers_ = 1519;</span>
 4945 |     | <span class='neutral'></span>
 4946 |     | <span class='neutral'>// The content of this 32 bytes memory space points to the beginning of the</span>
 4947 |     | <span class='neutral'>// kernel.</span>
 4948 |     | <span class='neutral'>// The memory space starting from &#39;getKernel()&#39; to</span>
 4949 |     | <span class='neutral'>// &#39;getKernel() + 64 * (getKernelLength() - 1)&#39; hosts the kernel breakpoints</span>
 4950 |     | <span class='neutral'>// that are loaded from the bytecode of the storage smart contract (64 bytes</span>
 4951 |     | <span class='neutral'>// for each breakpoint of the kernel function except for &#39;(b[0], c[0])&#39; which</span>
 4952 |     | <span class='neutral'>// is omitted).</span>
 4953 |     | <span class='neutral'>uint16 constant _kernel_ = 1519;</span>
 4954 |     | <span class='neutral'></span>
 4955 |     | <span class='neutral'>// The content of this 32 bytes memory space points to the beginning of the</span>
 4956 |     | <span class='neutral'>// curve sequence. The memory space starting from &#39;getCurve()&#39; to</span>
 4957 |     | <span class='neutral'>// &#39;getCurve() + 8 * getCurveLength()&#39; hosts the curve sequence which is loaded</span>
 4958 |     | <span class='neutral'>// from the protocol&#39;s storage (8 bytes for each member of the curve sequence).</span>
 4959 |     | <span class='neutral'>uint16 constant _curve_ = 1551;</span>
 4960 |     | <span class='neutral'></span>
 4961 |     | <span class='neutral'>// The content of this 32 bytes memory space points to the beginning of</span>
 4962 |     | <span class='neutral'>// &#39;hookData&#39;. The memory space starting from &#39;getHookData()&#39; to</span>
 4963 |     | <span class='neutral'>// &#39;getHookData() + getHookDataByteCount()&#39; hosts &#39;hookData&#39; which is loaded</span>
 4964 |     | <span class='neutral'>// from calldata.</span>
 4965 |     | <span class='neutral'>uint16 constant _hookData_ = 1583;</span>
 4966 |     | <span class='neutral'></span>
 4967 |     | <span class='neutral'>// This 2 bytes memory space hosts the number of breakpoints of the kernel</span>
 4968 |     | <span class='neutral'>// function which is calculated from the size of the storage smart contract.</span>
 4969 |     | <span class='neutral'>uint16 constant _kernelLength_ = 1615;</span>
 4970 |     | <span class='neutral'></span>
 4971 |     | <span class='neutral'>// This 2 bytes memory space hosts the number of members of the curve sequence.</span>
 4972 |     | <span class='neutral'>uint16 constant _curveLength_ = 1617;</span>
 4973 |     | <span class='neutral'></span>
 4974 |     | <span class='neutral'>// This 2 bytes memory space hosts the number of bytes that &#39;hookData&#39;</span>
 4975 |     | <span class='neutral'>// occupies.</span>
 4976 |     | <span class='neutral'>uint16 constant _hookDataByteCount_ = 1619;</span>
 4977 |     | <span class='neutral'></span>
 4978 |     | <span class='neutral'>// Dynamic Parameters</span>
 4979 |     | <span class='neutral'>// ----------------------------------------------------------------------------</span>
 4980 |     | <span class='neutral'>// The following memory pointers are dedicated to dynamic parameters of the</span>
 4981 |     | <span class='neutral'>// pool that may change with each swap. Dynamic parameters are stored in</span>
 4982 |     | <span class='neutral'>// protocol&#39;s storage and take a total of three slots. In the event that</span>
 4983 |     | <span class='neutral'>// &#39;staticParamsStoragePointer&#39; overflows and</span>
 4984 |     | <span class='neutral'>// &#39;staticParamsStoragePointerExtension&#39; is needed, a fourth storage slot is</span>
 4985 |     | <span class='neutral'>// populated, rendering interactions with the pool more expensive.</span>
 4986 |     | <span class='neutral'>uint16 constant _dynamicParams_ = 1621;</span>
 4987 |     | <span class='neutral'></span>
 4988 |     | <span class='neutral'>// The content of this 32 bytes memory space is referred to as</span>
 4989 |     | <span class='neutral'>// &#39;staticParamsStoragePointerExtension&#39; which is closely related to</span>
 4990 |     | <span class='neutral'>// &#39;staticParamsStoragePointer&#39;.</span>
 4991 |     | <span class='neutral'>//</span>
 4992 |     | <span class='neutral'>// If &#39;staticParamsStoragePointer &lt; type(uint16).max&#39;, then</span>
 4993 |     | <span class='neutral'>// &#39;staticParamsStoragePointerExtension&#39; is not written on protocol&#39;s storage</span>
 4994 |     | <span class='neutral'>// and we have:</span>
 4995 |     | <span class='neutral'>//</span>
 4996 |     | <span class='neutral'>//  &#39;staticParamsStoragePointerExtension == staticParamsStoragePointer&#39;</span>
 4997 |     | <span class='neutral'>//</span>
 4998 |     | <span class='neutral'>// If &#39;staticParamsStoragePointer == type(uint16).max&#39;, then</span>
 4999 |     | <span class='neutral'>// &#39;staticParamsStoragePointerExtension&#39; populates a dedicated storage slot</span>
 5000 |     | <span class='neutral'>// whose content can be used to derive the address of the storage smart</span>
 5001 |     | <span class='neutral'>// contract that contains the static parameters and the kernel.</span>
 5002 |     | <span class='neutral'>uint16 constant _staticParamsStoragePointerExtension_ = 1621;</span>
 5003 |     | <span class='neutral'></span>
 5004 |     | <span class='neutral'>// The content of this 2 bytes memory space is used to retrieve the address of</span>
 5005 |     | <span class='neutral'>// the smart contract which holds the pool&#39;s static parameters and the kernel</span>
 5006 |     | <span class='neutral'>// in its bytecode. This value is incremented every time that any of the static</span>
 5007 |     | <span class='neutral'>// parameters are updated or when the kernel is modified. In the event of</span>
 5008 |     | <span class='neutral'>// overflow, this value is set to &#39;type(uint16).max&#39; and the 32 bytes space</span>
 5009 |     | <span class='neutral'>// which is pointed to by &#39;_staticParamsStoragePointerExtension_&#39; is used to</span>
 5010 |     | <span class='neutral'>// store the value from which the address to the storage smart contract is</span>
 5011 |     | <span class='neutral'>// derived.</span>
 5012 |     | <span class='neutral'>uint16 constant _staticParamsStoragePointer_ = 1653;</span>
 5013 |     | <span class='neutral'></span>
 5014 |     | <span class='neutral'>// This 8 bytes memory space hosts &#39;logPriceCurrent&#39; which is the offsetted</span>
 5015 |     | <span class='neutral'>// value of the current log price of the pool in &#39;X59&#39; representation. More</span>
 5016 |     | <span class='neutral'>// precisely,</span>
 5017 |     | <span class='neutral'>//</span>
 5018 |     | <span class='neutral'>//  &#39;logPriceCurrent := (2 ** 59) * (16 + qCurrent)&#39;</span>
 5019 |     | <span class='neutral'>//</span>
 5020 |     | <span class='neutral'>// where </span>
 5021 |     | <span class='neutral'>// </span>
 5022 |     | <span class='neutral'>//  &#39;qCurrent := log(pCurrent / pOffset)&#39;,</span>
 5023 |     | <span class='neutral'>//</span>
 5024 |     | <span class='neutral'>// and &#39;pCurrent&#39; represents the current price of the pool.</span>
 5025 |     | <span class='neutral'>//</span>
 5026 |     | <span class='neutral'>// This value is also used to determine the end of the curve sequence while</span>
 5027 |     | <span class='neutral'>// reading the curve sequence from storage. Because the curve sequence does not</span>
 5028 |     | <span class='neutral'>// have a length slot, but its last member is equal to &#39;logPriceCurrent&#39;.</span>
 5029 |     | <span class='neutral'>uint16 constant _logPriceCurrent_ = 1655;</span>
 5030 |     | <span class='neutral'></span>
 5031 |     | <span class='neutral'>// The total number of shares that are deposited in the current active</span>
 5032 |     | <span class='neutral'>// liquidity interval across all LPs.</span>
 5033 |     | <span class='neutral'>//</span>
 5034 |     | <span class='neutral'>// We keep track of the total share values in all of the liquidity intervals</span>
 5035 |     | <span class='neutral'>// via the mapping &#39;sharesDelta&#39; within protocol&#39;s storage. Let &#39;qBoundary&#39;</span>
 5036 |     | <span class='neutral'>// denote an arbitrary boundary for a liquidity interval, i.e.,</span>
 5037 |     | <span class='neutral'>//</span>
 5038 |     | <span class='neutral'>//  &#39;qBoundary == qLower + j * qSpacing&#39;</span>
 5039 |     | <span class='neutral'>//</span>
 5040 |     | <span class='neutral'>// for some integer &#39;j&#39;. Let &#39;sharesTotalLeft&#39; and &#39;sharesTotalRight&#39; denote</span>
 5041 |     | <span class='neutral'>// the total number of shares within the intervals</span>
 5042 |     | <span class='neutral'>//</span>
 5043 |     | <span class='neutral'>//  &#39;[qBoundary - qSpacing, qBoundary]&#39; and</span>
 5044 |     | <span class='neutral'>//  &#39;[qBoundary, qBoundary + qSpacing]&#39;,</span>
 5045 |     | <span class='neutral'>//</span>
 5046 |     | <span class='neutral'>// respectively. Define:</span>
 5047 |     | <span class='neutral'>//</span>
 5048 |     | <span class='neutral'>//  &#39;sharesDelta[qBoundary] := sharesTotalRight - sharesTotalLeft&#39;.</span>
 5049 |     | <span class='neutral'>//</span>
 5050 |     | <span class='neutral'>// In other words, &#39;sharesDelta[qBoundary]&#39; is defined as the difference</span>
 5051 |     | <span class='neutral'>// between the total number of shares within the two liquidity intervals that</span>
 5052 |     | <span class='neutral'>// contain &#39;qBoundary&#39;.</span>
 5053 |     | <span class='neutral'>uint16 constant _sharesTotal_ = 1663;</span>
 5054 |     | <span class='neutral'></span>
 5055 |     | <span class='neutral'>// With each visit to a liquidity interval or as a result of donations, the</span>
 5056 |     | <span class='neutral'>// amount of liquidity which is allocated to a single LP share increases. We</span>
 5057 |     | <span class='neutral'>// use the parameter &#39;growth&#39; to keep track of liquidity per share for the</span>
 5058 |     | <span class='neutral'>// active interval. &#39;growth&#39; is stored in &#39;X111&#39; format and we always have</span>
 5059 |     | <span class='neutral'>// &#39;oneX111 &lt;= growth &lt;= maxGrowth == 1 &lt;&lt; 127&#39;.</span>
 5060 |     | <span class='neutral'>//</span>
 5061 |     | <span class='neutral'>// Let &#39;pLower&#39; and &#39;pUpper&#39;, respectively, denote the minimum and maximum</span>
 5062 |     | <span class='neutral'>// price in the current active liquidity interval and define</span>
 5063 |     | <span class='neutral'>//</span>
 5064 |     | <span class='neutral'>//  &#39;qLower := log(pLower / pOffset)&#39;,</span>
 5065 |     | <span class='neutral'>//  &#39;qUpper := log(pUpper / pOffset)&#39;.</span>
 5066 |     | <span class='neutral'>//</span>
 5067 |     | <span class='neutral'>// Growth values across inactive intervals are kept track of using the mapping</span>
 5068 |     | <span class='neutral'>// &#39;growthMultiplier&#39; as explained below.</span>
 5069 |     | <span class='neutral'>//</span>
 5070 |     | <span class='neutral'>// For every integer &#39;m &gt;= 1&#39;, let </span>
 5071 |     | <span class='neutral'>// </span>
 5072 |     | <span class='neutral'>//    sqrtInverseOffset     growthMultiplier[qLower + m * qSpacing]</span>
 5073 |     | <span class='neutral'>//  &#39;------------------- * -----------------------------------------&#39;</span>
 5074 |     | <span class='neutral'>//        2 ** 127                         2 ** 208</span>
 5075 |     | <span class='neutral'>//</span>
 5076 |     | <span class='neutral'>// represent the total amount of &#39;tag0&#39; corresponding to a single liquidity</span>
 5077 |     | <span class='neutral'>// provider&#39;s share from &#39;qLower + m * qSpacing&#39; to &#39;+oo&#39; and let</span>
 5078 |     | <span class='neutral'>//</span>
 5079 |     | <span class='neutral'>//    sqrtOffset     growthMultiplier[qUpper - m * qSpacing]</span>
 5080 |     | <span class='neutral'>//  &#39;------------ * -----------------------------------------&#39;</span>
 5081 |     | <span class='neutral'>//     2 ** 127                     2 ** 208</span>
 5082 |     | <span class='neutral'>//</span>
 5083 |     | <span class='neutral'>// represent the total amount of &#39;tag1&#39; corresponding to a single liquidity</span>
 5084 |     | <span class='neutral'>// provider&#39;s share from &#39;-oo&#39; to &#39;qLower&#39;.</span>
 5085 |     | <span class='neutral'>//</span>
 5086 |     | <span class='neutral'>// For every integer &#39;m&#39;, let &#39;growth(m)&#39; denote the &#39;growth&#39; value for the</span>
 5087 |     | <span class='neutral'>// interval</span>
 5088 |     | <span class='neutral'>//</span>
 5089 |     | <span class='neutral'>//  &#39;[qLower + m * qSpacing, qUpper + m * qSpacing]&#39;.</span>
 5090 |     | <span class='neutral'>//</span>
 5091 |     | <span class='neutral'>// Hence, &#39;growth(0)&#39; corresponds to &#39;[qLower, qUpper]&#39; which is stored in</span>
 5092 |     | <span class='neutral'>// the following memory space.</span>
 5093 |     | <span class='neutral'>//</span>
 5094 |     | <span class='neutral'>// According to the above definitions, for every integer &#39;m &gt;= 1&#39;, we have</span>
 5095 |     | <span class='neutral'>//</span>
 5096 |     | <span class='neutral'>//    growthMultiplier[qLower + m * qSpacing]</span>
 5097 |     | <span class='neutral'>//  &#39;----------------------------------------- := </span>
 5098 |     | <span class='neutral'>//                    2 ** 208</span>
 5099 |     | <span class='neutral'>//   ---- +oo</span>
 5100 |     | <span class='neutral'>//   \            growth(+j)      (- qLower - j * qSpacing) / 2</span>
 5101 |     | <span class='neutral'>//   /           ------------ * e                               &#39;.</span>
 5102 |     | <span class='neutral'>//   ---- j = m    2 ** 111</span>
 5103 |     | <span class='neutral'>//</span>
 5104 |     | <span class='neutral'>// and</span>
 5105 |     | <span class='neutral'>//</span>
 5106 |     | <span class='neutral'>//    growthMultiplier[qUpper - m * qSpacing]</span>
 5107 |     | <span class='neutral'>//  &#39;----------------------------------------- := </span>
 5108 |     | <span class='neutral'>//                    2 ** 208</span>
 5109 |     | <span class='neutral'>//   ---- +oo</span>
 5110 |     | <span class='neutral'>//   \            growth(-j)      (+ qUpper - j * qSpacing) / 2</span>
 5111 |     | <span class='neutral'>//   /           ------------ * e                               &#39;.</span>
 5112 |     | <span class='neutral'>//   ---- j = m    2 ** 111</span>
 5113 |     | <span class='neutral'>//</span>
 5114 |     | <span class='neutral'>// The following illustration further elaborates the notion of &#39;growth&#39; and</span>
 5115 |     | <span class='neutral'>// &#39;growthMultiplier&#39;:</span>
 5116 |     | <span class='neutral'>//</span>
 5117 |     | <span class='neutral'>//                                         growthMultiplier[qUpper + qSpacing]</span>
 5118 |     | <span class='neutral'>//                                                                    |--&gt;</span>
 5119 |     | <span class='neutral'>//       growthMultiplier[qLower - qSpacing]                          |</span>
 5120 |     | <span class='neutral'>//           &lt;--|                                                     |</span>
 5121 |     | <span class='neutral'>//              |                        growthMultiplier[qUpper]     |</span>
 5122 |     | <span class='neutral'>//              |                                   |--&gt;              |</span>
 5123 |     | <span class='neutral'>//              |      growthMultiplier[qLower]     |                 |</span>
 5124 |     | <span class='neutral'>//              |              &lt;--|                 |                 |</span>
 5125 |     | <span class='neutral'>//              |                 |     growth      |                 |</span>
 5126 |     | <span class='neutral'>//              |                 |       ==        |                 |</span>
 5127 |     | <span class='neutral'>//              |    growth(-1)   |    growth(0)    |    growth(+1)   |</span>
 5128 |     | <span class='neutral'>//       ... &lt;--+-----------------+-----------------+-----------------+--&gt; ...</span>
 5129 |     | <span class='neutral'>//                                |                 |</span>
 5130 |     | <span class='neutral'>//                              qLower           qUpper</span>
 5131 |     | <span class='neutral'>//</span>
 5132 |     | <span class='neutral'>// In the above figure, &#39;growthMultiplier[qUpper]&#39; and</span>
 5133 |     | <span class='neutral'>// &#39;growthMultiplier[qUpper + qSpacing]&#39; point towards &#39;+oo&#39; as well as every</span>
 5134 |     | <span class='neutral'>// growthMultiplier[qLower + m * qSpacing] for positive integers &#39;m&#39;.</span>
 5135 |     | <span class='neutral'>//</span>
 5136 |     | <span class='neutral'>// On the contrary, &#39;growthMultiplier[qLower]&#39; and</span>
 5137 |     | <span class='neutral'>// &#39;growthMultiplier[qLower - qSpacing]&#39; point towards &#39;-oo&#39; as well as every</span>
 5138 |     | <span class='neutral'>// growthMultiplier[qUpper - m * qSpacing] for positive integers &#39;m&#39;.</span>
 5139 |     | <span class='neutral'>uint16 constant _growth_ = 1679;</span>
 5140 |     | <span class='neutral'></span>
 5141 |     | <span class='neutral'>// Let &#39;pCurrent&#39; and &#39;pUpper&#39; represent the current price and the maximum</span>
 5142 |     | <span class='neutral'>// price of the active liquidity interval, respectively, and define:</span>
 5143 |     | <span class='neutral'>//</span>
 5144 |     | <span class='neutral'>// &#39;qCurrent := log(pCurrent / pOffset)&#39;,</span>
 5145 |     | <span class='neutral'>// &#39;qUpper := log(pUpper / pOffset)&#39;.</span>
 5146 |     | <span class='neutral'>//</span>
 5147 |     | <span class='neutral'>// The memory space which is pointed to by &#39;_integral0_&#39; hosts the following</span>
 5148 |     | <span class='neutral'>// integral in &#39;X216&#39; representation which takes up to 27 bytes:</span>
 5149 |     | <span class='neutral'>//</span>
 5150 |     | <span class='neutral'>//                     - 8     / qUpper</span>
 5151 |     | <span class='neutral'>//    integral0      e        |    - h / 2</span>
 5152 |     | <span class='neutral'>//  &#39;----------- := ------- * |  e         k(w(h)) dh&#39;.</span>
 5153 |     | <span class='neutral'>//    2 ** 216         2      |</span>
 5154 |     | <span class='neutral'>//                           / qCurrent</span>
 5155 |     | <span class='neutral'>//</span>
 5156 |     | <span class='neutral'>// The total reserve of &#39;tag0&#39; in the active liquidity interval can be derived</span>
 5157 |     | <span class='neutral'>// from the following formula:</span>
 5158 |     | <span class='neutral'>//</span>
 5159 |     | <span class='neutral'>//  &#39;totalReserveOfTag0 == sqrtInverseOffset * sharesTotal *</span>
 5160 |     | <span class='neutral'>//</span>
 5161 |     | <span class='neutral'>//                           growth       integral0</span>
 5162 |     | <span class='neutral'>//                         ---------- * -------------</span>
 5163 |     | <span class='neutral'>//                          2 ** 111     outgoingMax</span>
 5164 |     | <span class='neutral'>//</span>
 5165 |     | <span class='neutral'>uint16 constant _integral0_ = 1695;</span>
 5166 |     | <span class='neutral'></span>
 5167 |     | <span class='neutral'>// Let &#39;pCurrent&#39; and &#39;pLower&#39; represent the current price and the minimum</span>
 5168 |     | <span class='neutral'>// price of the active liquidity interval, respectively, and define:</span>
 5169 |     | <span class='neutral'>//</span>
 5170 |     | <span class='neutral'>// &#39;qCurrent := log(pCurrent / pOffset)&#39;,</span>
 5171 |     | <span class='neutral'>// &#39;qLower := log(pLower / pOffset)&#39;.</span>
 5172 |     | <span class='neutral'>//</span>
 5173 |     | <span class='neutral'>// The memory space which is pointed to by &#39;_integral1_&#39; hosts the following</span>
 5174 |     | <span class='neutral'>// integral in &#39;X216&#39; representation which takes up to 27 bytes:</span>
 5175 |     | <span class='neutral'>//</span>
 5176 |     | <span class='neutral'>//                     - 8     / qCurrent</span>
 5177 |     | <span class='neutral'>//    integral1      e        |    + h / 2</span>
 5178 |     | <span class='neutral'>//  &#39;----------- := ------- * |  e         k(w(h)) dh&#39;.</span>
 5179 |     | <span class='neutral'>//    2 ** 216         2      |</span>
 5180 |     | <span class='neutral'>//                           / qLower</span>
 5181 |     | <span class='neutral'>//</span>
 5182 |     | <span class='neutral'>// The total reserve of &#39;tag1&#39; in the active liquidity interval can be derived</span>
 5183 |     | <span class='neutral'>// from the following formula:</span>
 5184 |     | <span class='neutral'>//</span>
 5185 |     | <span class='neutral'>//  &#39;totalReserveOfTag1 == sqrtOffset * sharesTotal *</span>
 5186 |     | <span class='neutral'>//</span>
 5187 |     | <span class='neutral'>//                           growth       integral1</span>
 5188 |     | <span class='neutral'>//                         ---------- * -------------</span>
 5189 |     | <span class='neutral'>//                          2 ** 111     outgoingMax</span>
 5190 |     | <span class='neutral'>//</span>
 5191 |     | <span class='neutral'>uint16 constant _integral1_ = 1722;</span>
 5192 |     | <span class='neutral'></span>
 5193 |     | <span class='neutral'>// For every pool, the static parameters and the kernel are encoded in the</span>
 5194 |     | <span class='neutral'>// source code of a storage smart contract which is deployed using a disposable</span>
 5195 |     | <span class='neutral'>// proxy contract. When deploying a new storage smart contract, its creation</span>
 5196 |     | <span class='neutral'>// code is stored in this 11 bytes memory space with static parameters and</span>
 5197 |     | <span class='neutral'>// kernel appearing immediately after. This way, a chunk of memory can be sent</span>
 5198 |     | <span class='neutral'>// to the proxy in order to deploy the storage smart contract.</span>
 5199 |     | <span class='neutral'>uint16 constant _deploymentCreationCode_ = 1749;</span>
 5200 |     | <span class='neutral'></span>
 5201 |     | <span class='neutral'>// Static Parameters</span>
 5202 |     | <span class='neutral'>// ----------------------------------------------------------------------------</span>
 5203 |     | <span class='neutral'>// The following memory pointers are dedicated to the static parameters of the</span>
 5204 |     | <span class='neutral'>// pool that do not change as frequently as dynamic parameters. They are stored</span>
 5205 |     | <span class='neutral'>// along with the kernel. Hence, everytime the kernel or any of the growth</span>
 5206 |     | <span class='neutral'>// portions are updated, the entire storage smart contract is redeployed.</span>
 5207 |     | <span class='neutral'>uint16 constant _staticParams_ = 1760;</span>
 5208 |     | <span class='neutral'></span>
 5209 |     | <span class='neutral'>// The arithmetically smaller tag to be traded by the pool. This value is</span>
 5210 |     | <span class='neutral'>// immutable. A tag may refer to native, ERC-20, ERC-6909, or ERC-1155 tokens</span>
 5211 |     | <span class='neutral'>// as described in &#39;Tag.sol&#39;.</span>
 5212 |     | <span class='neutral'>uint16 constant _tag0_ = 1760;</span>
 5213 |     | <span class='neutral'></span>
 5214 |     | <span class='neutral'>// The arithmetically larger tag to be traded by the pool. This value is</span>
 5215 |     | <span class='neutral'>// immutable.</span>
 5216 |     | <span class='neutral'>uint16 constant _tag1_ = 1792;</span>
 5217 |     | <span class='neutral'></span>
 5218 |     | <span class='neutral'>// This memory space hosts the value:</span>
 5219 |     | <span class='neutral'>//</span>
 5220 |     | <span class='neutral'>// &#39;sqrtOffset := (2 ** 127) * sqrt(pOffset)&#39;</span>
 5221 |     | <span class='neutral'>//</span>
 5222 |     | <span class='neutral'>// where the natural logarithm of &#39;pOffset&#39; is an &#39;int8&#39; which is encoded from</span>
 5223 |     | <span class='neutral'>// bit 181 to bit 188 of poolId.</span>
 5224 |     | <span class='neutral'>uint16 constant _sqrtOffset_ = 1824;</span>
 5225 |     | <span class='neutral'></span>
 5226 |     | <span class='neutral'>// This memory space hosts the value:</span>
 5227 |     | <span class='neutral'>//</span>
 5228 |     | <span class='neutral'>// &#39;sqrtInverseOffset := (2 ** 127) / sqrt(pOffset)&#39;</span>
 5229 |     | <span class='neutral'>//</span>
 5230 |     | <span class='neutral'>// where the natural logarithm of &#39;pOffset&#39; is an &#39;int8&#39; which is encoded from</span>
 5231 |     | <span class='neutral'>// bit 181 to bit 188 of poolId.</span>
 5232 |     | <span class='neutral'>uint16 constant _sqrtInverseOffset_ = 1856;</span>
 5233 |     | <span class='neutral'></span>
 5234 |     | <span class='neutral'>// Let &#39;pLower&#39; and &#39;pUpper&#39; denote the minimum and maximum price in the active</span>
 5235 |     | <span class='neutral'>// liquidity interval, respectively, and define</span>
 5236 |     | <span class='neutral'>//</span>
 5237 |     | <span class='neutral'>//  &#39;qSpacing := log(pUpper / pLower)&#39;,</span>
 5238 |     | <span class='neutral'>//</span>
 5239 |     | <span class='neutral'>// The 62 bytes memory space which is pointed to by &#39;_spacing_&#39; hosts the</span>
 5240 |     | <span class='neutral'>// following values:</span>
 5241 |     | <span class='neutral'>//</span>
 5242 |     | <span class='neutral'>//  &#39;_spacing_.log() := (2 ** 59) * (16 + qSpacing)&#39;,</span>
 5243 |     | <span class='neutral'>//  &#39;_spacing_.sqrt(false) := (2 ** 216) * exp(- qSpacing / 2)&#39;,</span>
 5244 |     | <span class='neutral'>//  &#39;_spacing_.sqrt(true) := (2 ** 216) * exp(- 16 + qSpacing / 2)&#39;.</span>
 5245 |     | <span class='neutral'>//</span>
 5246 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The logarithmic price</span>
 5247 |     | <span class='neutral'>// &#39;_spacing_.log()&#39; occupies 64 bits, whereas &#39;_spacing_.sqrt(false)&#39; and</span>
 5248 |     | <span class='neutral'>// &#39;_spacing_.sqrt(true)&#39; occupy 216 bits each.</span>
 5249 |     | <span class='neutral'>uint16 constant _spacing_ = 1888;</span>
 5250 |     | <span class='neutral'></span>
 5251 |     | <span class='neutral'>// Let &#39;pLower&#39; and &#39;pUpper&#39; denote the minimum and maximum price in the active</span>
 5252 |     | <span class='neutral'>// liquidity interval, respectively, and define</span>
 5253 |     | <span class='neutral'>//</span>
 5254 |     | <span class='neutral'>//  &#39;qUpper := log(pUpper / pOffset)&#39;,</span>
 5255 |     | <span class='neutral'>//  &#39;qLower := log(pLower / pOffset)&#39;,</span>
 5256 |     | <span class='neutral'>//  &#39;qSpacing := log(pUpper / pLower)&#39;.</span>
 5257 |     | <span class='neutral'>//</span>
 5258 |     | <span class='neutral'>// This 27 bytes memory space hosts &#39;outgoingMax&#39; which is a kernel parameter.</span>
 5259 |     | <span class='neutral'>// The &#39;X216&#39; representation of &#39;outgoingMax&#39; is defined as follows:</span>
 5260 |     | <span class='neutral'>//</span>
 5261 |     | <span class='neutral'>//                       - 8     / qSpacing</span>
 5262 |     | <span class='neutral'>//    outgoingMax      e        |    - h / 2</span>
 5263 |     | <span class='neutral'>//  &#39;------------- := ------- * |  e         k(h) dh&#39;.</span>
 5264 |     | <span class='neutral'>//     2 ** 216          2      |</span>
 5265 |     | <span class='neutral'>//                             / 0</span>
 5266 |     | <span class='neutral'>//</span>
 5267 |     | <span class='neutral'>// &#39;outgoingMax&#39; is used frequently for calculating any amount of &#39;tag0&#39; and</span>
 5268 |     | <span class='neutral'>// &#39;tag1&#39;. Because of this, we calculate &#39;outgoingMax&#39; and its modular inverse</span>
 5269 |     | <span class='neutral'>// at the time of initialization or anytime that the kernel is modified and</span>
 5270 |     | <span class='neutral'>// then we store the resulting values among the static parameters.</span>
 5271 |     | <span class='neutral'>//</span>
 5272 |     | <span class='neutral'>// &#39;outgoingMax&#39; can be calculated with the following two equivalent formulas</span>
 5273 |     | <span class='neutral'>// as well:</span>
 5274 |     | <span class='neutral'>//</span>
 5275 |     | <span class='neutral'>//                       - 8 + qLower / 2     / qUpper</span>
 5276 |     | <span class='neutral'>//    outgoingMax      e                     |    - h / 2</span>
 5277 |     | <span class='neutral'>//  &#39;------------- := -------------------- * |  e         k(h - qLower) dh</span>
 5278 |     | <span class='neutral'>//     2 ** 216                 2            |</span>
 5279 |     | <span class='neutral'>//                                          / qLower</span>
 5280 |     | <span class='neutral'>//</span>
 5281 |     | <span class='neutral'>//                       - 8 - qUpper / 2     / qUpper</span>
 5282 |     | <span class='neutral'>//                     e                     |    + h / 2</span>
 5283 |     | <span class='neutral'>//                    -------------------- * |  e         k(qUpper - h) dh&#39;.</span>
 5284 |     | <span class='neutral'>//                              2            |</span>
 5285 |     | <span class='neutral'>//                                          / qLower</span>
 5286 |     | <span class='neutral'>//</span>
 5287 |     | <span class='neutral'>// Notice that the above formulas are independent of the choice for &#39;qLower&#39;</span>
 5288 |     | <span class='neutral'>// and &#39;qUpper&#39;, and they result in the same value as long as </span>
 5289 |     | <span class='neutral'>// &#39;qUpper - qLower == qSpacing&#39;.</span>
 5290 |     | <span class='neutral'>uint16 constant _outgoingMax_ = 1950;</span>
 5291 |     | <span class='neutral'></span>
 5292 |     | <span class='neutral'>// This 32 bytes memory space hosts &#39;outgoingMaxModularInverse&#39; which is the</span>
 5293 |     | <span class='neutral'>// modular inverse of</span>
 5294 |     | <span class='neutral'>//</span>
 5295 |     | <span class='neutral'>//    outgoingMax </span>
 5296 |     | <span class='neutral'>//  &#39;-------------&#39;</span>
 5297 |     | <span class='neutral'>//      2 ** n</span>
 5298 |     | <span class='neutral'>//</span>
 5299 |     | <span class='neutral'>// modulo &#39;2 ** 256&#39;, where &#39;n&#39; is the largest power of &#39;2&#39; that divides</span>
 5300 |     | <span class='neutral'>// &#39;outgoingMax&#39;. This value is calculated at the time of initialization or</span>
 5301 |     | <span class='neutral'>// anytime that the kernel function is modified.</span>
 5302 |     | <span class='neutral'>//</span>
 5303 |     | <span class='neutral'>// Precalculation of &#39;outgoingMaxModularInverse&#39; facilitates division by</span>
 5304 |     | <span class='neutral'>// &#39;outgoingMax&#39; which is done frequently.</span>
 5305 |     | <span class='neutral'>uint16 constant _outgoingMaxModularInverse_ = 1977;</span>
 5306 |     | <span class='neutral'></span>
 5307 |     | <span class='neutral'>// Let &#39;pLower&#39; and &#39;pUpper&#39; denote the minimum and maximum price in the active</span>
 5308 |     | <span class='neutral'>// liquidity interval, respectively, and define</span>
 5309 |     | <span class='neutral'>//</span>
 5310 |     | <span class='neutral'>//  &#39;qUpper := log(pUpper / pOffset)&#39;,</span>
 5311 |     | <span class='neutral'>//  &#39;qLower := log(pLower / pOffset)&#39;,</span>
 5312 |     | <span class='neutral'>//  &#39;qSpacing := log(pUpper / pLower)&#39;.</span>
 5313 |     | <span class='neutral'>//</span>
 5314 |     | <span class='neutral'>// This 27 bytes memory space hosts &#39;outgoingMax&#39; which is a kernel parameter.</span>
 5315 |     | <span class='neutral'>// The &#39;X216&#39; representation of &#39;outgoingMax&#39; is defined as follows:</span>
 5316 |     | <span class='neutral'>//</span>
 5317 |     | <span class='neutral'>//                       - 8 - qSpacing / 2     / qSpacing</span>
 5318 |     | <span class='neutral'>//    incomingMax      e                       |    + h / 2</span>
 5319 |     | <span class='neutral'>//  &#39;------------- := ---------------------- * |  e         k(h) dh&#39;.</span>
 5320 |     | <span class='neutral'>//     2 ** 216                 2              |</span>
 5321 |     | <span class='neutral'>//                                            / 0</span>
 5322 |     | <span class='neutral'>//</span>
 5323 |     | <span class='neutral'>// &#39;incomingMax&#39; is used for calculating the incoming amount as we cross an</span>
 5324 |     | <span class='neutral'>// entire liquidity interval from &#39;qBack&#39; to &#39;qNext&#39;. Because of this, we</span>
 5325 |     | <span class='neutral'>// calculate &#39;incomingMax&#39; at the time of initialization or anytime that the</span>
 5326 |     | <span class='neutral'>// kernel is modified and then we store the resulting value among the static</span>
 5327 |     | <span class='neutral'>// parameters.</span>
 5328 |     | <span class='neutral'>//</span>
 5329 |     | <span class='neutral'>// &#39;incomingMax&#39; can be calculated with the following two equivalent formulas</span>
 5330 |     | <span class='neutral'>// as well:</span>
 5331 |     | <span class='neutral'>//</span>
 5332 |     | <span class='neutral'>//                       - 8 - qUpper / 2     / qUpper</span>
 5333 |     | <span class='neutral'>//    incomingMax      e                     |    + h / 2</span>
 5334 |     | <span class='neutral'>//  &#39;------------- := -------------------- * |  e         k(h - qLower) dh</span>
 5335 |     | <span class='neutral'>//     2 ** 216                 2            |</span>
 5336 |     | <span class='neutral'>//                                          / qLower</span>
 5337 |     | <span class='neutral'>//</span>
 5338 |     | <span class='neutral'>//                       - 8 + qLower / 2     / qUpper</span>
 5339 |     | <span class='neutral'>//                     e                     |    - h / 2</span>
 5340 |     | <span class='neutral'>//                    -------------------- * |  e         k(qUpper - h) dh&#39;.</span>
 5341 |     | <span class='neutral'>//                              2            |</span>
 5342 |     | <span class='neutral'>//                                          / qLower</span>
 5343 |     | <span class='neutral'>//</span>
 5344 |     | <span class='neutral'>// Notice that the above formulas are independent of the choice for &#39;qLower&#39;</span>
 5345 |     | <span class='neutral'>// and &#39;qUpper&#39;, and they result in the same value as long as </span>
 5346 |     | <span class='neutral'>// &#39;qUpper - qLower == qSpacing&#39;.</span>
 5347 |     | <span class='neutral'>uint16 constant _incomingMax_ = 2009;</span>
 5348 |     | <span class='neutral'></span>
 5349 |     | <span class='neutral'>// The content of the 6 bytes memory space which is pointed to by</span>
 5350 |     | <span class='neutral'>// &#39;_poolGrowthPortion_&#39; dictates the portion of the growth that goes to the</span>
 5351 |     | <span class='neutral'>// pool owner followed by the protocol.</span>
 5352 |     | <span class='neutral'>//</span>
 5353 |     | <span class='neutral'>// The content of the 6 bytes memory space which is pointed to by</span>
 5354 |     | <span class='neutral'>// &#39;_maxPoolGrowthPortion_&#39; imposes a cap on the portion of the marginal growth</span>
 5355 |     | <span class='neutral'>// that goes to the pool owner followed by the protocol.</span>
 5356 |     | <span class='neutral'>//</span>
 5357 |     | <span class='neutral'>// The content of the 6 bytes memory space which is pointed to by</span>
 5358 |     | <span class='neutral'>// &#39;_protocolGrowthPortion_&#39; dictates the portion of the growth that goes to</span>
 5359 |     | <span class='neutral'>// the protocol.</span>
 5360 |     | <span class='neutral'>//</span>
 5361 |     | <span class='neutral'>// &#39;maxPoolGrowthPortion&#39; and &#39;protocolGrowthPortion&#39; are set by the protocol</span>
 5362 |     | <span class='neutral'>// slot or the sentinel contract. Any address can invoke a function to sync</span>
 5363 |     | <span class='neutral'>// these two values with the global portions.</span>
 5364 |     | <span class='neutral'>//</span>
 5365 |     | <span class='neutral'>// This value is set by the protocol slot or the sentinel contract.</span>
 5366 |     | <span class='neutral'>// Any address can invoke a function to sync this value with the global</span>
 5367 |     | <span class='neutral'>// portion.</span>
 5368 |     | <span class='neutral'>//</span>
 5369 |     | <span class='neutral'>// Let &#39;[qLower, qUpper]&#39; represent the active liquidity interval. As part of a</span>
 5370 |     | <span class='neutral'>// swap, assume that the price is moved from &#39;qCurrent&#39; to &#39;qTarget&#39; within</span>
 5371 |     | <span class='neutral'>// &#39;[qLower, qUpper]&#39;. Define:</span>
 5372 |     | <span class='neutral'>//</span>
 5373 |     | <span class='neutral'>//                                - 8     / qUpper</span>
 5374 |     | <span class='neutral'>//    integral0Incremented      e        |    - h / 2</span>
 5375 |     | <span class='neutral'>//  &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;,</span>
 5376 |     | <span class='neutral'>//          2 ** 216              2      |</span>
 5377 |     | <span class='neutral'>//                                      / qTarget</span>
 5378 |     | <span class='neutral'>//</span>
 5379 |     | <span class='neutral'>//                                - 8     / qTarget</span>
 5380 |     | <span class='neutral'>//    integral1Incremented      e        |    + h / 2</span>
 5381 |     | <span class='neutral'>//  &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;.</span>
 5382 |     | <span class='neutral'>//          2 ** 216              2      |</span>
 5383 |     | <span class='neutral'>//                                      / qLower</span>
 5384 |     | <span class='neutral'>//</span>
 5385 |     | <span class='neutral'>// Now, assume that the curve sequence is updated and the function &#39;w&#39; is</span>
 5386 |     | <span class='neutral'>// transformed into a new function &#39;wAmended&#39; which is constructed based on the</span>
 5387 |     | <span class='neutral'>// updated curve sequence. Define:</span>
 5388 |     | <span class='neutral'>//</span>
 5389 |     | <span class='neutral'>//                            - 8     / qUpper</span>
 5390 |     | <span class='neutral'>//    integral0Amended      e        |    - h / 2</span>
 5391 |     | <span class='neutral'>//  &#39;------------------ := ------- * |  e         k(wAmended(h)) dh&#39;,</span>
 5392 |     | <span class='neutral'>//        2 ** 216            2      |</span>
 5393 |     | <span class='neutral'>//                                  / qTarget</span>
 5394 |     | <span class='neutral'>//</span>
 5395 |     | <span class='neutral'>//                            - 8     / qTarget</span>
 5396 |     | <span class='neutral'>//    integral1Amended      e        |    + h / 2</span>
 5397 |     | <span class='neutral'>//  &#39;------------------ := ------- * |  e         k(wAmended(h)) dh&#39;.</span>
 5398 |     | <span class='neutral'>//        2 ** 216            2      |</span>
 5399 |     | <span class='neutral'>//                                  / qLower</span>
 5400 |     | <span class='neutral'>//</span>
 5401 |     | <span class='neutral'>// Then we have:</span>
 5402 |     | <span class='neutral'>//                              integral0Incremented</span>
 5403 |     | <span class='neutral'>//  &#39;growthAmended := growth * ----------------------</span>
 5404 |     | <span class='neutral'>//                                integral0Amended</span>
 5405 |     | <span class='neutral'>//</span>
 5406 |     | <span class='neutral'>//                              integral1Incremented</span>
 5407 |     | <span class='neutral'>//                 == growth * ----------------------&#39;.</span>
 5408 |     | <span class='neutral'>//                                integral1Amended</span>
 5409 |     | <span class='neutral'>//</span>
 5410 |     | <span class='neutral'>// Now, the marginal growth with respect to &#39;tag0&#39; and &#39;tag1&#39; can be defined</span>
 5411 |     | <span class='neutral'>// as:</span>
 5412 |     | <span class='neutral'>//</span>
 5413 |     | <span class='neutral'>//  &#39;marginalGrowthOfTag0 := sqrtInverseOffset * sharesTotal * </span>
 5414 |     | <span class='neutral'>//</span>
 5415 |     | <span class='neutral'>//                            growthAmended - growth     integral0Amended</span>
 5416 |     | <span class='neutral'>//                           ------------------------ * ------------------&#39;,</span>
 5417 |     | <span class='neutral'>//                                    2 ** 111             outgoingMax</span>
 5418 |     | <span class='neutral'>//</span>
 5419 |     | <span class='neutral'>//  &#39;marginalGrowthOfTag1 := sqrtOffset * sharesTotal * </span>
 5420 |     | <span class='neutral'>//</span>
 5421 |     | <span class='neutral'>//                            growthAmended - growth     integral1Amended</span>
 5422 |     | <span class='neutral'>//                           ------------------------ * ------------------&#39;.</span>
 5423 |     | <span class='neutral'>//                                    2 ** 111             outgoingMax</span>
 5424 |     | <span class='neutral'>//</span>
 5425 |     | <span class='neutral'>// Hence, as a result of this swap, the amount of &#39;tag0&#39; that goes to the</span>
 5426 |     | <span class='neutral'>// protocol is equal to:</span>
 5427 |     | <span class='neutral'>//</span>
 5428 |     | <span class='neutral'>//    protocolGrowthPortion</span>
 5429 |     | <span class='neutral'>//  &#39;----------------------- * marginalGrowthOfTag0&#39;</span>
 5430 |     | <span class='neutral'>//           2 ** 47</span>
 5431 |     | <span class='neutral'>//</span>
 5432 |     | <span class='neutral'>// and the amount of &#39;tag1&#39; that goes to the protocol is equal to:</span>
 5433 |     | <span class='neutral'>//</span>
 5434 |     | <span class='neutral'>//    protocolGrowthPortion</span>
 5435 |     | <span class='neutral'>//  &#39;----------------------- * marginalGrowthOfTag1&#39;</span>
 5436 |     | <span class='neutral'>//           2 ** 47</span>
 5437 |     | <span class='neutral'>//</span>
 5438 |     | <span class='neutral'>// Additionally, the amount of &#39;tag0&#39; that goes to the pool owner is equal to:</span>
 5439 |     | <span class='neutral'>//</span>
 5440 |     | <span class='neutral'>//    min(poolGrowthPortion, maxPoolGrowthPortion)</span>
 5441 |     | <span class='neutral'>//  &#39;---------------------------------------------- * </span>
 5442 |     | <span class='neutral'>//                      2 ** 47</span>
 5443 |     | <span class='neutral'>//</span>
 5444 |     | <span class='neutral'>//    oneX47 - protocolGrowthPortion</span>
 5445 |     | <span class='neutral'>//   -------------------------------- * marginalGrowthOfTag0&#39;</span>
 5446 |     | <span class='neutral'>//               2 ** 47</span>
 5447 |     | <span class='neutral'>//</span>
 5448 |     | <span class='neutral'>// and the amount of &#39;tag1&#39; that goes to the pool owner is equal to:</span>
 5449 |     | <span class='neutral'>//</span>
 5450 |     | <span class='neutral'>//    min(poolGrowthPortion, maxPoolGrowthPortion)</span>
 5451 |     | <span class='neutral'>//  &#39;---------------------------------------------- * </span>
 5452 |     | <span class='neutral'>//                      2 ** 47</span>
 5453 |     | <span class='neutral'>//</span>
 5454 |     | <span class='neutral'>//    oneX47 - protocolGrowthPortion</span>
 5455 |     | <span class='neutral'>//   -------------------------------- * marginalGrowthOfTag1&#39;</span>
 5456 |     | <span class='neutral'>//               2 ** 47</span>
 5457 |     | <span class='neutral'>//</span>
 5458 |     | <span class='neutral'>uint16 constant _poolGrowthPortion_ = 2036;</span>
 5459 |     | <span class='neutral'>uint16 constant _maxPoolGrowthPortion_ = 2042;</span>
 5460 |     | <span class='neutral'>uint16 constant _protocolGrowthPortion_ = 2048;</span>
 5461 |     | <span class='neutral'></span>
 5462 |     | <span class='neutral'>// The number of members for the pending kernel. Once a new kernel is</span>
 5463 |     | <span class='neutral'>// introduced, it remains pending until transition to a new liquidity interval.</span>
 5464 |     | <span class='neutral'>// This value is an indicator for whether there exists a pending kernel.</span>
 5465 |     | <span class='neutral'>// This value is used to ensure that a sufficient amount of space is reserved</span>
 5466 |     | <span class='neutral'>// in memory for kernel, in case the pending kernel needs to be activated in</span>
 5467 |     | <span class='neutral'>// the middle of a swap, i.e., read from the new storage smart contract.</span>
 5468 |     | <span class='neutral'>uint16 constant _pendingKernelLength_ = 2054;</span>
 5469 |     | <span class='neutral'></span>
 5470 |     | <span class='neutral'>uint16 constant _endOfStaticParams_ = 2056;</span>
 5471 |     | <span class='neutral'></span>
 5472 |     | <span class='neutral'>// Modify Position Parameters</span>
 5473 |     | <span class='neutral'>// ----------------------------------------------------------------------------</span>
 5474 |     | <span class='neutral'>// The following memory pointers host the inputs and the resulting outputs of</span>
 5475 |     | <span class='neutral'>// the method &#39;modifyPosition&#39;. An LP may choose any consecutive range of</span>
 5476 |     | <span class='neutral'>// liquidity intervals to deposit their liquidity. By doing so, the LP acquires</span>
 5477 |     | <span class='neutral'>// a number of shares in every liquidity interval that belongs to the given</span>
 5478 |     | <span class='neutral'>// range. The shares can be used later to withdraw liquidity along with any</span>
 5479 |     | <span class='neutral'>// accumulated growth which is accrued as a result of swap and donate actions.</span>
 5480 |     | <span class='neutral'>uint16 constant _modifyPositionInput_ = 248;</span>
 5481 |     | <span class='neutral'></span>
 5482 |     | <span class='neutral'>// Every LP position is characterized by two prices &#39;pMin&#39; and &#39;pMax&#39;. These</span>
 5483 |     | <span class='neutral'>// two prices, respectively, correspond to the left and the right boundaries of</span>
 5484 |     | <span class='neutral'>// the consecutive range in which the LP intends to deposit or withdraw</span>
 5485 |     | <span class='neutral'>// liquidity. The following two 8 bytes memory spaces, respectively, host:</span>
 5486 |     | <span class='neutral'>//</span>
 5487 |     | <span class='neutral'>//  &#39;(2 ** 59) * (16 + log(pMin / pOffset))&#39;,</span>
 5488 |     | <span class='neutral'>//  &#39;(2 ** 59) * (16 + log(pMax / pOffset))&#39;.</span>
 5489 |     | <span class='neutral'>uint16 constant _logPriceMinOffsetted_ = 248;</span>
 5490 |     | <span class='neutral'>uint16 constant _logPriceMaxOffsetted_ = 256;</span>
 5491 |     | <span class='neutral'></span>
 5492 |     | <span class='neutral'>// This 32 bytes memory space hosts the number of shares to be added (positive)</span>
 5493 |     | <span class='neutral'>// or removed (negative).</span>
 5494 |     | <span class='neutral'>uint16 constant _shares_ = 264;</span>
 5495 |     | <span class='neutral'></span>
 5496 |     | <span class='neutral'>// The following two 32 bytes memory spaces, respectively, host:</span>
 5497 |     | <span class='neutral'>//</span>
 5498 |     | <span class='neutral'>//  &#39;logPriceMin := (2 ** 59) * log(pMin)&#39;,</span>
 5499 |     | <span class='neutral'>//  &#39;logPriceMax := (2 ** 59) * log(pMax)&#39;.</span>
 5500 |     | <span class='neutral'>//</span>
 5501 |     | <span class='neutral'>// Both &#39;logPriceMin&#39; and &#39;logPriceMax&#39; must be equal to the active interval</span>
 5502 |     | <span class='neutral'>// boundaries modulo &#39;qSpacing&#39;.</span>
 5503 |     | <span class='neutral'>uint16 constant _logPriceMin_ = 296;</span>
 5504 |     | <span class='neutral'>uint16 constant _logPriceMax_ = 328;</span>
 5505 |     | <span class='neutral'></span>
 5506 |     | <span class='neutral'>// The amount of &#39;tag0&#39; to be added (positive) or removed (negative) in &#39;X127&#39;</span>
 5507 |     | <span class='neutral'>// representation, as a result of modifyPosition.</span>
 5508 |     | <span class='neutral'>uint16 constant _positionAmount0_ = 360;</span>
 5509 |     | <span class='neutral'>// The amount of &#39;tag1&#39; to be added (positive) or removed (negative) in &#39;X127&#39;</span>
 5510 |     | <span class='neutral'>// representation, as a result of modifyPosition.</span>
 5511 |     | <span class='neutral'>uint16 constant _positionAmount1_ = 392;</span>
 5512 |     | <span class='neutral'></span>
 5513 |     | <span class='neutral'>uint16 constant _endOfModifyPosition_ = 424;</span>
 5514 |     | <span class='neutral'></span>
 5515 |     | <span class='neutral'>////////////////////////////////////////////////////////////////////////////////</span>
 5516 |     | <span class='neutral'>// The remainder of this script contains automatically generated getter and</span>
 5517 |     | <span class='neutral'>// setter functions for the parameters introduced above.</span>
 5518 |     | <span class='neutral'></span>
 5519 |     | <span class='neutral'>function getFreeMemoryPointer() pure returns (</span>
 5520 |     | <span class='neutral'>  uint256 freeMemoryPointer</span>
 5521 |     | <span class='neutral'>) {</span>
 5522 |     | <span class='neutral'>  assembly {</span>
 5523 |     | <span class='neutral'>    freeMemoryPointer := mload(_freeMemoryPointer_)</span>
 5524 |     | <span class='neutral'>  }</span>
 5525 |     | <span class='neutral'>}</span>
 5526 |     | <span class='neutral'></span>
 5527 |     | <span class='unexecuted'>function setFreeMemoryPointer(</span>
 5528 |     | <span class='neutral'>  uint256 freeMemoryPointer</span>
 5529 |     | <span class='neutral'>) pure {</span>
 5530 |     | <span class='neutral'>  assembly {</span>
 5531 |     | <span class='unexecuted'>    mstore(_freeMemoryPointer_, freeMemoryPointer)</span>
 5532 |     | <span class='neutral'>  }</span>
 5533 |     | <span class='neutral'>}</span>
 5534 |     | <span class='neutral'></span>
 5535 |     | <span class='neutral'>function setHookSelector(</span>
 5536 |     | <span class='neutral'>  uint32 hookSelector</span>
 5537 |     | <span class='neutral'>) pure {</span>
 5538 |     | <span class='neutral'>  assembly {</span>
 5539 |     | <span class='neutral'>    mstore(</span>
 5540 |     | <span class='neutral'>      _hookSelector_,</span>
 5541 |     | <span class='neutral'>      or(</span>
 5542 |     | <span class='neutral'>        shl(224, hookSelector),</span>
 5543 |     | <span class='neutral'>        shr(32, mload(add(_hookSelector_, 4)))</span>
 5544 |     | <span class='neutral'>      )</span>
 5545 |     | <span class='neutral'>    )</span>
 5546 |     | <span class='neutral'>  }</span>
 5547 |     | <span class='neutral'>}</span>
 5548 |     | <span class='neutral'></span>
 5549 |     | <span class='neutral'>function setHookInputHeader(</span>
 5550 |     | <span class='neutral'>  uint256 hookInputHeader</span>
 5551 |     | <span class='neutral'>) pure {</span>
 5552 |     | <span class='neutral'>  assembly {</span>
 5553 |     | <span class='neutral'>    mstore(_hookInputHeader_, hookInputHeader)</span>
 5554 |     | <span class='neutral'>  }</span>
 5555 |     | <span class='neutral'>}</span>
 5556 |     | <span class='neutral'></span>
 5557 |     | <span class='neutral'>function getHookInputByteCount() pure returns (</span>
 5558 |     | <span class='neutral'>  uint256 hookInputByteCount</span>
 5559 |     | <span class='neutral'>) {</span>
 5560 |     | <span class='neutral'>  assembly {</span>
 5561 |     | <span class='neutral'>    hookInputByteCount := mload(_hookInputByteCount_)</span>
 5562 |     | <span class='neutral'>  }</span>
 5563 |     | <span class='neutral'>}</span>
 5564 |     | <span class='neutral'></span>
 5565 |     | <span class='neutral'>function setHookInputByteCount(</span>
 5566 |     | <span class='neutral'>  uint256 hookInputByteCount</span>
 5567 |     | <span class='neutral'>) pure {</span>
 5568 |     | <span class='neutral'>  assembly {</span>
 5569 |     | <span class='neutral'>    mstore(_hookInputByteCount_, hookInputByteCount)</span>
 5570 |     | <span class='neutral'>  }</span>
 5571 |     | <span class='neutral'>}</span>
 5572 |     | <span class='neutral'></span>
 5573 |     | <span class='neutral'>function setMsgSender(</span>
 5574 |     | <span class='neutral'>  address msgSender</span>
 5575 |     | <span class='neutral'>) pure {</span>
 5576 |     | <span class='neutral'>  assembly {</span>
 5577 |     | <span class='neutral'>    mstore(</span>
 5578 |     | <span class='neutral'>      _msgSender_,</span>
 5579 |     | <span class='neutral'>      or(</span>
 5580 |     | <span class='neutral'>        shl(96, msgSender),</span>
 5581 |     | <span class='neutral'>        shr(160, mload(add(_msgSender_, 20)))</span>
 5582 |     | <span class='neutral'>      )</span>
 5583 |     | <span class='neutral'>    )</span>
 5584 |     | <span class='neutral'>  }</span>
 5585 |     | <span class='neutral'>}</span>
 5586 |     | <span class='neutral'></span>
 5587 |     | <span class='neutral'>function getPoolId() pure returns (</span>
 5588 |     | <span class='neutral'>  uint256 poolId</span>
 5589 |     | <span class='neutral'>) {</span>
 5590 |     | <span class='neutral'>  assembly {</span>
 5591 |     | <span class='neutral'>    poolId := mload(_poolId_)</span>
 5592 |     | <span class='neutral'>  }</span>
 5593 |     | <span class='neutral'>}</span>
 5594 |     | <span class='neutral'></span>
 5595 |     | <span class='neutral'>function setPoolId(</span>
 5596 |     | <span class='neutral'>  uint256 poolId</span>
 5597 |     | <span class='neutral'>) pure {</span>
 5598 |     | <span class='neutral'>  assembly {</span>
 5599 |     | <span class='neutral'>    mstore(_poolId_, poolId)</span>
 5600 |     | <span class='neutral'>  }</span>
 5601 |     | <span class='neutral'>}</span>
 5602 |     | <span class='neutral'></span>
 5603 |     | <span class='neutral'>function getCrossThreshold() pure returns (</span>
 5604 |     | <span class='neutral'>  uint256 crossThreshold</span>
 5605 |     | <span class='neutral'>) {</span>
 5606 |     | <span class='neutral'>  assembly {</span>
 5607 |     | <span class='neutral'>    crossThreshold := shr(128, mload(_crossThreshold_))</span>
 5608 |     | <span class='neutral'>  }</span>
 5609 |     | <span class='neutral'>}</span>
 5610 |     | <span class='neutral'></span>
 5611 |     | <span class='neutral'>function setCrossThreshold(</span>
 5612 |     | <span class='neutral'>  uint256 crossThreshold</span>
 5613 |     | <span class='neutral'>) pure {</span>
 5614 |     | <span class='neutral'>  assembly {</span>
 5615 |     | <span class='neutral'>    mstore(</span>
 5616 |     | <span class='neutral'>      _crossThreshold_,</span>
 5617 |     | <span class='neutral'>      or(</span>
 5618 |     | <span class='neutral'>        shl(128, crossThreshold),</span>
 5619 |     | <span class='neutral'>        shr(128, mload(add(_crossThreshold_, 16)))</span>
 5620 |     | <span class='neutral'>      )</span>
 5621 |     | <span class='neutral'>    )</span>
 5622 |     | <span class='neutral'>  }</span>
 5623 |     | <span class='neutral'>}</span>
 5624 |     | <span class='neutral'></span>
 5625 |     | <span class='neutral'>function getAmountSpecified() pure returns (</span>
 5626 |     | <span class='neutral'>  X127 amountSpecified</span>
 5627 |     | <span class='neutral'>) {</span>
 5628 |     | <span class='neutral'>  assembly {</span>
 5629 |     | <span class='neutral'>    amountSpecified := mload(_amountSpecified_)</span>
 5630 |     | <span class='neutral'>  }</span>
 5631 |     | <span class='neutral'>}</span>
 5632 |     | <span class='neutral'></span>
 5633 |     | <span class='neutral'>function setAmountSpecified(</span>
 5634 |     | <span class='neutral'>  X127 amountSpecified</span>
 5635 |     | <span class='neutral'>) pure {</span>
 5636 |     | <span class='neutral'>  assembly {</span>
 5637 |     | <span class='neutral'>    mstore(_amountSpecified_, amountSpecified)</span>
 5638 |     | <span class='neutral'>  }</span>
 5639 |     | <span class='neutral'>}</span>
 5640 |     | <span class='neutral'></span>
 5641 |     | <span class='neutral'>function getLogPriceLimit() pure returns (</span>
 5642 |     | <span class='neutral'>  X59 logPriceLimit</span>
 5643 |     | <span class='neutral'>) {</span>
 5644 |     | <span class='neutral'>  assembly {</span>
 5645 |     | <span class='neutral'>    logPriceLimit := mload(_logPriceLimit_)</span>
 5646 |     | <span class='neutral'>  }</span>
 5647 |     | <span class='neutral'>}</span>
 5648 |     | <span class='neutral'></span>
 5649 |     | <span class='neutral'>function setLogPriceLimit(</span>
 5650 |     | <span class='neutral'>  X59 logPriceLimit</span>
 5651 |     | <span class='neutral'>) pure {</span>
 5652 |     | <span class='neutral'>  assembly {</span>
 5653 |     | <span class='neutral'>    mstore(_logPriceLimit_, logPriceLimit)</span>
 5654 |     | <span class='neutral'>  }</span>
 5655 |     | <span class='neutral'>}</span>
 5656 |     | <span class='neutral'></span>
 5657 |     | <span class='neutral'>function getLogPriceLimitOffsetted() pure returns (</span>
 5658 |     | <span class='neutral'>  X59 logPriceLimitOffsetted</span>
 5659 |     | <span class='neutral'>) {</span>
 5660 |     | <span class='neutral'>  assembly {</span>
 5661 |     | <span class='neutral'>    logPriceLimitOffsetted := shr(192, mload(_logPriceLimitOffsetted_))</span>
 5662 |     | <span class='neutral'>  }</span>
 5663 |     | <span class='neutral'>}</span>
 5664 |     | <span class='neutral'></span>
 5665 |     | <span class='neutral'>function setLogPriceLimitOffsetted(</span>
 5666 |     | <span class='neutral'>  X59 logPriceLimitOffsetted</span>
 5667 |     | <span class='neutral'>) pure {</span>
 5668 |     | <span class='neutral'>  assembly {</span>
 5669 |     | <span class='neutral'>    mstore(</span>
 5670 |     | <span class='neutral'>      _logPriceLimitOffsetted_,</span>
 5671 |     | <span class='neutral'>      or(</span>
 5672 |     | <span class='neutral'>        shl(192, logPriceLimitOffsetted),</span>
 5673 |     | <span class='neutral'>        shr(64, mload(add(_logPriceLimitOffsetted_, 8)))</span>
 5674 |     | <span class='neutral'>      )</span>
 5675 |     | <span class='neutral'>    )</span>
 5676 |     | <span class='neutral'>  }</span>
 5677 |     | <span class='neutral'>}</span>
 5678 |     | <span class='neutral'></span>
 5679 |     | <span class='neutral'>function getZeroForOne() pure returns (</span>
 5680 |     | <span class='neutral'>  bool zeroForOne</span>
 5681 |     | <span class='neutral'>) {</span>
 5682 |     | <span class='neutral'>  assembly {</span>
 5683 |     | <span class='neutral'>    zeroForOne := shr(255, mload(_zeroForOne_))</span>
 5684 |     | <span class='neutral'>  }</span>
 5685 |     | <span class='neutral'>}</span>
 5686 |     | <span class='neutral'></span>
 5687 |     | <span class='neutral'>function setZeroForOne(</span>
 5688 |     | <span class='neutral'>  bool zeroForOne</span>
 5689 |     | <span class='neutral'>) pure {</span>
 5690 |     | <span class='neutral'>  assembly {</span>
 5691 |     | <span class='neutral'>    mstore8(_zeroForOne_, mul(0xFF, zeroForOne))</span>
 5692 |     | <span class='neutral'>  }</span>
 5693 |     | <span class='neutral'>}</span>
 5694 |     | <span class='neutral'></span>
 5695 |     | <span class='neutral'>function getExactInput() pure returns (</span>
 5696 |     | <span class='neutral'>  bool exactInput</span>
 5697 |     | <span class='neutral'>) {</span>
 5698 |     | <span class='neutral'>  assembly {</span>
 5699 |     | <span class='neutral'>    exactInput := shr(255, mload(_exactInput_))</span>
 5700 |     | <span class='neutral'>  }</span>
 5701 |     | <span class='neutral'>}</span>
 5702 |     | <span class='neutral'></span>
 5703 |     | <span class='neutral'>function setExactInput(</span>
 5704 |     | <span class='neutral'>  bool exactInput</span>
 5705 |     | <span class='neutral'>) pure {</span>
 5706 |     | <span class='neutral'>  assembly {</span>
 5707 |     | <span class='neutral'>    mstore8(_exactInput_, mul(0xFF, exactInput))</span>
 5708 |     | <span class='neutral'>  }</span>
 5709 |     | <span class='neutral'>}</span>
 5710 |     | <span class='neutral'></span>
 5711 |     | <span class='neutral'>function getIntegralLimit() pure returns (</span>
 5712 |     | <span class='neutral'>  X216 integralLimit</span>
 5713 |     | <span class='neutral'>) {</span>
 5714 |     | <span class='neutral'>  assembly {</span>
 5715 |     | <span class='neutral'>    integralLimit := shr(40, mload(_integralLimit_))</span>
 5716 |     | <span class='neutral'>  }</span>
 5717 |     | <span class='neutral'>}</span>
 5718 |     | <span class='neutral'></span>
 5719 |     | <span class='neutral'>function setIntegralLimit(</span>
 5720 |     | <span class='neutral'>  X216 integralLimit</span>
 5721 |     | <span class='neutral'>) pure {</span>
 5722 |     | <span class='neutral'>  assembly {</span>
 5723 |     | <span class='neutral'>    mstore(</span>
 5724 |     | <span class='neutral'>      _integralLimit_,</span>
 5725 |     | <span class='neutral'>      or(</span>
 5726 |     | <span class='neutral'>        shl(40, integralLimit),</span>
 5727 |     | <span class='neutral'>        shr(216, mload(add(_integralLimit_, 27)))</span>
 5728 |     | <span class='neutral'>      )</span>
 5729 |     | <span class='neutral'>    )</span>
 5730 |     | <span class='neutral'>  }</span>
 5731 |     | <span class='neutral'>}</span>
 5732 |     | <span class='neutral'></span>
 5733 |     | <span class='neutral'>function getIntegralLimitInterval() pure returns (</span>
 5734 |     | <span class='neutral'>  X216 integralLimitInterval</span>
 5735 |     | <span class='neutral'>) {</span>
 5736 |     | <span class='neutral'>  assembly {</span>
 5737 |     | <span class='neutral'>    integralLimitInterval := shr(40, mload(_integralLimitInterval_))</span>
 5738 |     | <span class='neutral'>  }</span>
 5739 |     | <span class='neutral'>}</span>
 5740 |     | <span class='neutral'></span>
 5741 |     | <span class='neutral'>function setIntegralLimitInterval(</span>
 5742 |     | <span class='neutral'>  X216 integralLimitInterval</span>
 5743 |     | <span class='neutral'>) pure {</span>
 5744 |     | <span class='neutral'>  assembly {</span>
 5745 |     | <span class='neutral'>    mstore(</span>
 5746 |     | <span class='neutral'>      _integralLimitInterval_,</span>
 5747 |     | <span class='neutral'>      or(</span>
 5748 |     | <span class='neutral'>        shl(40, integralLimitInterval),</span>
 5749 |     | <span class='neutral'>        shr(216, mload(add(_integralLimitInterval_, 27)))</span>
 5750 |     | <span class='neutral'>      )</span>
 5751 |     | <span class='neutral'>    )</span>
 5752 |     | <span class='neutral'>  }</span>
 5753 |     | <span class='neutral'>}</span>
 5754 |     | <span class='neutral'></span>
 5755 |     | <span class='neutral'>function getAmount0() pure returns (</span>
 5756 |     | <span class='neutral'>  X127 amount0</span>
 5757 |     | <span class='neutral'>) {</span>
 5758 |     | <span class='neutral'>  assembly {</span>
 5759 |     | <span class='neutral'>    amount0 := mload(_amount0_)</span>
 5760 |     | <span class='neutral'>  }</span>
 5761 |     | <span class='neutral'>}</span>
 5762 |     | <span class='neutral'></span>
 5763 |     | <span class='neutral'>function setAmount0(</span>
 5764 |     | <span class='neutral'>  X127 amount0</span>
 5765 |     | <span class='neutral'>) pure {</span>
 5766 |     | <span class='neutral'>  assembly {</span>
 5767 |     | <span class='neutral'>    mstore(_amount0_, amount0)</span>
 5768 |     | <span class='neutral'>  }</span>
 5769 |     | <span class='neutral'>}</span>
 5770 |     | <span class='neutral'></span>
 5771 |     | <span class='neutral'>function getAmount1() pure returns (</span>
 5772 |     | <span class='neutral'>  X127 amount1</span>
 5773 |     | <span class='neutral'>) {</span>
 5774 |     | <span class='neutral'>  assembly {</span>
 5775 |     | <span class='neutral'>    amount1 := mload(_amount1_)</span>
 5776 |     | <span class='neutral'>  }</span>
 5777 |     | <span class='neutral'>}</span>
 5778 |     | <span class='neutral'></span>
 5779 |     | <span class='neutral'>function setAmount1(</span>
 5780 |     | <span class='neutral'>  X127 amount1</span>
 5781 |     | <span class='neutral'>) pure {</span>
 5782 |     | <span class='neutral'>  assembly {</span>
 5783 |     | <span class='neutral'>    mstore(_amount1_, amount1)</span>
 5784 |     | <span class='neutral'>  }</span>
 5785 |     | <span class='neutral'>}</span>
 5786 |     | <span class='neutral'></span>
 5787 |     | <span class='neutral'>function getBackGrowthMultiplier() pure returns (</span>
 5788 |     | <span class='neutral'>  X208 backGrowthMultiplier</span>
 5789 |     | <span class='neutral'>) {</span>
 5790 |     | <span class='neutral'>  assembly {</span>
 5791 |     | <span class='neutral'>    backGrowthMultiplier := mload(_backGrowthMultiplier_)</span>
 5792 |     | <span class='neutral'>  }</span>
 5793 |     | <span class='neutral'>}</span>
 5794 |     | <span class='neutral'></span>
 5795 |     | <span class='neutral'>function setBackGrowthMultiplier(</span>
 5796 |     | <span class='neutral'>  X208 backGrowthMultiplier</span>
 5797 |     | <span class='neutral'>) pure {</span>
 5798 |     | <span class='neutral'>  assembly {</span>
 5799 |     | <span class='neutral'>    mstore(_backGrowthMultiplier_, backGrowthMultiplier)</span>
 5800 |     | <span class='neutral'>  }</span>
 5801 |     | <span class='neutral'>}</span>
 5802 |     | <span class='neutral'></span>
 5803 |     | <span class='neutral'>function getNextGrowthMultiplier() pure returns (</span>
 5804 |     | <span class='neutral'>  X208 nextGrowthMultiplier</span>
 5805 |     | <span class='neutral'>) {</span>
 5806 |     | <span class='neutral'>  assembly {</span>
 5807 |     | <span class='neutral'>    nextGrowthMultiplier := mload(_nextGrowthMultiplier_)</span>
 5808 |     | <span class='neutral'>  }</span>
 5809 |     | <span class='neutral'>}</span>
 5810 |     | <span class='neutral'></span>
 5811 |     | <span class='neutral'>function setNextGrowthMultiplier(</span>
 5812 |     | <span class='neutral'>  X208 nextGrowthMultiplier</span>
 5813 |     | <span class='neutral'>) pure {</span>
 5814 |     | <span class='neutral'>  assembly {</span>
 5815 |     | <span class='neutral'>    mstore(_nextGrowthMultiplier_, nextGrowthMultiplier)</span>
 5816 |     | <span class='neutral'>  }</span>
 5817 |     | <span class='neutral'>}</span>
 5818 |     | <span class='neutral'></span>
 5819 |     | <span class='neutral'>function getDirection() pure returns (</span>
 5820 |     | <span class='neutral'>  bool direction</span>
 5821 |     | <span class='neutral'>) {</span>
 5822 |     | <span class='neutral'>  assembly {</span>
 5823 |     | <span class='neutral'>    direction := shr(255, mload(_direction_))</span>
 5824 |     | <span class='neutral'>  }</span>
 5825 |     | <span class='neutral'>}</span>
 5826 |     | <span class='neutral'></span>
 5827 |     | <span class='neutral'>function setDirection(</span>
 5828 |     | <span class='neutral'>  bool direction</span>
 5829 |     | <span class='neutral'>) pure {</span>
 5830 |     | <span class='neutral'>  assembly {</span>
 5831 |     | <span class='neutral'>    mstore8(_direction_, mul(0xFF, direction))</span>
 5832 |     | <span class='neutral'>  }</span>
 5833 |     | <span class='neutral'>}</span>
 5834 |     | <span class='neutral'></span>
 5835 |     | <span class='neutral'>function getIndexCurve() pure returns (</span>
 5836 |     | <span class='neutral'>  Index indexCurve</span>
 5837 |     | <span class='neutral'>) {</span>
 5838 |     | <span class='neutral'>  assembly {</span>
 5839 |     | <span class='neutral'>    indexCurve := shr(240, mload(_indexCurve_))</span>
 5840 |     | <span class='neutral'>  }</span>
 5841 |     | <span class='neutral'>}</span>
 5842 |     | <span class='neutral'></span>
 5843 |     | <span class='neutral'>function setIndexCurve(</span>
 5844 |     | <span class='neutral'>  Index indexCurve</span>
 5845 |     | <span class='neutral'>) pure {</span>
 5846 |     | <span class='neutral'>  assembly {</span>
 5847 |     | <span class='neutral'>    mstore(</span>
 5848 |     | <span class='neutral'>      _indexCurve_,</span>
 5849 |     | <span class='neutral'>      or(</span>
 5850 |     | <span class='neutral'>        shl(240, indexCurve),</span>
 5851 |     | <span class='neutral'>        shr(16, mload(add(_indexCurve_, 2)))</span>
 5852 |     | <span class='neutral'>      )</span>
 5853 |     | <span class='neutral'>    )</span>
 5854 |     | <span class='neutral'>  }</span>
 5855 |     | <span class='neutral'>}</span>
 5856 |     | <span class='neutral'></span>
 5857 |     | <span class='neutral'>function getLogPriceLimitOffsettedWithinInterval() pure returns (</span>
 5858 |     | <span class='neutral'>  X59 logPriceLimitOffsettedWithinInterval</span>
 5859 |     | <span class='neutral'>) {</span>
 5860 |     | <span class='neutral'>  assembly {</span>
 5861 |     | <span class='neutral'>    logPriceLimitOffsettedWithinInterval := </span>
 5862 |     | <span class='neutral'>      shr(192, mload(_logPriceLimitOffsettedWithinInterval_))</span>
 5863 |     | <span class='neutral'>  }</span>
 5864 |     | <span class='neutral'>}</span>
 5865 |     | <span class='neutral'></span>
 5866 |     | <span class='neutral'>function setLogPriceLimitOffsettedWithinInterval(</span>
 5867 |     | <span class='neutral'>  X59 logPriceLimitOffsettedWithinInterval</span>
 5868 |     | <span class='neutral'>) pure {</span>
 5869 |     | <span class='neutral'>  assembly {</span>
 5870 |     | <span class='neutral'>    mstore(</span>
 5871 |     | <span class='neutral'>      _logPriceLimitOffsettedWithinInterval_,</span>
 5872 |     | <span class='neutral'>      or(</span>
 5873 |     | <span class='neutral'>        shl(192, logPriceLimitOffsettedWithinInterval),</span>
 5874 |     | <span class='neutral'>        shr(64, mload(add(_logPriceLimitOffsettedWithinInterval_, 8)))</span>
 5875 |     | <span class='neutral'>      )</span>
 5876 |     | <span class='neutral'>    )</span>
 5877 |     | <span class='neutral'>  }</span>
 5878 |     | <span class='neutral'>}</span>
 5879 |     | <span class='neutral'></span>
 5880 |     | <span class='neutral'>function getAccrued0() pure returns (</span>
 5881 |     | <span class='neutral'>  X127 accrued0</span>
 5882 |     | <span class='neutral'>) {</span>
 5883 |     | <span class='neutral'>  assembly {</span>
 5884 |     | <span class='neutral'>    accrued0 := mload(_accrued0_)</span>
 5885 |     | <span class='neutral'>  }</span>
 5886 |     | <span class='neutral'>}</span>
 5887 |     | <span class='neutral'></span>
 5888 |     | <span class='neutral'>function setAccrued0(</span>
 5889 |     | <span class='neutral'>  X127 accrued0</span>
 5890 |     | <span class='neutral'>) pure {</span>
 5891 |     | <span class='neutral'>  assembly {</span>
 5892 |     | <span class='neutral'>    mstore(_accrued0_, accrued0)</span>
 5893 |     | <span class='neutral'>  }</span>
 5894 |     | <span class='neutral'>}</span>
 5895 |     | <span class='neutral'></span>
 5896 |     | <span class='neutral'>function getAccrued1() pure returns (</span>
 5897 |     | <span class='neutral'>  X127 accrued1</span>
 5898 |     | <span class='neutral'>) {</span>
 5899 |     | <span class='neutral'>  assembly {</span>
 5900 |     | <span class='neutral'>    accrued1 := mload(_accrued1_)</span>
 5901 |     | <span class='neutral'>  }</span>
 5902 |     | <span class='neutral'>}</span>
 5903 |     | <span class='neutral'></span>
 5904 |     | <span class='neutral'>function setAccrued1(</span>
 5905 |     | <span class='neutral'>  X127 accrued1</span>
 5906 |     | <span class='neutral'>) pure {</span>
 5907 |     | <span class='neutral'>  assembly {</span>
 5908 |     | <span class='neutral'>    mstore(_accrued1_, accrued1)</span>
 5909 |     | <span class='neutral'>  }</span>
 5910 |     | <span class='neutral'>}</span>
 5911 |     | <span class='neutral'></span>
 5912 |     | <span class='neutral'>function getPoolRatio0() pure returns (</span>
 5913 |     | <span class='neutral'>  X23 poolRatio0</span>
 5914 |     | <span class='neutral'>) {</span>
 5915 |     | <span class='neutral'>  assembly {</span>
 5916 |     | <span class='neutral'>    poolRatio0 := shr(232, mload(_poolRatio0_))</span>
 5917 |     | <span class='neutral'>  }</span>
 5918 |     | <span class='neutral'>}</span>
 5919 |     | <span class='neutral'></span>
 5920 |     | <span class='neutral'>function setPoolRatio0(</span>
 5921 |     | <span class='neutral'>  X23 poolRatio0</span>
 5922 |     | <span class='neutral'>) pure {</span>
 5923 |     | <span class='neutral'>  assembly {</span>
 5924 |     | <span class='neutral'>    mstore(</span>
 5925 |     | <span class='neutral'>      _poolRatio0_,</span>
 5926 |     | <span class='neutral'>      or(</span>
 5927 |     | <span class='neutral'>        shl(232, poolRatio0),</span>
 5928 |     | <span class='neutral'>        shr(24, mload(add(_poolRatio0_, 3)))</span>
 5929 |     | <span class='neutral'>      )</span>
 5930 |     | <span class='neutral'>    )</span>
 5931 |     | <span class='neutral'>  }</span>
 5932 |     | <span class='neutral'>}</span>
 5933 |     | <span class='neutral'></span>
 5934 |     | <span class='neutral'>function getPoolRatio1() pure returns (</span>
 5935 |     | <span class='neutral'>  X23 poolRatio1</span>
 5936 |     | <span class='neutral'>) {</span>
 5937 |     | <span class='neutral'>  assembly {</span>
 5938 |     | <span class='neutral'>    poolRatio1 := shr(232, mload(_poolRatio1_))</span>
 5939 |     | <span class='neutral'>  }</span>
 5940 |     | <span class='neutral'>}</span>
 5941 |     | <span class='neutral'></span>
 5942 |     | <span class='neutral'>function setPoolRatio1(</span>
 5943 |     | <span class='neutral'>  X23 poolRatio1</span>
 5944 |     | <span class='neutral'>) pure {</span>
 5945 |     | <span class='neutral'>  assembly {</span>
 5946 |     | <span class='neutral'>    mstore(</span>
 5947 |     | <span class='neutral'>      _poolRatio1_,</span>
 5948 |     | <span class='neutral'>      or(</span>
 5949 |     | <span class='neutral'>        shl(232, poolRatio1),</span>
 5950 |     | <span class='neutral'>        shr(24, mload(add(_poolRatio1_, 3)))</span>
 5951 |     | <span class='neutral'>      )</span>
 5952 |     | <span class='neutral'>    )</span>
 5953 |     | <span class='neutral'>  }</span>
 5954 |     | <span class='neutral'>}</span>
 5955 |     | <span class='neutral'></span>
 5956 |     | <span class='unexecuted'>function getKernel() pure returns (</span>
 5957 |     | <span class='unexecuted'>  Kernel kernel</span>
 5958 |     | <span class='neutral'>) {</span>
 5959 |     | <span class='neutral'>  assembly {</span>
 5960 |     | <span class='unexecuted'>    kernel := mload(_kernel_)</span>
 5961 |     | <span class='neutral'>  }</span>
 5962 |     | <span class='neutral'>}</span>
 5963 |     | <span class='neutral'></span>
 5964 |     | <span class='unexecuted'>function setKernel(</span>
 5965 |     | <span class='neutral'>  Kernel kernel</span>
 5966 |     | <span class='neutral'>) pure {</span>
 5967 |     | <span class='neutral'>  assembly {</span>
 5968 |     | <span class='unexecuted'>    mstore(_kernel_, kernel)</span>
 5969 |     | <span class='neutral'>  }</span>
 5970 |     | <span class='neutral'>}</span>
 5971 |     | <span class='neutral'></span>
 5972 |     | <span class='unexecuted'>function getCurve() pure returns (</span>
 5973 |     | <span class='unexecuted'>  Curve curve</span>
 5974 |     | <span class='neutral'>) {</span>
 5975 |     | <span class='neutral'>  assembly {</span>
 5976 |     | <span class='unexecuted'>    curve := mload(_curve_)</span>
 5977 |     | <span class='neutral'>  }</span>
 5978 |     | <span class='neutral'>}</span>
 5979 |     | <span class='neutral'></span>
 5980 |     | <span class='unexecuted'>function setCurve(</span>
 5981 |     | <span class='neutral'>  Curve curve</span>
 5982 |     | <span class='neutral'>) pure {</span>
 5983 |     | <span class='neutral'>  assembly {</span>
 5984 |     | <span class='unexecuted'>    mstore(_curve_, curve)</span>
 5985 |     | <span class='neutral'>  }</span>
 5986 |     | <span class='neutral'>}</span>
 5987 |     | <span class='neutral'></span>
 5988 |     | <span class='neutral'>function getHookData() pure returns (</span>
 5989 |     | <span class='neutral'>  uint256 hookData</span>
 5990 |     | <span class='neutral'>) {</span>
 5991 |     | <span class='neutral'>  assembly {</span>
 5992 |     | <span class='neutral'>    hookData := mload(_hookData_)</span>
 5993 |     | <span class='neutral'>  }</span>
 5994 |     | <span class='neutral'>}</span>
 5995 |     | <span class='neutral'></span>
 5996 |     | <span class='neutral'>function setHookData(</span>
 5997 |     | <span class='neutral'>  uint256 hookData</span>
 5998 |     | <span class='neutral'>) pure {</span>
 5999 |     | <span class='neutral'>  assembly {</span>
 6000 |     | <span class='neutral'>    mstore(_hookData_, hookData)</span>
 6001 |     | <span class='neutral'>  }</span>
 6002 |     | <span class='neutral'>}</span>
 6003 |     | <span class='neutral'></span>
 6004 |     | <span class='unexecuted'>function getKernelLength() pure returns (</span>
 6005 |     | <span class='unexecuted'>  Index kernelLength</span>
 6006 |     | <span class='neutral'>) {</span>
 6007 |     | <span class='neutral'>  assembly {</span>
 6008 |     | <span class='unexecuted'>    kernelLength := shr(240, mload(_kernelLength_))</span>
 6009 |     | <span class='neutral'>  }</span>
 6010 |     | <span class='neutral'>}</span>
 6011 |     | <span class='neutral'></span>
 6012 |     | <span class='unexecuted'>function setKernelLength(</span>
 6013 |     | <span class='neutral'>  Index kernelLength</span>
 6014 |     | <span class='neutral'>) pure {</span>
 6015 |     | <span class='neutral'>  assembly {</span>
 6016 |     | <span class='unexecuted'>    mstore(</span>
 6017 |     | <span class='unexecuted'>      _kernelLength_,</span>
 6018 |     | <span class='unexecuted'>      or(</span>
 6019 |     | <span class='unexecuted'>        shl(240, kernelLength),</span>
 6020 |     | <span class='unexecuted'>        shr(16, mload(add(_kernelLength_, 2)))</span>
 6021 |     | <span class='neutral'>      )</span>
 6022 |     | <span class='neutral'>    )</span>
 6023 |     | <span class='neutral'>  }</span>
 6024 |     | <span class='neutral'>}</span>
 6025 |     | <span class='neutral'></span>
 6026 |     | <span class='unexecuted'>function getCurveLength() pure returns (</span>
 6027 |     | <span class='unexecuted'>  Index curveLength</span>
 6028 |     | <span class='neutral'>) {</span>
 6029 |     | <span class='neutral'>  assembly {</span>
 6030 |     | <span class='unexecuted'>    curveLength := shr(240, mload(_curveLength_))</span>
 6031 |     | <span class='neutral'>  }</span>
 6032 |     | <span class='neutral'>}</span>
 6033 |     | <span class='neutral'></span>
 6034 |     | <span class='unexecuted'>function setCurveLength(</span>
 6035 |     | <span class='neutral'>  Index curveLength</span>
 6036 |     | <span class='neutral'>) pure {</span>
 6037 |     | <span class='neutral'>  assembly {</span>
 6038 |     | <span class='unexecuted'>    mstore(</span>
 6039 |     | <span class='unexecuted'>      _curveLength_,</span>
 6040 |     | <span class='unexecuted'>      or(</span>
 6041 |     | <span class='unexecuted'>        shl(240, curveLength),</span>
 6042 |     | <span class='unexecuted'>        shr(16, mload(add(_curveLength_, 2)))</span>
 6043 |     | <span class='neutral'>      )</span>
 6044 |     | <span class='neutral'>    )</span>
 6045 |     | <span class='neutral'>  }</span>
 6046 |     | <span class='neutral'>}</span>
 6047 |     | <span class='neutral'></span>
 6048 |     | <span class='neutral'>function getHookDataByteCount() pure returns (</span>
 6049 |     | <span class='neutral'>  uint16 hookDataByteCount</span>
 6050 |     | <span class='neutral'>) {</span>
 6051 |     | <span class='neutral'>  assembly {</span>
 6052 |     | <span class='neutral'>    hookDataByteCount := shr(240, mload(_hookDataByteCount_))</span>
 6053 |     | <span class='neutral'>  }</span>
 6054 |     | <span class='neutral'>}</span>
 6055 |     | <span class='neutral'></span>
 6056 |     | <span class='neutral'>function setHookDataByteCount(</span>
 6057 |     | <span class='neutral'>  uint16 hookDataByteCount</span>
 6058 |     | <span class='neutral'>) pure {</span>
 6059 |     | <span class='neutral'>  assembly {</span>
 6060 |     | <span class='neutral'>    mstore(</span>
 6061 |     | <span class='neutral'>      _hookDataByteCount_,</span>
 6062 |     | <span class='neutral'>      or(</span>
 6063 |     | <span class='neutral'>        shl(240, hookDataByteCount),</span>
 6064 |     | <span class='neutral'>        shr(16, mload(add(_hookDataByteCount_, 2)))</span>
 6065 |     | <span class='neutral'>      )</span>
 6066 |     | <span class='neutral'>    )</span>
 6067 |     | <span class='neutral'>  }</span>
 6068 |     | <span class='neutral'>}</span>
 6069 |     | <span class='neutral'></span>
 6070 |     | <span class='neutral'>function getStaticParamsStoragePointerExtension() pure returns (</span>
 6071 |     | <span class='neutral'>  uint256 staticParamsStoragePointerExtension</span>
 6072 |     | <span class='neutral'>) {</span>
 6073 |     | <span class='neutral'>  assembly {</span>
 6074 |     | <span class='neutral'>    staticParamsStoragePointerExtension := </span>
 6075 |     | <span class='neutral'>      mload(_staticParamsStoragePointerExtension_)</span>
 6076 |     | <span class='neutral'>  }</span>
 6077 |     | <span class='neutral'>}</span>
 6078 |     | <span class='neutral'></span>
 6079 |     | <span class='neutral'>function setStaticParamsStoragePointerExtension(</span>
 6080 |     | <span class='neutral'>  uint256 staticParamsStoragePointerExtension</span>
 6081 |     | <span class='neutral'>) pure {</span>
 6082 |     | <span class='neutral'>  assembly {</span>
 6083 |     | <span class='neutral'>    mstore(</span>
 6084 |     | <span class='neutral'>      _staticParamsStoragePointerExtension_,</span>
 6085 |     | <span class='neutral'>      staticParamsStoragePointerExtension</span>
 6086 |     | <span class='neutral'>    )</span>
 6087 |     | <span class='neutral'>  }</span>
 6088 |     | <span class='neutral'>}</span>
 6089 |     | <span class='neutral'></span>
 6090 |     | <span class='neutral'>function getGrowth() pure returns (</span>
 6091 |     | <span class='neutral'>  X111 growth</span>
 6092 |     | <span class='neutral'>) {</span>
 6093 |     | <span class='neutral'>  assembly {</span>
 6094 |     | <span class='neutral'>    growth := shr(128, mload(_growth_))</span>
 6095 |     | <span class='neutral'>  }</span>
 6096 |     | <span class='neutral'>}</span>
 6097 |     | <span class='neutral'></span>
 6098 |     | <span class='neutral'>function setGrowth(</span>
 6099 |     | <span class='neutral'>  X111 growth</span>
 6100 |     | <span class='neutral'>) pure {</span>
 6101 |     | <span class='neutral'>  assembly {</span>
 6102 |     | <span class='neutral'>    mstore(</span>
 6103 |     | <span class='neutral'>      _growth_,</span>
 6104 |     | <span class='neutral'>      or(</span>
 6105 |     | <span class='neutral'>        shl(128, growth),</span>
 6106 |     | <span class='neutral'>        shr(128, mload(add(_growth_, 16)))</span>
 6107 |     | <span class='neutral'>      )</span>
 6108 |     | <span class='neutral'>    )</span>
 6109 |     | <span class='neutral'>  }</span>
 6110 |     | <span class='neutral'>}</span>
 6111 |     | <span class='neutral'></span>
 6112 |     | <span class='neutral'>function getIntegral0() pure returns (</span>
 6113 |     | <span class='neutral'>  X216 integral0</span>
 6114 |     | <span class='neutral'>) {</span>
 6115 |     | <span class='neutral'>  assembly {</span>
 6116 |     | <span class='neutral'>    integral0 := shr(40, mload(_integral0_))</span>
 6117 |     | <span class='neutral'>  }</span>
 6118 |     | <span class='neutral'>}</span>
 6119 |     | <span class='neutral'></span>
 6120 |     | <span class='neutral'>function setIntegral0(</span>
 6121 |     | <span class='neutral'>  X216 integral0</span>
 6122 |     | <span class='neutral'>) pure {</span>
 6123 |     | <span class='neutral'>  assembly {</span>
 6124 |     | <span class='neutral'>    mstore(</span>
 6125 |     | <span class='neutral'>      _integral0_,</span>
 6126 |     | <span class='neutral'>      or(</span>
 6127 |     | <span class='neutral'>        shl(40, integral0),</span>
 6128 |     | <span class='neutral'>        shr(216, mload(add(_integral0_, 27)))</span>
 6129 |     | <span class='neutral'>      )</span>
 6130 |     | <span class='neutral'>    )</span>
 6131 |     | <span class='neutral'>  }</span>
 6132 |     | <span class='neutral'>}</span>
 6133 |     | <span class='neutral'></span>
 6134 |     | <span class='neutral'>function getIntegral1() pure returns (</span>
 6135 |     | <span class='neutral'>  X216 integral1</span>
 6136 |     | <span class='neutral'>) {</span>
 6137 |     | <span class='neutral'>  assembly {</span>
 6138 |     | <span class='neutral'>    integral1 := shr(40, mload(_integral1_))</span>
 6139 |     | <span class='neutral'>  }</span>
 6140 |     | <span class='neutral'>}</span>
 6141 |     | <span class='neutral'></span>
 6142 |     | <span class='neutral'>function setIntegral1(</span>
 6143 |     | <span class='neutral'>  X216 integral1</span>
 6144 |     | <span class='neutral'>) pure {</span>
 6145 |     | <span class='neutral'>  assembly {</span>
 6146 |     | <span class='neutral'>    mstore(</span>
 6147 |     | <span class='neutral'>      _integral1_,</span>
 6148 |     | <span class='neutral'>      or(</span>
 6149 |     | <span class='neutral'>        shl(40, integral1),</span>
 6150 |     | <span class='neutral'>        shr(216, mload(add(_integral1_, 27)))</span>
 6151 |     | <span class='neutral'>      )</span>
 6152 |     | <span class='neutral'>    )</span>
 6153 |     | <span class='neutral'>  }</span>
 6154 |     | <span class='neutral'>}</span>
 6155 |     | <span class='neutral'></span>
 6156 |     | <span class='neutral'>function getSharesTotal() pure returns (</span>
 6157 |     | <span class='neutral'>  uint256 sharesTotal</span>
 6158 |     | <span class='neutral'>) {</span>
 6159 |     | <span class='neutral'>  assembly {</span>
 6160 |     | <span class='neutral'>    sharesTotal := shr(128, mload(_sharesTotal_))</span>
 6161 |     | <span class='neutral'>  }</span>
 6162 |     | <span class='neutral'>}</span>
 6163 |     | <span class='neutral'></span>
 6164 |     | <span class='neutral'>function setSharesTotal(</span>
 6165 |     | <span class='neutral'>  uint256 sharesTotal</span>
 6166 |     | <span class='neutral'>) pure {</span>
 6167 |     | <span class='neutral'>  assembly {</span>
 6168 |     | <span class='neutral'>    mstore(</span>
 6169 |     | <span class='neutral'>      _sharesTotal_,</span>
 6170 |     | <span class='neutral'>      or(</span>
 6171 |     | <span class='neutral'>        shl(128, sharesTotal),</span>
 6172 |     | <span class='neutral'>        shr(128, mload(add(_sharesTotal_, 16)))</span>
 6173 |     | <span class='neutral'>      )</span>
 6174 |     | <span class='neutral'>    )</span>
 6175 |     | <span class='neutral'>  }</span>
 6176 |     | <span class='neutral'>}</span>
 6177 |     | <span class='neutral'></span>
 6178 |     | <span class='neutral'>function getStaticParamsStoragePointer() pure returns (</span>
 6179 |     | <span class='neutral'>  uint16 staticParamsStoragePointer</span>
 6180 |     | <span class='neutral'>) {</span>
 6181 |     | <span class='neutral'>  assembly {</span>
 6182 |     | <span class='neutral'>    staticParamsStoragePointer := shr(240, mload(_staticParamsStoragePointer_))</span>
 6183 |     | <span class='neutral'>  }</span>
 6184 |     | <span class='neutral'>}</span>
 6185 |     | <span class='neutral'></span>
 6186 |     | <span class='neutral'>function setStaticParamsStoragePointer(</span>
 6187 |     | <span class='neutral'>  uint16 staticParamsStoragePointer</span>
 6188 |     | <span class='neutral'>) pure {</span>
 6189 |     | <span class='neutral'>  assembly {</span>
 6190 |     | <span class='neutral'>    mstore(</span>
 6191 |     | <span class='neutral'>      _staticParamsStoragePointer_,</span>
 6192 |     | <span class='neutral'>      or(</span>
 6193 |     | <span class='neutral'>        shl(240, staticParamsStoragePointer),</span>
 6194 |     | <span class='neutral'>        shr(16, mload(add(_staticParamsStoragePointer_, 2)))</span>
 6195 |     | <span class='neutral'>      )</span>
 6196 |     | <span class='neutral'>    )</span>
 6197 |     | <span class='neutral'>  }</span>
 6198 |     | <span class='neutral'>}</span>
 6199 |     | <span class='neutral'></span>
 6200 |     | <span class='neutral'>function getLogPriceCurrent() pure returns (</span>
 6201 |     | <span class='neutral'>  X59 logPriceCurrent</span>
 6202 |     | <span class='neutral'>) {</span>
 6203 |     | <span class='neutral'>  assembly {</span>
 6204 |     | <span class='neutral'>    logPriceCurrent := shr(192, mload(_logPriceCurrent_))</span>
 6205 |     | <span class='neutral'>  }</span>
 6206 |     | <span class='neutral'>}</span>
 6207 |     | <span class='neutral'></span>
 6208 |     | <span class='neutral'>function setLogPriceCurrent(</span>
 6209 |     | <span class='neutral'>  X59 logPriceCurrent</span>
 6210 |     | <span class='neutral'>) pure {</span>
 6211 |     | <span class='neutral'>  assembly {</span>
 6212 |     | <span class='neutral'>    mstore(</span>
 6213 |     | <span class='neutral'>      _logPriceCurrent_,</span>
 6214 |     | <span class='neutral'>      or(</span>
 6215 |     | <span class='neutral'>        shl(192, logPriceCurrent),</span>
 6216 |     | <span class='neutral'>        shr(64, mload(add(_logPriceCurrent_, 8)))</span>
 6217 |     | <span class='neutral'>      )</span>
 6218 |     | <span class='neutral'>    )</span>
 6219 |     | <span class='neutral'>  }</span>
 6220 |     | <span class='neutral'>}</span>
 6221 |     | <span class='neutral'></span>
 6222 |     | <span class='neutral'>function setDeploymentCreationCode(</span>
 6223 |     | <span class='neutral'>  uint256 deploymentCreationCode</span>
 6224 |     | <span class='neutral'>) pure {</span>
 6225 |     | <span class='neutral'>  assembly {</span>
 6226 |     | <span class='neutral'>    mstore(</span>
 6227 |     | <span class='neutral'>      _deploymentCreationCode_,</span>
 6228 |     | <span class='neutral'>      or(</span>
 6229 |     | <span class='neutral'>        shl(168, deploymentCreationCode),</span>
 6230 |     | <span class='neutral'>        shr(88, mload(add(_deploymentCreationCode_, 11)))</span>
 6231 |     | <span class='neutral'>      )</span>
 6232 |     | <span class='neutral'>    )</span>
 6233 |     | <span class='neutral'>  }</span>
 6234 |     | <span class='neutral'>}</span>
 6235 |     | <span class='neutral'></span>
 6236 |     | <span class='neutral'>function getTag0() pure returns (</span>
 6237 |     | <span class='neutral'>  Tag tag0</span>
 6238 |     | <span class='neutral'>) {</span>
 6239 |     | <span class='neutral'>  assembly {</span>
 6240 |     | <span class='neutral'>    tag0 := mload(_tag0_)</span>
 6241 |     | <span class='neutral'>  }</span>
 6242 |     | <span class='neutral'>}</span>
 6243 |     | <span class='neutral'></span>
 6244 |     | <span class='neutral'>function setTag0(</span>
 6245 |     | <span class='neutral'>  Tag tag0</span>
 6246 |     | <span class='neutral'>) pure {</span>
 6247 |     | <span class='neutral'>  assembly {</span>
 6248 |     | <span class='neutral'>    mstore(_tag0_, tag0)</span>
 6249 |     | <span class='neutral'>  }</span>
 6250 |     | <span class='neutral'>}</span>
 6251 |     | <span class='neutral'></span>
 6252 |     | <span class='neutral'>function getTag1() pure returns (</span>
 6253 |     | <span class='neutral'>  Tag tag1</span>
 6254 |     | <span class='neutral'>) {</span>
 6255 |     | <span class='neutral'>  assembly {</span>
 6256 |     | <span class='neutral'>    tag1 := mload(_tag1_)</span>
 6257 |     | <span class='neutral'>  }</span>
 6258 |     | <span class='neutral'>}</span>
 6259 |     | <span class='neutral'></span>
 6260 |     | <span class='neutral'>function setTag1(</span>
 6261 |     | <span class='neutral'>  Tag tag1</span>
 6262 |     | <span class='neutral'>) pure {</span>
 6263 |     | <span class='neutral'>  assembly {</span>
 6264 |     | <span class='neutral'>    mstore(_tag1_, tag1)</span>
 6265 |     | <span class='neutral'>  }</span>
 6266 |     | <span class='neutral'>}</span>
 6267 |     | <span class='neutral'></span>
 6268 |     | <span class='neutral'>function getSqrtOffset() pure returns (</span>
 6269 |     | <span class='neutral'>  X127 sqrtOffset</span>
 6270 |     | <span class='neutral'>) {</span>
 6271 |     | <span class='neutral'>  assembly {</span>
 6272 |     | <span class='neutral'>    sqrtOffset := mload(_sqrtOffset_)</span>
 6273 |     | <span class='neutral'>  }</span>
 6274 |     | <span class='neutral'>}</span>
 6275 |     | <span class='neutral'></span>
 6276 |     | <span class='neutral'>function setSqrtOffset(</span>
 6277 |     | <span class='neutral'>  X127 sqrtOffset</span>
 6278 |     | <span class='neutral'>) pure {</span>
 6279 |     | <span class='neutral'>  assembly {</span>
 6280 |     | <span class='neutral'>    mstore(_sqrtOffset_, sqrtOffset)</span>
 6281 |     | <span class='neutral'>  }</span>
 6282 |     | <span class='neutral'>}</span>
 6283 |     | <span class='neutral'></span>
 6284 |     | <span class='neutral'>function getSqrtInverseOffset() pure returns (</span>
 6285 |     | <span class='neutral'>  X127 sqrtInverseOffset</span>
 6286 |     | <span class='neutral'>) {</span>
 6287 |     | <span class='neutral'>  assembly {</span>
 6288 |     | <span class='neutral'>    sqrtInverseOffset := mload(_sqrtInverseOffset_)</span>
 6289 |     | <span class='neutral'>  }</span>
 6290 |     | <span class='neutral'>}</span>
 6291 |     | <span class='neutral'></span>
 6292 |     | <span class='neutral'>function setSqrtInverseOffset(</span>
 6293 |     | <span class='neutral'>  X127 sqrtInverseOffset</span>
 6294 |     | <span class='neutral'>) pure {</span>
 6295 |     | <span class='neutral'>  assembly {</span>
 6296 |     | <span class='neutral'>    mstore(_sqrtInverseOffset_, sqrtInverseOffset)</span>
 6297 |     | <span class='neutral'>  }</span>
 6298 |     | <span class='neutral'>}</span>
 6299 |     | <span class='neutral'></span>
 6300 |     | <span class='neutral'>function getOutgoingMax() pure returns (</span>
 6301 |     | <span class='neutral'>  X216 outgoingMax</span>
 6302 |     | <span class='neutral'>) {</span>
 6303 |     | <span class='neutral'>  assembly {</span>
 6304 |     | <span class='neutral'>    outgoingMax := shr(40, mload(_outgoingMax_))</span>
 6305 |     | <span class='neutral'>  }</span>
 6306 |     | <span class='neutral'>}</span>
 6307 |     | <span class='neutral'></span>
 6308 |     | <span class='neutral'>function setOutgoingMax(</span>
 6309 |     | <span class='neutral'>  X216 outgoingMax</span>
 6310 |     | <span class='neutral'>) pure {</span>
 6311 |     | <span class='neutral'>  assembly {</span>
 6312 |     | <span class='neutral'>    mstore(</span>
 6313 |     | <span class='neutral'>      _outgoingMax_,</span>
 6314 |     | <span class='neutral'>      or(</span>
 6315 |     | <span class='neutral'>        shl(40, outgoingMax),</span>
 6316 |     | <span class='neutral'>        shr(216, mload(add(_outgoingMax_, 27)))</span>
 6317 |     | <span class='neutral'>      )</span>
 6318 |     | <span class='neutral'>    )</span>
 6319 |     | <span class='neutral'>  }</span>
 6320 |     | <span class='neutral'>}</span>
 6321 |     | <span class='neutral'></span>
 6322 |     | <span class='neutral'>function getOutgoingMaxModularInverse() pure returns (</span>
 6323 |     | <span class='neutral'>  uint256 outgoingMaxModularInverse</span>
 6324 |     | <span class='neutral'>) {</span>
 6325 |     | <span class='neutral'>  assembly {</span>
 6326 |     | <span class='neutral'>    outgoingMaxModularInverse := mload(_outgoingMaxModularInverse_)</span>
 6327 |     | <span class='neutral'>  }</span>
 6328 |     | <span class='neutral'>}</span>
 6329 |     | <span class='neutral'></span>
 6330 |     | <span class='neutral'>function setOutgoingMaxModularInverse(</span>
 6331 |     | <span class='neutral'>  uint256 outgoingMaxModularInverse</span>
 6332 |     | <span class='neutral'>) pure {</span>
 6333 |     | <span class='neutral'>  assembly {</span>
 6334 |     | <span class='neutral'>    mstore(_outgoingMaxModularInverse_, outgoingMaxModularInverse)</span>
 6335 |     | <span class='neutral'>  }</span>
 6336 |     | <span class='neutral'>}</span>
 6337 |     | <span class='neutral'></span>
 6338 |     | <span class='neutral'>function getIncomingMax() pure returns (</span>
 6339 |     | <span class='neutral'>  X216 incomingMax</span>
 6340 |     | <span class='neutral'>) {</span>
 6341 |     | <span class='neutral'>  assembly {</span>
 6342 |     | <span class='neutral'>    incomingMax := shr(40, mload(_incomingMax_))</span>
 6343 |     | <span class='neutral'>  }</span>
 6344 |     | <span class='neutral'>}</span>
 6345 |     | <span class='neutral'></span>
 6346 |     | <span class='neutral'>function setIncomingMax(</span>
 6347 |     | <span class='neutral'>  X216 incomingMax</span>
 6348 |     | <span class='neutral'>) pure {</span>
 6349 |     | <span class='neutral'>  assembly {</span>
 6350 |     | <span class='neutral'>    mstore(</span>
 6351 |     | <span class='neutral'>      _incomingMax_,</span>
 6352 |     | <span class='neutral'>      or(</span>
 6353 |     | <span class='neutral'>        shl(40, incomingMax),</span>
 6354 |     | <span class='neutral'>        shr(216, mload(add(_incomingMax_, 27)))</span>
 6355 |     | <span class='neutral'>      )</span>
 6356 |     | <span class='neutral'>    )</span>
 6357 |     | <span class='neutral'>  }</span>
 6358 |     | <span class='neutral'>}</span>
 6359 |     | <span class='neutral'></span>
 6360 |     | <span class='neutral'>function getPoolGrowthPortion() pure returns (</span>
 6361 |     | <span class='neutral'>  X47 poolGrowthPortion</span>
 6362 |     | <span class='neutral'>) {</span>
 6363 |     | <span class='neutral'>  assembly {</span>
 6364 |     | <span class='neutral'>    poolGrowthPortion := shr(208, mload(_poolGrowthPortion_))</span>
 6365 |     | <span class='neutral'>  }</span>
 6366 |     | <span class='neutral'>}</span>
 6367 |     | <span class='neutral'></span>
 6368 |     | <span class='neutral'>function setPoolGrowthPortion(</span>
 6369 |     | <span class='neutral'>  X47 poolGrowthPortion</span>
 6370 |     | <span class='neutral'>) pure {</span>
 6371 |     | <span class='neutral'>  assembly {</span>
 6372 |     | <span class='neutral'>    mstore(</span>
 6373 |     | <span class='neutral'>      _poolGrowthPortion_,</span>
 6374 |     | <span class='neutral'>      or(</span>
 6375 |     | <span class='neutral'>        shl(208, poolGrowthPortion),</span>
 6376 |     | <span class='neutral'>        shr(48, mload(add(_poolGrowthPortion_, 6)))</span>
 6377 |     | <span class='neutral'>      )</span>
 6378 |     | <span class='neutral'>    )</span>
 6379 |     | <span class='neutral'>  }</span>
 6380 |     | <span class='neutral'>}</span>
 6381 |     | <span class='neutral'></span>
 6382 |     | <span class='neutral'>function getMaxPoolGrowthPortion() pure returns (</span>
 6383 |     | <span class='neutral'>  X47 maxPoolGrowthPortion</span>
 6384 |     | <span class='neutral'>) {</span>
 6385 |     | <span class='neutral'>  assembly {</span>
 6386 |     | <span class='neutral'>    maxPoolGrowthPortion := shr(208, mload(_maxPoolGrowthPortion_))</span>
 6387 |     | <span class='neutral'>  }</span>
 6388 |     | <span class='neutral'>}</span>
 6389 |     | <span class='neutral'></span>
 6390 |     | <span class='neutral'>function setMaxPoolGrowthPortion(</span>
 6391 |     | <span class='neutral'>  X47 maxPoolGrowthPortion</span>
 6392 |     | <span class='neutral'>) pure {</span>
 6393 |     | <span class='neutral'>  assembly {</span>
 6394 |     | <span class='neutral'>    mstore(</span>
 6395 |     | <span class='neutral'>      _maxPoolGrowthPortion_,</span>
 6396 |     | <span class='neutral'>      or(</span>
 6397 |     | <span class='neutral'>        shl(208, maxPoolGrowthPortion),</span>
 6398 |     | <span class='neutral'>        shr(48, mload(add(_maxPoolGrowthPortion_, 6)))</span>
 6399 |     | <span class='neutral'>      )</span>
 6400 |     | <span class='neutral'>    )</span>
 6401 |     | <span class='neutral'>  }</span>
 6402 |     | <span class='neutral'>}</span>
 6403 |     | <span class='neutral'></span>
 6404 |     | <span class='neutral'>function getProtocolGrowthPortion() pure returns (</span>
 6405 |     | <span class='neutral'>  X47 protocolGrowthPortion</span>
 6406 |     | <span class='neutral'>) {</span>
 6407 |     | <span class='neutral'>  assembly {</span>
 6408 |     | <span class='neutral'>    protocolGrowthPortion := shr(208, mload(_protocolGrowthPortion_))</span>
 6409 |     | <span class='neutral'>  }</span>
 6410 |     | <span class='neutral'>}</span>
 6411 |     | <span class='neutral'></span>
 6412 |     | <span class='neutral'>function setProtocolGrowthPortion(</span>
 6413 |     | <span class='neutral'>  X47 protocolGrowthPortion</span>
 6414 |     | <span class='neutral'>) pure {</span>
 6415 |     | <span class='neutral'>  assembly {</span>
 6416 |     | <span class='neutral'>    mstore(</span>
 6417 |     | <span class='neutral'>      _protocolGrowthPortion_,</span>
 6418 |     | <span class='neutral'>      or(</span>
 6419 |     | <span class='neutral'>        shl(208, protocolGrowthPortion),</span>
 6420 |     | <span class='neutral'>        shr(48, mload(add(_protocolGrowthPortion_, 6)))</span>
 6421 |     | <span class='neutral'>      )</span>
 6422 |     | <span class='neutral'>    )</span>
 6423 |     | <span class='neutral'>  }</span>
 6424 |     | <span class='neutral'>}</span>
 6425 |     | <span class='neutral'></span>
 6426 |     | <span class='neutral'>function getPendingKernelLength() pure returns (</span>
 6427 |     | <span class='neutral'>  Index pendingKernelLength</span>
 6428 |     | <span class='neutral'>) {</span>
 6429 |     | <span class='neutral'>  assembly {</span>
 6430 |     | <span class='neutral'>    pendingKernelLength := shr(240, mload(_pendingKernelLength_))</span>
 6431 |     | <span class='neutral'>  }</span>
 6432 |     | <span class='neutral'>}</span>
 6433 |     | <span class='neutral'></span>
 6434 |     | <span class='neutral'>function setPendingKernelLength(</span>
 6435 |     | <span class='neutral'>  Index pendingKernelLength</span>
 6436 |     | <span class='neutral'>) pure {</span>
 6437 |     | <span class='neutral'>  assembly {</span>
 6438 |     | <span class='neutral'>    mstore(</span>
 6439 |     | <span class='neutral'>      _pendingKernelLength_,</span>
 6440 |     | <span class='neutral'>      or(</span>
 6441 |     | <span class='neutral'>        shl(240, pendingKernelLength),</span>
 6442 |     | <span class='neutral'>        shr(16, mload(add(_pendingKernelLength_, 2)))</span>
 6443 |     | <span class='neutral'>      )</span>
 6444 |     | <span class='neutral'>    )</span>
 6445 |     | <span class='neutral'>  }</span>
 6446 |     | <span class='neutral'>}</span>
 6447 |     | <span class='neutral'></span>
 6448 |     | <span class='neutral'>function getLogPriceMinOffsetted() pure returns (</span>
 6449 |     | <span class='neutral'>  X59 logPriceMinOffsetted</span>
 6450 |     | <span class='neutral'>) {</span>
 6451 |     | <span class='neutral'>  assembly {</span>
 6452 |     | <span class='neutral'>    logPriceMinOffsetted := shr(192, mload(_logPriceMinOffsetted_))</span>
 6453 |     | <span class='neutral'>  }</span>
 6454 |     | <span class='neutral'>}</span>
 6455 |     | <span class='neutral'></span>
 6456 |     | <span class='neutral'>function setLogPriceMinOffsetted(</span>
 6457 |     | <span class='neutral'>  X59 logPriceMinOffsetted</span>
 6458 |     | <span class='neutral'>) pure {</span>
 6459 |     | <span class='neutral'>  assembly {</span>
 6460 |     | <span class='neutral'>    mstore(</span>
 6461 |     | <span class='neutral'>      _logPriceMinOffsetted_,</span>
 6462 |     | <span class='neutral'>      or(</span>
 6463 |     | <span class='neutral'>        shl(192, logPriceMinOffsetted),</span>
 6464 |     | <span class='neutral'>        shr(64, mload(add(_logPriceMinOffsetted_, 8)))</span>
 6465 |     | <span class='neutral'>      )</span>
 6466 |     | <span class='neutral'>    )</span>
 6467 |     | <span class='neutral'>  }</span>
 6468 |     | <span class='neutral'>}</span>
 6469 |     | <span class='neutral'></span>
 6470 |     | <span class='neutral'>function getLogPriceMaxOffsetted() pure returns (</span>
 6471 |     | <span class='neutral'>  X59 logPriceMaxOffsetted</span>
 6472 |     | <span class='neutral'>) {</span>
 6473 |     | <span class='neutral'>  assembly {</span>
 6474 |     | <span class='neutral'>    logPriceMaxOffsetted := shr(192, mload(_logPriceMaxOffsetted_))</span>
 6475 |     | <span class='neutral'>  }</span>
 6476 |     | <span class='neutral'>}</span>
 6477 |     | <span class='neutral'></span>
 6478 |     | <span class='neutral'>function setLogPriceMaxOffsetted(</span>
 6479 |     | <span class='neutral'>  X59 logPriceMaxOffsetted</span>
 6480 |     | <span class='neutral'>) pure {</span>
 6481 |     | <span class='neutral'>  assembly {</span>
 6482 |     | <span class='neutral'>    mstore(</span>
 6483 |     | <span class='neutral'>      _logPriceMaxOffsetted_,</span>
 6484 |     | <span class='neutral'>      or(</span>
 6485 |     | <span class='neutral'>        shl(192, logPriceMaxOffsetted),</span>
 6486 |     | <span class='neutral'>        shr(64, mload(add(_logPriceMaxOffsetted_, 8)))</span>
 6487 |     | <span class='neutral'>      )</span>
 6488 |     | <span class='neutral'>    )</span>
 6489 |     | <span class='neutral'>  }</span>
 6490 |     | <span class='neutral'>}</span>
 6491 |     | <span class='neutral'></span>
 6492 |     | <span class='neutral'>function getShares() pure returns (</span>
 6493 |     | <span class='neutral'>  int256 shares</span>
 6494 |     | <span class='neutral'>) {</span>
 6495 |     | <span class='neutral'>  assembly {</span>
 6496 |     | <span class='neutral'>    shares := mload(_shares_)</span>
 6497 |     | <span class='neutral'>  }</span>
 6498 |     | <span class='neutral'>}</span>
 6499 |     | <span class='neutral'></span>
 6500 |     | <span class='neutral'>function setShares(</span>
 6501 |     | <span class='neutral'>  int256 shares</span>
 6502 |     | <span class='neutral'>) pure {</span>
 6503 |     | <span class='neutral'>  assembly {</span>
 6504 |     | <span class='neutral'>    mstore(_shares_, shares)</span>
 6505 |     | <span class='neutral'>  }</span>
 6506 |     | <span class='neutral'>}</span>
 6507 |     | <span class='neutral'></span>
 6508 |     | <span class='neutral'>function getLogPriceMin() pure returns (</span>
 6509 |     | <span class='neutral'>  X59 logPriceMin</span>
 6510 |     | <span class='neutral'>) {</span>
 6511 |     | <span class='neutral'>  assembly {</span>
 6512 |     | <span class='neutral'>    logPriceMin := mload(_logPriceMin_)</span>
 6513 |     | <span class='neutral'>  }</span>
 6514 |     | <span class='neutral'>}</span>
 6515 |     | <span class='neutral'></span>
 6516 |     | <span class='neutral'>function setLogPriceMin(</span>
 6517 |     | <span class='neutral'>  X59 logPriceMin</span>
 6518 |     | <span class='neutral'>) pure {</span>
 6519 |     | <span class='neutral'>  assembly {</span>
 6520 |     | <span class='neutral'>    mstore(_logPriceMin_, logPriceMin)</span>
 6521 |     | <span class='neutral'>  }</span>
 6522 |     | <span class='neutral'>}</span>
 6523 |     | <span class='neutral'></span>
 6524 |     | <span class='neutral'>function getLogPriceMax() pure returns (</span>
 6525 |     | <span class='neutral'>  X59 logPriceMax</span>
 6526 |     | <span class='neutral'>) {</span>
 6527 |     | <span class='neutral'>  assembly {</span>
 6528 |     | <span class='neutral'>    logPriceMax := mload(_logPriceMax_)</span>
 6529 |     | <span class='neutral'>  }</span>
 6530 |     | <span class='neutral'>}</span>
 6531 |     | <span class='neutral'></span>
 6532 |     | <span class='neutral'>function setLogPriceMax(</span>
 6533 |     | <span class='neutral'>  X59 logPriceMax</span>
 6534 |     | <span class='neutral'>) pure {</span>
 6535 |     | <span class='neutral'>  assembly {</span>
 6536 |     | <span class='neutral'>    mstore(_logPriceMax_, logPriceMax)</span>
 6537 |     | <span class='neutral'>  }</span>
 6538 |     | <span class='neutral'>}</span>
 6539 |     | <span class='neutral'></span>
 6540 |     | <span class='neutral'>function getPositionAmount0() pure returns (</span>
 6541 |     | <span class='neutral'>  int256 positionAmount0</span>
 6542 |     | <span class='neutral'>) {</span>
 6543 |     | <span class='neutral'>  assembly {</span>
 6544 |     | <span class='neutral'>    positionAmount0 := mload(_positionAmount0_)</span>
 6545 |     | <span class='neutral'>  }</span>
 6546 |     | <span class='neutral'>}</span>
 6547 |     | <span class='neutral'></span>
 6548 |     | <span class='neutral'>function setPositionAmount0(</span>
 6549 |     | <span class='neutral'>  int256 positionAmount0</span>
 6550 |     | <span class='neutral'>) pure {</span>
 6551 |     | <span class='neutral'>  assembly {</span>
 6552 |     | <span class='neutral'>    mstore(_positionAmount0_, positionAmount0)</span>
 6553 |     | <span class='neutral'>  }</span>
 6554 |     | <span class='neutral'>}</span>
 6555 |     | <span class='neutral'></span>
 6556 |     | <span class='neutral'>function getPositionAmount1() pure returns (</span>
 6557 |     | <span class='neutral'>  int256 positionAmount1</span>
 6558 |     | <span class='neutral'>) {</span>
 6559 |     | <span class='neutral'>  assembly {</span>
 6560 |     | <span class='neutral'>    positionAmount1 := mload(_positionAmount1_)</span>
 6561 |     | <span class='neutral'>  }</span>
 6562 |     | <span class='neutral'>}</span>
 6563 |     | <span class='neutral'></span>
 6564 |     | <span class='neutral'>function setPositionAmount1(</span>
 6565 |     | <span class='neutral'>  int256 positionAmount1</span>
 6566 |     | <span class='neutral'>) pure {</span>
 6567 |     | <span class='neutral'>  assembly {</span>
 6568 |     | <span class='neutral'>    mstore(_positionAmount1_, positionAmount1)</span>
 6569 |     | <span class='neutral'>  }</span>
 6570 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/Price.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {X15} from &quot;./X15.sol&quot;;</span>
   5 |     | <span class='neutral'>import {X59} from &quot;./X59.sol&quot;;</span>
   6 |     | <span class='neutral'>import {X216} from &quot;./X216.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='unexecuted'>library PriceLibrary {</span>
   9 |     | <span class='neutral'>  using PriceLibrary for uint256;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>  /// @notice Stores a given price in a given memory location with the </span>
  12 |     | <span class='neutral'>  /// following layout:</span>
  13 |     | <span class='neutral'>  ///</span>
  14 |     | <span class='neutral'>  ///  pointer</span>
  15 |     | <span class='neutral'>  ///     |</span>
  16 |     | <span class='neutral'>  ///     +--------+---------------------------+---------------------------+</span>
  17 |     | <span class='neutral'>  ///     | 8 byte |          27 byte          |          27 byte          |</span>
  18 |     | <span class='neutral'>  ///     +--------+---------------------------+---------------------------+</span>
  19 |     | <span class='neutral'>  ///     |        |                           |</span>
  20 |     | <span class='neutral'>  ///     |        |                            \</span>
  21 |     | <span class='neutral'>  ///     |        |                             sqrtInversePrice</span>
  22 |     | <span class='neutral'>  ///     |         \</span>
  23 |     | <span class='neutral'>  ///     |          sqrtPrice</span>
  24 |     | <span class='neutral'>  ///      \</span>
  25 |     | <span class='neutral'>  ///       logPrice</span>
  26 |     | <span class='neutral'>  ///</span>
  27 |     | <span class='neutral'>  /// &#39;pointer&#39; should not be less than &#39;32&#39;.</span>
  28 |     | <span class='neutral'>  /// &#39;logPrice&#39; should be non-negative and less than &#39;2 ** 64&#39;.</span>
  29 |     | <span class='neutral'>  /// &#39;sqrtPrice&#39; should be non-negative and less than &#39;oneX216&#39;.</span>
  30 |     | <span class='neutral'>  /// &#39;sqrtInversePrice&#39; should be non-negative and less than &#39;oneX216&#39;.</span>
  31 | *   | <span class='executed'>  function storePrice(</span>
  32 |     | <span class='neutral'>    uint256 pointer,</span>
  33 |     | <span class='neutral'>    X59 logPrice,</span>
  34 |     | <span class='neutral'>    X216 sqrtPrice,</span>
  35 |     | <span class='neutral'>    X216 sqrtInversePrice</span>
  36 |     | <span class='neutral'>  ) internal pure {</span>
  37 | *   | <span class='executed'>    assembly {</span>
  38 |     | <span class='neutral'>      // The preceding slot is cached so that it can be restored after we place</span>
  39 |     | <span class='neutral'>      // all values in their appropriate memory locations.</span>
  40 |     | <span class='neutral'>      // The subtraction is safe because of the input requirement on &#39;pointer&#39;.</span>
  41 | *   | <span class='executed'>      let precedingPointer := sub(pointer, 32)</span>
  42 | *   | <span class='executed'>      let precedingSlot := mload(precedingPointer)</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>      // We move &#39;64 + 216 + 216&#39; bits forward to reach the following location:</span>
  45 |     | <span class='neutral'>      //</span>
  46 |     | <span class='neutral'>      //                                                          pointer + 62</span>
  47 |     | <span class='neutral'>      //                                                                  \</span>
  48 |     | <span class='neutral'>      //                                                                   |</span>
  49 |     | <span class='neutral'>      //  +--------+---------------------------+---------------------------+</span>
  50 |     | <span class='neutral'>      //  | 8 byte |          27 byte          |          27 byte          |</span>
  51 |     | <span class='neutral'>      //  +--------+---------------------------+---------------------------+</span>
  52 |     | <span class='neutral'>      //  |        |                           |</span>
  53 |     | <span class='neutral'>      //  |        |                            \</span>
  54 |     | <span class='neutral'>      //  |        |                             sqrtInversePrice</span>
  55 |     | <span class='neutral'>      //  |         \</span>
  56 |     | <span class='neutral'>      //  |          sqrtPrice</span>
  57 |     | <span class='neutral'>      //   \</span>
  58 |     | <span class='neutral'>      //    logPrice</span>
  59 |     | <span class='neutral'>      //</span>
  60 |     | <span class='neutral'>      // Then we move &#39;256&#39; bits backward to point to the beginning of the slot</span>
  61 |     | <span class='neutral'>      // whose least significant &#39;216&#39; bits are supposed to host</span>
  62 |     | <span class='neutral'>      // &#39;sqrtInversePrice&#39;.</span>
  63 |     | <span class='neutral'>      //</span>
  64 |     | <span class='neutral'>      // &#39;64 + 216 + 216 - 256&#39; bits == &#39;30&#39; bytes.</span>
  65 | *   | <span class='executed'>      mstore(add(pointer, 30), sqrtInversePrice)</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>      // We move &#39;64 + 216&#39; bits forward to reach the following location:</span>
  68 |     | <span class='neutral'>      //</span>
  69 |     | <span class='neutral'>      //                                  pointer + 35</span>
  70 |     | <span class='neutral'>      //                                       |</span>
  71 |     | <span class='neutral'>      //  +--------+---------------------------+---------------------------+</span>
  72 |     | <span class='neutral'>      //  | 8 byte |          27 byte          |          27 byte          |</span>
  73 |     | <span class='neutral'>      //  +--------+---------------------------+---------------------------+</span>
  74 |     | <span class='neutral'>      //  |        |                           |</span>
  75 |     | <span class='neutral'>      //  |        |                            \</span>
  76 |     | <span class='neutral'>      //  |        |                             sqrtInversePrice</span>
  77 |     | <span class='neutral'>      //  |         \</span>
  78 |     | <span class='neutral'>      //  |          sqrtPrice</span>
  79 |     | <span class='neutral'>      //   \</span>
  80 |     | <span class='neutral'>      //    logPrice</span>
  81 |     | <span class='neutral'>      //</span>
  82 |     | <span class='neutral'>      // Then we move &#39;256&#39; bits backward to point to the beginning of the slot</span>
  83 |     | <span class='neutral'>      // whose least significant &#39;216&#39; bits are supposed to host &#39;sqrtPrice&#39;.</span>
  84 |     | <span class='neutral'>      //</span>
  85 |     | <span class='neutral'>      // &#39;64 + 216 - 256&#39; bits == &#39;3&#39; bytes.</span>
  86 | *   | <span class='executed'>      mstore(add(pointer, 3), sqrtPrice)</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>      // We move &#39;64&#39; bits forward to reach the following location:</span>
  89 |     | <span class='neutral'>      //</span>
  90 |     | <span class='neutral'>      //      pointer + 8</span>
  91 |     | <span class='neutral'>      //           |</span>
  92 |     | <span class='neutral'>      //  +--------+---------------------------+---------------------------+</span>
  93 |     | <span class='neutral'>      //  | 8 byte |          27 byte          |          27 byte          |</span>
  94 |     | <span class='neutral'>      //  +--------+---------------------------+---------------------------+</span>
  95 |     | <span class='neutral'>      //  |        |                           |</span>
  96 |     | <span class='neutral'>      //  |        |                            \</span>
  97 |     | <span class='neutral'>      //  |        |                             sqrtInversePrice</span>
  98 |     | <span class='neutral'>      //  |         \</span>
  99 |     | <span class='neutral'>      //  |          sqrtPrice</span>
 100 |     | <span class='neutral'>      //   \</span>
 101 |     | <span class='neutral'>      //    logPrice</span>
 102 |     | <span class='neutral'>      //</span>
 103 |     | <span class='neutral'>      // Then we move &#39;256&#39; bits backward to point to the beginning of the slot</span>
 104 |     | <span class='neutral'>      // whose least significant &#39;64&#39; bits are supposed to host &#39;logPrice&#39;.</span>
 105 |     | <span class='neutral'>      //</span>
 106 |     | <span class='neutral'>      // &#39;64 - 256&#39; bits == &#39;-24&#39; bytes.</span>
 107 |     | <span class='neutral'>      //</span>
 108 |     | <span class='neutral'>      // The subtraction is safe because of the input requirement on &#39;pointer&#39;.</span>
 109 | *   | <span class='executed'>      mstore(sub(pointer, 24), logPrice)</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>      // The preceding slot is restored.</span>
 112 | *   | <span class='executed'>      mstore(precedingPointer, precedingSlot)</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'>  }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>  /// @notice Calculates the sqrt and sqrtInverse of a given logPrice and</span>
 117 |     | <span class='neutral'>  /// stores everything in the given memory location with the following</span>
 118 |     | <span class='neutral'>  /// layout:</span>
 119 |     | <span class='neutral'>  ///</span>
 120 |     | <span class='neutral'>  ///  pointer</span>
 121 |     | <span class='neutral'>  ///     |</span>
 122 |     | <span class='neutral'>  ///     +--------+---------------------------+---------------------------+</span>
 123 |     | <span class='neutral'>  ///     | 8 byte |          27 byte          |          27 byte          |</span>
 124 |     | <span class='neutral'>  ///     +--------+---------------------------+---------------------------+</span>
 125 |     | <span class='neutral'>  ///     |        |                           |</span>
 126 |     | <span class='neutral'>  ///     |        |                            \</span>
 127 |     | <span class='neutral'>  ///     |        |                             sqrtInversePrice</span>
 128 |     | <span class='neutral'>  ///     |         \</span>
 129 |     | <span class='neutral'>  ///     |          sqrtPrice</span>
 130 |     | <span class='neutral'>  ///      \</span>
 131 |     | <span class='neutral'>  ///       logPrice</span>
 132 |     | <span class='neutral'>  ///</span>
 133 |     | <span class='neutral'>  /// &#39;pointer&#39; should not be less than &#39;32&#39; and &#39;pointer + 30&#39; should not</span>
 134 |     | <span class='neutral'>  /// overflow.</span>
 135 |     | <span class='neutral'>  ///</span>
 136 |     | <span class='neutral'>  /// &#39;logPrice&#39; should be greater than 0 and less than (2 ** 64).</span>
 137 |     | <span class='neutral'>  function storePrice(</span>
 138 |     | <span class='neutral'>    uint256 pointer,</span>
 139 |     | <span class='neutral'>    X59 logPrice</span>
 140 |     | <span class='neutral'>  ) internal pure {</span>
 141 |     | <span class='neutral'>    // The requirements of &#39;exp&#39; are satisfied here because </span>
 142 |     | <span class='neutral'>    // &#39;0 &lt; logPrice &lt; 2 ** 64&#39;.</span>
 143 |     | <span class='neutral'>    (X216 sqrtPrice, X216 sqrtInversePrice) = logPrice.exp();</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>    // The requirements of &#39;storePrice&#39; are satisfied here, because of the</span>
 146 |     | <span class='neutral'>    // input requirement on &#39;pointer&#39; and because both outputs of &#39;exp&#39; are</span>
 147 |     | <span class='neutral'>    // less than &#39;oneX216&#39;:</span>
 148 |     | <span class='neutral'>    //</span>
 149 |     | <span class='neutral'>    // &#39;0 &lt; logPrice&#39; -&gt; &#39;(2 ** 216) * exp(- logPrice / (2 ** 60)) &lt; 2 ** 216&#39;</span>
 150 |     | <span class='neutral'>    //</span>
 151 |     | <span class='neutral'>    // &#39;logPrice &lt; 2 ** 64&#39; -&gt; </span>
 152 |     | <span class='neutral'>    // &#39;(2 ** 216) * exp(- 16 + logPrice / (2 ** 60)) &lt; 2 ** 216&#39;</span>
 153 |     | <span class='neutral'>    //</span>
 154 |     | <span class='neutral'>    pointer.storePrice(logPrice, sqrtPrice, sqrtInversePrice);</span>
 155 |     | <span class='neutral'>  }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>  /// @notice Stores a given price in a given memory location with the</span>
 158 |     | <span class='neutral'>  /// following layout:</span>
 159 |     | <span class='neutral'>  ///</span>
 160 |     | <span class='neutral'>  ///   pointer</span>
 161 |     | <span class='neutral'>  ///      |</span>
 162 |     | <span class='neutral'>  ///   +--+--------+---------------------------+---------------------------+</span>
 163 |     | <span class='neutral'>  ///   |  | 8 byte |          27 byte          |          27 byte          |</span>
 164 |     | <span class='neutral'>  ///   +--+--------+---------------------------+---------------------------+</span>
 165 |     | <span class='neutral'>  ///   |  |        |                           |</span>
 166 |     | <span class='neutral'>  ///   |  |        |                            \</span>
 167 |     | <span class='neutral'>  ///   |  |        |                             sqrtInversePrice</span>
 168 |     | <span class='neutral'>  ///   |  |         \</span>
 169 |     | <span class='neutral'>  ///   |  |          sqrtPrice</span>
 170 |     | <span class='neutral'>  ///   |   \</span>
 171 |     | <span class='neutral'>  ///   |    logPrice</span>
 172 |     | <span class='neutral'>  ///    \</span>
 173 |     | <span class='neutral'>  ///     heightPrice</span>
 174 |     | <span class='neutral'>  ///</span>
 175 |     | <span class='neutral'>  /// &#39;pointer&#39; should not be less than &#39;34&#39;.</span>
 176 |     | <span class='neutral'>  /// &#39;heightPrice&#39; should be less than or equal to &#39;oneX15&#39;.</span>
 177 |     | <span class='neutral'>  /// &#39;logPrice&#39; should be non-negative and less than (2 ** 64).</span>
 178 |     | <span class='neutral'>  /// &#39;sqrtPrice&#39; should be non-negative and less than &#39;oneX216&#39;.</span>
 179 |     | <span class='neutral'>  /// &#39;sqrtInversePrice&#39; should be non-negative and less than &#39;oneX216&#39;.</span>
 180 | *   | <span class='executed'>  function storePrice(</span>
 181 |     | <span class='neutral'>    uint256 pointer,</span>
 182 |     | <span class='neutral'>    X15 heightPrice,</span>
 183 |     | <span class='neutral'>    X59 logPrice,</span>
 184 |     | <span class='neutral'>    X216 sqrtPrice,</span>
 185 |     | <span class='neutral'>    X216 sqrtInversePrice</span>
 186 |     | <span class='neutral'>  ) internal pure {</span>
 187 | *   | <span class='executed'>    assembly {</span>
 188 |     | <span class='neutral'>      // The preceding slot is cached so that it can be restored after we place</span>
 189 |     | <span class='neutral'>      // all values in their appropriate memory location.</span>
 190 |     | <span class='neutral'>      // The subtraction is safe because of the input requirement on &#39;pointer&#39;.</span>
 191 | *   | <span class='executed'>      let precedingPointer := sub(pointer, 34)</span>
 192 | *   | <span class='executed'>      let precedingSlot := mload(precedingPointer)</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>      // We move &#39;64 + 216 + 216&#39; bits forward to reach the following location:</span>
 195 |     | <span class='neutral'>      //</span>
 196 |     | <span class='neutral'>      //                                                          pointer + 62</span>
 197 |     | <span class='neutral'>      //                                                                     \</span>
 198 |     | <span class='neutral'>      //                                                                      |</span>
 199 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 200 |     | <span class='neutral'>      //  |  | 8 byte |          27 byte          |          27 byte          |</span>
 201 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 202 |     | <span class='neutral'>      //  |  |        |                           |</span>
 203 |     | <span class='neutral'>      //  |  |        |                            \</span>
 204 |     | <span class='neutral'>      //  |  |        |                             sqrtInversePrice</span>
 205 |     | <span class='neutral'>      //  |  |         \</span>
 206 |     | <span class='neutral'>      //  |  |          sqrtPrice</span>
 207 |     | <span class='neutral'>      //  |   \</span>
 208 |     | <span class='neutral'>      //  |    logPrice</span>
 209 |     | <span class='neutral'>      //   \</span>
 210 |     | <span class='neutral'>      //    heightPrice</span>
 211 |     | <span class='neutral'>      //</span>
 212 |     | <span class='neutral'>      // Then we move &#39;256&#39; bits backward to point to the beginning of the slot</span>
 213 |     | <span class='neutral'>      // whose least significant &#39;216&#39; bits are supposed to host</span>
 214 |     | <span class='neutral'>      // &#39;sqrtInversePrice&#39;.</span>
 215 |     | <span class='neutral'>      //</span>
 216 |     | <span class='neutral'>      // &#39;64 + 216 + 216 - 256&#39; bits == &#39;30&#39; bytes.</span>
 217 | *   | <span class='executed'>      mstore(add(pointer, 30), sqrtInversePrice)</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>      // We move &#39;64 + 216&#39; bits forward to reach the following location:</span>
 220 |     | <span class='neutral'>      //</span>
 221 |     | <span class='neutral'>      //                                  pointer + 35</span>
 222 |     | <span class='neutral'>      //                                         \</span>
 223 |     | <span class='neutral'>      //                                          |</span>
 224 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 225 |     | <span class='neutral'>      //  |  | 8 byte |          27 byte          |          27 byte          |</span>
 226 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 227 |     | <span class='neutral'>      //  |  |        |                           |</span>
 228 |     | <span class='neutral'>      //  |  |        |                            \</span>
 229 |     | <span class='neutral'>      //  |  |        |                             sqrtInversePrice</span>
 230 |     | <span class='neutral'>      //  |  |         \</span>
 231 |     | <span class='neutral'>      //  |  |          sqrtPrice</span>
 232 |     | <span class='neutral'>      //  |   \</span>
 233 |     | <span class='neutral'>      //  |    logPrice</span>
 234 |     | <span class='neutral'>      //   \</span>
 235 |     | <span class='neutral'>      //    heightPrice</span>
 236 |     | <span class='neutral'>      //</span>
 237 |     | <span class='neutral'>      // Then we move &#39;256&#39; bits backward to point to the beginning of the slot</span>
 238 |     | <span class='neutral'>      // whose least significant &#39;216&#39; bits are supposed to host &#39;sqrtPrice&#39;.</span>
 239 |     | <span class='neutral'>      //</span>
 240 |     | <span class='neutral'>      // &#39;64 + 216 - 256&#39; bits == &#39;3&#39; bytes.</span>
 241 | *   | <span class='executed'>      mstore(add(pointer, 3), sqrtPrice)</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>      // We move &#39;64&#39; bits forward to reach the following location:</span>
 244 |     | <span class='neutral'>      //</span>
 245 |     | <span class='neutral'>      //      pointer + 8</span>
 246 |     | <span class='neutral'>      //             \</span>
 247 |     | <span class='neutral'>      //              |</span>
 248 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 249 |     | <span class='neutral'>      //  |  | 8 byte |          27 byte          |          27 byte          |</span>
 250 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 251 |     | <span class='neutral'>      //  |  |        |                           |</span>
 252 |     | <span class='neutral'>      //  |  |        |                            \</span>
 253 |     | <span class='neutral'>      //  |  |        |                             sqrtInversePrice</span>
 254 |     | <span class='neutral'>      //  |  |         \</span>
 255 |     | <span class='neutral'>      //  |  |          sqrtPrice</span>
 256 |     | <span class='neutral'>      //  |   \</span>
 257 |     | <span class='neutral'>      //  |    logPrice</span>
 258 |     | <span class='neutral'>      //   \</span>
 259 |     | <span class='neutral'>      //    heightPrice</span>
 260 |     | <span class='neutral'>      //</span>
 261 |     | <span class='neutral'>      // Then we move &#39;256&#39; bits backward to point to the beginning of the slot</span>
 262 |     | <span class='neutral'>      // whose least significant &#39;64&#39; bits are supposed to host &#39;logPrice&#39;.</span>
 263 |     | <span class='neutral'>      //</span>
 264 |     | <span class='neutral'>      // &#39;64 - 256&#39; bits == &#39;-24&#39; bytes.</span>
 265 |     | <span class='neutral'>      // The subtraction is safe because of the input requirement on &#39;pointer&#39;.</span>
 266 | *   | <span class='executed'>      mstore(sub(pointer, 24), logPrice)</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>      // We move &#39;256&#39; bits backward to point to the beginning of the slot</span>
 269 |     | <span class='neutral'>      // whose least significant &#39;16&#39; bits are supposed to host &#39;heightPrice&#39;.</span>
 270 |     | <span class='neutral'>      //</span>
 271 |     | <span class='neutral'>      // &#39;0 - 256&#39; bits == &#39;-32&#39; bytes.</span>
 272 |     | <span class='neutral'>      // The subtraction is safe because of the input requirement on &#39;pointer&#39;.</span>
 273 | *   | <span class='executed'>      mstore(sub(pointer, 32), heightPrice)</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='neutral'>      // The preceding slot is restored.</span>
 276 | *   | <span class='executed'>      mstore(precedingPointer, precedingSlot)</span>
 277 |     | <span class='neutral'>    }</span>
 278 |     | <span class='neutral'>  }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>  /// @notice Returns the height of a price given its memory pointer with the </span>
 281 |     | <span class='neutral'>  /// following layout:</span>
 282 |     | <span class='neutral'>  ///</span>
 283 |     | <span class='neutral'>  ///       pointer</span>
 284 |     | <span class='neutral'>  ///      /</span>
 285 |     | <span class='neutral'>  ///     |</span>
 286 |     | <span class='neutral'>  ///  +--+--------+---------------------------+---------------------------+</span>
 287 |     | <span class='neutral'>  ///  |  | 8 byte |          27 byte          |          27 byte          |</span>
 288 |     | <span class='neutral'>  ///  +--+--------+---------------------------+---------------------------+</span>
 289 |     | <span class='neutral'>  ///  |  |        |                           |</span>
 290 |     | <span class='neutral'>  ///  |  |        |                            \</span>
 291 |     | <span class='neutral'>  ///  |  |        |                             sqrtInversePrice</span>
 292 |     | <span class='neutral'>  ///  |  |         \</span>
 293 |     | <span class='neutral'>  ///  |  |          sqrtPrice</span>
 294 |     | <span class='neutral'>  ///  |   \</span>
 295 |     | <span class='neutral'>  ///  |    logPrice</span>
 296 |     | <span class='neutral'>  ///   \</span>
 297 |     | <span class='neutral'>  ///    heightPrice</span>
 298 |     | <span class='neutral'>  ///</span>
 299 | *   | <span class='executed'>  function height(</span>
 300 |     | <span class='neutral'>    uint256 pointer</span>
 301 |     | <span class='neutral'>  ) internal pure returns (</span>
 302 | *   | <span class='executed'>    X15 value</span>
 303 |     | <span class='neutral'>  ) {</span>
 304 |     | <span class='neutral'>    assembly {</span>
 305 |     | <span class='neutral'>      // We move &#39;2&#39; bytes backward to read the slot whose most significant</span>
 306 |     | <span class='neutral'>      // &#39;16&#39; bits host &#39;height&#39;.</span>
 307 |     | <span class='neutral'>      //</span>
 308 |     | <span class='neutral'>      //    pointer - 2</span>
 309 |     | <span class='neutral'>      //   /</span>
 310 |     | <span class='neutral'>      //  |</span>
 311 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 312 |     | <span class='neutral'>      //  |  | 8 byte |          27 byte          |          27 byte          |</span>
 313 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 314 |     | <span class='neutral'>      //  |  |        |                           |</span>
 315 |     | <span class='neutral'>      //  |  |        |                            \</span>
 316 |     | <span class='neutral'>      //  |  |        |                             sqrtInversePrice</span>
 317 |     | <span class='neutral'>      //  |  |         \</span>
 318 |     | <span class='neutral'>      //  |  |          sqrtPrice</span>
 319 |     | <span class='neutral'>      //  |   \</span>
 320 |     | <span class='neutral'>      //  |    logPrice</span>
 321 |     | <span class='neutral'>      //   \</span>
 322 |     | <span class='neutral'>      //    heightPrice</span>
 323 |     | <span class='neutral'>      //</span>
 324 |     | <span class='neutral'>      // Then we shift the content by &#39;240&#39; bits to the right in order to get</span>
 325 |     | <span class='neutral'>      // &#39;height&#39;.</span>
 326 |     | <span class='neutral'>      //</span>
 327 |     | <span class='neutral'>      // The subtraction is safe, because the pointer refer to a price with</span>
 328 |     | <span class='neutral'>      // height and therefore its value is not less than &#39;2&#39;.</span>
 329 | *   | <span class='executed'>      value := shr(240, mload(sub(pointer, 2)))</span>
 330 |     | <span class='neutral'>    }</span>
 331 |     | <span class='neutral'>  }</span>
 332 |     | <span class='neutral'></span>
 333 |     | <span class='neutral'>  /// @notice Returns the logarithm of a price given its memory pointer with</span>
 334 |     | <span class='neutral'>  /// the following layout:</span>
 335 |     | <span class='neutral'>  ///</span>
 336 |     | <span class='neutral'>  ///       pointer</span>
 337 |     | <span class='neutral'>  ///      /</span>
 338 |     | <span class='neutral'>  ///     |</span>
 339 |     | <span class='neutral'>  ///  +--+--------+---------------------------+---------------------------+</span>
 340 |     | <span class='neutral'>  ///  |  | 8 byte |          27 byte          |          27 byte          |</span>
 341 |     | <span class='neutral'>  ///  +--+--------+---------------------------+---------------------------+</span>
 342 |     | <span class='neutral'>  ///  |  |        |                           |</span>
 343 |     | <span class='neutral'>  ///  |  |        |                            \</span>
 344 |     | <span class='neutral'>  ///  |  |        |                             sqrtInversePrice</span>
 345 |     | <span class='neutral'>  ///  |  |         \</span>
 346 |     | <span class='neutral'>  ///  |  |          sqrtPrice</span>
 347 |     | <span class='neutral'>  ///  |   \</span>
 348 |     | <span class='neutral'>  ///  |    logPrice</span>
 349 |     | <span class='neutral'>  ///   \</span>
 350 |     | <span class='neutral'>  ///    heightPrice</span>
 351 |     | <span class='neutral'>  ///</span>
 352 | *   | <span class='executed'>  function log(</span>
 353 |     | <span class='neutral'>    uint256 pointer</span>
 354 |     | <span class='neutral'>  ) internal pure returns (</span>
 355 | *   | <span class='executed'>    X59 logPrice</span>
 356 |     | <span class='neutral'>  ) {</span>
 357 |     | <span class='neutral'>    assembly {</span>
 358 |     | <span class='neutral'>      // The given pointer refers to the slot whose most significant &#39;64&#39; bits</span>
 359 |     | <span class='neutral'>      // host &#39;logPrice&#39;. We read this slot and then we shift the content by</span>
 360 |     | <span class='neutral'>      // &#39;192&#39; bits to the right in order to get &#39;logPrice&#39;.</span>
 361 | *   | <span class='executed'>      logPrice := shr(192, mload(pointer))</span>
 362 |     | <span class='neutral'>    }</span>
 363 |     | <span class='neutral'>  }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>  /// @notice Returns the &#39;sqrtPrice&#39; or &#39;sqrtInversePrice&#39; given a memory </span>
 366 |     | <span class='neutral'>  /// pointer with the following layout:</span>
 367 |     | <span class='neutral'>  ///</span>
 368 |     | <span class='neutral'>  ///       pointer</span>
 369 |     | <span class='neutral'>  ///      /</span>
 370 |     | <span class='neutral'>  ///     |</span>
 371 |     | <span class='neutral'>  ///  +--+--------+---------------------------+---------------------------+</span>
 372 |     | <span class='neutral'>  ///  |  | 8 byte |          27 byte          |          27 byte          |</span>
 373 |     | <span class='neutral'>  ///  +--+--------+---------------------------+---------------------------+</span>
 374 |     | <span class='neutral'>  ///  |  |        |                           |</span>
 375 |     | <span class='neutral'>  ///  |  |        |                            \</span>
 376 |     | <span class='neutral'>  ///  |  |        |                             sqrtInversePrice</span>
 377 |     | <span class='neutral'>  ///  |  |         \</span>
 378 |     | <span class='neutral'>  ///  |  |          sqrtPrice</span>
 379 |     | <span class='neutral'>  ///  |   \</span>
 380 |     | <span class='neutral'>  ///  |    logPrice</span>
 381 |     | <span class='neutral'>  ///   \</span>
 382 |     | <span class='neutral'>  ///    heightPrice</span>
 383 |     | <span class='neutral'>  ///</span>
 384 | *   | <span class='executed'>  function sqrt(</span>
 385 |     | <span class='neutral'>    uint256 pointer,</span>
 386 |     | <span class='neutral'>    bool inverse</span>
 387 |     | <span class='neutral'>  ) internal pure returns (</span>
 388 | *   | <span class='executed'>    X216 value</span>
 389 |     | <span class='neutral'>  ) {</span>
 390 |     | <span class='neutral'>    assembly {</span>
 391 |     | <span class='neutral'>      // If &#39;inverse == true&#39; then we move &#39;35&#39; bytes forward to read the slot</span>
 392 |     | <span class='neutral'>      // whose most significant &#39;216&#39; bits host &#39;sqrtPriceInverse&#39;.</span>
 393 |     | <span class='neutral'>      //</span>
 394 |     | <span class='neutral'>      //                                  pointer + 35</span>
 395 |     | <span class='neutral'>      //                                         \</span>
 396 |     | <span class='neutral'>      //                                          |</span>
 397 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 398 |     | <span class='neutral'>      //  |  | 8 byte |          27 byte          |          27 byte          |</span>
 399 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 400 |     | <span class='neutral'>      //  |  |        |                           |</span>
 401 |     | <span class='neutral'>      //  |  |        |                            \</span>
 402 |     | <span class='neutral'>      //  |  |        |                             sqrtInversePrice</span>
 403 |     | <span class='neutral'>      //  |  |         \</span>
 404 |     | <span class='neutral'>      //  |  |          sqrtPrice</span>
 405 |     | <span class='neutral'>      //  |   \</span>
 406 |     | <span class='neutral'>      //  |    logPrice</span>
 407 |     | <span class='neutral'>      //   \</span>
 408 |     | <span class='neutral'>      //    heightPrice</span>
 409 |     | <span class='neutral'>      //</span>
 410 |     | <span class='neutral'>      // Then we shift the content by &#39;40&#39; bits to the right in order to get</span>
 411 |     | <span class='neutral'>      // &#39;sqrtPriceInverse&#39;.</span>
 412 |     | <span class='neutral'>      //</span>
 413 |     | <span class='neutral'>      // If &#39;inverse == false&#39; then we move &#39;8&#39; bytes forward to read the slot</span>
 414 |     | <span class='neutral'>      // whose most significant &#39;216&#39; bits host &#39;sqrtPrice&#39;.</span>
 415 |     | <span class='neutral'>      //</span>
 416 |     | <span class='neutral'>      //      pointer + 8</span>
 417 |     | <span class='neutral'>      //             \</span>
 418 |     | <span class='neutral'>      //              |</span>
 419 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 420 |     | <span class='neutral'>      //  |  | 8 byte |          27 byte          |          27 byte          |</span>
 421 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 422 |     | <span class='neutral'>      //  |  |        |                           |</span>
 423 |     | <span class='neutral'>      //  |  |        |                            \</span>
 424 |     | <span class='neutral'>      //  |  |        |                             sqrtInversePrice</span>
 425 |     | <span class='neutral'>      //  |  |         \</span>
 426 |     | <span class='neutral'>      //  |  |          sqrtPrice</span>
 427 |     | <span class='neutral'>      //  |   \</span>
 428 |     | <span class='neutral'>      //  |    logPrice</span>
 429 |     | <span class='neutral'>      //   \</span>
 430 |     | <span class='neutral'>      //    heightPrice</span>
 431 |     | <span class='neutral'>      //</span>
 432 |     | <span class='neutral'>      // Then we shift the content by &#39;40&#39; bits to the right in order to get</span>
 433 |     | <span class='neutral'>      // &#39;sqrtPrice&#39;.</span>
 434 |     | <span class='neutral'>      //</span>
 435 |     | <span class='neutral'>      // The additions and the multiplication are safe because </span>
 436 |     | <span class='neutral'>      // &#39;iszero(inverse)&#39; is a boolean.</span>
 437 | *   | <span class='executed'>      value := shr(</span>
 438 | *   | <span class='executed'>        40,</span>
 439 | *   | <span class='executed'>        mload(</span>
 440 | *   | <span class='executed'>          add(</span>
 441 | *   | <span class='executed'>            sub(35, mul(27, iszero(inverse))), // inverse ? 35 : 8</span>
 442 | *   | <span class='executed'>            pointer</span>
 443 |     | <span class='neutral'>          )</span>
 444 |     | <span class='neutral'>        )</span>
 445 |     | <span class='neutral'>      )</span>
 446 |     | <span class='neutral'>    }</span>
 447 |     | <span class='neutral'>  }</span>
 448 |     | <span class='neutral'></span>
 449 |     | <span class='neutral'>  /// @notice Copies a price from one memory pointer to another each with the </span>
 450 |     | <span class='neutral'>  /// following layout:</span>
 451 |     | <span class='neutral'>  ///</span>
 452 |     | <span class='neutral'>  ///  pointer</span>
 453 |     | <span class='neutral'>  ///     |</span>
 454 |     | <span class='neutral'>  ///     +--------+---------------------------+---------------------------+</span>
 455 |     | <span class='neutral'>  ///     | 8 byte |          27 byte          |          27 byte          |</span>
 456 |     | <span class='neutral'>  ///     +--------+---------------------------+---------------------------+</span>
 457 |     | <span class='neutral'>  ///     |        |                           |</span>
 458 |     | <span class='neutral'>  ///     |        |                            \</span>
 459 |     | <span class='neutral'>  ///     |        |                             sqrtInversePrice</span>
 460 |     | <span class='neutral'>  ///     |         \</span>
 461 |     | <span class='neutral'>  ///     |          sqrtPrice</span>
 462 |     | <span class='neutral'>  ///      \</span>
 463 |     | <span class='neutral'>  ///       logPrice</span>
 464 |     | <span class='neutral'>  ///</span>
 465 |     | <span class='neutral'>  function copyPrice(</span>
 466 |     | <span class='neutral'>    uint256 pointer0,</span>
 467 |     | <span class='neutral'>    uint256 pointer1</span>
 468 |     | <span class='neutral'>  ) internal pure {</span>
 469 |     | <span class='neutral'>    assembly {</span>
 470 |     | <span class='neutral'>      // Each price contains &#39;62&#39; bytes which is copied from one place to the</span>
 471 |     | <span class='neutral'>      // next.</span>
 472 |     | <span class='neutral'>      mcopy(pointer0, pointer1, 62)</span>
 473 |     | <span class='neutral'>    }</span>
 474 |     | <span class='neutral'>  }</span>
 475 |     | <span class='neutral'> </span>
 476 |     | <span class='neutral'>  /// @notice Copies a price with height from one memory pointer to another</span>
 477 |     | <span class='neutral'>  /// each with the following layout:</span>
 478 |     | <span class='neutral'>  ///</span>
 479 |     | <span class='neutral'>  ///       pointer</span>
 480 |     | <span class='neutral'>  ///      /</span>
 481 |     | <span class='neutral'>  ///     |</span>
 482 |     | <span class='neutral'>  ///  +--+--------+---------------------------+---------------------------+</span>
 483 |     | <span class='neutral'>  ///  |  | 8 byte |          27 byte          |          27 byte          |</span>
 484 |     | <span class='neutral'>  ///  +--+--------+---------------------------+---------------------------+</span>
 485 |     | <span class='neutral'>  ///  |  |        |                           |</span>
 486 |     | <span class='neutral'>  ///  |  |        |                            \</span>
 487 |     | <span class='neutral'>  ///  |  |        |                             sqrtInversePrice</span>
 488 |     | <span class='neutral'>  ///  |  |         \</span>
 489 |     | <span class='neutral'>  ///  |  |          sqrtPrice</span>
 490 |     | <span class='neutral'>  ///  |   \</span>
 491 |     | <span class='neutral'>  ///  |    logPrice</span>
 492 |     | <span class='neutral'>  ///   \</span>
 493 |     | <span class='neutral'>  ///    heightPrice</span>
 494 |     | <span class='neutral'>  ///</span>
 495 |     | <span class='neutral'>  function copyPriceWithHeight(</span>
 496 |     | <span class='neutral'>    uint256 pointer0,</span>
 497 |     | <span class='neutral'>    uint256 pointer1</span>
 498 |     | <span class='neutral'>  ) internal pure {</span>
 499 |     | <span class='neutral'>    assembly {</span>
 500 |     | <span class='neutral'>      // Each price contains &#39;64&#39; bytes which is copied from one place to the</span>
 501 |     | <span class='neutral'>      // next. We move two bytes backward to point to the beginning of &#39;height&#39;</span>
 502 |     | <span class='neutral'>      // as opposed to the end of &#39;height&#39;:</span>
 503 |     | <span class='neutral'>      //</span>
 504 |     | <span class='neutral'>      //    pointer</span>
 505 |     | <span class='neutral'>      //   /</span>
 506 |     | <span class='neutral'>      //  |</span>
 507 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 508 |     | <span class='neutral'>      //  |  | 8 byte |          27 byte          |          27 byte          |</span>
 509 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 510 |     | <span class='neutral'>      //  |  |        |                           |</span>
 511 |     | <span class='neutral'>      //  |  |        |                            \</span>
 512 |     | <span class='neutral'>      //  |  |        |                             sqrtInversePrice</span>
 513 |     | <span class='neutral'>      //  |  |         \</span>
 514 |     | <span class='neutral'>      //  |  |          sqrtPrice</span>
 515 |     | <span class='neutral'>      //  |   \</span>
 516 |     | <span class='neutral'>      //  |    logPrice</span>
 517 |     | <span class='neutral'>      //   \</span>
 518 |     | <span class='neutral'>      //    heightPrice</span>
 519 |     | <span class='neutral'>      //</span>
 520 |     | <span class='neutral'>      // The subtractions are safe, because both pointers refer to prices with</span>
 521 |     | <span class='neutral'>      // height and therefore their values are not less than &#39;2&#39;.</span>
 522 |     | <span class='neutral'>      mcopy(sub(pointer0, 2), sub(pointer1, 2), 64)</span>
 523 |     | <span class='neutral'>    }</span>
 524 |     | <span class='neutral'>  }</span>
 525 |     | <span class='neutral'></span>
 526 |     | <span class='neutral'>  /// @notice Given the memory pointer for a pair of prices with height, this</span>
 527 |     | <span class='neutral'>  /// function reads the corresponding horizontal and vertical coordinates.</span>
 528 |     | <span class='neutral'>  /// &#39;pointer&#39; refers to the first price and &#39;pointer + 64&#39; refers to the</span>
 529 |     | <span class='neutral'>  /// second one.</span>
 530 | *   | <span class='executed'>  function segment(</span>
 531 |     | <span class='neutral'>    uint256 pointer</span>
 532 |     | <span class='neutral'>  ) internal pure returns (</span>
 533 | *   | <span class='executed'>    X59 b0,</span>
 534 | *   | <span class='executed'>    X59 b1,</span>
 535 | *   | <span class='executed'>    X15 c0,</span>
 536 | *   | <span class='executed'>    X15 c1</span>
 537 |     | <span class='neutral'>  ) {</span>
 538 | *   | <span class='executed'>    c0 = pointer.height();</span>
 539 | *   | <span class='executed'>    b0 = pointer.log();</span>
 540 |     | <span class='neutral'></span>
 541 |     | <span class='neutral'>    // We move &#39;64&#39; bytes forward to point to the second price.</span>
 542 |     | <span class='neutral'>    unchecked {</span>
 543 | *   | <span class='executed'>      pointer += 64;</span>
 544 |     | <span class='neutral'>    }</span>
 545 |     | <span class='neutral'></span>
 546 | *   | <span class='executed'>    c1 = pointer.height();</span>
 547 | *   | <span class='executed'>    b1 = pointer.log();</span>
 548 |     | <span class='neutral'>  }</span>
 549 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/Tag.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {X59} from &quot;./X59.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>// Type &#39;Tag&#39; may refer to any of the followings:</span>
   7 |     | <span class='neutral'>//</span>
   8 |     | <span class='neutral'>// - Native token corresponding to &#39;Tag.wrap(0)&#39;.</span>
   9 |     | <span class='neutral'>//</span>
  10 |     | <span class='neutral'>// - An ERC-20 address, i.e., &#39;Tag.wrap(uint256(uint160(tokenAddress)))&#39;.</span>
  11 |     | <span class='neutral'>//</span>
  12 |     | <span class='neutral'>// - An ERC-1155 token whose value is determined by hashing token address and</span>
  13 |     | <span class='neutral'>// token ID, i.e., </span>
  14 |     | <span class='neutral'>// &#39;Tag.wrap(uint256(keccak256(abi.encodePacked(tokenAddress, tokenId))))&#39;.</span>
  15 |     | <span class='neutral'>//</span>
  16 |     | <span class='neutral'>// - An ERC-6909 token whose value is determined by hashing token address and</span>
  17 |     | <span class='neutral'>// token ID, i.e., </span>
  18 |     | <span class='neutral'>// &#39;Tag.wrap(uint256(keccak256(abi.encodePacked(tokenAddress, tokenId))))&#39;.</span>
  19 |     | <span class='neutral'>//</span>
  20 |     | <span class='neutral'>// - A nofeeswap position whose value is determined by hashing, poolId and</span>
  21 |     | <span class='neutral'>// min/max position boundaries, i.e., </span>
  22 |     | <span class='neutral'>// &#39;Tag.wrap(uint256(keccak256(abi.encodePacked(</span>
  23 |     | <span class='neutral'>//    poolId,</span>
  24 |     | <span class='neutral'>//    qMin,</span>
  25 |     | <span class='neutral'>//    qMax</span>
  26 |     | <span class='neutral'>//  ))))&#39;.</span>
  27 |     | <span class='neutral'>//</span>
  28 |     | <span class='neutral'>type Tag is uint256;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>Tag constant native = Tag.wrap(0);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>using {equals as ==, notEqual as !=} for Tag global;</span>
  33 |     | <span class='neutral'>using {lessThan as &lt;, greaterThan as &gt;} for Tag global;</span>
  34 |     | <span class='neutral'>using {</span>
  35 |     | <span class='neutral'>  lessThanOrEqualTo as &lt;=,</span>
  36 |     | <span class='neutral'>  greaterThanOrEqualTo as &gt;=</span>
  37 |     | <span class='neutral'>} for Tag global;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>function equals(</span>
  40 |     | <span class='neutral'>  Tag value0,</span>
  41 |     | <span class='neutral'>  Tag value1</span>
  42 |     | <span class='neutral'>) pure returns (</span>
  43 |     | <span class='neutral'>  bool result</span>
  44 |     | <span class='neutral'>) {</span>
  45 |     | <span class='neutral'>  assembly {</span>
  46 |     | <span class='neutral'>    result := eq(value0, value1)</span>
  47 |     | <span class='neutral'>  }</span>
  48 |     | <span class='neutral'>}</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>function notEqual(</span>
  51 |     | <span class='neutral'>  Tag value0,</span>
  52 |     | <span class='neutral'>  Tag value1</span>
  53 |     | <span class='neutral'>) pure returns (</span>
  54 |     | <span class='neutral'>  bool result</span>
  55 |     | <span class='neutral'>) {</span>
  56 |     | <span class='neutral'>  return !(value0 == value1);</span>
  57 |     | <span class='neutral'>}</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>function lessThan(</span>
  60 |     | <span class='neutral'>  Tag value0,</span>
  61 |     | <span class='neutral'>  Tag value1</span>
  62 |     | <span class='neutral'>) pure returns (</span>
  63 |     | <span class='neutral'>  bool result</span>
  64 |     | <span class='neutral'>) {</span>
  65 |     | <span class='neutral'>  assembly {</span>
  66 |     | <span class='neutral'>    result := lt(value0, value1)</span>
  67 |     | <span class='neutral'>  }</span>
  68 |     | <span class='neutral'>}</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>function greaterThan(</span>
  71 |     | <span class='neutral'>  Tag value0,</span>
  72 |     | <span class='neutral'>  Tag value1</span>
  73 |     | <span class='neutral'>) pure returns (</span>
  74 |     | <span class='neutral'>  bool result</span>
  75 |     | <span class='neutral'>) {</span>
  76 |     | <span class='neutral'>  assembly {</span>
  77 |     | <span class='neutral'>    result := gt(value0, value1)</span>
  78 |     | <span class='neutral'>  }</span>
  79 |     | <span class='neutral'>}</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>function lessThanOrEqualTo(</span>
  82 |     | <span class='neutral'>  Tag value0,</span>
  83 |     | <span class='neutral'>  Tag value1</span>
  84 |     | <span class='neutral'>) pure returns (</span>
  85 |     | <span class='neutral'>  bool result</span>
  86 |     | <span class='neutral'>) {</span>
  87 |     | <span class='neutral'>  return !(value0 &gt; value1);</span>
  88 |     | <span class='neutral'>}</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>function greaterThanOrEqualTo(</span>
  91 |     | <span class='neutral'>  Tag value0,</span>
  92 |     | <span class='neutral'>  Tag value1</span>
  93 |     | <span class='neutral'>) pure returns (</span>
  94 |     | <span class='neutral'>  bool result</span>
  95 |     | <span class='neutral'>) {</span>
  96 |     | <span class='neutral'>  return !(value0 &lt; value1);</span>
  97 |     | <span class='neutral'>}</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>library TagLibrary {</span>
 100 |     | <span class='neutral'>  /// @notice Generates a tag given an ERC-20 address.</span>
 101 |     | <span class='neutral'>  /// @param tokenAddress The given ERC-20 address to be transformed to the</span>
 102 |     | <span class='neutral'>  /// type &#39;tag&#39;.</span>
 103 |     | <span class='neutral'>  function tag(</span>
 104 |     | <span class='neutral'>    address tokenAddress</span>
 105 |     | <span class='neutral'>  ) internal pure returns (</span>
 106 |     | <span class='neutral'>    Tag tokenTag</span>
 107 |     | <span class='neutral'>  ) {</span>
 108 |     | <span class='neutral'>    assembly {</span>
 109 |     | <span class='neutral'>      tokenTag := and(tokenAddress, sub(shl(160, 1), 1))</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'>  }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>  /// @notice Generates a tag given a multi-token address and tokenId.</span>
 114 |     | <span class='neutral'>  /// @param tokenAddress The given multi-token address to be transformed to</span>
 115 |     | <span class='neutral'>  /// the type &#39;tag&#39;.</span>
 116 |     | <span class='neutral'>  /// @param tokenId The given multi-token id to be used to generate &#39;tag&#39;.</span>
 117 |     | <span class='neutral'>  function tag(</span>
 118 |     | <span class='neutral'>    address tokenAddress,</span>
 119 |     | <span class='neutral'>    uint256 tokenId</span>
 120 |     | <span class='neutral'>  ) internal pure returns (</span>
 121 |     | <span class='neutral'>    Tag tokenTag</span>
 122 |     | <span class='neutral'>  ) {</span>
 123 |     | <span class='neutral'>    assembly {</span>
 124 |     | <span class='neutral'>      mstore(20, tokenAddress)</span>
 125 |     | <span class='neutral'>      mstore(0, tokenId)</span>
 126 |     | <span class='neutral'>      tokenTag := keccak256(0, 52)</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'>  }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>  /// @notice Generates a tag given a nofeeswap liquidity position.</span>
 131 |     | <span class='neutral'>  /// @param poolId The pool identifier hosting this liquidity position.</span>
 132 |     | <span class='neutral'>  /// @param qMin Equal to &#39;(2 ** 59) * log(pMin)&#39; where &#39;pMin&#39; is the left</span>
 133 |     | <span class='neutral'>  /// position boundary.</span>
 134 |     | <span class='neutral'>  /// @param qMax Equal to &#39;(2 ** 59) * log(pMax)&#39; where &#39;pMax&#39; is the right</span>
 135 |     | <span class='neutral'>  /// position boundary.</span>
 136 |     | <span class='neutral'>  function tag(</span>
 137 |     | <span class='neutral'>    uint256 poolId,</span>
 138 |     | <span class='neutral'>    X59 qMin,</span>
 139 |     | <span class='neutral'>    X59 qMax</span>
 140 |     | <span class='neutral'>  ) internal pure returns (</span>
 141 |     | <span class='neutral'>    Tag positionTag</span>
 142 |     | <span class='neutral'>  ) {</span>
 143 |     | <span class='neutral'>    assembly {</span>
 144 |     | <span class='neutral'>      // Cache the free memory pointer so that the third memory slot can be</span>
 145 |     | <span class='neutral'>      // used for hashing.</span>
 146 |     | <span class='neutral'>      let freeMemoryPointer := mload(0x40)</span>
 147 |     | <span class='neutral'>      mstore(64, qMax)</span>
 148 |     | <span class='neutral'>      mstore(32, qMin)</span>
 149 |     | <span class='neutral'>      mstore(0, poolId)</span>
 150 |     | <span class='neutral'>      positionTag := keccak256(0, 96)</span>
 151 |     | <span class='neutral'>      // The &#39;freeMemoryPointer&#39; is restored.</span>
 152 |     | <span class='neutral'>      mstore(0x40, freeMemoryPointer)</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'>  }</span>
 155 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/X111.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {X208} from &quot;./X208.sol&quot;;</span>
   5 |     | <span class='neutral'>import {X216} from &quot;./X216.sol&quot;;</span>
   6 |     | <span class='neutral'>import {FullMathLibrary} from &quot;./FullMath.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// Type &#39;X111&#39; is dedicated to growth and liquidity values.</span>
   9 |     | <span class='neutral'>type X111 is int256;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>using X111Library for X111 global;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>X111 constant zeroX111 = X111.wrap(0);</span>
  14 |     | <span class='neutral'>X111 constant oneX111 = X111.wrap(1 &lt;&lt; 111);</span>
  15 |     | <span class='neutral'>X111 constant maxGrowth = X111.wrap(1 &lt;&lt; 127);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>using {equals as ==, notEqual as !=} for X111 global;</span>
  18 |     | <span class='neutral'>using {lessThan as &lt;, greaterThan as &gt;} for X111 global;</span>
  19 |     | <span class='neutral'>using {</span>
  20 |     | <span class='neutral'>  lessThanOrEqualTo as &lt;=,</span>
  21 |     | <span class='neutral'>  greaterThanOrEqualTo as &gt;=</span>
  22 |     | <span class='neutral'>} for X111 global;</span>
  23 |     | <span class='neutral'>using {add as +, sub as -} for X111 global;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>function equals(</span>
  26 |     | <span class='neutral'>  X111 value0,</span>
  27 |     | <span class='neutral'>  X111 value1</span>
  28 |     | <span class='neutral'>) pure returns (</span>
  29 |     | <span class='neutral'>  bool result</span>
  30 |     | <span class='neutral'>) {</span>
  31 |     | <span class='neutral'>  assembly {</span>
  32 |     | <span class='neutral'>    result := eq(value0, value1)</span>
  33 |     | <span class='neutral'>  }</span>
  34 |     | <span class='neutral'>}</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>function notEqual(</span>
  37 |     | <span class='neutral'>  X111 value0,</span>
  38 |     | <span class='neutral'>  X111 value1</span>
  39 |     | <span class='neutral'>) pure returns (</span>
  40 |     | <span class='neutral'>  bool result</span>
  41 |     | <span class='neutral'>) {</span>
  42 |     | <span class='neutral'>  return !(value0 == value1);</span>
  43 |     | <span class='neutral'>}</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>function lessThan(</span>
  46 |     | <span class='neutral'>  X111 value0,</span>
  47 |     | <span class='neutral'>  X111 value1</span>
  48 |     | <span class='neutral'>) pure returns (</span>
  49 |     | <span class='neutral'>  bool result</span>
  50 |     | <span class='neutral'>) {</span>
  51 |     | <span class='neutral'>  assembly {</span>
  52 |     | <span class='neutral'>    result := slt(value0, value1)</span>
  53 |     | <span class='neutral'>  }</span>
  54 |     | <span class='neutral'>}</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>function greaterThan(</span>
  57 |     | <span class='neutral'>  X111 value0,</span>
  58 |     | <span class='neutral'>  X111 value1</span>
  59 |     | <span class='neutral'>) pure returns (</span>
  60 |     | <span class='neutral'>  bool result</span>
  61 |     | <span class='neutral'>) {</span>
  62 |     | <span class='neutral'>  assembly {</span>
  63 |     | <span class='neutral'>    result := sgt(value0, value1)</span>
  64 |     | <span class='neutral'>  }</span>
  65 |     | <span class='neutral'>}</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>function lessThanOrEqualTo(</span>
  68 |     | <span class='neutral'>  X111 value0,</span>
  69 |     | <span class='neutral'>  X111 value1</span>
  70 |     | <span class='neutral'>) pure returns (</span>
  71 |     | <span class='neutral'>  bool result</span>
  72 |     | <span class='neutral'>) {</span>
  73 |     | <span class='neutral'>  return !(value0 &gt; value1);</span>
  74 |     | <span class='neutral'>}</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>function greaterThanOrEqualTo(</span>
  77 |     | <span class='neutral'>  X111 value0,</span>
  78 |     | <span class='neutral'>  X111 value1</span>
  79 |     | <span class='neutral'>) pure returns (</span>
  80 |     | <span class='neutral'>  bool result</span>
  81 |     | <span class='neutral'>) {</span>
  82 |     | <span class='neutral'>  return !(value0 &lt; value1);</span>
  83 |     | <span class='neutral'>}</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
  86 |     | <span class='neutral'>function add(</span>
  87 |     | <span class='neutral'>  X111 value0,</span>
  88 |     | <span class='neutral'>  X111 value1</span>
  89 |     | <span class='neutral'>) pure returns (</span>
  90 |     | <span class='neutral'>  X111 result</span>
  91 |     | <span class='neutral'>) {</span>
  92 |     | <span class='neutral'>  assembly {</span>
  93 |     | <span class='neutral'>    result := add(value0, value1)</span>
  94 |     | <span class='neutral'>  }</span>
  95 |     | <span class='neutral'>}</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
  98 |     | <span class='neutral'>function sub(</span>
  99 |     | <span class='neutral'>  X111 value0,</span>
 100 |     | <span class='neutral'>  X111 value1</span>
 101 |     | <span class='neutral'>) pure returns (</span>
 102 |     | <span class='neutral'>  X111 result</span>
 103 |     | <span class='neutral'>) {</span>
 104 |     | <span class='neutral'>  assembly {</span>
 105 |     | <span class='neutral'>    result := sub(value0, value1)</span>
 106 |     | <span class='neutral'>  }</span>
 107 |     | <span class='neutral'>}</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>function min(</span>
 110 |     | <span class='neutral'>  X111 value0,</span>
 111 |     | <span class='neutral'>  X111 value1</span>
 112 |     | <span class='neutral'>) pure returns (</span>
 113 |     | <span class='neutral'>  X111 result</span>
 114 |     | <span class='neutral'>) {</span>
 115 |     | <span class='neutral'>  return (value0 &lt; value1) ? value0 : value1;</span>
 116 |     | <span class='neutral'>}</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>function max(</span>
 119 |     | <span class='neutral'>  X111 value0,</span>
 120 |     | <span class='neutral'>  X111 value1</span>
 121 |     | <span class='neutral'>) pure returns (</span>
 122 |     | <span class='neutral'>  X111 result</span>
 123 |     | <span class='neutral'>) {</span>
 124 |     | <span class='neutral'>  return (value0 &lt; value1) ? value1 : value0;</span>
 125 |     | <span class='neutral'>}</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='unexecuted'>library X111Library {</span>
 128 |     | <span class='neutral'>  /// @notice Calculates &#39;liquidity == growth * shares&#39;.</span>
 129 |     | <span class='neutral'>  /// &#39;growth&#39; should not be less than &#39;oneX111&#39;.</span>
 130 |     | <span class='neutral'>  /// &#39;growth&#39; should be less than or equal to &#39;1 &lt;&lt; 127&#39;.</span>
 131 |     | <span class='neutral'>  /// &#39;shares&#39; should be less than &#39;1 &lt;&lt; 127&#39;</span>
 132 |     | <span class='neutral'>  function times(</span>
 133 |     | <span class='neutral'>    X111 growth,</span>
 134 |     | <span class='neutral'>    uint256 shares</span>
 135 |     | <span class='neutral'>  ) internal pure returns (</span>
 136 |     | <span class='neutral'>    X111 liquidity</span>
 137 |     | <span class='neutral'>  ) {</span>
 138 |     | <span class='neutral'>    assembly {</span>
 139 |     | <span class='neutral'>      // Multiplication is safe because of the input requirements.</span>
 140 |     | <span class='neutral'>      liquidity := mul(growth, shares)</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'>  }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>  /// @notice Calculates &#39;liquidity == growth * shares&#39;.</span>
 145 |     | <span class='neutral'>  /// &#39;growth&#39; should not be less than &#39;oneX111&#39;.</span>
 146 |     | <span class='neutral'>  /// &#39;growth&#39; should be less than or equal to &#39;1 &lt;&lt; 127&#39;.</span>
 147 |     | <span class='neutral'>  /// &#39;shares&#39; should be greater than &#39;- (1 &lt;&lt; 127)&#39;.</span>
 148 |     | <span class='neutral'>  /// &#39;shares&#39; should be less than &#39;1 &lt;&lt; 127&#39;.</span>
 149 |     | <span class='neutral'>  function times(</span>
 150 |     | <span class='neutral'>    X111 growth,</span>
 151 |     | <span class='neutral'>    int256 shares</span>
 152 |     | <span class='neutral'>  ) internal pure returns (</span>
 153 |     | <span class='neutral'>    X111 liquidity</span>
 154 |     | <span class='neutral'>  ) {</span>
 155 |     | <span class='neutral'>    assembly {</span>
 156 |     | <span class='neutral'>      // Multiplication is safe because of the input requirements.</span>
 157 |     | <span class='neutral'>      liquidity := mul(growth, shares)</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'>  }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>  /// @notice Calculates</span>
 162 |     | <span class='neutral'>  /// &#39;(value * multiplier) / ((2 ** 119) * exp(-8))&#39;</span>
 163 |     | <span class='neutral'>  /// &#39;growth&#39; should not be less than &#39;oneX111&#39;.</span>
 164 |     | <span class='neutral'>  /// &#39;growth&#39; should be less than or equal to &#39;1 &lt;&lt; 127&#39;.</span>
 165 |     | <span class='neutral'>  /// &#39;multiplier&#39; should be non-negative and less than &#39;oneX216&#39;.</span>
 166 |     | <span class='neutral'>  function mulDivByExpInv8(</span>
 167 |     | <span class='neutral'>    X111 growth,</span>
 168 |     | <span class='neutral'>    X216 multiplier</span>
 169 |     | <span class='neutral'>  ) internal pure returns (</span>
 170 |     | <span class='neutral'>    X208 product</span>
 171 |     | <span class='neutral'>  ) {</span>
 172 |     | <span class='neutral'>    // Both castings are safe because</span>
 173 |     | <span class='neutral'>    // &#39;growth &gt;= oneX111&#39; and &#39;multiplier &gt;= zeroX216&#39;</span>
 174 |     | <span class='neutral'>    ( ,  , uint256 q2) = FullMathLibrary.mul768(</span>
 175 |     | <span class='neutral'>      // (2 ** 244) * exp(8)</span>
 176 |     | <span class='neutral'>      0xBA4F53EA38636F85F007042540AE8EF33225E9A7AB4F4473A86D4A8FDD1A5B82,</span>
 177 |     | <span class='neutral'>      // The shift is safe because &#39;oneX111 &lt;= growth &lt;= (1 &lt;&lt; 127)&#39;</span>
 178 |     | <span class='neutral'>      uint256(X111.unwrap(growth)) &lt;&lt; 110,</span>
 179 |     | <span class='neutral'>      // The shift is safe because &#39;0 &lt;= multiplier &lt;= oneX216&#39;</span>
 180 |     | <span class='neutral'>      uint256(X216.unwrap(multiplier)) &lt;&lt; 39</span>
 181 |     | <span class='neutral'>    );</span>
 182 |     | <span class='neutral'>    product = X208.wrap(q2);</span>
 183 |     | <span class='neutral'>  }</span>
 184 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/X127.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {X23} from &quot;./X23.sol&quot;;</span>
   5 |     | <span class='neutral'>import {X216} from &quot;./X216.sol&quot;;</span>
   6 |     | <span class='neutral'>import {SafeAddFailed} from &quot;./Errors.sol&quot;;</span>
   7 |     | <span class='neutral'>import {FullMathLibrary} from &quot;./FullMath.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>// Type &#39;X127&#39; is used for &#39;sqrtOffset&#39;, &#39;sqrtInverseOffset&#39;, and token</span>
  10 |     | <span class='neutral'>// amounts.</span>
  11 |     | <span class='neutral'>type X127 is int256;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>using X127Library for X127 global;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>X127 constant oneX127 = X127.wrap(1 &lt;&lt; 127);</span>
  16 |     | <span class='neutral'>X127 constant zeroX127 = X127.wrap(0);</span>
  17 |     | <span class='neutral'>X127 constant epsilonX127 = X127.wrap(1);</span>
  18 |     | <span class='neutral'>// 104 = 231 - 127 digits of non-decimal</span>
  19 |     | <span class='neutral'>X127 constant accruedMax = X127.wrap((1 &lt;&lt; 231) - 1);</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>using {equals as ==, notEquals as !=} for X127 global;</span>
  22 |     | <span class='neutral'>using {lessThan as &lt;, greaterThan as &gt;} for X127 global;</span>
  23 |     | <span class='neutral'>using {</span>
  24 |     | <span class='neutral'>  lessThanOrEqualTo as &lt;=,</span>
  25 |     | <span class='neutral'>  greaterThanOrEqualTo as &gt;=</span>
  26 |     | <span class='neutral'>} for X127 global;</span>
  27 |     | <span class='neutral'>using {add as +, sub as -, safeAdd as &amp;} for X127 global;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>function equals(</span>
  30 |     | <span class='neutral'>  X127 value0,</span>
  31 |     | <span class='neutral'>  X127 value1</span>
  32 |     | <span class='neutral'>) pure returns (</span>
  33 |     | <span class='neutral'>  bool result</span>
  34 |     | <span class='neutral'>) {</span>
  35 |     | <span class='neutral'>  assembly {</span>
  36 |     | <span class='neutral'>    result := eq(value0, value1)</span>
  37 |     | <span class='neutral'>  }</span>
  38 |     | <span class='neutral'>}</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>function notEquals(</span>
  41 |     | <span class='neutral'>  X127 value0,</span>
  42 |     | <span class='neutral'>  X127 value1</span>
  43 |     | <span class='neutral'>) pure returns (</span>
  44 |     | <span class='neutral'>  bool result</span>
  45 |     | <span class='neutral'>) {</span>
  46 |     | <span class='neutral'>  return !(value0 == value1);</span>
  47 |     | <span class='neutral'>}</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>function lessThan(</span>
  50 |     | <span class='neutral'>  X127 value0,</span>
  51 |     | <span class='neutral'>  X127 value1</span>
  52 |     | <span class='neutral'>) pure returns (</span>
  53 |     | <span class='neutral'>  bool result</span>
  54 |     | <span class='neutral'>) {</span>
  55 |     | <span class='neutral'>  assembly {</span>
  56 |     | <span class='neutral'>    result := slt(value0, value1)</span>
  57 |     | <span class='neutral'>  }</span>
  58 |     | <span class='neutral'>}</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>function greaterThan(</span>
  61 |     | <span class='neutral'>  X127 value0,</span>
  62 |     | <span class='neutral'>  X127 value1</span>
  63 |     | <span class='neutral'>) pure returns (</span>
  64 |     | <span class='neutral'>  bool result</span>
  65 |     | <span class='neutral'>) {</span>
  66 |     | <span class='neutral'>  assembly {</span>
  67 |     | <span class='neutral'>    result := sgt(value0, value1)</span>
  68 |     | <span class='neutral'>  }</span>
  69 |     | <span class='neutral'>}</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>function lessThanOrEqualTo(</span>
  72 |     | <span class='neutral'>  X127 value0,</span>
  73 |     | <span class='neutral'>  X127 value1</span>
  74 |     | <span class='neutral'>) pure returns (</span>
  75 |     | <span class='neutral'>  bool result</span>
  76 |     | <span class='neutral'>) {</span>
  77 |     | <span class='neutral'>  return !(value0 &gt; value1);</span>
  78 |     | <span class='neutral'>}</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>function greaterThanOrEqualTo(</span>
  81 |     | <span class='neutral'>  X127 value0,</span>
  82 |     | <span class='neutral'>  X127 value1</span>
  83 |     | <span class='neutral'>) pure returns (</span>
  84 |     | <span class='neutral'>  bool result</span>
  85 |     | <span class='neutral'>) {</span>
  86 |     | <span class='neutral'>  return !(value0 &lt; value1);</span>
  87 |     | <span class='neutral'>}</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
  90 |     | <span class='neutral'>function add(</span>
  91 |     | <span class='neutral'>  X127 value0,</span>
  92 |     | <span class='neutral'>  X127 value1</span>
  93 |     | <span class='neutral'>) pure returns (</span>
  94 |     | <span class='neutral'>  X127 result</span>
  95 |     | <span class='neutral'>) {</span>
  96 |     | <span class='neutral'>  assembly {</span>
  97 |     | <span class='neutral'>    result := add(value0, value1)</span>
  98 |     | <span class='neutral'>  }</span>
  99 |     | <span class='neutral'>}</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
 102 |     | <span class='neutral'>function sub(</span>
 103 |     | <span class='neutral'>  X127 value0,</span>
 104 |     | <span class='neutral'>  X127 value1</span>
 105 |     | <span class='neutral'>) pure returns (</span>
 106 |     | <span class='neutral'>  X127 result</span>
 107 |     | <span class='neutral'>) {</span>
 108 |     | <span class='neutral'>  assembly {</span>
 109 |     | <span class='neutral'>    result := sub(value0, value1)</span>
 110 |     | <span class='neutral'>  }</span>
 111 |     | <span class='neutral'>}</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>// Throws in case of overflow/underflow.</span>
 114 |     | <span class='neutral'>function safeAdd(</span>
 115 |     | <span class='neutral'>  X127 value0,</span>
 116 |     | <span class='neutral'>  X127 value1</span>
 117 |     | <span class='neutral'>) pure returns (</span>
 118 |     | <span class='neutral'>  X127 result</span>
 119 |     | <span class='neutral'>) {</span>
 120 |     | <span class='neutral'>  // We first add the two values unsafely and then examine the result.</span>
 121 |     | <span class='neutral'>  result = value0 + value1;</span>
 122 |     | <span class='neutral'>  </span>
 123 |     | <span class='neutral'>  // The following requirement is satisfied if and only if &#39;result&#39; does not</span>
 124 |     | <span class='neutral'>  // overflow or underflow. Because,</span>
 125 |     | <span class='neutral'>  // - overflow implies that both &#39;value0&#39; and &#39;value1&#39; are positive but</span>
 126 |     | <span class='neutral'>  // &#39;result&#39; is negative which contradicts the following requirement.</span>
 127 |     | <span class='neutral'>  // - underflow implies that both &#39;value0&#39; and &#39;value1&#39; are negative but</span>
 128 |     | <span class='neutral'>  // &#39;result&#39; is positive which contradicts the following requirement as well.</span>
 129 |     | <span class='neutral'>  // - Lastly, in case of no overflow/underflow, the following requirement is</span>
 130 |     | <span class='neutral'>  // trivial.</span>
 131 |     | <span class='neutral'>  require(</span>
 132 |     | <span class='neutral'>    (value1 &gt;= zeroX127) == (result &gt;= value0),</span>
 133 |     | <span class='neutral'>    SafeAddFailed(value0, value1)</span>
 134 |     | <span class='neutral'>  );</span>
 135 |     | <span class='neutral'>}</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>function min(</span>
 138 |     | <span class='neutral'>  X127 value0,</span>
 139 |     | <span class='neutral'>  X127 value1</span>
 140 |     | <span class='neutral'>) pure returns (</span>
 141 |     | <span class='neutral'>  X127 result</span>
 142 |     | <span class='neutral'>) {</span>
 143 |     | <span class='neutral'>  return (value0 &lt; value1) ? value0 : value1;</span>
 144 |     | <span class='neutral'>}</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>function max(</span>
 147 |     | <span class='neutral'>  X127 value0,</span>
 148 |     | <span class='neutral'>  X127 value1</span>
 149 |     | <span class='neutral'>) pure returns (</span>
 150 |     | <span class='neutral'>  X127 result</span>
 151 |     | <span class='neutral'>) {</span>
 152 |     | <span class='neutral'>  return (value0 &lt; value1) ? value1 : value0;</span>
 153 |     | <span class='neutral'>}</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='unexecuted'>library X127Library {</span>
 156 |     | <span class='neutral'>  /// @notice Calculates &#39;value * multiplier / (2 ** 23)&#39;</span>
 157 |     | <span class='neutral'>  /// &#39;value&#39; should be non-negative.</span>
 158 |     | <span class='neutral'>  /// &#39;value * multiplier&#39; should be less than &#39;2 ** 256&#39;.</span>
 159 |     | <span class='neutral'>  function times(</span>
 160 |     | <span class='neutral'>    X127 value,</span>
 161 |     | <span class='neutral'>    X23 multiplier</span>
 162 |     | <span class='neutral'>  ) internal pure returns (</span>
 163 |     | <span class='neutral'>    X127 product</span>
 164 |     | <span class='neutral'>  ) {</span>
 165 |     | <span class='neutral'>    // The multiplication is safe because of the input requirement.</span>
 166 |     | <span class='neutral'>    assembly {</span>
 167 |     | <span class='neutral'>      product := shr(23, mul(value, multiplier))</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'>  }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>  /// @notice Calculates &#39;(value * numerator) / denominator&#39;</span>
 172 |     | <span class='neutral'>  /// Overflow and division by zero should be avoided externally.</span>
 173 |     | <span class='neutral'>  /// All input values should be non-negative.</span>
 174 |     | <span class='neutral'>  function mulDiv(</span>
 175 |     | <span class='neutral'>    X127 value,</span>
 176 |     | <span class='neutral'>    X216 numerator,</span>
 177 |     | <span class='neutral'>    X216 denominator</span>
 178 |     | <span class='neutral'>  ) internal pure returns (</span>
 179 |     | <span class='neutral'>    X127 result</span>
 180 |     | <span class='neutral'>  ) {</span>
 181 |     | <span class='neutral'>    result = X127.wrap(</span>
 182 |     | <span class='neutral'>      // Casting to &#39;int256&#39; is safe because overflow is handled externally.</span>
 183 |     | <span class='neutral'>      int256(</span>
 184 |     | <span class='neutral'>        // The three castings are safe because of the input requirement.</span>
 185 |     | <span class='neutral'>        // The requirements of &#39;mulDiv&#39; are met because overflow is handled</span>
 186 |     | <span class='neutral'>        // externally.</span>
 187 |     | <span class='neutral'>        FullMathLibrary.mulDiv(</span>
 188 |     | <span class='neutral'>          uint256(X127.unwrap(value)),</span>
 189 |     | <span class='neutral'>          uint256(X216.unwrap(numerator)),</span>
 190 |     | <span class='neutral'>          uint256(X216.unwrap(denominator))</span>
 191 |     | <span class='neutral'>        )</span>
 192 |     | <span class='neutral'>      )</span>
 193 |     | <span class='neutral'>    );</span>
 194 |     | <span class='neutral'>  }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>  /// @notice Transforms type X127 to the integer &#39;value / (2 ** 127)&#39; while</span>
 197 |     | <span class='neutral'>  /// maintaining the sign. Rounds towards negative infinity.</span>
 198 |     | <span class='neutral'>  function toInteger(</span>
 199 |     | <span class='neutral'>    X127 value</span>
 200 |     | <span class='neutral'>  ) internal pure returns (</span>
 201 |     | <span class='neutral'>    int256 result</span>
 202 |     | <span class='neutral'>  ) {</span>
 203 |     | <span class='neutral'>    assembly {</span>
 204 |     | <span class='neutral'>      result := sar(127, value)</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'>  }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>  /// @notice Transforms type X127 to the integer &#39;value / (2 ** 127)&#39; while</span>
 209 |     | <span class='neutral'>  /// maintaining the sign.</span>
 210 |     | <span class='neutral'>  /// Rounds towards positive infinity.</span>
 211 |     | <span class='neutral'>  /// &#39;value&#39; should be greater than &#39;- 2 ** 255&#39;.</span>
 212 |     | <span class='neutral'>  function toIntegerRoundUp(</span>
 213 |     | <span class='neutral'>    X127 value</span>
 214 |     | <span class='neutral'>  ) internal pure returns (</span>
 215 |     | <span class='neutral'>    int256 result</span>
 216 |     | <span class='neutral'>  ) {</span>
 217 |     | <span class='neutral'>    // The inner subtraction is safe because &#39;value &gt; - 2 ** 255&#39;.</span>
 218 |     | <span class='neutral'>    // The outer subtraction is safe because </span>
 219 |     | <span class='neutral'>    // &#39;- 2 ** 128 &lt; (0 - value) / (2 ** 127) &lt; 2 ** 128&#39;</span>
 220 |     | <span class='neutral'>    assembly {</span>
 221 |     | <span class='neutral'>      result := sub(0, sar(127, sub(0, value)))</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'>  }</span>
 224 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/X15.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// Type &#39;X15&#39; is dedicated to the vertical coordinates of the kernel</span>
   5 |     | <span class='neutral'>// breakpoints. The distribution of liquidity within every interval is governed</span>
   6 |     | <span class='neutral'>// by a piecewise linear kernel function. The kernel function is characterized</span>
   7 |     | <span class='neutral'>// by a list of breakpoints given by the pool owner. The vertical coordinate of</span>
   8 |     | <span class='neutral'>// each breakpoint is a number within the interval [0, 1] which is stored in</span>
   9 |     | <span class='neutral'>// &#39;X15&#39; format, with &#39;2 ** 15&#39; representing 1.</span>
  10 |     | <span class='neutral'>type X15 is uint256;</span>
  11 |     | <span class='neutral'></span>
  12 | *   | <span class='executed'>X15 constant zeroX15 = X15.wrap(0);</span>
  13 |     | <span class='unexecuted'>X15 constant oneX15 = X15.wrap(1 &lt;&lt; 15);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>using {equals as ==, notEqual as !=} for X15 global;</span>
  16 |     | <span class='neutral'>using {lessThan as &lt;, greaterThan as &gt;} for X15 global;</span>
  17 |     | <span class='neutral'>using {</span>
  18 |     | <span class='neutral'>  lessThanOrEqualTo as &lt;=,</span>
  19 |     | <span class='neutral'>  greaterThanOrEqualTo as &gt;=</span>
  20 |     | <span class='neutral'>} for X15 global;</span>
  21 |     | <span class='neutral'>using {add as +, sub as -} for X15 global;</span>
  22 |     | <span class='neutral'></span>
  23 | *   | <span class='executed'>function equals(</span>
  24 |     | <span class='neutral'>  X15 value0,</span>
  25 |     | <span class='neutral'>  X15 value1</span>
  26 |     | <span class='neutral'>) pure returns (</span>
  27 | *   | <span class='executed'>  bool result</span>
  28 |     | <span class='neutral'>) {</span>
  29 |     | <span class='neutral'>  assembly {</span>
  30 | *   | <span class='executed'>    result := eq(value0, value1)</span>
  31 |     | <span class='neutral'>  }</span>
  32 |     | <span class='neutral'>}</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>function notEqual(</span>
  35 |     | <span class='neutral'>  X15 value0,</span>
  36 |     | <span class='neutral'>  X15 value1</span>
  37 |     | <span class='neutral'>) pure returns (</span>
  38 |     | <span class='neutral'>  bool result</span>
  39 |     | <span class='neutral'>) {</span>
  40 |     | <span class='neutral'>  return !(value0 == value1);</span>
  41 |     | <span class='neutral'>}</span>
  42 |     | <span class='neutral'></span>
  43 | *   | <span class='executed'>function lessThan(</span>
  44 |     | <span class='neutral'>  X15 value0,</span>
  45 |     | <span class='neutral'>  X15 value1</span>
  46 |     | <span class='neutral'>) pure returns (</span>
  47 | *   | <span class='executed'>  bool result</span>
  48 |     | <span class='neutral'>) {</span>
  49 |     | <span class='neutral'>  assembly {</span>
  50 | *   | <span class='executed'>    result := lt(value0, value1)</span>
  51 |     | <span class='neutral'>  }</span>
  52 |     | <span class='neutral'>}</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>function greaterThan(</span>
  55 |     | <span class='neutral'>  X15 value0,</span>
  56 |     | <span class='neutral'>  X15 value1</span>
  57 |     | <span class='neutral'>) pure returns (</span>
  58 |     | <span class='unexecuted'>  bool result</span>
  59 |     | <span class='neutral'>) {</span>
  60 |     | <span class='neutral'>  assembly {</span>
  61 |     | <span class='unexecuted'>    result := gt(value0, value1)</span>
  62 |     | <span class='neutral'>  }</span>
  63 |     | <span class='neutral'>}</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>function lessThanOrEqualTo(</span>
  66 |     | <span class='neutral'>  X15 value0,</span>
  67 |     | <span class='neutral'>  X15 value1</span>
  68 |     | <span class='neutral'>) pure returns (</span>
  69 |     | <span class='unexecuted'>  bool result</span>
  70 |     | <span class='neutral'>) {</span>
  71 |     | <span class='unexecuted'>  return !(value0 &gt; value1);</span>
  72 |     | <span class='neutral'>}</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>function greaterThanOrEqualTo(</span>
  75 |     | <span class='neutral'>  X15 value0,</span>
  76 |     | <span class='neutral'>  X15 value1</span>
  77 |     | <span class='neutral'>) pure returns (</span>
  78 |     | <span class='neutral'>  bool result</span>
  79 |     | <span class='neutral'>) {</span>
  80 |     | <span class='neutral'>  return !(value0 &lt; value1);</span>
  81 |     | <span class='neutral'>}</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>// Overflow should be avoided externally.</span>
  84 |     | <span class='unexecuted'>function add(</span>
  85 |     | <span class='neutral'>  X15 value0,</span>
  86 |     | <span class='neutral'>  X15 value1</span>
  87 |     | <span class='neutral'>) pure returns (</span>
  88 |     | <span class='unexecuted'>  X15 result</span>
  89 |     | <span class='neutral'>) {</span>
  90 |     | <span class='neutral'>  assembly {</span>
  91 |     | <span class='unexecuted'>    result := add(value0, value1)</span>
  92 |     | <span class='neutral'>  }</span>
  93 |     | <span class='neutral'>}</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>// Underflow should be avoided externally.</span>
  96 | *   | <span class='executed'>function sub(</span>
  97 |     | <span class='neutral'>  X15 value0,</span>
  98 |     | <span class='neutral'>  X15 value1</span>
  99 |     | <span class='neutral'>) pure returns (</span>
 100 | *   | <span class='executed'>  X15 result</span>
 101 |     | <span class='neutral'>) {</span>
 102 |     | <span class='neutral'>  assembly {</span>
 103 | *   | <span class='executed'>    result := sub(value0, value1)</span>
 104 |     | <span class='neutral'>  }</span>
 105 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/X208.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {X111} from &quot;./X111.sol&quot;;</span>
   5 |     | <span class='neutral'>import {X216} from &quot;./X216.sol&quot;;</span>
   6 |     | <span class='neutral'>import {FullMathLibrary} from &quot;./FullMath.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// Type &#39;X208&#39; is dedicated to growth multipliers.</span>
   9 |     | <span class='neutral'>type X208 is uint256;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>using X208Library for X208 global;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>X208 constant zeroX208 = X208.wrap(0);</span>
  14 |     | <span class='neutral'>// (2 ** 208) * exp(+8)</span>
  15 |     | <span class='neutral'>X208 constant exp8X208 = X208.wrap(</span>
  16 |     | <span class='neutral'>  0x000000000BA4F53EA38636F85F007042540AE8EF33225E9A7AB4F4473A86D4A8</span>
  17 |     | <span class='neutral'>);</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>using {equals as ==, notEquals as !=} for X208 global;</span>
  20 |     | <span class='neutral'>using {lessThan as &lt;, greaterThan as &gt;} for X208 global;</span>
  21 |     | <span class='neutral'>using {</span>
  22 |     | <span class='neutral'>  lessThanOrEqualTo as &lt;=,</span>
  23 |     | <span class='neutral'>  greaterThanOrEqualTo as &gt;=</span>
  24 |     | <span class='neutral'>} for X208 global;</span>
  25 |     | <span class='neutral'>using {add as +, sub as -} for X208 global;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>function equals(</span>
  28 |     | <span class='neutral'>  X208 value0,</span>
  29 |     | <span class='neutral'>  X208 value1</span>
  30 |     | <span class='neutral'>) pure returns (</span>
  31 |     | <span class='neutral'>  bool result</span>
  32 |     | <span class='neutral'>) {</span>
  33 |     | <span class='neutral'>  assembly {</span>
  34 |     | <span class='neutral'>    result := eq(value0, value1)</span>
  35 |     | <span class='neutral'>  }</span>
  36 |     | <span class='neutral'>}</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>function notEquals(</span>
  39 |     | <span class='neutral'>  X208 value0,</span>
  40 |     | <span class='neutral'>  X208 value1</span>
  41 |     | <span class='neutral'>) pure returns (</span>
  42 |     | <span class='neutral'>  bool result</span>
  43 |     | <span class='neutral'>) {</span>
  44 |     | <span class='neutral'>  return !(value0 == value1);</span>
  45 |     | <span class='neutral'>}</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>function lessThan(</span>
  48 |     | <span class='neutral'>  X208 value0,</span>
  49 |     | <span class='neutral'>  X208 value1</span>
  50 |     | <span class='neutral'>) pure returns (</span>
  51 |     | <span class='neutral'>  bool result</span>
  52 |     | <span class='neutral'>) {</span>
  53 |     | <span class='neutral'>  assembly {</span>
  54 |     | <span class='neutral'>    result := lt(value0, value1)</span>
  55 |     | <span class='neutral'>  }</span>
  56 |     | <span class='neutral'>}</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>function greaterThan(</span>
  59 |     | <span class='neutral'>  X208 value0,</span>
  60 |     | <span class='neutral'>  X208 value1</span>
  61 |     | <span class='neutral'>) pure returns (</span>
  62 |     | <span class='neutral'>  bool result</span>
  63 |     | <span class='neutral'>) {</span>
  64 |     | <span class='neutral'>  assembly {</span>
  65 |     | <span class='neutral'>    result := gt(value0, value1)</span>
  66 |     | <span class='neutral'>  }</span>
  67 |     | <span class='neutral'>}</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>function lessThanOrEqualTo(</span>
  70 |     | <span class='neutral'>  X208 value0,</span>
  71 |     | <span class='neutral'>  X208 value1</span>
  72 |     | <span class='neutral'>) pure returns (</span>
  73 |     | <span class='neutral'>  bool result</span>
  74 |     | <span class='neutral'>) {</span>
  75 |     | <span class='neutral'>  return !(value0 &gt; value1);</span>
  76 |     | <span class='neutral'>}</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>function greaterThanOrEqualTo(</span>
  79 |     | <span class='neutral'>  X208 value0,</span>
  80 |     | <span class='neutral'>  X208 value1</span>
  81 |     | <span class='neutral'>) pure returns (</span>
  82 |     | <span class='neutral'>  bool result</span>
  83 |     | <span class='neutral'>) {</span>
  84 |     | <span class='neutral'>  return !(value0 &lt; value1);</span>
  85 |     | <span class='neutral'>}</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>// Overflow should be avoided externally.</span>
  88 |     | <span class='neutral'>function add(</span>
  89 |     | <span class='neutral'>  X208 value0,</span>
  90 |     | <span class='neutral'>  X208 value1</span>
  91 |     | <span class='neutral'>) pure returns (</span>
  92 |     | <span class='neutral'>  X208 result</span>
  93 |     | <span class='neutral'>) {</span>
  94 |     | <span class='neutral'>  assembly {</span>
  95 |     | <span class='neutral'>    result := add(value0, value1)</span>
  96 |     | <span class='neutral'>  }</span>
  97 |     | <span class='neutral'>}</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>// Underflow should be avoided externally.</span>
 100 |     | <span class='neutral'>function sub(</span>
 101 |     | <span class='neutral'>  X208 value0,</span>
 102 |     | <span class='neutral'>  X208 value1</span>
 103 |     | <span class='neutral'>) pure returns (</span>
 104 |     | <span class='neutral'>  X208 result</span>
 105 |     | <span class='neutral'>) {</span>
 106 |     | <span class='neutral'>  assembly {</span>
 107 |     | <span class='neutral'>    result := sub(value0, value1)</span>
 108 |     | <span class='neutral'>  }</span>
 109 |     | <span class='neutral'>}</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>library X208Library {</span>
 112 |     | <span class='neutral'>  /// @notice Calculates &#39;(value * numerator) / denominator&#39;</span>
 113 |     | <span class='neutral'>  /// Overflow and division by zero should be avoided externally.</span>
 114 |     | <span class='neutral'>  /// &#39;numerator&#39; and &#39;denominator&#39; values should be non-negative.</span>
 115 |     | <span class='neutral'>  function mulDiv(</span>
 116 |     | <span class='neutral'>    X208 value,</span>
 117 |     | <span class='neutral'>    X216 numerator,</span>
 118 |     | <span class='neutral'>    X216 denominator</span>
 119 |     | <span class='neutral'>  ) internal pure returns (</span>
 120 |     | <span class='neutral'>    X208 result</span>
 121 |     | <span class='neutral'>  ) {</span>
 122 |     | <span class='neutral'>    // Both castings are safe because of the non-negative requirement on both</span>
 123 |     | <span class='neutral'>    // &#39;numerator&#39; and &#39;denominator&#39;.</span>
 124 |     | <span class='neutral'>    result = X208.wrap(</span>
 125 |     | <span class='neutral'>      FullMathLibrary.mulDiv(</span>
 126 |     | <span class='neutral'>        X208.unwrap(value),</span>
 127 |     | <span class='neutral'>        uint256(X216.unwrap(numerator)),</span>
 128 |     | <span class='neutral'>        uint256(X216.unwrap(denominator))</span>
 129 |     | <span class='neutral'>      )</span>
 130 |     | <span class='neutral'>    );</span>
 131 |     | <span class='neutral'>  }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>  /// @notice Calculates</span>
 134 |     | <span class='neutral'>  /// &#39;(value * multiplier) / ((2 ** 313) * exp(-8))&#39;</span>
 135 |     | <span class='neutral'>  /// &#39;multiplier&#39; should be non-negative.</span>
 136 |     | <span class='neutral'>  function mulDivByExpInv8(</span>
 137 |     | <span class='neutral'>    X208 value,</span>
 138 |     | <span class='neutral'>    X216 multiplier</span>
 139 |     | <span class='neutral'>  ) internal pure returns (</span>
 140 |     | <span class='neutral'>    X111 product</span>
 141 |     | <span class='neutral'>  ) {</span>
 142 |     | <span class='neutral'>    ( ,  , uint256 q2) = FullMathLibrary.mul768(</span>
 143 |     | <span class='neutral'>      // (2 ** 244) * exp(8)</span>
 144 |     | <span class='neutral'>      0xBA4F53EA38636F85F007042540AE8EF33225E9A7AB4F4473A86D4A8FDD1A5B82,</span>
 145 |     | <span class='neutral'>      X208.unwrap(value),</span>
 146 |     | <span class='neutral'>      // Casting is safe because of the non-negative requirement on</span>
 147 |     | <span class='neutral'>      // &#39;multiplier&#39;.</span>
 148 |     | <span class='neutral'>      uint256(X216.unwrap(multiplier))</span>
 149 |     | <span class='neutral'>    );</span>
 150 |     | <span class='neutral'>    unchecked {</span>
 151 |     | <span class='neutral'>      // Casting is safe because &#39;q2 &gt;&gt; 45&#39; never exceeds &#39;type(int256).max&#39;.</span>
 152 |     | <span class='neutral'>      // &#39;45 == 244 + 208 + 216 - 512 - 111&#39;</span>
 153 |     | <span class='neutral'>      product = X111.wrap(int256(q2 &gt;&gt; 45));</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'>  }</span>
 156 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/X216.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {FullMathLibrary} from &quot;./FullMath.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>// Type &#39;X216&#39; is dedicated to integrals and sqrt of price values.</span>
   7 |     | <span class='neutral'>type X216 is int256;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>using X216Library for X216 global;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>X216 constant oneX216 = X216.wrap(1 &lt;&lt; 216);</span>
  12 | *   | <span class='executed'>X216 constant zeroX216 = X216.wrap(0);</span>
  13 |     | <span class='neutral'>X216 constant epsilonX216 = X216.wrap(1);</span>
  14 |     | <span class='neutral'>// (2 ** 216) * exp(-8)</span>
  15 |     | <span class='neutral'>X216 constant expInverse8X216 = X216.wrap(</span>
  16 | *   | <span class='executed'>  0x00000000000015FC21041027ACBBFCD46780FEE71EAD23FBCB7F4A81E58767EF</span>
  17 |     | <span class='neutral'>);</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>using {equals as ==, notEquals as !=} for X216 global;</span>
  20 |     | <span class='neutral'>using {lessThan as &lt;, greaterThan as &gt;} for X216 global;</span>
  21 |     | <span class='neutral'>using {</span>
  22 |     | <span class='neutral'>  lessThanOrEqualTo as &lt;=,</span>
  23 |     | <span class='neutral'>  greaterThanOrEqualTo as &gt;=</span>
  24 |     | <span class='neutral'>} for X216 global;</span>
  25 |     | <span class='neutral'>using {add as +, sub as -} for X216 global;</span>
  26 |     | <span class='neutral'>using {mul as *, cheapMul as &amp;} for X216 global;</span>
  27 |     | <span class='neutral'>using {mulDivByExpInv8 as %, mulDivByExpInv16 as ^} for X216 global;</span>
  28 |     | <span class='neutral'></span>
  29 | *   | <span class='executed'>function equals(</span>
  30 |     | <span class='neutral'>  X216 value0,</span>
  31 |     | <span class='neutral'>  X216 value1</span>
  32 |     | <span class='neutral'>) pure returns (</span>
  33 | *   | <span class='executed'>  bool result</span>
  34 |     | <span class='neutral'>) {</span>
  35 |     | <span class='neutral'>  assembly {</span>
  36 | *   | <span class='executed'>    result := eq(value0, value1)</span>
  37 |     | <span class='neutral'>  }</span>
  38 |     | <span class='neutral'>}</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>function notEquals(</span>
  41 |     | <span class='neutral'>  X216 value0,</span>
  42 |     | <span class='neutral'>  X216 value1</span>
  43 |     | <span class='neutral'>) pure returns (</span>
  44 |     | <span class='neutral'>  bool result</span>
  45 |     | <span class='neutral'>) {</span>
  46 |     | <span class='neutral'>  return !(value0 == value1);</span>
  47 |     | <span class='neutral'>}</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>function lessThan(</span>
  50 |     | <span class='neutral'>  X216 value0,</span>
  51 |     | <span class='neutral'>  X216 value1</span>
  52 |     | <span class='neutral'>) pure returns (</span>
  53 |     | <span class='neutral'>  bool result</span>
  54 |     | <span class='neutral'>) {</span>
  55 |     | <span class='neutral'>  assembly {</span>
  56 |     | <span class='neutral'>    result := slt(value0, value1)</span>
  57 |     | <span class='neutral'>  }</span>
  58 |     | <span class='neutral'>}</span>
  59 |     | <span class='neutral'></span>
  60 | *   | <span class='executed'>function greaterThan(</span>
  61 |     | <span class='neutral'>  X216 value0,</span>
  62 |     | <span class='neutral'>  X216 value1</span>
  63 |     | <span class='neutral'>) pure returns (</span>
  64 | *   | <span class='executed'>  bool result</span>
  65 |     | <span class='neutral'>) {</span>
  66 |     | <span class='neutral'>  assembly {</span>
  67 | *   | <span class='executed'>    result := sgt(value0, value1)</span>
  68 |     | <span class='neutral'>  }</span>
  69 |     | <span class='neutral'>}</span>
  70 |     | <span class='neutral'></span>
  71 | *   | <span class='executed'>function lessThanOrEqualTo(</span>
  72 |     | <span class='neutral'>  X216 value0,</span>
  73 |     | <span class='neutral'>  X216 value1</span>
  74 |     | <span class='neutral'>) pure returns (</span>
  75 | *   | <span class='executed'>  bool result</span>
  76 |     | <span class='neutral'>) {</span>
  77 | *   | <span class='executed'>  return !(value0 &gt; value1);</span>
  78 |     | <span class='neutral'>}</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>function greaterThanOrEqualTo(</span>
  81 |     | <span class='neutral'>  X216 value0,</span>
  82 |     | <span class='neutral'>  X216 value1</span>
  83 |     | <span class='neutral'>) pure returns (</span>
  84 |     | <span class='neutral'>  bool result</span>
  85 |     | <span class='neutral'>) {</span>
  86 |     | <span class='neutral'>  return !(value0 &lt; value1);</span>
  87 |     | <span class='neutral'>}</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
  90 |     | <span class='unexecuted'>function add(</span>
  91 |     | <span class='neutral'>  X216 value0,</span>
  92 |     | <span class='neutral'>  X216 value1</span>
  93 |     | <span class='neutral'>) pure returns (</span>
  94 |     | <span class='unexecuted'>  X216 result</span>
  95 |     | <span class='neutral'>) {</span>
  96 |     | <span class='neutral'>  assembly {</span>
  97 |     | <span class='unexecuted'>    result := add(value0, value1)</span>
  98 |     | <span class='neutral'>  }</span>
  99 |     | <span class='neutral'>}</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
 102 | *   | <span class='executed'>function sub(</span>
 103 |     | <span class='neutral'>  X216 value0,</span>
 104 |     | <span class='neutral'>  X216 value1</span>
 105 |     | <span class='neutral'>) pure returns (</span>
 106 | *   | <span class='executed'>  X216 result</span>
 107 |     | <span class='neutral'>) {</span>
 108 |     | <span class='neutral'>  assembly {</span>
 109 | *   | <span class='executed'>    result := sub(value0, value1)</span>
 110 |     | <span class='neutral'>  }</span>
 111 |     | <span class='neutral'>}</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>// Calculates &#39;(value0 * value1) / (2 ** 216)&#39;.</span>
 114 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
 115 |     | <span class='neutral'>// Both values should be greater than &#39;- 2 ** 255&#39;.</span>
 116 | *   | <span class='executed'>function mul(</span>
 117 |     | <span class='neutral'>  X216 value0,</span>
 118 |     | <span class='neutral'>  X216 value1</span>
 119 |     | <span class='neutral'>) pure returns (</span>
 120 | *   | <span class='executed'>  X216 result</span>
 121 |     | <span class='neutral'>) {</span>
 122 |     | <span class='neutral'>  // Let &#39;s := value0 * value1 - (2 ** 256 - 1) * p&#39;</span>
 123 |     | <span class='neutral'>  // Let &#39;r := value0 * value1 - (2 ** 216) * q&#39;</span>
 124 |     | <span class='neutral'>  // Then &#39;s - r == (2 ** 216) * q&#39; [modulo &#39;2 ** 256 - 1&#39;]</span>
 125 |     | <span class='neutral'>  // Then &#39;q == (2 ** 40) * (s - r)&#39; [modulo &#39;2 ** 256 - 1&#39;]</span>
 126 |     | <span class='neutral'>  assembly {</span>
 127 | *   | <span class='executed'>    result := mulmod(</span>
 128 | *   | <span class='executed'>      addmod(</span>
 129 |     | <span class='neutral'>        // We account for the additional term &#39;2 ** 256&#39; in two&#39;s complement</span>
 130 |     | <span class='neutral'>        // representation by subtracting &#39;slt(value, 0)&#39;. Because if a two&#39;s</span>
 131 |     | <span class='neutral'>        // complement representation &#39;value&#39; correspond to a negative number,</span>
 132 |     | <span class='neutral'>        // we have:</span>
 133 |     | <span class='neutral'>        //</span>
 134 |     | <span class='neutral'>        // &#39;value - 2 ** 256 == value - 1&#39; [modulo 2 ** 256 - 1]</span>
 135 |     | <span class='neutral'>        //</span>
 136 |     | <span class='neutral'>        // Both subtractions are safe due to the input requirement.</span>
 137 | *   | <span class='executed'>        mulmod(</span>
 138 | *   | <span class='executed'>          sub(value0, slt(value0, 0)),</span>
 139 | *   | <span class='executed'>          sub(value1, slt(value1, 0)),</span>
 140 | *   | <span class='executed'>          not(0)</span>
 141 |     | <span class='neutral'>        ), // s</span>
 142 |     | <span class='neutral'>        // Here, we do not need to account for the additional term &#39;2 ** 256&#39;</span>
 143 |     | <span class='neutral'>        // in two&#39;s complement representation because if a two&#39;s complement</span>
 144 |     | <span class='neutral'>        // representation &#39;value&#39; is negative, we have:</span>
 145 |     | <span class='neutral'>        //</span>
 146 |     | <span class='neutral'>        // &#39;value - 2 ** 256 == value&#39; [modulo 2 ** 216]</span>
 147 |     | <span class='neutral'>        //</span>
 148 |     | <span class='neutral'>        // The subtraction is safe because &#39;2 ** 216 &lt; 2 ** 256 - 1&#39;.</span>
 149 | *   | <span class='executed'>        sub(not(0), mulmod(value0, value1, shl(216, 1))), // 0 - r</span>
 150 | *   | <span class='executed'>        not(0)</span>
 151 |     | <span class='neutral'>      ),</span>
 152 | *   | <span class='executed'>      shl(40, 1),</span>
 153 | *   | <span class='executed'>      not(0)</span>
 154 |     | <span class='neutral'>    )</span>
 155 |     | <span class='neutral'>  }</span>
 156 |     | <span class='neutral'>}</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>// Calculates &#39;(value0 * value1) / (2 ** 216)&#39;.</span>
 159 |     | <span class='neutral'>// &#39;value0&#39; and &#39;value1&#39; should be non-negative and less than &#39;oneX216&#39;.</span>
 160 |     | <span class='neutral'>function cheapMul(</span>
 161 |     | <span class='neutral'>  X216 value0,</span>
 162 |     | <span class='neutral'>  X216 value1</span>
 163 |     | <span class='neutral'>) pure returns (</span>
 164 |     | <span class='neutral'>  X216 result</span>
 165 |     | <span class='neutral'>) {</span>
 166 |     | <span class='neutral'>  // Let &#39;s := value0 * value1 - (2 ** 216 - 1) * p&#39;</span>
 167 |     | <span class='neutral'>  // Let &#39;r := value0 * value1 - (2 ** 216) * q&#39;</span>
 168 |     | <span class='neutral'>  // Then &#39;s - r == q&#39; [modulo &#39;2 ** 216 - 1&#39;]</span>
 169 |     | <span class='neutral'>  // Because of the input requirements, &#39;q&#39; does not exceed &#39;2 ** 216 - 1&#39;</span>
 170 |     | <span class='neutral'>  // which concludes that: &#39;s - r == q&#39;.</span>
 171 |     | <span class='neutral'>  assembly {</span>
 172 |     | <span class='neutral'>    result := addmod(</span>
 173 |     | <span class='neutral'>      mulmod(value0, value1, sub(shl(216, 1), 1)), // s</span>
 174 |     | <span class='neutral'>      // The subtraction is safe because the output of &#39;mulmod&#39; does not exceed</span>
 175 |     | <span class='neutral'>      // &#39;2 ** 216 - 1&#39;.</span>
 176 |     | <span class='neutral'>      sub(sub(shl(216, 1), 1), mulmod(value0, value1, shl(216, 1))), // 0 - r</span>
 177 |     | <span class='neutral'>      sub(shl(216, 1), 1)</span>
 178 |     | <span class='neutral'>    )</span>
 179 |     | <span class='neutral'>  }</span>
 180 |     | <span class='neutral'>}</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>// Calculates &#39;(value0 * value1) / ((2 ** 216) * exp(-8))&#39;.</span>
 183 |     | <span class='neutral'>//</span>
 184 |     | <span class='neutral'>// The following approximation is used: &#39;(2 ** 216) * exp(-8) ~= b / a&#39; where</span>
 185 |     | <span class='neutral'>// &#39;a = 0xF8F6376C44&#39; and </span>
 186 |     | <span class='neutral'>// &#39;b = 0x1561650620DABB6A84B684E2A7E5A47CAA0A0905210083F0E3B551AABF84E9&#39;</span>
 187 |     | <span class='neutral'>//</span>
 188 |     | <span class='neutral'>// Overflow should be avoided externally.</span>
 189 |     | <span class='neutral'>// Both values should be non-negative.</span>
 190 |     | <span class='neutral'>// &#39;value0&#39; should be less than &#39;oneX216&#39;.</span>
 191 |     | <span class='neutral'>function mulDivByExpInv8(</span>
 192 |     | <span class='neutral'>  X216 value0,</span>
 193 |     | <span class='neutral'>  X216 value1</span>
 194 |     | <span class='neutral'>) pure returns (</span>
 195 |     | <span class='neutral'>  X216 result</span>
 196 |     | <span class='neutral'>) {</span>
 197 |     | <span class='neutral'>  // Let &#39;s := value0 * value1 * a - (2 ** 256) * p&#39;</span>
 198 |     | <span class='neutral'>  // Let &#39;r := value0 * value1 * a - b * q&#39;</span>
 199 |     | <span class='neutral'>  // Then &#39;s - r == b * q&#39; [modulo &#39;2 ** 256&#39;]</span>
 200 |     | <span class='neutral'>  assembly {</span>
 201 |     | <span class='neutral'>    // Multiplication is safe because of the input requirement:</span>
 202 |     | <span class='neutral'>    // &#39;0 &lt;= value0 &lt; oneX216&#39;.</span>
 203 |     | <span class='neutral'>    result := mul(value0, 0xF8F6376C44)</span>
 204 |     | <span class='neutral'>    result := mul(</span>
 205 |     | <span class='neutral'>      // s - r</span>
 206 |     | <span class='neutral'>      sub(</span>
 207 |     | <span class='neutral'>        // s</span>
 208 |     | <span class='neutral'>        mul(result, value1),</span>
 209 |     | <span class='neutral'>        // r</span>
 210 |     | <span class='neutral'>        mulmod(</span>
 211 |     | <span class='neutral'>          result,</span>
 212 |     | <span class='neutral'>          value1,</span>
 213 |     | <span class='neutral'>          0x1561650620DABB6A84B684E2A7E5A47CAA0A0905210083F0E3B551AABF84E9 // b</span>
 214 |     | <span class='neutral'>        )</span>
 215 |     | <span class='neutral'>      ),</span>
 216 |     | <span class='neutral'>      // modular inverse of &#39;b&#39; modulo &#39;2 ** 256&#39;</span>
 217 |     | <span class='neutral'>      0x28256938C4923FF15AB260970AA81F81C15E6F5EF3AF38DC210569E77DB19359</span>
 218 |     | <span class='neutral'>    )</span>
 219 |     | <span class='neutral'>  }</span>
 220 |     | <span class='neutral'>}</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>// Calculates &#39;(value0 * value1) / ((2 ** 216) * exp(-16))&#39;.</span>
 223 |     | <span class='neutral'>//</span>
 224 |     | <span class='neutral'>// The following approximation is used: &#39;(2 ** 216) * exp(-16) ~= b / a&#39; where</span>
 225 |     | <span class='neutral'>// &#39;a = 0x27D117D7B * 0x2EC3A856&#39; and </span>
 226 |     | <span class='neutral'>// &#39;b = 0xDBB82F7041B890FE67970A62A3568CC34DF9DCB17CC3A2A6A027850E7E3724F9&#39;</span>
 227 |     | <span class='neutral'>//</span>
 228 |     | <span class='neutral'>// Overflow should be avoided externally.</span>
 229 |     | <span class='neutral'>// Both values should be non-negative.</span>
 230 |     | <span class='neutral'>// &#39;value0&#39; and &#39;value1&#39; should be less than &#39;oneX216&#39;.</span>
 231 |     | <span class='neutral'>function mulDivByExpInv16(</span>
 232 |     | <span class='neutral'>  X216 value0,</span>
 233 |     | <span class='neutral'>  X216 value1</span>
 234 |     | <span class='neutral'>) pure returns (</span>
 235 |     | <span class='neutral'>  X216 result</span>
 236 |     | <span class='neutral'>) {</span>
 237 |     | <span class='neutral'>  // Let &#39;s := value0 * value1 * a - (2 ** 256) * p&#39;</span>
 238 |     | <span class='neutral'>  // Let &#39;r := value0 * value1 * a - b * q&#39;</span>
 239 |     | <span class='neutral'>  // Then &#39;s - r == b * q&#39; [modulo &#39;2 ** 256&#39;]</span>
 240 |     | <span class='neutral'>  assembly {</span>
 241 |     | <span class='neutral'>    // Both of the following multiplications are safe because of the input</span>
 242 |     | <span class='neutral'>    // requirements:</span>
 243 |     | <span class='neutral'>    // &#39;0 &lt;= value0 &lt; oneX216&#39;.</span>
 244 |     | <span class='neutral'>    // &#39;0 &lt;= value1 &lt; oneX216&#39;.</span>
 245 |     | <span class='neutral'>    value0 := mul(value0, 0x27D117D7B)</span>
 246 |     | <span class='neutral'>    value1 := mul(value1, 0x2EC3A856)</span>
 247 |     | <span class='neutral'>    result := mul(</span>
 248 |     | <span class='neutral'>      // s - r</span>
 249 |     | <span class='neutral'>      sub(</span>
 250 |     | <span class='neutral'>        // s</span>
 251 |     | <span class='neutral'>        mul(value0, value1),</span>
 252 |     | <span class='neutral'>        // r</span>
 253 |     | <span class='neutral'>        mulmod(</span>
 254 |     | <span class='neutral'>          value0,</span>
 255 |     | <span class='neutral'>          value1,</span>
 256 |     | <span class='neutral'>          // b</span>
 257 |     | <span class='neutral'>          0xDBB82F7041B890FE67970A62A3568CC34DF9DCB17CC3A2A6A027850E7E3724F9</span>
 258 |     | <span class='neutral'>        )</span>
 259 |     | <span class='neutral'>      ),</span>
 260 |     | <span class='neutral'>      // modular inverse of &#39;b&#39; modulo &#39;2 ** 256&#39;</span>
 261 |     | <span class='neutral'>      0x7F6AF8233BADA11DD406B4458454ED9904D7AF796BE7AA4885B23E25B6985D49</span>
 262 |     | <span class='neutral'>    )</span>
 263 |     | <span class='neutral'>  }</span>
 264 |     | <span class='neutral'>}</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>function min(</span>
 267 |     | <span class='neutral'>  X216 value0,</span>
 268 |     | <span class='neutral'>  X216 value1</span>
 269 |     | <span class='neutral'>) pure returns (</span>
 270 |     | <span class='neutral'>  X216 result</span>
 271 |     | <span class='neutral'>) {</span>
 272 |     | <span class='neutral'>  return (value0 &lt; value1) ? value0 : value1;</span>
 273 |     | <span class='neutral'>}</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='neutral'>function max(</span>
 276 |     | <span class='neutral'>  X216 value0,</span>
 277 |     | <span class='neutral'>  X216 value1</span>
 278 |     | <span class='neutral'>) pure returns (</span>
 279 |     | <span class='neutral'>  X216 result</span>
 280 |     | <span class='neutral'>) {</span>
 281 |     | <span class='neutral'>  return (value0 &lt; value1) ? value1 : value0;</span>
 282 |     | <span class='neutral'>}</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>/// @notice Returns the minimum of two unsigned fractions. &#39;0 / 0&#39; is </span>
 285 |     | <span class='neutral'>/// interpreted as infinity. &#39;which == false&#39; and &#39;which == true&#39; indicate</span>
 286 |     | <span class='neutral'>/// &#39;(numerator0, denominator0)&#39; and &#39;(numerator1, denominator1)&#39;,</span>
 287 |     | <span class='neutral'>/// respectively.</span>
 288 |     | <span class='neutral'>/// All four values should be non-negative.</span>
 289 |     | <span class='neutral'>/// At least one &#39;denominator&#39; should be non-zero.</span>
 290 |     | <span class='neutral'>function minFractions(</span>
 291 |     | <span class='neutral'>  X216 numerator0,</span>
 292 |     | <span class='neutral'>  X216 denominator0,</span>
 293 |     | <span class='neutral'>  X216 numerator1,</span>
 294 |     | <span class='neutral'>  X216 denominator1</span>
 295 |     | <span class='neutral'>) pure returns (</span>
 296 |     | <span class='neutral'>  X216 numerator,</span>
 297 |     | <span class='neutral'>  X216 denominator,</span>
 298 |     | <span class='neutral'>  bool which</span>
 299 |     | <span class='neutral'>) {</span>
 300 |     | <span class='neutral'>  if (numerator0 == zeroX216) {</span>
 301 |     | <span class='neutral'>    if (denominator0 == zeroX216) {</span>
 302 |     | <span class='neutral'>      return (numerator1, denominator1, true);</span>
 303 |     | <span class='neutral'>    }</span>
 304 |     | <span class='neutral'>  }</span>
 305 |     | <span class='neutral'>  // Castings are safe because all four values are non-negative.</span>
 306 |     | <span class='neutral'>  (uint256 lsb0, uint256 msb0) = FullMathLibrary.mul512(</span>
 307 |     | <span class='neutral'>    uint256(X216.unwrap(numerator0)),</span>
 308 |     | <span class='neutral'>    uint256(X216.unwrap(denominator1))</span>
 309 |     | <span class='neutral'>  );</span>
 310 |     | <span class='neutral'>  (uint256 lsb1, uint256 msb1) = FullMathLibrary.mul512(</span>
 311 |     | <span class='neutral'>    uint256(X216.unwrap(numerator1)),</span>
 312 |     | <span class='neutral'>    uint256(X216.unwrap(denominator0))</span>
 313 |     | <span class='neutral'>  );</span>
 314 |     | <span class='neutral'>  (numerator, denominator, which) = </span>
 315 |     | <span class='neutral'>    ((msb1 &gt; msb0) || ((msb1 == msb0) &amp;&amp; (lsb1 &gt;= lsb0))) ? </span>
 316 |     | <span class='neutral'>    (numerator0, denominator0, false) : </span>
 317 |     | <span class='neutral'>    (numerator1, denominator1, true);</span>
 318 |     | <span class='neutral'>}</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='unexecuted'>library X216Library {</span>
 321 |     | <span class='neutral'>  /// @notice Calculates &#39;value * exp(1 / (2 ** 60))&#39;.</span>
 322 |     | <span class='neutral'>  /// Overflow should be avoided externally.</span>
 323 |     | <span class='neutral'>  /// &#39;value&#39; should be non-negative.</span>
 324 |     | <span class='neutral'>  function multiplyByExpEpsilon(</span>
 325 |     | <span class='neutral'>    X216 value</span>
 326 |     | <span class='neutral'>  ) internal pure returns (</span>
 327 |     | <span class='neutral'>    X216 result</span>
 328 |     | <span class='neutral'>  ) {</span>
 329 |     | <span class='neutral'>    // Let &#39;a := floor((2 ** 256) * exp(-1 / (2 ** 60)))&#39;</span>
 330 |     | <span class='neutral'>    // Let &#39;r := (2 ** 256) * value - a * q&#39;</span>
 331 |     | <span class='neutral'>    // Let &#39;b := modularInverse(- a, 2 ** 256)&#39;</span>
 332 |     | <span class='neutral'>    // Then &#39;q == b * r&#39; [modulo &#39;2 ** 256&#39;]</span>
 333 |     | <span class='neutral'>    assembly {</span>
 334 |     | <span class='neutral'>      result := mul(</span>
 335 |     | <span class='neutral'>        // r</span>
 336 |     | <span class='neutral'>        mulmod(</span>
 337 |     | <span class='neutral'>          value,</span>
 338 |     | <span class='neutral'>          // We are subtracting by &#39;a&#39; because &#39;2 ** 256&#39; does not fit, which</span>
 339 |     | <span class='neutral'>          // is okay because the multiplication is done modulo &#39;a&#39;.</span>
 340 |     | <span class='neutral'>          // 2 ** 256 - a</span>
 341 |     | <span class='neutral'>          0xFFFFFFFFFFFFFFF8000000000000002AAAAAAAAAAAAAAA001,</span>
 342 |     | <span class='neutral'>          // a</span>
 343 |     | <span class='neutral'>          0xFFFFFFFFFFFFFFF0000000000000007FFFFFFFFFFFFFFD555555555555555FFF</span>
 344 |     | <span class='neutral'>        ),</span>
 345 |     | <span class='neutral'>        // b</span>
 346 |     | <span class='neutral'>        0xAA3ED2381A8B1241D16168FD77EF989ED2B13BE12B716AA23F35ED0E39556001</span>
 347 |     | <span class='neutral'>      )</span>
 348 |     | <span class='neutral'>    }</span>
 349 |     | <span class='neutral'>  }</span>
 350 |     | <span class='neutral'></span>
 351 |     | <span class='neutral'>  /// @notice Calculates &#39;value / exp(1 / (2 ** 60))&#39;.</span>
 352 |     | <span class='neutral'>  /// &#39;value&#39; should be non-negative.</span>
 353 |     | <span class='neutral'>  function divideByExpEpsilon(</span>
 354 |     | <span class='neutral'>    X216 value</span>
 355 |     | <span class='neutral'>  ) internal pure returns (</span>
 356 |     | <span class='neutral'>    X216 result</span>
 357 |     | <span class='neutral'>  ) {</span>
 358 |     | <span class='neutral'>    assembly {</span>
 359 |     | <span class='neutral'>      // Let &#39;a := floor((2 ** 256 - 1) * exp(-1 / (2 ** 60)))&#39;.</span>
 360 |     | <span class='neutral'>      // Let &#39;s := value * a - q * not(0)&#39;.</span>
 361 |     | <span class='neutral'>      // Let &#39;r := value * a&#39;.</span>
 362 |     | <span class='neutral'>      // Then &#39;s - r == - q * not(0) == q&#39;.</span>
 363 |     | <span class='neutral'>      result := sub(</span>
 364 |     | <span class='neutral'>        // s</span>
 365 |     | <span class='neutral'>        mulmod(</span>
 366 |     | <span class='neutral'>          value,</span>
 367 |     | <span class='neutral'>          // a</span>
 368 |     | <span class='neutral'>          0xFFFFFFFFFFFFFFF0000000000000007FFFFFFFFFFFFFFD555555555555555FFE,</span>
 369 |     | <span class='neutral'>          not(0)</span>
 370 |     | <span class='neutral'>        ),</span>
 371 |     | <span class='neutral'>        // r</span>
 372 |     | <span class='neutral'>        mul(</span>
 373 |     | <span class='neutral'>          value,</span>
 374 |     | <span class='neutral'>          // a</span>
 375 |     | <span class='neutral'>          0xFFFFFFFFFFFFFFF0000000000000007FFFFFFFFFFFFFFD555555555555555FFE</span>
 376 |     | <span class='neutral'>        )</span>
 377 |     | <span class='neutral'>      )</span>
 378 |     | <span class='neutral'>    }</span>
 379 |     | <span class='neutral'>  }</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='neutral'>  /// @notice Calculates &#39;(value * numerator) / denominator&#39;</span>
 382 |     | <span class='neutral'>  /// Overflow and division by zero should be avoided externally.</span>
 383 |     | <span class='neutral'>  /// All input values should be non-negative.</span>
 384 |     | <span class='neutral'>  function mulDiv(</span>
 385 |     | <span class='neutral'>    X216 value,</span>
 386 |     | <span class='neutral'>    X216 numerator,</span>
 387 |     | <span class='neutral'>    X216 denominator</span>
 388 |     | <span class='neutral'>  ) internal pure returns (</span>
 389 |     | <span class='neutral'>    X216 result</span>
 390 |     | <span class='neutral'>  ) {</span>
 391 |     | <span class='neutral'>    result = X216.wrap(</span>
 392 |     | <span class='neutral'>      // Casting is safe because overflow is handled externally.</span>
 393 |     | <span class='neutral'>      int256(</span>
 394 |     | <span class='neutral'>        // All three castings are safe due to the input requirements.</span>
 395 |     | <span class='neutral'>        FullMathLibrary.mulDiv(</span>
 396 |     | <span class='neutral'>          uint256(X216.unwrap(value)),</span>
 397 |     | <span class='neutral'>          uint256(X216.unwrap(numerator)),</span>
 398 |     | <span class='neutral'>          uint256(X216.unwrap(denominator))</span>
 399 |     | <span class='neutral'>        )</span>
 400 |     | <span class='neutral'>      )</span>
 401 |     | <span class='neutral'>    );</span>
 402 |     | <span class='neutral'>  }</span>
 403 |     | <span class='neutral'></span>
 404 |     | <span class='neutral'>  /// @notice Calculates &#39;(value * numerator) / denominator&#39; when </span>
 405 |     | <span class='neutral'>  /// &#39;value * numerator &lt; denominator * (denominator - 1)&#39;.</span>
 406 |     | <span class='neutral'>  /// value should be non-negative</span>
 407 |     | <span class='neutral'>  function cheapMulDiv(</span>
 408 |     | <span class='neutral'>    X216 value,</span>
 409 |     | <span class='neutral'>    uint256 numerator,</span>
 410 |     | <span class='neutral'>    uint256 denominator</span>
 411 |     | <span class='neutral'>  ) internal pure returns (</span>
 412 |     | <span class='neutral'>    X216 result</span>
 413 |     | <span class='neutral'>  ) {</span>
 414 |     | <span class='neutral'>    result = X216.wrap(</span>
 415 |     | <span class='neutral'>      // Casting is safe because overflow is handled externally.</span>
 416 |     | <span class='neutral'>      int256(</span>
 417 |     | <span class='neutral'>        // The requirement of &#39;cheapMulDiv&#39; is met because of the above input</span>
 418 |     | <span class='neutral'>        // requirement.</span>
 419 |     | <span class='neutral'>        FullMathLibrary.cheapMulDiv(</span>
 420 |     | <span class='neutral'>          // Casting is safe due to the input requirement in &#39;value&#39;.</span>
 421 |     | <span class='neutral'>          uint256(X216.unwrap(value)),</span>
 422 |     | <span class='neutral'>          numerator,</span>
 423 |     | <span class='neutral'>          denominator</span>
 424 |     | <span class='neutral'>        )</span>
 425 |     | <span class='neutral'>      )</span>
 426 |     | <span class='neutral'>    );</span>
 427 |     | <span class='neutral'>  }</span>
 428 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/X23.sol</b>
<code>
  1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// Type &#39;X23&#39; is dedicated to pool growth ratios which determine the ratio of</span>
  5 |     | <span class='neutral'>// the accrued growth portions that belong to a pool owner. &#39;oneX23&#39; represents</span>
  6 |     | <span class='neutral'>// 100%.</span>
  7 |     | <span class='neutral'>type X23 is uint256;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>X23 constant zeroX23 = X23.wrap(0);</span>
 10 |     | <span class='neutral'>X23 constant oneX23 = X23.wrap(1 &lt;&lt; 23);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>using {add as +, sub as -} for X23 global;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>// Overflow should be avoided externally.</span>
 15 |     | <span class='neutral'>function add(</span>
 16 |     | <span class='neutral'>  X23 value0,</span>
 17 |     | <span class='neutral'>  X23 value1</span>
 18 |     | <span class='neutral'>) pure returns (</span>
 19 |     | <span class='neutral'>  X23 result</span>
 20 |     | <span class='neutral'>) {</span>
 21 |     | <span class='neutral'>  assembly {</span>
 22 |     | <span class='neutral'>    result := add(value0, value1)</span>
 23 |     | <span class='neutral'>  }</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>// Underflow should be avoided externally.</span>
 27 |     | <span class='neutral'>function sub(</span>
 28 |     | <span class='neutral'>  X23 value0,</span>
 29 |     | <span class='neutral'>  X23 value1</span>
 30 |     | <span class='neutral'>) pure returns (</span>
 31 |     | <span class='neutral'>  X23 result</span>
 32 |     | <span class='neutral'>) {</span>
 33 |     | <span class='neutral'>  assembly {</span>
 34 |     | <span class='neutral'>    result := sub(value0, value1)</span>
 35 |     | <span class='neutral'>  }</span>
 36 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/X47.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// Type &#39;X47&#39; is dedicated to growth portions. Interval liquidity can grow as a</span>
   5 |     | <span class='neutral'>// result of a swap or a donation. A portion of this growth goes to the</span>
   6 |     | <span class='neutral'>// protocol. A portion of the remaining growth goes to the pool owner. These</span>
   7 |     | <span class='neutral'>// portions are stored as &#39;X47&#39; type with &#39;oneX47&#39; representing 100%.</span>
   8 |     | <span class='neutral'>type X47 is uint256;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>X47 constant zeroX47 = X47.wrap(0);</span>
  11 |     | <span class='neutral'>// Largest valid value for growth portions:</span>
  12 |     | <span class='neutral'>X47 constant oneX47 = X47.wrap(1 &lt;&lt; 47);</span>
  13 |     | <span class='neutral'>// An invalid value for growth portions which is used as an indicator:</span>
  14 |     | <span class='neutral'>X47 constant maxX47 = X47.wrap(type(uint48).max);</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>using {equals as ==, notEqual as !=} for X47 global;</span>
  17 |     | <span class='neutral'>using {lessThan as &lt;, greaterThan as &gt;} for X47 global;</span>
  18 |     | <span class='neutral'>using {</span>
  19 |     | <span class='neutral'>  lessThanOrEqualTo as &lt;=,</span>
  20 |     | <span class='neutral'>  greaterThanOrEqualTo as &gt;=</span>
  21 |     | <span class='neutral'>} for X47 global;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>function equals(</span>
  24 |     | <span class='neutral'>  X47 value0,</span>
  25 |     | <span class='neutral'>  X47 value1</span>
  26 |     | <span class='neutral'>) pure returns (</span>
  27 |     | <span class='neutral'>  bool result</span>
  28 |     | <span class='neutral'>) {</span>
  29 |     | <span class='neutral'>  assembly {</span>
  30 |     | <span class='neutral'>    result := eq(value0, value1)</span>
  31 |     | <span class='neutral'>  }</span>
  32 |     | <span class='neutral'>}</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>function notEqual(</span>
  35 |     | <span class='neutral'>  X47 value0,</span>
  36 |     | <span class='neutral'>  X47 value1</span>
  37 |     | <span class='neutral'>) pure returns (</span>
  38 |     | <span class='neutral'>  bool result</span>
  39 |     | <span class='neutral'>) {</span>
  40 |     | <span class='neutral'>  return !(value0 == value1);</span>
  41 |     | <span class='neutral'>}</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>function lessThan(</span>
  44 |     | <span class='neutral'>  X47 value0,</span>
  45 |     | <span class='neutral'>  X47 value1</span>
  46 |     | <span class='neutral'>) pure returns (</span>
  47 |     | <span class='neutral'>  bool result</span>
  48 |     | <span class='neutral'>) {</span>
  49 |     | <span class='neutral'>  assembly {</span>
  50 |     | <span class='neutral'>    result := lt(value0, value1)</span>
  51 |     | <span class='neutral'>  }</span>
  52 |     | <span class='neutral'>}</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>function greaterThan(</span>
  55 |     | <span class='neutral'>  X47 value0,</span>
  56 |     | <span class='neutral'>  X47 value1</span>
  57 |     | <span class='neutral'>) pure returns (</span>
  58 |     | <span class='neutral'>  bool result</span>
  59 |     | <span class='neutral'>) {</span>
  60 |     | <span class='neutral'>  assembly {</span>
  61 |     | <span class='neutral'>    result := gt(value0, value1)</span>
  62 |     | <span class='neutral'>  }</span>
  63 |     | <span class='neutral'>}</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>function lessThanOrEqualTo(</span>
  66 |     | <span class='neutral'>  X47 value0,</span>
  67 |     | <span class='neutral'>  X47 value1</span>
  68 |     | <span class='neutral'>) pure returns (</span>
  69 |     | <span class='neutral'>  bool result</span>
  70 |     | <span class='neutral'>) {</span>
  71 |     | <span class='neutral'>  return !(value0 &gt; value1);</span>
  72 |     | <span class='neutral'>}</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>function greaterThanOrEqualTo(</span>
  75 |     | <span class='neutral'>  X47 value0,</span>
  76 |     | <span class='neutral'>  X47 value1</span>
  77 |     | <span class='neutral'>) pure returns (</span>
  78 |     | <span class='neutral'>  bool result</span>
  79 |     | <span class='neutral'>) {</span>
  80 |     | <span class='neutral'>  return !(value0 &lt; value1);</span>
  81 |     | <span class='neutral'>}</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>function min(</span>
  84 |     | <span class='neutral'>  X47 value0,</span>
  85 |     | <span class='neutral'>  X47 value1</span>
  86 |     | <span class='neutral'>) pure returns (</span>
  87 |     | <span class='neutral'>  X47 result</span>
  88 |     | <span class='neutral'>) {</span>
  89 |     | <span class='neutral'>  return (value0 &lt; value1) ? value0 : value1;</span>
  90 |     | <span class='neutral'>}</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>function max(</span>
  93 |     | <span class='neutral'>  X47 value0,</span>
  94 |     | <span class='neutral'>  X47 value1</span>
  95 |     | <span class='neutral'>) pure returns (</span>
  96 |     | <span class='neutral'>  X47 result</span>
  97 |     | <span class='neutral'>) {</span>
  98 |     | <span class='neutral'>  return (value0 &lt; value1) ? value1 : value0;</span>
  99 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/X59.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {X15} from &quot;./X15.sol&quot;;</span>
   5 |     | <span class='neutral'>import {X74} from &quot;./X74.sol&quot;;</span>
   6 |     | <span class='neutral'>import {X127} from &quot;./X127.sol&quot;;</span>
   7 |     | <span class='neutral'>import {X216} from &quot;./X216.sol&quot;;</span>
   8 |     | <span class='neutral'>import {FullMathLibrary} from &quot;./FullMath.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>// Type &#39;X59&#39; is dedicated to the natural logarithm of price.</span>
  11 |     | <span class='neutral'>type X59 is int256;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>using X59Library for X59 global;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>X59 constant zeroX59 = X59.wrap(0);</span>
  16 | *   | <span class='executed'>X59 constant epsilonX59 = X59.wrap(1);</span>
  17 |     | <span class='neutral'>X59 constant oneX59 = X59.wrap(1 &lt;&lt; 59);</span>
  18 | *   | <span class='executed'>X59 constant twoX59 = X59.wrap(2 &lt;&lt; 59);</span>
  19 |     | <span class='neutral'>X59 constant threeX59 = X59.wrap(3 &lt;&lt; 59);</span>
  20 |     | <span class='neutral'>X59 constant fourX59 = X59.wrap(4 &lt;&lt; 59);</span>
  21 |     | <span class='neutral'>X59 constant sixteenX59 = X59.wrap(16 &lt;&lt; 59);</span>
  22 | *   | <span class='executed'>X59 constant thirtyTwoX59 = X59.wrap(32 &lt;&lt; 59);</span>
  23 |     | <span class='unexecuted'>X59 constant minLogSpacing = X59.wrap((1 &lt;&lt; 59) &gt;&gt; 19);</span>
  24 |     | <span class='unexecuted'>X59 constant minLogStep = X59.wrap((1 &lt;&lt; 59) &gt;&gt; 27);</span>
  25 |     | <span class='neutral'>X59 constant minLogOffset = X59.wrap(0 - int256(90 &lt;&lt; 59));</span>
  26 |     | <span class='neutral'>X59 constant maxLogOffset = X59.wrap(90 &lt;&lt; 59);</span>
  27 |     | <span class='neutral'>X59 constant minX59 = X59.wrap(0 - type(int256).max);</span>
  28 |     | <span class='neutral'>X59 constant maxX59 = X59.wrap(type(int256).max);</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>using {equals as ==, notEqual as !=} for X59 global;</span>
  31 |     | <span class='neutral'>using {lessThan as &lt;, greaterThan as &gt;} for X59 global;</span>
  32 |     | <span class='neutral'>using {</span>
  33 |     | <span class='neutral'>  lessThanOrEqualTo as &lt;=,</span>
  34 |     | <span class='neutral'>  greaterThanOrEqualTo as &gt;=</span>
  35 |     | <span class='neutral'>} for X59 global;</span>
  36 |     | <span class='neutral'>using {add as +, sub as -} for X59 global;</span>
  37 |     | <span class='neutral'>using {mod as %} for X59 global;</span>
  38 |     | <span class='neutral'></span>
  39 | *   | <span class='executed'>function equals(</span>
  40 |     | <span class='neutral'>  X59 value0,</span>
  41 |     | <span class='neutral'>  X59 value1</span>
  42 |     | <span class='neutral'>) pure returns (</span>
  43 | *   | <span class='executed'>  bool result</span>
  44 |     | <span class='neutral'>) {</span>
  45 |     | <span class='neutral'>  assembly {</span>
  46 | *   | <span class='executed'>    result := eq(value0, value1)</span>
  47 |     | <span class='neutral'>  }</span>
  48 |     | <span class='neutral'>}</span>
  49 |     | <span class='neutral'></span>
  50 | *   | <span class='executed'>function notEqual(</span>
  51 |     | <span class='neutral'>  X59 value0,</span>
  52 |     | <span class='neutral'>  X59 value1</span>
  53 |     | <span class='neutral'>) pure returns (</span>
  54 | *   | <span class='executed'>  bool result</span>
  55 |     | <span class='neutral'>) {</span>
  56 | *   | <span class='executed'>  return !(value0 == value1);</span>
  57 |     | <span class='neutral'>}</span>
  58 |     | <span class='neutral'></span>
  59 | *   | <span class='executed'>function lessThan(</span>
  60 |     | <span class='neutral'>  X59 value0,</span>
  61 |     | <span class='neutral'>  X59 value1</span>
  62 |     | <span class='neutral'>) pure returns (</span>
  63 | *   | <span class='executed'>  bool result</span>
  64 |     | <span class='neutral'>) {</span>
  65 |     | <span class='neutral'>  assembly {</span>
  66 | *   | <span class='executed'>    result := slt(value0, value1)</span>
  67 |     | <span class='neutral'>  }</span>
  68 |     | <span class='neutral'>}</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>function greaterThan(</span>
  71 |     | <span class='neutral'>  X59 value0,</span>
  72 |     | <span class='neutral'>  X59 value1</span>
  73 |     | <span class='neutral'>) pure returns (</span>
  74 |     | <span class='unexecuted'>  bool result</span>
  75 |     | <span class='neutral'>) {</span>
  76 |     | <span class='neutral'>  assembly {</span>
  77 |     | <span class='unexecuted'>    result := sgt(value0, value1)</span>
  78 |     | <span class='neutral'>  }</span>
  79 |     | <span class='neutral'>}</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>function lessThanOrEqualTo(</span>
  82 |     | <span class='neutral'>  X59 value0,</span>
  83 |     | <span class='neutral'>  X59 value1</span>
  84 |     | <span class='neutral'>) pure returns (</span>
  85 |     | <span class='unexecuted'>  bool result</span>
  86 |     | <span class='neutral'>) {</span>
  87 |     | <span class='unexecuted'>  return !(value0 &gt; value1);</span>
  88 |     | <span class='neutral'>}</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>function greaterThanOrEqualTo(</span>
  91 |     | <span class='neutral'>  X59 value0,</span>
  92 |     | <span class='neutral'>  X59 value1</span>
  93 |     | <span class='neutral'>) pure returns (</span>
  94 |     | <span class='neutral'>  bool result</span>
  95 |     | <span class='neutral'>) {</span>
  96 |     | <span class='neutral'>  return !(value0 &lt; value1);</span>
  97 |     | <span class='neutral'>}</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
 100 | *   | <span class='executed'>function add(</span>
 101 |     | <span class='neutral'>  X59 value0,</span>
 102 |     | <span class='neutral'>  X59 value1</span>
 103 |     | <span class='neutral'>) pure returns (</span>
 104 | *   | <span class='executed'>  X59 result</span>
 105 |     | <span class='neutral'>) {</span>
 106 |     | <span class='neutral'>  assembly {</span>
 107 | *   | <span class='executed'>    result := add(value0, value1)</span>
 108 |     | <span class='neutral'>  }</span>
 109 |     | <span class='neutral'>}</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
 112 | *   | <span class='executed'>function sub(</span>
 113 |     | <span class='neutral'>  X59 value0,</span>
 114 |     | <span class='neutral'>  X59 value1</span>
 115 |     | <span class='neutral'>) pure returns (</span>
 116 | *   | <span class='executed'>  X59 result</span>
 117 |     | <span class='neutral'>) {</span>
 118 |     | <span class='neutral'>  assembly {</span>
 119 | *   | <span class='executed'>    result := sub(value0, value1)</span>
 120 |     | <span class='neutral'>  }</span>
 121 |     | <span class='neutral'>}</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>// &#39;value&#39; should be non-negative.</span>
 124 |     | <span class='neutral'>// &#39;modulus&#39; should be positive.</span>
 125 |     | <span class='neutral'>function mod(</span>
 126 |     | <span class='neutral'>  X59 value,</span>
 127 |     | <span class='neutral'>  X59 modulus</span>
 128 |     | <span class='neutral'>) pure returns (</span>
 129 |     | <span class='neutral'>  X59 result</span>
 130 |     | <span class='neutral'>) {</span>
 131 |     | <span class='neutral'>  assembly {</span>
 132 |     | <span class='neutral'>    result := mod(value, modulus)</span>
 133 |     | <span class='neutral'>  }</span>
 134 |     | <span class='neutral'>}</span>
 135 |     | <span class='neutral'></span>
 136 | *   | <span class='executed'>function min(</span>
 137 |     | <span class='neutral'>  X59 value0,</span>
 138 |     | <span class='neutral'>  X59 value1</span>
 139 |     | <span class='neutral'>) pure returns (</span>
 140 | *   | <span class='executed'>  X59 result</span>
 141 |     | <span class='neutral'>) {</span>
 142 | *   | <span class='executed'>  return (value0 &lt; value1) ? value0 : value1;</span>
 143 |     | <span class='neutral'>}</span>
 144 |     | <span class='neutral'></span>
 145 | *   | <span class='executed'>function max(</span>
 146 |     | <span class='neutral'>  X59 value0,</span>
 147 |     | <span class='neutral'>  X59 value1</span>
 148 |     | <span class='neutral'>) pure returns (</span>
 149 | *   | <span class='executed'>  X59 result</span>
 150 |     | <span class='neutral'>) {</span>
 151 | *   | <span class='executed'>  return (value0 &lt; value1) ? value1 : value0;</span>
 152 |     | <span class='neutral'>}</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>library X59Library {</span>
 155 |     | <span class='neutral'>  // Overflow should be avoided externally.</span>
 156 |     | <span class='neutral'>  // &#39;value0&#39; should be non-negative.</span>
 157 | *   | <span class='executed'>  function times(</span>
 158 |     | <span class='neutral'>    X59 value0,</span>
 159 |     | <span class='neutral'>    X15 value1</span>
 160 |     | <span class='neutral'>  ) internal pure returns (</span>
 161 | *   | <span class='executed'>    X74 result</span>
 162 |     | <span class='neutral'>  ) {</span>
 163 |     | <span class='neutral'>    assembly {</span>
 164 | *   | <span class='executed'>      result := mul(value0, value1)</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'>  }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>  /// @notice Calculates &#39;(value * numerator) / denominator&#39; when </span>
 169 |     | <span class='neutral'>  /// &#39;value * numerator &lt; denominator * (denominator - 1)&#39;.</span>
 170 |     | <span class='neutral'>  /// The three inputs should be non-negative.</span>
 171 |     | <span class='neutral'>  function cheapMulDiv(</span>
 172 |     | <span class='neutral'>    X59 value,</span>
 173 |     | <span class='neutral'>    X216 numerator,</span>
 174 |     | <span class='neutral'>    X216 denominator</span>
 175 |     | <span class='neutral'>  ) internal pure returns (</span>
 176 |     | <span class='neutral'>    X59 result</span>
 177 |     | <span class='neutral'>  ) {</span>
 178 |     | <span class='neutral'>    // The three castings to &#39;uint256&#39; are safe because of the &#39;non-negative&#39;</span>
 179 |     | <span class='neutral'>    // requirement on input values.</span>
 180 |     | <span class='neutral'>    //</span>
 181 |     | <span class='neutral'>    // The casting to &#39;int256&#39; is safe because</span>
 182 |     | <span class='neutral'>    // &#39;value * numerator / denominator &lt; denominator - 1 &lt;= 2 ** 255 - 2&#39;.</span>
 183 |     | <span class='neutral'>    //</span>
 184 |     | <span class='neutral'>    // The requirement of &#39;cheapMulDiv&#39; are met because of the above input</span>
 185 |     | <span class='neutral'>    // requirement.</span>
 186 |     | <span class='neutral'>    result = X59.wrap(int256(FullMathLibrary.cheapMulDiv(</span>
 187 |     | <span class='neutral'>      uint256(X59.unwrap(value)),</span>
 188 |     | <span class='neutral'>      uint256(X216.unwrap(numerator)),</span>
 189 |     | <span class='neutral'>      uint256(X216.unwrap(denominator))</span>
 190 |     | <span class='neutral'>    )));</span>
 191 |     | <span class='neutral'>  }</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='neutral'>  /// @notice Calculates</span>
 194 |     | <span class='neutral'>  /// &#39;(value * multiplier0 * multiplier1) / ((2 ** (216 + 59)) * exp(-16))&#39;</span>
 195 |     | <span class='neutral'>  /// Overflow should be avoided externally.</span>
 196 |     | <span class='neutral'>  /// All three inputs should be non-negative.</span>
 197 |     | <span class='neutral'>  function mulDivByExpInv16(</span>
 198 |     | <span class='neutral'>    X59 value,</span>
 199 |     | <span class='neutral'>    X216 multiplier0,</span>
 200 |     | <span class='neutral'>    X216 multiplier1</span>
 201 |     | <span class='neutral'>  ) internal pure returns (</span>
 202 |     | <span class='neutral'>    X216 product</span>
 203 |     | <span class='neutral'>  ) {</span>
 204 |     | <span class='neutral'>    assembly {</span>
 205 |     | <span class='neutral'>      // Let &#39;r := value * multiplier0 * multiplier1 </span>
 206 |     | <span class='neutral'>      //         - floor((2 ** 275) * exp(-16)) * q&#39;.</span>
 207 |     | <span class='neutral'>      //</span>
 208 |     | <span class='neutral'>      // Let &#39;s := value * multiplier0 * multiplier1 - (2 ** 256) * p&#39;.</span>
 209 |     | <span class='neutral'>      //</span>
 210 |     | <span class='neutral'>      // Then &#39;s - r == floor((2 ** 275) * exp(-16)) * q&#39; [modulo &#39;2 ** 256&#39;]</span>
 211 |     | <span class='neutral'>      product := mul(</span>
 212 |     | <span class='neutral'>        sub(</span>
 213 |     | <span class='neutral'>          // s</span>
 214 |     | <span class='neutral'>          mul(mul(value, multiplier0), multiplier1),</span>
 215 |     | <span class='neutral'>          // r</span>
 216 |     | <span class='neutral'>          mulmod(</span>
 217 |     | <span class='neutral'>            mulmod(</span>
 218 |     | <span class='neutral'>              value,</span>
 219 |     | <span class='neutral'>              multiplier0,</span>
 220 |     | <span class='neutral'>              // floor((2 ** 275) * exp(-16))</span>
 221 |     | <span class='neutral'>              0xF1AADDD7742E56D32FB9F997447D9E6314DB84884FABAB26BF059AF9BC20B61</span>
 222 |     | <span class='neutral'>            ),</span>
 223 |     | <span class='neutral'>            multiplier1,</span>
 224 |     | <span class='neutral'>            // floor((2 ** 275) * exp(-16))</span>
 225 |     | <span class='neutral'>            0xF1AADDD7742E56D32FB9F997447D9E6314DB84884FABAB26BF059AF9BC20B61</span>
 226 |     | <span class='neutral'>          )</span>
 227 |     | <span class='neutral'>        ),</span>
 228 |     | <span class='neutral'>        // modularInverse(floor((2 ** 275) * exp(-16)), 2 ** 256)</span>
 229 |     | <span class='neutral'>        0xD49C04AF80AF1EA5F98F85886B450A4B264FC14874F9F64143836145A37DD8A1</span>
 230 |     | <span class='neutral'>      )</span>
 231 |     | <span class='neutral'>    }</span>
 232 |     | <span class='neutral'>  }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>  /// @notice Calculates &#39;(2 ** 256) * exp(- x / (2 ** 60))&#39;.</span>
 235 |     | <span class='neutral'>  /// &quot;Pade Approximant&quot; is employed for this purpose:</span>
 236 |     | <span class='neutral'>  /// &#39;exp(- x / (2 ** 60)) ~= ((u(x) - v(x)) / (u(x) + v(x))) ** (2 ** 14)&#39;</span>
 237 |     | <span class='neutral'>  /// where</span>
 238 |     | <span class='neutral'>  ///                x ** 2      x ** 4       x ** 6          x ** 8</span>
 239 |     | <span class='neutral'>  /// &#39;u(x) = 1 + 7 --------- + --------- + ----------- + --------------&#39;</span>
 240 |     | <span class='neutral'>  ///                15&lt;&lt;150     39&lt;&lt;300     6435&lt;&lt;449     2027025&lt;&lt;600</span>
 241 |     | <span class='neutral'>  /// and</span>
 242 |     | <span class='neutral'>  ///            x       x ** 3       x ** 5        x ** 7</span>
 243 |     | <span class='neutral'>  /// &#39;v(x) = ------- + --------- + ---------- + -------------&#39;.</span>
 244 |     | <span class='neutral'>  ///          1&lt;&lt;75     15&lt;&lt;224     585&lt;&lt;374     225225&lt;&lt;523</span>
 245 |     | <span class='neutral'>  ///</span>
 246 |     | <span class='neutral'>  /// This formula can be reproduced via the following Mathematica command:</span>
 247 |     | <span class='neutral'>  /// &#39;PadeApproximant[Exp[- x / (2 ^ 74)], {x, 0, 8}]&#39;.</span>
 248 |     | <span class='neutral'>  ///</span>
 249 |     | <span class='neutral'>  /// Input should be greater than &#39;0&#39; and less than &#39;2 ** 64&#39;.</span>
 250 | *   | <span class='executed'>  function expInverse(</span>
 251 |     | <span class='neutral'>    X59 value</span>
 252 |     | <span class='neutral'>  ) internal pure returns (</span>
 253 | *   | <span class='executed'>    uint256 exponentialInverse</span>
 254 |     | <span class='neutral'>  ) {</span>
 255 |     | <span class='neutral'>    unchecked {</span>
 256 |     | <span class='neutral'>      // Casting is safe because &#39;value&#39; is between &#39;0&#39; and &#39;2 ** 64&#39;.</span>
 257 | *   | <span class='executed'>      uint256 x = uint256(X59.unwrap(value));</span>
 258 |     | <span class='neutral'>      </span>
 259 |     | <span class='neutral'>      // x ** 2</span>
 260 | *   | <span class='executed'>      uint256 x2 = x * x;</span>
 261 |     | <span class='neutral'>      </span>
 262 |     | <span class='neutral'>      // x ** 4</span>
 263 | *   | <span class='executed'>      uint256 x4 = x2 * x2;</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='neutral'>      // (x ** 6) / (2 ** 128)</span>
 266 | *   | <span class='executed'>      uint256 x6;</span>
 267 |     | <span class='neutral'>      assembly {</span>
 268 |     | <span class='neutral'>        // Let &#39;r := x2 * x4 - (2 ** 128) * q&#39;</span>
 269 |     | <span class='neutral'>        // Let &#39;s := x2 * x4 - (2 ** 256 - 1) * p&#39;</span>
 270 |     | <span class='neutral'>        // Then &#39;s - r == (2 ** 128) * q&#39; [modulo &#39;2 ** 256 - 1&#39;]</span>
 271 |     | <span class='neutral'>        // And &#39;q == (2 ** 128) * (s - r)&#39; [modulo &#39;2 ** 256 - 1&#39;]</span>
 272 |     | <span class='neutral'>        // Calculation modulo &#39;2 ** 256 - 1&#39; is safe because:</span>
 273 |     | <span class='neutral'>        // &#39;((2 ** 64 - 1) ** 6) / (2 ** 128) &lt; 2 ** 256 - 1&#39;</span>
 274 | *   | <span class='executed'>        x6 := mulmod(</span>
 275 |     | <span class='neutral'>          // The subtraction is safe because the remainder is greater than or</span>
 276 |     | <span class='neutral'>          // equal to the second one.</span>
 277 | *   | <span class='executed'>          sub(mulmod(x2, x4, not(0)), mulmod(x2, x4, shl(128, 1))),</span>
 278 | *   | <span class='executed'>          shl(128, 1),</span>
 279 | *   | <span class='executed'>          not(0)</span>
 280 |     | <span class='neutral'>        )</span>
 281 |     | <span class='neutral'>      }</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>      // (x ** 8) / (2 ** 256)</span>
 284 | *   | <span class='executed'>      uint256 x8;</span>
 285 |     | <span class='neutral'>      assembly {</span>
 286 |     | <span class='neutral'>        // Let &#39;r := x4 * x4 - (2 ** 256) * q&#39;</span>
 287 |     | <span class='neutral'>        // Let &#39;s := x4 * x4 - (2 ** 256 - 1) * p&#39;</span>
 288 |     | <span class='neutral'>        // Then &#39;s - r == q&#39; [modulo &#39;2 ** 256 - 1&#39;]</span>
 289 |     | <span class='neutral'>        // Calculation modulo &#39;2 ** 256 - 1&#39; is safe because:</span>
 290 |     | <span class='neutral'>        // &#39;((2 ** 64 - 1) ** 8) / (2 ** 256) &lt; 2 ** 256 - 1&#39;</span>
 291 | *   | <span class='executed'>        x8 := sub(mulmod(x4, x4, not(0)), mul(x4, x4))</span>
 292 |     | <span class='neutral'>      }</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>      // (2 ** 254) * u(x)</span>
 295 |     | <span class='neutral'>      // The additions are safe because the first term is &#39;1 &lt;&lt; 254&#39; and none</span>
 296 |     | <span class='neutral'>      // of the other terms exceed &#39;1 &lt;&lt; 250&#39;.</span>
 297 | *   | <span class='executed'>      uint256 a = </span>
 298 | *   | <span class='executed'>        ((x2 * (7 &lt;&lt; 104)) / 15) + </span>
 299 | *   | <span class='executed'>        (x4 / (39 &lt;&lt; 46)) + </span>
 300 | *   | <span class='executed'>        (x6 / (6435 &lt;&lt; 67)) + </span>
 301 | *   | <span class='executed'>        (x8 / (2027025 &lt;&lt; 90)) + </span>
 302 | *   | <span class='executed'>        (1 &lt;&lt; 254);</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='neutral'>      // (2 ** 254) * v(x)</span>
 305 |     | <span class='neutral'>      // The additions are safe because the first term is &#39;1 &lt;&lt; 255&#39; and none</span>
 306 |     | <span class='neutral'>      // of the other terms exceed &#39;1 &lt;&lt; 250&#39;.</span>
 307 | *   | <span class='executed'>      uint256 b = </span>
 308 | *   | <span class='executed'>        ((x2 &lt;&lt; 106) / 15) + </span>
 309 | *   | <span class='executed'>        (x4 / (585 &lt;&lt; 44)) + </span>
 310 | *   | <span class='executed'>        (x6 / (225225 &lt;&lt; 65)) + </span>
 311 | *   | <span class='executed'>        (1 &lt;&lt; 255);</span>
 312 |     | <span class='neutral'>        </span>
 313 |     | <span class='neutral'>      assembly {</span>
 314 |     | <span class='neutral'>        // Here we multiply the result by (x / (2 ** 76)).</span>
 315 |     | <span class='neutral'>        // Let &#39;r := x * b - (2 ** 76) * q&#39;</span>
 316 |     | <span class='neutral'>        // Let &#39;s := x * b - (2 ** 256 - 1) * p&#39;</span>
 317 |     | <span class='neutral'>        // Then &#39;s - r == (2 ** 76) * q&#39; [modulo &#39;2 ** 256 - 1&#39;]</span>
 318 |     | <span class='neutral'>        // And &#39;q == (2 ** 180) * (s - r)&#39; [modulo &#39;2 ** 256 - 1&#39;]</span>
 319 |     | <span class='neutral'>        // Calculation modulo &#39;2 ** 256 - 1&#39; is safe because:</span>
 320 |     | <span class='neutral'>        // &#39;b &lt; 2 ** 256 - 1&#39;</span>
 321 | *   | <span class='executed'>        b := mulmod(</span>
 322 |     | <span class='neutral'>          // The subtraction is safe because the remainder is greater than or</span>
 323 |     | <span class='neutral'>          // equal to the second one.</span>
 324 | *   | <span class='executed'>          sub(mulmod(x, b, not(0)), mulmod(x, b, shl(76, 1))),</span>
 325 | *   | <span class='executed'>          shl(180, 1),</span>
 326 | *   | <span class='executed'>          not(0)</span>
 327 |     | <span class='neutral'>        )</span>
 328 |     | <span class='neutral'>      }</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='neutral'>      // (2 ** 256) * (u(x) - v(x)) / (u(x) + v(x))</span>
 331 |     | <span class='neutral'>      // Since &#39;(2 ** 254) * (a - b) - (a + b) * (a + b - 1)&#39; is a</span>
 332 |     | <span class='neutral'>      // decreasing function with respect to &#39;x&#39;, it suffices to verify</span>
 333 |     | <span class='neutral'>      // that &#39;(2 ** 254) * (a - b) - (a + b) * (a + b - 1) &lt; 0&#39; only for</span>
 334 |     | <span class='neutral'>      // &#39;x == 1&#39; which is true. Hence, the requirement of &#39;cheapMulDiv&#39; is</span>
 335 |     | <span class='neutral'>      // satisfied.</span>
 336 | *   | <span class='executed'>      a = FullMathLibrary.cheapMulDiv(a - b, 1 &lt;&lt; 254, a + b) &lt;&lt; 2;</span>
 337 |     | <span class='neutral'></span>
 338 |     | <span class='neutral'>      // Next, we compute &#39;f(f(f(f(f(f(f(f(f(f(f(f(f(f(a))))))))))))))&#39;</span>
 339 |     | <span class='neutral'>      // where &#39;f(y) = (y ** 2) / (2 ** 256 - 1) ~ (y ** 2) / (2 ** 256)&#39;</span>
 340 |     | <span class='neutral'>      // This is because of the &#39;2 ** 14&#39; term which was discussed before.</span>
 341 |     | <span class='neutral'>      assembly {</span>
 342 | *   | <span class='executed'>        a := sub(</span>
 343 | *   | <span class='executed'>          mulmod(a, a, not(0)), // s := a * a - q * not(0)</span>
 344 | *   | <span class='executed'>          mul(a, a) // r := a * a</span>
 345 |     | <span class='neutral'>        ) // s - r == - q * not(0) == q</span>
 346 | *   | <span class='executed'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 347 | *   | <span class='executed'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 348 | *   | <span class='executed'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 349 | *   | <span class='executed'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 350 | *   | <span class='executed'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 351 | *   | <span class='executed'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 352 | *   | <span class='executed'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 353 | *   | <span class='executed'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 354 | *   | <span class='executed'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 355 | *   | <span class='executed'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 356 | *   | <span class='executed'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 357 | *   | <span class='executed'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 358 | *   | <span class='executed'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 359 |     | <span class='neutral'>      }</span>
 360 |     | <span class='neutral'></span>
 361 | *   | <span class='executed'>      return a;</span>
 362 |     | <span class='neutral'>    }</span>
 363 |     | <span class='neutral'>  }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>  /// @notice Transforms natural logarithm of price to square root of price.</span>
 366 |     | <span class='neutral'>  /// @param value The input whose exponential to be calculated.</span>
 367 |     | <span class='neutral'>  /// @return exponentialInverse is &#39;(2 ** 216) * exp(- x / (2 ** 60))&#39;</span>
 368 |     | <span class='neutral'>  /// @return exponentialOverExp16 is &#39;(2 ** 216) * exp(- 16 + x / (2 ** 60))&#39;</span>
 369 |     | <span class='neutral'>  /// Input should be greater than 0 and less than (2 ** 64).</span>
 370 | *   | <span class='executed'>  function exp(</span>
 371 |     | <span class='neutral'>    X59 value</span>
 372 |     | <span class='neutral'>  ) internal pure returns (</span>
 373 | *   | <span class='executed'>    X216 exponentialInverse,</span>
 374 | *   | <span class='executed'>    X216 exponentialOverExp16</span>
 375 | *   | <span class='executed'>  ) {</span>
 376 |     | <span class='neutral'>    // The requirements of &#39;expInverse&#39; are the same as the requirements here.</span>
 377 | *   | <span class='executed'>    uint256 a = expInverse(value);</span>
 378 |     | <span class='neutral'></span>
 379 |     | <span class='neutral'>    // Since &#39;0 &lt; value &lt; 2 ** 64&#39;, we have</span>
 380 |     | <span class='neutral'>    // &#39;(2 ** 256) * exp(-16) &lt; a &lt; (2 ** 256)&#39;, hence</span>
 381 |     | <span class='neutral'>    // &#39;(2 ** 472) * exp(-16) &lt; a * (a - 1)&#39; and the requirements of</span>
 382 |     | <span class='neutral'>    // &#39;cheapMulDiv&#39; are satisfied.</span>
 383 |     | <span class='neutral'>    //</span>
 384 |     | <span class='neutral'>    // Casting to &#39;int256&#39; is safe because the output of &#39;cheapMulDiv&#39; is</span>
 385 |     | <span class='neutral'>    // non-negative and it is less than &#39;oneX216&#39;.</span>
 386 |     | <span class='neutral'>    //</span>
 387 |     | <span class='neutral'>    // So, we can calculate &#39;(2 ** 472) * exp(-16) / a&#39; as follows:</span>
 388 | *   | <span class='executed'>    exponentialOverExp16 = X216.wrap(int256(FullMathLibrary.cheapMulDiv(</span>
 389 |     | <span class='neutral'>      // (2 ** 279) * exp(-16)</span>
 390 | *   | <span class='executed'>      0xF1AADDD7742E56D32FB9F997447D9E6314DB84884FABAB26BF059AF9BC20B609,</span>
 391 | *   | <span class='executed'>      1 &lt;&lt; 193,</span>
 392 | *   | <span class='executed'>      a</span>
 393 |     | <span class='neutral'>    )));</span>
 394 |     | <span class='neutral'></span>
 395 |     | <span class='neutral'>    // Casting to &#39;int256&#39; is safe because &#39;a &gt;&gt; 40&#39; is non-negative and it is</span>
 396 |     | <span class='neutral'>    // less than &#39;oneX216&#39;.</span>
 397 | *   | <span class='executed'>    exponentialInverse = X216.wrap(int256(a &gt;&gt; 40));</span>
 398 |     | <span class='neutral'>  }</span>
 399 |     | <span class='neutral'></span>
 400 |     | <span class='neutral'>  /// @notice Transforms natural logarithm of price to square root of price.</span>
 401 |     | <span class='neutral'>  /// &quot;Pade Approximant&quot; is employed for this purpose:</span>
 402 |     | <span class='neutral'>  /// &#39;exp(- x / (2 ** 60)) ~= ((u(x) - v(x)) / (u(x) + v(x))) ** (2 ** 48)&#39;</span>
 403 |     | <span class='neutral'>  /// where</span>
 404 |     | <span class='neutral'>  ///              x ** 2</span>
 405 |     | <span class='neutral'>  /// &#39;u(x) = 1 + --------&#39;</span>
 406 |     | <span class='neutral'>  ///              3&lt;&lt;218</span>
 407 |     | <span class='neutral'>  /// and</span>
 408 |     | <span class='neutral'>  ///             x</span>
 409 |     | <span class='neutral'>  /// &#39;v(x) = --------&#39;.</span>
 410 |     | <span class='neutral'>  ///          1&lt;&lt;109</span>
 411 |     | <span class='neutral'>  ///</span>
 412 |     | <span class='neutral'>  /// This formula can be reproduced via the following Mathematica command:</span>
 413 |     | <span class='neutral'>  /// &#39;PadeApproximant[Exp[- x / (2 ^ 108)], {x, 0, 2}]&#39;.</span>
 414 |     | <span class='neutral'>  ///</span>
 415 |     | <span class='neutral'>  /// @param value The input whose exponential to be calculated.</span>
 416 |     | <span class='neutral'>  /// @return exponentialInverse is &#39;(2 ** 256) * exp(- x / (2 ** 60))&#39;</span>
 417 |     | <span class='neutral'>  /// Input should be positive and less than &#39;2 * maxLogOffset&#39;.</span>
 418 |     | <span class='neutral'>  function expOffset(</span>
 419 |     | <span class='neutral'>    X59 value</span>
 420 |     | <span class='neutral'>  ) internal pure returns (</span>
 421 |     | <span class='neutral'>    uint256 exponentialInverse</span>
 422 |     | <span class='neutral'>  ) {</span>
 423 |     | <span class='neutral'>    unchecked {</span>
 424 |     | <span class='neutral'>      // Casting is safe because &#39;value&#39; is between &#39;0&#39; and &#39;2 ** 64&#39;.</span>
 425 |     | <span class='neutral'>      uint256 x = uint256(X59.unwrap(value));</span>
 426 |     | <span class='neutral'></span>
 427 |     | <span class='neutral'>      // (2 ** 255) * u(x)</span>
 428 |     | <span class='neutral'>      // The multiplication and addition are safe because &#39;x &lt; 2 ** 64&#39;.</span>
 429 |     | <span class='neutral'>      uint256 a = (((x * x) &lt;&lt; 37) / 3) + (1 &lt;&lt; 255);</span>
 430 |     | <span class='neutral'></span>
 431 |     | <span class='neutral'>      // (2 ** 255) * v(x)</span>
 432 |     | <span class='neutral'>      // The shift is safe because &#39;x &lt; 2 ** 64&#39;.</span>
 433 |     | <span class='neutral'>      x &lt;&lt;= 146;</span>
 434 |     | <span class='neutral'></span>
 435 |     | <span class='neutral'>      // The requirements of &#39;cheapMulDiv&#39; are satisfied because</span>
 436 |     | <span class='neutral'>      // (a - x) * (2 ** 254) - (a + x) (a + x - 1) is a decreasing function</span>
 437 |     | <span class='neutral'>      // with respect to &#39;x&#39;. Hence, we just need to verify that it is negative</span>
 438 |     | <span class='neutral'>      // for &#39;x == 1&#39; which is true.</span>
 439 |     | <span class='neutral'>      a = FullMathLibrary.cheapMulDiv(a - x, 1 &lt;&lt; 254, a + x) &lt;&lt; 2;</span>
 440 |     | <span class='neutral'></span>
 441 |     | <span class='neutral'>      // Next, we apply the function </span>
 442 |     | <span class='neutral'>      // &#39;f(y) = (y ** 2) / (2 ** 256 - 1) ~ (y ** 2) / (2 ** 256)&#39;, 48 times.</span>
 443 |     | <span class='neutral'>      // This is because of the &#39;2 ** 48&#39; term which was discussed before.</span>
 444 |     | <span class='neutral'>      assembly {</span>
 445 |     | <span class='neutral'>        a := sub(</span>
 446 |     | <span class='neutral'>          mulmod(a, a, not(0)), // s := a * a - q * not(0)</span>
 447 |     | <span class='neutral'>          mul(a, a) // r := a * a</span>
 448 |     | <span class='neutral'>        ) // s - r == - q * not(0) == q</span>
 449 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 450 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 451 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 452 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 453 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 454 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 455 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 456 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 457 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 458 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 459 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 460 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 461 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 462 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 463 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 464 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 465 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 466 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 467 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 468 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 469 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 470 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 471 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 472 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 473 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 474 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 475 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 476 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 477 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 478 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 479 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 480 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 481 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 482 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 483 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 484 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 485 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 486 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 487 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 488 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 489 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 490 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 491 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 492 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 493 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 494 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 495 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 496 |     | <span class='neutral'>      }</span>
 497 |     | <span class='neutral'></span>
 498 |     | <span class='neutral'>      return a;</span>
 499 |     | <span class='neutral'>    }</span>
 500 |     | <span class='neutral'>  }</span>
 501 |     | <span class='neutral'></span>
 502 |     | <span class='neutral'>  /// @notice Transforms natural logarithm of price in two&#39;s complement to</span>
 503 |     | <span class='neutral'>  /// square root of price.</span>
 504 |     | <span class='neutral'>  /// Input should be between &#39;minLogOffset&#39; and &#39;maxLogOffset&#39;.</span>
 505 |     | <span class='neutral'>  /// @param logOffset The input whose exponential to be calculated.</span>
 506 |     | <span class='neutral'>  /// @return sqrtOffset is &#39;(2 ** 127) * exp(logOffset / (2 ** 60))&#39;</span>
 507 |     | <span class='neutral'>  function logToSqrtOffset(</span>
 508 |     | <span class='neutral'>    X59 logOffset</span>
 509 |     | <span class='neutral'>  ) internal pure returns (</span>
 510 |     | <span class='neutral'>    X127 sqrtOffset</span>
 511 |     | <span class='neutral'>  ) {</span>
 512 |     | <span class='neutral'>    // &#39;(2 ** 256) * exp(- (maxLogOffset - logOffset) / (2 ** 60))&#39;</span>
 513 |     | <span class='neutral'>    // The requirements of &#39;expOffset&#39; are satisfied here because:</span>
 514 |     | <span class='neutral'>    // &#39;minLogOffset &lt; logOffset &lt; maxLogOffset&#39;</span>
 515 |     | <span class='neutral'>    // &#39;0 &lt; maxLogOffset - logOffset &lt; </span>
 516 |     | <span class='neutral'>    //      maxLogOffset - minLogOffset == 2 * maxLogOffset&#39;.</span>
 517 |     | <span class='neutral'>    uint256 exponential = (maxLogOffset - logOffset).expOffset();</span>
 518 |     | <span class='neutral'>    // (2 ** (256 + 191)) * exp(- (maxLogOffset - logOffset) / (2 ** 60)) / </span>
 519 |     | <span class='neutral'>    // ((2 ** 320) * exp(-45))</span>
 520 |     | <span class='neutral'>    assembly {</span>
 521 |     | <span class='neutral'>      // Let &#39;s := exponential * (2 ** 191) - (2 ** 256) * p&#39;</span>
 522 |     | <span class='neutral'>      // Let &#39;r := exponential * (2 ** 191) - floor((2 ** 320) * exp(-45)) * q&#39;</span>
 523 |     | <span class='neutral'>      // Then &#39;s - r == floor((2 ** 320) * exp(-45)) * q&#39; [modulo &#39;2 ** 256&#39;]</span>
 524 |     | <span class='neutral'>      sqrtOffset := mul(</span>
 525 |     | <span class='neutral'>        // s - r</span>
 526 |     | <span class='neutral'>        sub(</span>
 527 |     | <span class='neutral'>          // s</span>
 528 |     | <span class='neutral'>          mul(exponential, shl(191, 1)), // Because &#39;256 + 191 - 320 == 127&#39;</span>
 529 |     | <span class='neutral'>          // r</span>
 530 |     | <span class='neutral'>          mulmod(</span>
 531 |     | <span class='neutral'>            exponential,</span>
 532 |     | <span class='neutral'>            shl(191, 1),</span>
 533 |     | <span class='neutral'>            // floor((2 ** 320) * exp(-45))</span>
 534 |     | <span class='neutral'>            0x872DB9E8FFA9E7D41F2AAF39897B91E4002E70FCEED391471FAD73D51503772D</span>
 535 |     | <span class='neutral'>          )</span>
 536 |     | <span class='neutral'>        ),</span>
 537 |     | <span class='neutral'>        // modularInverse(floor((2 ** 320) * exp(-45)), 2 ** 256)</span>
 538 |     | <span class='neutral'>        0xCF8E41E6C4D4AA5E9CC597C10CD32EACD30C44F750A8FFDB1A8863DD8F72F0A5</span>
 539 |     | <span class='neutral'>      )</span>
 540 |     | <span class='neutral'>    }</span>
 541 |     | <span class='neutral'>  }</span>
 542 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/X74.sol</b>
<code>
  1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {X216} from &quot;./X216.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>// Type &#39;X74&#39; is used as an intermediate type when searching for precise log</span>
  7 |     | <span class='neutral'>// price movement corresponding to the specified outgoing/incoming token </span>
  8 |     | <span class='neutral'>// amounts.</span>
  9 |     | <span class='neutral'>type X74 is int256;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>X74 constant zeroX74 = X74.wrap(0);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>using {equals as ==, notEqual as !=} for X74 global;</span>
 14 |     | <span class='neutral'>using {add as +, sub as -} for X74 global;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>using X74Library for X74 global;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>function equals(</span>
 19 |     | <span class='neutral'>  X74 value0,</span>
 20 |     | <span class='neutral'>  X74 value1</span>
 21 |     | <span class='neutral'>) pure returns (</span>
 22 |     | <span class='neutral'>  bool result</span>
 23 |     | <span class='neutral'>) {</span>
 24 |     | <span class='neutral'>  assembly {</span>
 25 |     | <span class='neutral'>    result := eq(value0, value1)</span>
 26 |     | <span class='neutral'>  }</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>function notEqual(</span>
 30 |     | <span class='neutral'>  X74 value0,</span>
 31 |     | <span class='neutral'>  X74 value1</span>
 32 |     | <span class='neutral'>) pure returns (</span>
 33 |     | <span class='neutral'>  bool result</span>
 34 |     | <span class='neutral'>) {</span>
 35 |     | <span class='neutral'>  return !(value0 == value1);</span>
 36 |     | <span class='neutral'>}</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
 39 |     | <span class='neutral'>function add(</span>
 40 |     | <span class='neutral'>  X74 value0,</span>
 41 |     | <span class='neutral'>  X74 value1</span>
 42 |     | <span class='neutral'>) pure returns (</span>
 43 |     | <span class='neutral'>  X74 result</span>
 44 |     | <span class='neutral'>) {</span>
 45 |     | <span class='neutral'>  assembly {</span>
 46 |     | <span class='neutral'>    result := add(value0, value1)</span>
 47 |     | <span class='neutral'>  }</span>
 48 |     | <span class='neutral'>}</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
 51 |     | <span class='neutral'>function sub(</span>
 52 |     | <span class='neutral'>  X74 value0,</span>
 53 |     | <span class='neutral'>  X74 value1</span>
 54 |     | <span class='neutral'>) pure returns (</span>
 55 |     | <span class='neutral'>  X74 result</span>
 56 |     | <span class='neutral'>) {</span>
 57 |     | <span class='neutral'>  assembly {</span>
 58 |     | <span class='neutral'>    result := sub(value0, value1)</span>
 59 |     | <span class='neutral'>  }</span>
 60 |     | <span class='neutral'>}</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='unexecuted'>library X74Library {</span>
 63 |     | <span class='neutral'>  // Converts type &#39;X74&#39; to &#39;X216&#39;.</span>
 64 |     | <span class='neutral'>  // Overflow should be avoided externally.</span>
 65 |     | <span class='neutral'>  function toX216(</span>
 66 |     | <span class='neutral'>    X74 value</span>
 67 |     | <span class='neutral'>  ) internal pure returns (</span>
 68 |     | <span class='neutral'>    X216 result</span>
 69 |     | <span class='neutral'>  ) {</span>
 70 |     | <span class='neutral'>    assembly {</span>
 71 |     | <span class='neutral'>      // Multiplication is safe because overflow is avoided externally.</span>
 72 |     | <span class='neutral'>      result := mul(shl(142, 1), value)</span>
 73 |     | <span class='neutral'>    }</span>
 74 |     | <span class='neutral'>  }</span>
 75 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/echidna/FuzzUtilities.sol</b>
<code>
    1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
    2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>import {</span>
    5 |     | <span class='neutral'>  _begin_,</span>
    6 |     | <span class='neutral'>  _target_,</span>
    7 |     | <span class='neutral'>  _total0_,</span>
    8 |     | <span class='neutral'>  _total1_,</span>
    9 |     | <span class='neutral'>  _currentToTarget_,</span>
   10 |     | <span class='neutral'>  _incomingCurrentToTarget_,</span>
   11 |     | <span class='neutral'>  _overshoot_,</span>
   12 |     | <span class='neutral'>  _end_,</span>
   13 |     | <span class='neutral'>  _forward1_,</span>
   14 |     | <span class='neutral'>  _current_,</span>
   15 |     | <span class='neutral'>  _currentToOvershoot_,</span>
   16 |     | <span class='neutral'>  _endOfStaticParams_,</span>
   17 |     | <span class='neutral'>  _pointers_,</span>
   18 |     | <span class='neutral'>  setIntegral0,</span>
   19 |     | <span class='neutral'>  setIntegral1,</span>
   20 |     | <span class='neutral'>  getZeroForOne,</span>
   21 |     | <span class='neutral'>  getIntegralLimit,</span>
   22 |     | <span class='neutral'>  setZeroForOne,</span>
   23 |     | <span class='neutral'>  setIntegralLimit,</span>
   24 |     | <span class='neutral'>  getCurve,</span>
   25 |     | <span class='neutral'>  getCurveLength,</span>
   26 |     | <span class='neutral'>  setCurve,</span>
   27 |     | <span class='neutral'>  setCurveLength,</span>
   28 |     | <span class='neutral'>  getKernel,</span>
   29 |     | <span class='neutral'>  getKernelLength,</span>
   30 |     | <span class='neutral'>  setKernel,</span>
   31 |     | <span class='neutral'>  setKernelLength,</span>
   32 |     | <span class='neutral'>  setFreeMemoryPointer,</span>
   33 |     | <span class='neutral'>  getLogPriceLimitOffsetted,</span>
   34 |     | <span class='neutral'>  setLogPriceLimitOffsetted,</span>
   35 |     | <span class='neutral'>  getLogPriceLimitOffsettedWithinInterval</span>
   36 |     | <span class='neutral'>} from &quot;../contracts/utilities/Memory.sol&quot;;</span>
   37 |     | <span class='neutral'>import {X15, zeroX15, oneX15} from &quot;../contracts/utilities/X15.sol&quot;;</span>
   38 |     | <span class='neutral'>import {</span>
   39 |     | <span class='neutral'>  X59,</span>
   40 |     | <span class='neutral'>  epsilonX59,</span>
   41 |     | <span class='neutral'>  twoX59,</span>
   42 |     | <span class='neutral'>  thirtyTwoX59,</span>
   43 |     | <span class='neutral'>  min,</span>
   44 |     | <span class='neutral'>  max,</span>
   45 |     | <span class='neutral'>  minLogStep,</span>
   46 |     | <span class='neutral'>  minLogSpacing</span>
   47 |     | <span class='neutral'>} from &quot;../contracts/utilities/X59.sol&quot;;</span>
   48 |     | <span class='neutral'>import {</span>
   49 |     | <span class='neutral'>  X216,</span>
   50 |     | <span class='neutral'>  zeroX216,</span>
   51 |     | <span class='neutral'>  epsilonX216,</span>
   52 |     | <span class='neutral'>  oneX216,</span>
   53 |     | <span class='neutral'>  expInverse8X216,</span>
   54 |     | <span class='neutral'>  min,</span>
   55 |     | <span class='neutral'>  max</span>
   56 |     | <span class='neutral'>} from &quot;../contracts/utilities/X216.sol&quot;;</span>
   57 |     | <span class='neutral'>import {</span>
   58 |     | <span class='neutral'>  IntegralLibrary,</span>
   59 |     | <span class='neutral'>  EXP_INV_8_X240</span>
   60 |     | <span class='neutral'>} from &quot;../contracts/utilities/Integral.sol&quot;;</span>
   61 |     | <span class='neutral'>import {FullMathLibrary} from &quot;../contracts/utilities/FullMath.sol&quot;;</span>
   62 |     | <span class='neutral'>import {PriceLibrary} from &quot;../contracts/utilities/Price.sol&quot;;</span>
   63 |     | <span class='neutral'>import {</span>
   64 |     | <span class='neutral'>  initiateInterval,</span>
   65 |     | <span class='neutral'>  searchOutgoingTarget,</span>
   66 |     | <span class='neutral'>  searchIncomingTarget,</span>
   67 |     | <span class='neutral'>  moveOvershootByEpsilon,</span>
   68 |     | <span class='neutral'>  newIntegrals,</span>
   69 |     | <span class='neutral'>  searchOvershoot,</span>
   70 |     | <span class='neutral'>  moveTarget,</span>
   71 |     | <span class='neutral'>  moveOvershoot</span>
   72 |     | <span class='neutral'>} from &quot;../contracts/utilities/Interval.sol&quot;;</span>
   73 |     | <span class='neutral'>import {</span>
   74 |     | <span class='neutral'>  Index,</span>
   75 |     | <span class='neutral'>  zeroIndex,</span>
   76 |     | <span class='neutral'>  oneIndex,</span>
   77 |     | <span class='neutral'>  twoIndex</span>
   78 |     | <span class='neutral'>} from &quot;../contracts/utilities/Index.sol&quot;;</span>
   79 |     | <span class='neutral'>import {Curve} from &quot;../contracts/utilities/Curve.sol&quot;;</span>
   80 |     | <span class='neutral'>import {Kernel} from &quot;../contracts/utilities/Kernel.sol&quot;;</span>
   81 |     | <span class='neutral'></span>
   82 |     | <span class='neutral'>using PriceLibrary for uint256;</span>
   83 |     | <span class='neutral'></span>
   84 |     | <span class='neutral'>/// @notice Reserves 27 bytes in memory for an integral and returns the</span>
   85 |     | <span class='neutral'>/// corresponding memory pointer.</span>
   86 | *   | <span class='executed'>function get_an_integral_pointer() pure returns (uint256 pointer) {</span>
   87 |     | <span class='neutral'>  assembly {</span>
   88 | *   | <span class='executed'>    pointer := mload(0x40)</span>
   89 | *   | <span class='executed'>    mstore(0x40, add(pointer, 27))</span>
   90 |     | <span class='neutral'>  }</span>
   91 |     | <span class='neutral'>}</span>
   92 |     | <span class='neutral'></span>
   93 |     | <span class='neutral'>/// @notice Reserves 64 bytes in memory for a price as outlined in &#39;price.sol&#39;</span>
   94 |     | <span class='neutral'>/// and returns the corresponding memory pointer.</span>
   95 |     | <span class='neutral'>///</span>
   96 |     | <span class='neutral'>///   pointer</span>
   97 |     | <span class='neutral'>///      |</span>
   98 |     | <span class='neutral'>///   +--+--------+---------------------------+---------------------------+</span>
   99 |     | <span class='neutral'>///   |  | 8 byte |          27 byte          |          27 byte          |</span>
  100 |     | <span class='neutral'>///   +--+--------+---------------------------+---------------------------+</span>
  101 |     | <span class='neutral'>///   |  |        |                           |</span>
  102 |     | <span class='neutral'>///   |  |        |                            \</span>
  103 |     | <span class='neutral'>///   |  |        |                             sqrtInversePrice</span>
  104 |     | <span class='neutral'>///   |  |         \</span>
  105 |     | <span class='neutral'>///   |  |          sqrtPrice</span>
  106 |     | <span class='neutral'>///   |   \</span>
  107 |     | <span class='neutral'>///   |    logPrice</span>
  108 |     | <span class='neutral'>///    \</span>
  109 |     | <span class='neutral'>///     heightPrice</span>
  110 |     | <span class='neutral'>///</span>
  111 | *   | <span class='executed'>function get_a_price_pointer() pure returns (uint256 pointer) {</span>
  112 |     | <span class='neutral'>  assembly {</span>
  113 | *   | <span class='executed'>    pointer := add(mload(0x40), 2)</span>
  114 | *   | <span class='executed'>    mstore(0x40, add(pointer, 62))</span>
  115 |     | <span class='neutral'>  }</span>
  116 |     | <span class='neutral'>}</span>
  117 |     | <span class='neutral'></span>
  118 |     | <span class='neutral'>/// @notice Reserves 128 bytes in memory for two consecutive prices as outlined</span>
  119 |     | <span class='neutral'>/// in &#39;price.sol&#39; and returns the memory pointer associated with the first</span>
  120 |     | <span class='neutral'>/// one.</span>
  121 | *   | <span class='executed'>function get_a_segment_pointer() pure returns (uint256 pointer) {</span>
  122 |     | <span class='neutral'>  assembly {</span>
  123 | *   | <span class='executed'>    pointer := add(mload(0x40), 2)</span>
  124 | *   | <span class='executed'>    mstore(0x40, add(pointer, 126))</span>
  125 |     | <span class='neutral'>  }</span>
  126 |     | <span class='neutral'>}</span>
  127 |     | <span class='neutral'></span>
  128 |     | <span class='neutral'>/// @notice Transforms the given random &#39;seed&#39; into an integral of type &#39;X216&#39;.</span>
  129 | *   | <span class='executed'>function get_an_integral(uint216 seed) pure returns (X216) {</span>
  130 | *   | <span class='executed'>  return X216.wrap(int256(uint256(seed)));</span>
  131 |     | <span class='neutral'>}</span>
  132 |     | <span class='neutral'></span>
  133 |     | <span class='neutral'>/// @notice Transforms the given random &#39;seed&#39; into an &#39;X15&#39; value which may</span>
  134 |     | <span class='neutral'>/// not exceed &#39;oneX15&#39;.</span>
  135 | *   | <span class='executed'>function get_a_height(uint16 seed) pure returns (X15) {</span>
  136 | *   | <span class='executed'>  return X15.wrap(seed % ((2 ** 15) + 1));</span>
  137 |     | <span class='neutral'>}</span>
  138 |     | <span class='neutral'></span>
  139 |     | <span class='neutral'>/// @notice Transforms the given random &#39;seed&#39; into an &#39;X15&#39; value which</span>
  140 |     | <span class='neutral'>/// satisfies:</span>
  141 |     | <span class='neutral'>///</span>
  142 |     | <span class='neutral'>///   &#39;min(height0, height1) &lt;= value &lt;= min(height0, height1)&#39;</span>
  143 |     | <span class='neutral'>///</span>
  144 |     | <span class='unexecuted'>function get_a_height_in_between(</span>
  145 |     | <span class='neutral'>  uint16 seed,</span>
  146 |     | <span class='neutral'>  X15 height0,</span>
  147 |     | <span class='neutral'>  X15 height1</span>
  148 |     | <span class='unexecuted'>) pure returns (X15) {</span>
  149 |     | <span class='unexecuted'>  X15 _min = height0 &lt; height1 ? height0 : height1;</span>
  150 |     | <span class='unexecuted'>  X15 _max = height0 &lt; height1 ? height1 : height0;</span>
  151 |     | <span class='unexecuted'>  return _min + X15.wrap(seed % (X15.unwrap(_max - _min) + 1));</span>
  152 |     | <span class='neutral'>}</span>
  153 |     | <span class='neutral'></span>
  154 |     | <span class='neutral'>/// @notice Transforms the given random &#39;seed&#39; into an &#39;X59&#39; value which may</span>
  155 |     | <span class='neutral'>/// not exceed &#39;thirtyTwoX59 - epsilonX59&#39;.</span>
  156 |     | <span class='neutral'>function get_a_logPrice(uint64 seed) pure returns (X59) {</span>
  157 |     | <span class='neutral'>  return X59.wrap(int256(uint256(1 + (seed % ((2 ** 64) - 1)))));</span>
  158 |     | <span class='neutral'>}</span>
  159 |     | <span class='neutral'></span>
  160 |     | <span class='neutral'>/// @notice Transforms the given random &#39;seed&#39; into an &#39;X59&#39; value which</span>
  161 |     | <span class='neutral'>/// satisfies:</span>
  162 |     | <span class='neutral'>///</span>
  163 |     | <span class='neutral'>///   &#39;min(logPrice0, logPrice1) &lt;= value &lt;= min(logPrice0, logPrice1)&#39;</span>
  164 |     | <span class='neutral'>///</span>
  165 | *   | <span class='executed'>function get_a_logPrice_in_between(</span>
  166 |     | <span class='neutral'>  uint64 seed,</span>
  167 |     | <span class='neutral'>  X59 logPrice0,</span>
  168 |     | <span class='neutral'>  X59 logPrice1</span>
  169 | *   | <span class='executed'>) pure returns (X59) {</span>
  170 | *   | <span class='executed'>  X59 _min = min(logPrice0, logPrice1);</span>
  171 | *   | <span class='executed'>  X59 _max = max(logPrice0, logPrice1);</span>
  172 | *   | <span class='executed'>  return _min + X59.wrap(</span>
  173 | *   | <span class='executed'>    int256(uint256(seed) % uint256(X59.unwrap(_max - _min + epsilonX59)))</span>
  174 |     | <span class='neutral'>  );</span>
  175 |     | <span class='neutral'>}</span>
  176 |     | <span class='neutral'></span>
  177 |     | <span class='neutral'>/// @notice A reference for the function &#39;evaluate&#39; in &#39;Integral.sol&#39;.</span>
  178 |     | <span class='neutral'>/// Calculates:</span>
  179 |     | <span class='neutral'>///</span>
  180 |     | <span class='neutral'>///                                      c1 - c0</span>
  181 |     | <span class='neutral'>///  (2 ** 201) * (exp(-8) / 2) * (c0 + --------- (q - b0))</span>
  182 |     | <span class='neutral'>///                                      b1 - b0</span>
  183 |     | <span class='neutral'>///</span>
  184 | *   | <span class='executed'>function evaluate_reference(</span>
  185 |     | <span class='neutral'>  X15 c0,</span>
  186 |     | <span class='neutral'>  X15 c1,</span>
  187 |     | <span class='neutral'>  X59 b0,</span>
  188 |     | <span class='neutral'>  X59 b1,</span>
  189 |     | <span class='neutral'>  X59 q</span>
  190 | *   | <span class='executed'>) pure returns (X216) {</span>
  191 | *   | <span class='executed'>  if (b0 &lt; b1) {</span>
  192 | *   | <span class='executed'>    return X216.wrap(</span>
  193 | *   | <span class='executed'>      int256(</span>
  194 | *   | <span class='executed'>        FullMathLibrary.mulDiv(</span>
  195 |     | <span class='neutral'>          EXP_INV_8_X240,</span>
  196 | *   | <span class='executed'>          X15.unwrap(c0) * uint256(X59.unwrap(b1 - b0)) + </span>
  197 | *   | <span class='executed'>            X15.unwrap(c1 - c0) * uint256(X59.unwrap(q - b0)),</span>
  198 | *   | <span class='executed'>          uint256(X59.unwrap(b1 - b0))</span>
  199 |     | <span class='neutral'>        )</span>
  200 | *   | <span class='executed'>      ) &gt;&gt; 40</span>
  201 |     | <span class='neutral'>    );</span>
  202 |     | <span class='neutral'>  } else {</span>
  203 | *   | <span class='executed'>    return X216.wrap(</span>
  204 | *   | <span class='executed'>      int256(</span>
  205 | *   | <span class='executed'>        FullMathLibrary.mulDiv(</span>
  206 |     | <span class='neutral'>          EXP_INV_8_X240,</span>
  207 | *   | <span class='executed'>          X15.unwrap(c0) * uint256(X59.unwrap(b0 - b1)) + </span>
  208 | *   | <span class='executed'>            X15.unwrap(c1 - c0) * uint256(X59.unwrap(b0 - q)),</span>
  209 | *   | <span class='executed'>          uint256(X59.unwrap(b0 - b1))</span>
  210 |     | <span class='neutral'>        )</span>
  211 | *   | <span class='executed'>      ) &gt;&gt; 40</span>
  212 |     | <span class='neutral'>    );</span>
  213 |     | <span class='neutral'>  }</span>
  214 |     | <span class='neutral'>}</span>
  215 |     | <span class='neutral'></span>
  216 |     | <span class='neutral'>/// @notice A reference for the function &#39;outgoing&#39; in &#39;Integral.sol&#39;.</span>
  217 |     | <span class='neutral'>/// Define:</span>
  218 |     | <span class='neutral'>///</span>
  219 |     | <span class='neutral'>///               from.log()                          to.log()</span>
  220 |     | <span class='neutral'>///  f := - 16 + ------------    and    t := - 16 + ------------</span>
  221 |     | <span class='neutral'>///                2 ** 59                            2 ** 59</span>
  222 |     | <span class='neutral'>///</span>
  223 |     | <span class='neutral'>/// If &#39;f &lt; t&#39; this function calculates:</span>
  224 |     | <span class='neutral'>///</span>
  225 |     | <span class='neutral'>///                                / t</span>
  226 |     | <span class='neutral'>///                               |     -h/2         c1 - c0</span>
  227 |     | <span class='neutral'>///  (2 ** 201) * (exp(-8) / 2) * |    e      (c0 + --------- (h - b0)) dh</span>
  228 |     | <span class='neutral'>///                               |                  b1 - b0</span>
  229 |     | <span class='neutral'>///                              / f</span>
  230 |     | <span class='neutral'>///</span>
  231 |     | <span class='neutral'>/// If &#39;t &lt; f&#39; this function calculates:</span>
  232 |     | <span class='neutral'>///</span>
  233 |     | <span class='neutral'>///                                / f</span>
  234 |     | <span class='neutral'>///                               |     +h/2         c1 - c0</span>
  235 |     | <span class='neutral'>///  (2 ** 201) * (exp(-8) / 2) * |    e      (c0 + --------- (b0 - h)) dh</span>
  236 |     | <span class='neutral'>///                               |                  b0 - b1</span>
  237 |     | <span class='neutral'>///                              / t</span>
  238 |     | <span class='neutral'>///</span>
  239 | *   | <span class='executed'>function outgoing_reference(</span>
  240 |     | <span class='neutral'>  X15 c0,</span>
  241 |     | <span class='neutral'>  X15 c1,</span>
  242 |     | <span class='neutral'>  X59 b0,</span>
  243 |     | <span class='neutral'>  X59 b1,</span>
  244 |     | <span class='neutral'>  X59 logFrom,</span>
  245 |     | <span class='neutral'>  X59 logTo</span>
  246 | *   | <span class='executed'>) pure returns (X216) {</span>
  247 | *   | <span class='executed'>  uint256 result;</span>
  248 | *   | <span class='executed'>  if (b0 != b1) {</span>
  249 |     | <span class='neutral'>    unchecked {</span>
  250 | *   | <span class='executed'>      if (logFrom &lt; logTo) {</span>
  251 | *   | <span class='executed'>        (X216 sqrtFrom, ) = logFrom.exp();</span>
  252 | *   | <span class='executed'>        (X216 sqrtTo, ) = logTo.exp();</span>
  253 | *   | <span class='executed'>        result = X15.unwrap(c0) * uint256(X216.unwrap(sqrtFrom - sqrtTo));</span>
  254 | *   | <span class='executed'>        result += FullMathLibrary.mulDiv(</span>
  255 | *   | <span class='executed'>          uint256(X216.unwrap(sqrtFrom)),</span>
  256 | *   | <span class='executed'>          X15.unwrap(c1 - c0) * uint256(X59.unwrap(logFrom - b0 + twoX59)),</span>
  257 | *   | <span class='executed'>          uint256(X59.unwrap(b1 - b0))</span>
  258 |     | <span class='neutral'>        );</span>
  259 | *   | <span class='executed'>        result -= FullMathLibrary.mulDiv(</span>
  260 | *   | <span class='executed'>          uint256(X216.unwrap(sqrtTo)),</span>
  261 | *   | <span class='executed'>          X15.unwrap(c1 - c0) * uint256(X59.unwrap(logTo - b0 + twoX59)),</span>
  262 | *   | <span class='executed'>          uint256(X59.unwrap(b1 - b0))</span>
  263 |     | <span class='neutral'>        );</span>
  264 | *   | <span class='executed'>      } else {</span>
  265 | *   | <span class='executed'>        (, X216 sqrtInverseFrom) = logFrom.exp();</span>
  266 | *   | <span class='executed'>        (, X216 sqrtInverseTo) = logTo.exp();</span>
  267 | *   | <span class='executed'>        result = X15.unwrap(c0) * uint256(</span>
  268 | *   | <span class='executed'>          X216.unwrap(sqrtInverseFrom - sqrtInverseTo)</span>
  269 |     | <span class='neutral'>        );</span>
  270 | *   | <span class='executed'>        result += FullMathLibrary.mulDiv(</span>
  271 | *   | <span class='executed'>          uint256(X216.unwrap(sqrtInverseFrom)),</span>
  272 | *   | <span class='executed'>          X15.unwrap(c1 - c0) * uint256(X59.unwrap(b0 - logFrom + twoX59)),</span>
  273 | *   | <span class='executed'>          uint256(X59.unwrap(b0 - b1))</span>
  274 |     | <span class='neutral'>        );</span>
  275 | *   | <span class='executed'>        result -= FullMathLibrary.mulDiv(</span>
  276 | *   | <span class='executed'>          uint256(X216.unwrap(sqrtInverseTo)),</span>
  277 | *   | <span class='executed'>          X15.unwrap(c1 - c0) * uint256(X59.unwrap(b0 - logTo + twoX59)),</span>
  278 | *   | <span class='executed'>          uint256(X59.unwrap(b0 - b1))</span>
  279 |     | <span class='neutral'>        );</span>
  280 |     | <span class='neutral'>      }</span>
  281 |     | <span class='neutral'>    }</span>
  282 |     | <span class='neutral'>  }</span>
  283 | *   | <span class='executed'>  return X216.wrap(int256(result &gt;&gt; 15));</span>
  284 |     | <span class='neutral'>}</span>
  285 |     | <span class='neutral'></span>
  286 |     | <span class='neutral'>/// @notice A reference for the function &#39;incoming&#39; in &#39;Integral.sol&#39;.</span>
  287 |     | <span class='neutral'>/// Define:</span>
  288 |     | <span class='neutral'>///</span>
  289 |     | <span class='neutral'>///               from.log()                          to.log()</span>
  290 |     | <span class='neutral'>///  f := - 16 + ------------    and    t := - 16 + ------------</span>
  291 |     | <span class='neutral'>///                2 ** 59                            2 ** 59</span>
  292 |     | <span class='neutral'>///</span>
  293 |     | <span class='neutral'>/// If &#39;f &lt; t&#39; this function calculates:</span>
  294 |     | <span class='neutral'>///</span>
  295 |     | <span class='neutral'>///                                / t</span>
  296 |     | <span class='neutral'>///                               |     +h/2         c1 - c0</span>
  297 |     | <span class='neutral'>///  (2 ** 201) * (exp(-8) / 2) * |    e      (c0 + --------- (h - b0)) dh</span>
  298 |     | <span class='neutral'>///                               |                  b1 - b0</span>
  299 |     | <span class='neutral'>///                              / f</span>
  300 |     | <span class='neutral'>///</span>
  301 |     | <span class='neutral'>/// If &#39;t &lt; f&#39; this function calculates:</span>
  302 |     | <span class='neutral'>///</span>
  303 |     | <span class='neutral'>///                                / f</span>
  304 |     | <span class='neutral'>///                               |     -h/2         c1 - c0</span>
  305 |     | <span class='neutral'>///  (2 ** 201) * (exp(-8) / 2) * |    e      (c0 + --------- (b0 - h)) dh</span>
  306 |     | <span class='neutral'>///                               |                  b0 - b1</span>
  307 |     | <span class='neutral'>///                              / t</span>
  308 |     | <span class='neutral'>///</span>
  309 | *   | <span class='executed'>function incoming_reference(</span>
  310 |     | <span class='neutral'>  X15 c0,</span>
  311 |     | <span class='neutral'>  X15 c1,</span>
  312 |     | <span class='neutral'>  X59 b0,</span>
  313 |     | <span class='neutral'>  X59 b1,</span>
  314 |     | <span class='neutral'>  X59 logFrom,</span>
  315 |     | <span class='neutral'>  X59 logTo</span>
  316 | *   | <span class='executed'>) pure returns (X216) {</span>
  317 | *   | <span class='executed'>  uint256 result;</span>
  318 | *   | <span class='executed'>  if (b0 != b1) {</span>
  319 |     | <span class='neutral'>    unchecked {</span>
  320 | *   | <span class='executed'>      if (logFrom &lt; logTo) {</span>
  321 | *   | <span class='executed'>        (, X216 sqrtInverseFrom) = logFrom.exp();</span>
  322 | *   | <span class='executed'>        (, X216 sqrtInverseTo) = logTo.exp();</span>
  323 | *   | <span class='executed'>        result = X15.unwrap(c1) * uint256(</span>
  324 | *   | <span class='executed'>          X216.unwrap(sqrtInverseTo - sqrtInverseFrom)</span>
  325 |     | <span class='neutral'>        );</span>
  326 | *   | <span class='executed'>        result += FullMathLibrary.mulDiv(</span>
  327 | *   | <span class='executed'>          uint256(X216.unwrap(sqrtInverseFrom)),</span>
  328 | *   | <span class='executed'>          X15.unwrap(c1 - c0) * uint256(X59.unwrap(b1 - logFrom + twoX59)),</span>
  329 | *   | <span class='executed'>          uint256(X59.unwrap(b1 - b0))</span>
  330 |     | <span class='neutral'>        );</span>
  331 | *   | <span class='executed'>        result -= FullMathLibrary.mulDiv(</span>
  332 | *   | <span class='executed'>          uint256(X216.unwrap(sqrtInverseTo)),</span>
  333 | *   | <span class='executed'>          X15.unwrap(c1 - c0) * uint256(X59.unwrap(b1 - logTo + twoX59)),</span>
  334 | *   | <span class='executed'>          uint256(X59.unwrap(b1 - b0))</span>
  335 |     | <span class='neutral'>        );</span>
  336 | *   | <span class='executed'>      } else {</span>
  337 | *   | <span class='executed'>        (X216 sqrtFrom, ) = logFrom.exp();</span>
  338 | *   | <span class='executed'>        (X216 sqrtTo, ) = logTo.exp();</span>
  339 | *   | <span class='executed'>        result = X15.unwrap(c1) * uint256(X216.unwrap(sqrtTo - sqrtFrom));</span>
  340 | *   | <span class='executed'>        result += FullMathLibrary.mulDiv(</span>
  341 | *   | <span class='executed'>          uint256(X216.unwrap(sqrtFrom)),</span>
  342 | *   | <span class='executed'>          X15.unwrap(c1 - c0) * uint256(X59.unwrap(logFrom - b1 + twoX59)),</span>
  343 | *   | <span class='executed'>          uint256(X59.unwrap(b0 - b1))</span>
  344 |     | <span class='neutral'>        );</span>
  345 | *   | <span class='executed'>        result -= FullMathLibrary.mulDiv(</span>
  346 | *   | <span class='executed'>          uint256(X216.unwrap(sqrtTo)),</span>
  347 | *   | <span class='executed'>          X15.unwrap(c1 - c0) * uint256(X59.unwrap(logTo - b1 + twoX59)),</span>
  348 | *   | <span class='executed'>          uint256(X59.unwrap(b0 - b1))</span>
  349 |     | <span class='neutral'>        );</span>
  350 |     | <span class='neutral'>      }</span>
  351 |     | <span class='neutral'>    }</span>
  352 |     | <span class='neutral'>  }</span>
  353 | *   | <span class='executed'>  return X216.wrap(int256(result &gt;&gt; 15));</span>
  354 |     | <span class='neutral'>}</span>
  355 |     | <span class='neutral'></span>
  356 |     | <span class='neutral'>/// @notice A reference for the function &#39;shift&#39; in &#39;Integral.sol&#39;.</span>
  357 |     | <span class='neutral'>/// Calculates:</span>
  358 |     | <span class='neutral'>///</span>
  359 |     | <span class='neutral'>///  sqrt0 * sqrt1 * integral</span>
  360 |     | <span class='neutral'>/// --------------------------</span>
  361 |     | <span class='neutral'>///   (2 ** 432) * exp(-16)</span>
  362 |     | <span class='neutral'>///</span>
  363 | *   | <span class='executed'>function shift_reference(</span>
  364 |     | <span class='neutral'>  X216 integral,</span>
  365 |     | <span class='neutral'>  X216 sqrt0,</span>
  366 |     | <span class='neutral'>  X216 sqrt1</span>
  367 | *   | <span class='executed'>) pure returns (X216) {</span>
  368 | *   | <span class='executed'>  return X216.wrap(</span>
  369 | *   | <span class='executed'>    int256(FullMathLibrary.mulDiv(</span>
  370 | *   | <span class='executed'>      uint256(X216.unwrap(integral)),</span>
  371 | *   | <span class='executed'>      FullMathLibrary.mulDiv(</span>
  372 | *   | <span class='executed'>        uint256(X216.unwrap(sqrt0)) &lt;&lt; 20,</span>
  373 | *   | <span class='executed'>        uint256(X216.unwrap(sqrt1)) &lt;&lt; 20,</span>
  374 | *   | <span class='executed'>        2 ** 216</span>
  375 |     | <span class='neutral'>      ),</span>
  376 | *   | <span class='executed'>      0x1e355bbaee85cada65f73f32e88fb3cc629b709109f57564d7e0b35f378</span>
  377 |     | <span class='neutral'>    ))</span>
  378 |     | <span class='neutral'>  );</span>
  379 |     | <span class='neutral'>}</span>
  380 |     | <span class='neutral'></span>
  381 |     | <span class='neutral'>/// @notice Returns true if and only if:</span>
  382 |     | <span class='neutral'>///</span>
  383 |     | <span class='neutral'>///   |a - b| &lt;= err</span>
  384 |     | <span class='neutral'>///</span>
  385 | *   | <span class='executed'>function approximatelyEqual(</span>
  386 |     | <span class='neutral'>  X216 a,</span>
  387 |     | <span class='neutral'>  X216 b,</span>
  388 |     | <span class='neutral'>  uint256 err</span>
  389 | *   | <span class='executed'>) pure returns (bool) {</span>
  390 | *   | <span class='executed'>  (a, b) = (a &gt; b) ? (a, b) : (b, a);</span>
  391 | *   | <span class='executed'>  return uint256(X216.unwrap(a - b)) &lt;= err;</span>
  392 |     | <span class='neutral'>}</span>
  393 |     | <span class='neutral'></span>
  394 |     | <span class='neutral'>/// @notice Produces a pseudorandom transient slot by hashing the content of</span>
  395 |     | <span class='neutral'>/// slot0. The resulting transient slot is then returned and also stored on</span>
  396 |     | <span class='neutral'>/// slot0 to be used as a future seed. </span>
  397 |     | <span class='unexecuted'>function get_a_transient_pointer() returns (</span>
  398 |     | <span class='unexecuted'>  uint256 pointer</span>
  399 |     | <span class='neutral'>) {</span>
  400 |     | <span class='neutral'>  assembly {</span>
  401 |     | <span class='unexecuted'>    mstore(0, tload(0))</span>
  402 |     | <span class='unexecuted'>    pointer := keccak256(0, 32)</span>
  403 |     | <span class='unexecuted'>    tstore(0, pointer)</span>
  404 |     | <span class='neutral'>  }</span>
  405 |     | <span class='neutral'>}</span>
  406 |     | <span class='neutral'></span>
  407 |     | <span class='neutral'>/// @notice Writes an X59 value on transient.</span>
  408 |     | <span class='unexecuted'>function store_logPrice(uint256 pointer, X59 logPrice) {</span>
  409 |     | <span class='neutral'>  assembly {</span>
  410 |     | <span class='unexecuted'>    tstore(pointer, logPrice)</span>
  411 |     | <span class='neutral'>  }</span>
  412 |     | <span class='neutral'>}</span>
  413 |     | <span class='neutral'></span>
  414 |     | <span class='neutral'>/// @notice Writes an X59 value on transient.</span>
  415 |     | <span class='unexecuted'>function load_logPrice(</span>
  416 |     | <span class='neutral'>  uint256 pointer</span>
  417 |     | <span class='unexecuted'>) view returns (X59 logPrice) {</span>
  418 |     | <span class='neutral'>  assembly {</span>
  419 |     | <span class='unexecuted'>    logPrice := tload(pointer)</span>
  420 |     | <span class='neutral'>  }</span>
  421 |     | <span class='neutral'>}</span>
  422 |     | <span class='neutral'></span>
  423 |     | <span class='neutral'>/// @notice Writes an X15 value on transient.</span>
  424 |     | <span class='unexecuted'>function store_height(uint256 pointer, X15 height) {</span>
  425 |     | <span class='neutral'>  assembly {</span>
  426 |     | <span class='unexecuted'>    tstore(pointer, height)</span>
  427 |     | <span class='neutral'>  }</span>
  428 |     | <span class='neutral'>}</span>
  429 |     | <span class='neutral'></span>
  430 |     | <span class='neutral'>/// @notice Reads an X15 value on transient.</span>
  431 |     | <span class='unexecuted'>function load_height(</span>
  432 |     | <span class='neutral'>  uint256 pointer</span>
  433 |     | <span class='unexecuted'>) view returns (X15 height) {</span>
  434 |     | <span class='neutral'>  assembly {</span>
  435 |     | <span class='unexecuted'>    height := tload(pointer)</span>
  436 |     | <span class='neutral'>  }</span>
  437 |     | <span class='neutral'>}</span>
  438 |     | <span class='neutral'></span>
  439 |     | <span class='neutral'>/// @notice These two functions will be used to created a sorted sequence of</span>
  440 |     | <span class='neutral'>/// values. A value is stored at &#39;pointer&#39; and &#39;pointer + 1&#39; points to the next</span>
  441 |     | <span class='neutral'>/// value.</span>
  442 |     | <span class='unexecuted'>function store_next(</span>
  443 |     | <span class='neutral'>  uint256 pointer,</span>
  444 |     | <span class='neutral'>  uint256 nextPointer</span>
  445 |     | <span class='neutral'>) {</span>
  446 |     | <span class='neutral'>  assembly {</span>
  447 |     | <span class='unexecuted'>    sstore(add(pointer, 1), nextPointer)</span>
  448 |     | <span class='neutral'>  }</span>
  449 |     | <span class='neutral'>}</span>
  450 |     | <span class='unexecuted'>function load_next(</span>
  451 |     | <span class='neutral'>  uint256 pointer</span>
  452 |     | <span class='neutral'>) view returns (</span>
  453 |     | <span class='unexecuted'>  uint256 nextPointer</span>
  454 |     | <span class='neutral'>) {</span>
  455 |     | <span class='neutral'>  assembly {</span>
  456 |     | <span class='unexecuted'>    nextPointer := sload(add(pointer, 1))</span>
  457 |     | <span class='neutral'>  }</span>
  458 |     | <span class='neutral'>}</span>
  459 |     | <span class='neutral'></span>
  460 |     | <span class='neutral'>/// @notice Sets a new memeber for the current kernel set in memory.</span>
  461 |     | <span class='unexecuted'>function set_breakPoint(</span>
  462 |     | <span class='neutral'>  Index ii,</span>
  463 |     | <span class='neutral'>  X59 iLog,</span>
  464 |     | <span class='neutral'>  X15 iHeight</span>
  465 |     | <span class='unexecuted'>) pure {</span>
  466 |     | <span class='unexecuted'>  uint256 pointer;</span>
  467 |     | <span class='unexecuted'>  Kernel kernel = getKernel();</span>
  468 |     | <span class='neutral'>  assembly {</span>
  469 |     | <span class='unexecuted'>    pointer := add(sub(kernel, 62), mul(ii, 64))</span>
  470 |     | <span class='neutral'>  }</span>
  471 |     | <span class='unexecuted'>  (X216 iSqrt, X216 iSqrtInverse) = iLog.exp();</span>
  472 |     | <span class='unexecuted'>  pointer.storePrice(iHeight, iLog, iSqrt, iSqrtInverse);</span>
  473 |     | <span class='neutral'>}</span>
  474 |     | <span class='neutral'></span>
  475 |     | <span class='neutral'>/// @notice This contract generates a random curve and a random kernel given</span>
  476 |     | <span class='neutral'>/// the given seeds and sets them in memory.</span>
  477 |     | <span class='unexecuted'>contract KernelAndCurveFactory {</span>
  478 |     | <span class='neutral'>  uint256 immutable kernelLimit;</span>
  479 |     | <span class='neutral'>  uint256 immutable curveLimit;</span>
  480 |     | <span class='neutral'></span>
  481 |     | <span class='unexecuted'>  constructor(uint256 _kernelLimit, uint256 _curveLimit) {</span>
  482 |     | <span class='unexecuted'>    kernelLimit = _kernelLimit;</span>
  483 |     | <span class='unexecuted'>    curveLimit = _curveLimit;</span>
  484 |     | <span class='neutral'>  }</span>
  485 |     | <span class='neutral'></span>
  486 |     | <span class='unexecuted'>  function kernelLengthLimit(</span>
  487 |     | <span class='neutral'>    uint256 length</span>
  488 |     | <span class='neutral'>  ) private returns (</span>
  489 |     | <span class='unexecuted'>    uint256 limitedLength</span>
  490 |     | <span class='neutral'>  ) {</span>
  491 |     | <span class='unexecuted'>    if (length &gt; kernelLimit) {</span>
  492 |     | <span class='unexecuted'>      limitedLength = kernelLimit;</span>
  493 |     | <span class='neutral'>    } else {</span>
  494 |     | <span class='unexecuted'>      limitedLength = length;</span>
  495 |     | <span class='neutral'>    }</span>
  496 |     | <span class='neutral'>  }</span>
  497 |     | <span class='neutral'></span>
  498 |     | <span class='unexecuted'>  function curveLengthLimit(</span>
  499 |     | <span class='neutral'>    uint256 length</span>
  500 |     | <span class='neutral'>  ) private returns (</span>
  501 |     | <span class='unexecuted'>    uint256 limitedLength</span>
  502 |     | <span class='neutral'>  ) {</span>
  503 |     | <span class='unexecuted'>    if (length &gt; curveLimit) {</span>
  504 |     | <span class='unexecuted'>      limitedLength = curveLimit;</span>
  505 |     | <span class='neutral'>    } else {</span>
  506 |     | <span class='unexecuted'>      limitedLength = length;</span>
  507 |     | <span class='neutral'>    }</span>
  508 |     | <span class='neutral'>  }</span>
  509 |     | <span class='neutral'></span>
  510 |     | <span class='neutral'>  /// @notice Generates a random curve and a random kernel based on the given</span>
  511 |     | <span class='neutral'>  /// seeds and gives them as returndata.</span>
  512 |     | <span class='unexecuted'>  function buildAndIntegrate(</span>
  513 |     | <span class='neutral'>    bool[3] calldata seed_base,</span>
  514 |     | <span class='neutral'>    uint64[3] calldata seed_boundaries,</span>
  515 |     | <span class='neutral'>    uint88[] calldata seed_kernel,</span>
  516 |     | <span class='neutral'>    uint64[] calldata seed_curve</span>
  517 |     | <span class='neutral'>  ) external {</span>
  518 |     | <span class='neutral'>    // In this case, the spacing is determined based on the given seeds.</span>
  519 |     | <span class='unexecuted'>    _build(</span>
  520 |     | <span class='unexecuted'>      get_a_logPrice_in_between(</span>
  521 |     | <span class='unexecuted'>        seed_boundaries[0],</span>
  522 |     | <span class='neutral'>        minLogSpacing,</span>
  523 |     | <span class='unexecuted'>        X59.wrap(6148914691236517204)</span>
  524 |     | <span class='neutral'>      ),</span>
  525 |     | <span class='unexecuted'>      seed_base,</span>
  526 |     | <span class='unexecuted'>      seed_boundaries,</span>
  527 |     | <span class='unexecuted'>      seed_kernel,</span>
  528 |     | <span class='unexecuted'>      seed_curve</span>
  529 |     | <span class='neutral'>    );</span>
  530 |     | <span class='neutral'>  }</span>
  531 |     | <span class='neutral'></span>
  532 |     | <span class='neutral'>  /// @notice Generates a random spacing, curve and kernel based on the given</span>
  533 |     | <span class='neutral'>  /// seeds and gives them as returndata.</span>
  534 |     | <span class='unexecuted'>  function buildWithSpacingAndIntegrate(</span>
  535 |     | <span class='neutral'>    X59 qSpacing,</span>
  536 |     | <span class='neutral'>    bool[3] calldata seed_base,</span>
  537 |     | <span class='neutral'>    uint64[3] calldata seed_boundaries,</span>
  538 |     | <span class='neutral'>    uint88[] calldata seed_kernel,</span>
  539 |     | <span class='neutral'>    uint64[] calldata seed_curve</span>
  540 |     | <span class='neutral'>  ) external {</span>
  541 |     | <span class='neutral'>    // In this case, the spacing is read from the storage contract.</span>
  542 |     | <span class='unexecuted'>    _build(qSpacing, seed_base, seed_boundaries, seed_kernel, seed_curve);</span>
  543 |     | <span class='neutral'>  }</span>
  544 |     | <span class='neutral'></span>
  545 |     | <span class='neutral'>  /// @notice This function creates a sorted chain of X59 values between</span>
  546 |     | <span class='neutral'>  /// &#39;zeroX59&#39; and &#39;spacing&#39; in storage. It is going to look like this:</span>
  547 |     | <span class='neutral'>  ///</span>
  548 |     | <span class='neutral'>  ///    +-----------------+--------------------------------+</span>
  549 |     | <span class='neutral'>  ///    |   logPrice[0]   | Storage pointer to logPrice[1] |</span>
  550 |     | <span class='neutral'>  ///    +-----------------+--------------------------------+</span>
  551 |     | <span class='neutral'>  ///</span>
  552 |     | <span class='neutral'>  ///    +-----------------+--------------------------------+</span>
  553 |     | <span class='neutral'>  ///    |   logPrice[1]   | Storage pointer to logPrice[2] |</span>
  554 |     | <span class='neutral'>  ///    +-----------------+--------------------------------+</span>
  555 |     | <span class='neutral'>  ///</span>
  556 |     | <span class='neutral'>  ///    +-----------------+--------------------------------+</span>
  557 |     | <span class='neutral'>  ///    |   logPrice[2]   | Storage pointer to logPrice[3] |</span>
  558 |     | <span class='neutral'>  ///    +-----------------+--------------------------------+</span>
  559 |     | <span class='neutral'>  ///    </span>
  560 |     | <span class='neutral'>  ///      .</span>
  561 |     | <span class='neutral'>  ///      .</span>
  562 |     | <span class='neutral'>  ///      .</span>
  563 |     | <span class='neutral'>  ///</span>
  564 |     | <span class='neutral'>  ///    +-----------------+--------------------------------+</span>
  565 |     | <span class='neutral'>  ///    | logPrice[n - 1] | Storage pointer to logPrice[n] |</span>
  566 |     | <span class='neutral'>  ///    +-----------------+--------------------------------+</span>
  567 |     | <span class='neutral'>  ///</span>
  568 |     | <span class='neutral'>  ///    +-----------------+</span>
  569 |     | <span class='neutral'>  ///    |   logPrice[n]   |</span>
  570 |     | <span class='neutral'>  ///    +-----------------+</span>
  571 |     | <span class='neutral'>  ///</span>
  572 |     | <span class='unexecuted'>  function _sortedX59(</span>
  573 |     | <span class='neutral'>    uint88[] calldata seed_kernel,</span>
  574 |     | <span class='neutral'>    uint64 seed,</span>
  575 |     | <span class='neutral'>    X59 qSpacing</span>
  576 |     | <span class='neutral'>  ) private returns (</span>
  577 |     | <span class='unexecuted'>    uint256 smallestPointer</span>
  578 |     | <span class='unexecuted'>  ) {</span>
  579 |     | <span class='unexecuted'>    smallestPointer = get_a_transient_pointer();</span>
  580 |     | <span class='unexecuted'>    store_logPrice(</span>
  581 |     | <span class='unexecuted'>      smallestPointer,</span>
  582 |     | <span class='unexecuted'>      get_a_logPrice_in_between(</span>
  583 |     | <span class='unexecuted'>        seed,</span>
  584 |     | <span class='neutral'>        epsilonX59,</span>
  585 |     | <span class='unexecuted'>        qSpacing - epsilonX59</span>
  586 |     | <span class='neutral'>      )</span>
  587 |     | <span class='neutral'>    );</span>
  588 |     | <span class='unexecuted'>    uint256 largestPointer = smallestPointer;</span>
  589 |     | <span class='neutral'></span>
  590 |     | <span class='unexecuted'>    for (uint256 ii = 0; ii &lt; kernelLengthLimit(seed_kernel.length); ++ii) {</span>
  591 |     | <span class='unexecuted'>      X59 logPrice = get_a_logPrice_in_between(</span>
  592 |     | <span class='unexecuted'>        uint64(seed_kernel[ii]),</span>
  593 |     | <span class='neutral'>        epsilonX59,</span>
  594 |     | <span class='unexecuted'>        qSpacing - epsilonX59</span>
  595 |     | <span class='neutral'>      );</span>
  596 |     | <span class='unexecuted'>      uint256 pointer = get_a_transient_pointer();</span>
  597 |     | <span class='unexecuted'>      store_logPrice(pointer, logPrice);</span>
  598 |     | <span class='neutral'></span>
  599 |     | <span class='unexecuted'>      if (logPrice &lt;= load_logPrice(smallestPointer)) {</span>
  600 |     | <span class='unexecuted'>        store_next(pointer, smallestPointer);</span>
  601 |     | <span class='unexecuted'>        smallestPointer = pointer;</span>
  602 |     | <span class='unexecuted'>      } else if (load_logPrice(largestPointer) &lt; logPrice) {</span>
  603 |     | <span class='unexecuted'>        store_next(largestPointer, pointer);</span>
  604 |     | <span class='unexecuted'>        largestPointer = pointer;</span>
  605 |     | <span class='unexecuted'>      } else {</span>
  606 |     | <span class='unexecuted'>        uint256 pointer0 = smallestPointer;</span>
  607 |     | <span class='unexecuted'>        uint256 pointer1 = load_next(smallestPointer);</span>
  608 |     | <span class='unexecuted'>        while (</span>
  609 |     | <span class='unexecuted'>          logPrice &lt; load_logPrice(pointer0)</span>
  610 |     | <span class='neutral'>           || </span>
  611 |     | <span class='unexecuted'>          load_logPrice(pointer1) &lt; logPrice</span>
  612 |     | <span class='neutral'>        ) {</span>
  613 |     | <span class='unexecuted'>          pointer0 = pointer1;</span>
  614 |     | <span class='unexecuted'>          pointer1 = load_next(pointer0);</span>
  615 |     | <span class='neutral'>        }</span>
  616 |     | <span class='unexecuted'>        store_next(pointer0, pointer);</span>
  617 |     | <span class='unexecuted'>        store_next(pointer, pointer1);</span>
  618 |     | <span class='neutral'>      }</span>
  619 |     | <span class='neutral'>    }</span>
  620 |     | <span class='neutral'>  }</span>
  621 |     | <span class='neutral'></span>
  622 |     | <span class='neutral'>  /// @notice This function creates a sorted chain of X15 values within</span>
  623 |     | <span class='neutral'>  /// &#39;[zeroX15, oneX15 - 1]&#39; in storage. It is going to look like this:</span>
  624 |     | <span class='neutral'>  ///</span>
  625 |     | <span class='neutral'>  ///    +-----------------+------------------------------+</span>
  626 |     | <span class='neutral'>  ///    |    height[0]    | Storage pointer to height[1] |</span>
  627 |     | <span class='neutral'>  ///    +-----------------+------------------------------+</span>
  628 |     | <span class='neutral'>  ///</span>
  629 |     | <span class='neutral'>  ///    +-----------------+------------------------------+</span>
  630 |     | <span class='neutral'>  ///    |    height[1]    | Storage pointer to height[2] |</span>
  631 |     | <span class='neutral'>  ///    +-----------------+------------------------------+</span>
  632 |     | <span class='neutral'>  ///</span>
  633 |     | <span class='neutral'>  ///    +-----------------+------------------------------+</span>
  634 |     | <span class='neutral'>  ///    |    height[2]    | Storage pointer to height[3] |</span>
  635 |     | <span class='neutral'>  ///    +-----------------+------------------------------+</span>
  636 |     | <span class='neutral'>  ///    </span>
  637 |     | <span class='neutral'>  ///      .</span>
  638 |     | <span class='neutral'>  ///      .</span>
  639 |     | <span class='neutral'>  ///      .</span>
  640 |     | <span class='neutral'>  ///</span>
  641 |     | <span class='neutral'>  ///    +-----------------+------------------------------+</span>
  642 |     | <span class='neutral'>  ///    |  height[n - 1]  | Storage pointer to height[n] |</span>
  643 |     | <span class='neutral'>  ///    +-----------------+------------------------------+</span>
  644 |     | <span class='neutral'>  ///</span>
  645 |     | <span class='neutral'>  ///    +-----------------+</span>
  646 |     | <span class='neutral'>  ///    |    height[n]    |</span>
  647 |     | <span class='neutral'>  ///    +-----------------+</span>
  648 |     | <span class='neutral'>  ///</span>
  649 |     | <span class='unexecuted'>  function _sortedX15(</span>
  650 |     | <span class='neutral'>    uint88[] calldata seed_kernel</span>
  651 |     | <span class='neutral'>  ) private returns (</span>
  652 |     | <span class='unexecuted'>    uint256 smallestPointer</span>
  653 |     | <span class='unexecuted'>  ) {</span>
  654 |     | <span class='unexecuted'>    smallestPointer = get_a_transient_pointer();</span>
  655 |     | <span class='unexecuted'>    store_height(smallestPointer, zeroX15);</span>
  656 |     | <span class='unexecuted'>    uint256 largestPointer = smallestPointer;</span>
  657 |     | <span class='neutral'></span>
  658 |     | <span class='unexecuted'>    for (uint256 ii = 0; ii &lt; kernelLengthLimit(seed_kernel.length); ++ii) {</span>
  659 |     | <span class='unexecuted'>      X15 height = get_a_height_in_between(</span>
  660 |     | <span class='unexecuted'>        uint16(seed_kernel[ii] &gt;&gt; 64),</span>
  661 |     | <span class='unexecuted'>        X15.wrap(1),</span>
  662 |     | <span class='unexecuted'>        oneX15 - X15.wrap(1)</span>
  663 |     | <span class='neutral'>      );</span>
  664 |     | <span class='unexecuted'>      uint256 pointer = get_a_transient_pointer();</span>
  665 |     | <span class='unexecuted'>      store_height(pointer, height);</span>
  666 |     | <span class='neutral'></span>
  667 |     | <span class='unexecuted'>      if (height &lt;= load_height(smallestPointer)) {</span>
  668 |     | <span class='unexecuted'>        store_next(pointer, smallestPointer);</span>
  669 |     | <span class='unexecuted'>        smallestPointer = pointer;</span>
  670 |     | <span class='unexecuted'>      } else if (load_height(largestPointer) &lt; height) {</span>
  671 |     | <span class='unexecuted'>        store_next(largestPointer, pointer);</span>
  672 |     | <span class='unexecuted'>        largestPointer = pointer;</span>
  673 |     | <span class='unexecuted'>      } else {</span>
  674 |     | <span class='unexecuted'>        uint256 pointer0 = smallestPointer;</span>
  675 |     | <span class='unexecuted'>        uint256 pointer1 = load_next(smallestPointer);</span>
  676 |     | <span class='unexecuted'>        while (</span>
  677 |     | <span class='unexecuted'>          height &lt; load_height(pointer0)</span>
  678 |     | <span class='neutral'>           || </span>
  679 |     | <span class='unexecuted'>          load_height(pointer1) &lt; height</span>
  680 |     | <span class='neutral'>        ) {</span>
  681 |     | <span class='unexecuted'>          pointer0 = pointer1;</span>
  682 |     | <span class='unexecuted'>          pointer1 = load_next(pointer0);</span>
  683 |     | <span class='neutral'>        }</span>
  684 |     | <span class='unexecuted'>        store_next(pointer0, pointer);</span>
  685 |     | <span class='unexecuted'>        store_next(pointer, pointer1);</span>
  686 |     | <span class='neutral'>      }</span>
  687 |     | <span class='neutral'>    }</span>
  688 |     | <span class='neutral'>  }</span>
  689 |     | <span class='neutral'></span>
  690 |     | <span class='neutral'>  /// @notice This function remove repetitions in the chain of breakpoints.</span>
  691 |     | <span class='unexecuted'>  function _pruneRepetition(</span>
  692 |     | <span class='neutral'>    uint256 initialLength,</span>
  693 |     | <span class='neutral'>    uint256 smallestPointerX59,</span>
  694 |     | <span class='neutral'>    uint256 smallestPointerX15</span>
  695 |     | <span class='neutral'>  ) private returns (</span>
  696 |     | <span class='unexecuted'>    uint256 length</span>
  697 |     | <span class='neutral'>  ) {</span>
  698 |     | <span class='unexecuted'>    length = initialLength;</span>
  699 |     | <span class='unexecuted'>    for (uint256 ii = 0; ii &lt; initialLength; ++ii) {</span>
  700 |     | <span class='unexecuted'>      if (</span>
  701 |     | <span class='unexecuted'>        (</span>
  702 |     | <span class='unexecuted'>          load_logPrice(smallestPointerX59)</span>
  703 |     | <span class='neutral'>           == </span>
  704 |     | <span class='unexecuted'>          load_logPrice(load_next(smallestPointerX59))</span>
  705 |     | <span class='neutral'>        ) || (</span>
  706 |     | <span class='unexecuted'>          load_height(smallestPointerX15)</span>
  707 |     | <span class='neutral'>           == </span>
  708 |     | <span class='unexecuted'>          load_height(load_next(smallestPointerX15))</span>
  709 |     | <span class='neutral'>        )</span>
  710 |     | <span class='neutral'>      ) {</span>
  711 |     | <span class='unexecuted'>        store_next(</span>
  712 |     | <span class='unexecuted'>          smallestPointerX59,</span>
  713 |     | <span class='unexecuted'>          load_next(load_next(smallestPointerX59))</span>
  714 |     | <span class='neutral'>        );</span>
  715 |     | <span class='unexecuted'>        store_next(</span>
  716 |     | <span class='unexecuted'>          smallestPointerX15,</span>
  717 |     | <span class='unexecuted'>          load_next(load_next(smallestPointerX15))</span>
  718 |     | <span class='neutral'>        );</span>
  719 |     | <span class='unexecuted'>        --length;</span>
  720 |     | <span class='neutral'>      } else {</span>
  721 |     | <span class='unexecuted'>        smallestPointerX59 = load_next(smallestPointerX59);</span>
  722 |     | <span class='unexecuted'>        smallestPointerX15 = load_next(smallestPointerX15);</span>
  723 |     | <span class='neutral'>      }</span>
  724 |     | <span class='neutral'>    }</span>
  725 |     | <span class='neutral'>  }</span>
  726 |     | <span class='neutral'></span>
  727 |     | <span class='neutral'>  /// @notice This function builds a kernel and places it in memory.</span>
  728 |     | <span class='unexecuted'>  function _buildKernel(</span>
  729 |     | <span class='neutral'>    uint88[] calldata seed_kernel,</span>
  730 |     | <span class='neutral'>    X59 qSpacing,</span>
  731 |     | <span class='neutral'>    bool notSkip0,</span>
  732 |     | <span class='neutral'>    bool notSkip1,</span>
  733 |     | <span class='neutral'>    uint256 length,</span>
  734 |     | <span class='neutral'>    uint256 smallestPointerX59,</span>
  735 |     | <span class='neutral'>    uint256 smallestPointerX15</span>
  736 |     | <span class='unexecuted'>  ) private {</span>
  737 |     | <span class='neutral'>    // Repetitions are removed.</span>
  738 |     | <span class='unexecuted'>    length = _pruneRepetition(</span>
  739 |     | <span class='unexecuted'>      length,</span>
  740 |     | <span class='unexecuted'>      smallestPointerX59,</span>
  741 |     | <span class='unexecuted'>      smallestPointerX15</span>
  742 |     | <span class='neutral'>    );</span>
  743 |     | <span class='neutral'></span>
  744 |     | <span class='unexecuted'>    Kernel kernel;</span>
  745 |     | <span class='neutral'>    assembly {</span>
  746 |     | <span class='unexecuted'>      kernel := _endOfStaticParams_</span>
  747 |     | <span class='neutral'>    }</span>
  748 |     | <span class='unexecuted'>    setKernel(kernel);</span>
  749 |     | <span class='neutral'></span>
  750 |     | <span class='unexecuted'>    Index index = oneIndex;</span>
  751 |     | <span class='neutral'></span>
  752 |     | <span class='neutral'>    // In this case, we first add a breakpoint corresponding to the first X59</span>
  753 |     | <span class='neutral'>    // and X15.</span>
  754 |     | <span class='unexecuted'>    if (notSkip0 || load_logPrice(smallestPointerX59) &lt;= minLogStep) {</span>
  755 |     | <span class='unexecuted'>      set_breakPoint(</span>
  756 |     | <span class='unexecuted'>        index,</span>
  757 |     | <span class='unexecuted'>        load_logPrice(smallestPointerX59),</span>
  758 |     | <span class='unexecuted'>        load_height(smallestPointerX15)</span>
  759 |     | <span class='neutral'>      );</span>
  760 |     | <span class='unexecuted'>      index = index + oneIndex;</span>
  761 |     | <span class='neutral'>    }</span>
  762 |     | <span class='neutral'></span>
  763 |     | <span class='unexecuted'>    if (length &gt;= 1) {</span>
  764 |     | <span class='unexecuted'>      for (uint256 ii = 0; ii &lt; length - 1; ++ii) {</span>
  765 |     | <span class='neutral'>        // The X15 is updated while the X59 remains the same.</span>
  766 |     | <span class='unexecuted'>        smallestPointerX15 = load_next(smallestPointerX15);</span>
  767 |     | <span class='neutral'></span>
  768 |     | <span class='neutral'>        // In this case, we add a vertical breakpoint.</span>
  769 |     | <span class='unexecuted'>        if (</span>
  770 |     | <span class='unexecuted'>          (</span>
  771 |     | <span class='unexecuted'>            (seed_kernel[ii] &gt;&gt; 80) % 2 == 0</span>
  772 |     | <span class='neutral'>          ) || (</span>
  773 |     | <span class='unexecuted'>            load_logPrice(load_next(smallestPointerX59))</span>
  774 |     | <span class='neutral'>             - </span>
  775 |     | <span class='unexecuted'>            load_logPrice(smallestPointerX59) &lt;= minLogStep</span>
  776 |     | <span class='neutral'>          )</span>
  777 |     | <span class='neutral'>        ) {</span>
  778 |     | <span class='unexecuted'>          set_breakPoint(</span>
  779 |     | <span class='unexecuted'>            index,</span>
  780 |     | <span class='unexecuted'>            load_logPrice(smallestPointerX59),</span>
  781 |     | <span class='unexecuted'>            load_height(smallestPointerX15)</span>
  782 |     | <span class='neutral'>          );</span>
  783 |     | <span class='unexecuted'>          index = index + oneIndex;</span>
  784 |     | <span class='neutral'>        }</span>
  785 |     | <span class='neutral'></span>
  786 |     | <span class='neutral'>        // In this case, if the previous &#39;if&#39; condition is met, we add a</span>
  787 |     | <span class='neutral'>        // horizontal breakpoint. Otherwise, we add a ramp.</span>
  788 |     | <span class='unexecuted'>        if (</span>
  789 |     | <span class='unexecuted'>          (</span>
  790 |     | <span class='unexecuted'>            (seed_kernel[ii] &gt;&gt; 84) % 2 == 0</span>
  791 |     | <span class='neutral'>          ) || (</span>
  792 |     | <span class='unexecuted'>            load_logPrice(load_next(smallestPointerX59))</span>
  793 |     | <span class='neutral'>             - </span>
  794 |     | <span class='unexecuted'>            load_logPrice(smallestPointerX59) &lt;= minLogStep</span>
  795 |     | <span class='neutral'>          )</span>
  796 |     | <span class='neutral'>        ) {</span>
  797 |     | <span class='unexecuted'>          set_breakPoint(</span>
  798 |     | <span class='unexecuted'>            index,</span>
  799 |     | <span class='unexecuted'>            load_logPrice(load_next(smallestPointerX59)),</span>
  800 |     | <span class='unexecuted'>            load_height(smallestPointerX15)</span>
  801 |     | <span class='neutral'>          );</span>
  802 |     | <span class='unexecuted'>          index = index + oneIndex;</span>
  803 |     | <span class='neutral'>        }</span>
  804 |     | <span class='neutral'></span>
  805 |     | <span class='unexecuted'>        smallestPointerX59 = load_next(smallestPointerX59);</span>
  806 |     | <span class='neutral'>      }</span>
  807 |     | <span class='neutral'>    }</span>
  808 |     | <span class='neutral'></span>
  809 |     | <span class='unexecuted'>    if (</span>
  810 |     | <span class='unexecuted'>      notSkip1</span>
  811 |     | <span class='neutral'>       || </span>
  812 |     | <span class='unexecuted'>      qSpacing - load_logPrice(smallestPointerX59) &lt;= minLogStep</span>
  813 |     | <span class='neutral'>    ) {</span>
  814 |     | <span class='unexecuted'>      set_breakPoint(</span>
  815 |     | <span class='unexecuted'>        index,</span>
  816 |     | <span class='unexecuted'>        load_logPrice(smallestPointerX59),</span>
  817 |     | <span class='neutral'>        oneX15</span>
  818 |     | <span class='neutral'>      );</span>
  819 |     | <span class='unexecuted'>      index = index + oneIndex;</span>
  820 |     | <span class='neutral'>    }</span>
  821 |     | <span class='neutral'></span>
  822 |     | <span class='unexecuted'>    set_breakPoint(index, qSpacing, oneX15);</span>
  823 |     | <span class='unexecuted'>    index = index + oneIndex;</span>
  824 |     | <span class='neutral'></span>
  825 |     | <span class='unexecuted'>    setKernelLength(index);</span>
  826 |     | <span class='neutral'>  }</span>
  827 |     | <span class='neutral'></span>
  828 |     | <span class='neutral'>  /// @notice This function builds a curve and places it in memory.</span>
  829 |     | <span class='unexecuted'>  function _buildCurve(</span>
  830 |     | <span class='neutral'>    uint64[] calldata seed_curve,</span>
  831 |     | <span class='neutral'>    bool seed,</span>
  832 |     | <span class='neutral'>    X59 qLower,</span>
  833 |     | <span class='neutral'>    X59 qUpper</span>
  834 |     | <span class='unexecuted'>  ) private {</span>
  835 |     | <span class='unexecuted'>    uint256 pointer;</span>
  836 |     | <span class='unexecuted'>    {</span>
  837 |     | <span class='unexecuted'>      Curve curve;</span>
  838 |     | <span class='unexecuted'>      Kernel kernel = getKernel();</span>
  839 |     | <span class='unexecuted'>      Index length = getKernelLength() - oneIndex;</span>
  840 |     | <span class='neutral'>      assembly {</span>
  841 |     | <span class='unexecuted'>        pointer := add(kernel, shl(6, length))</span>
  842 |     | <span class='unexecuted'>        curve := pointer</span>
  843 |     | <span class='neutral'>      }</span>
  844 |     | <span class='unexecuted'>      setCurve(curve);</span>
  845 |     | <span class='neutral'>    }</span>
  846 |     | <span class='neutral'></span>
  847 |     | <span class='unexecuted'>    (</span>
  848 |     | <span class='unexecuted'>      X59 logPrice0,</span>
  849 |     | <span class='unexecuted'>      X59 logPrice1</span>
  850 |     | <span class='unexecuted'>    ) = seed ? (qLower, qUpper) : (qUpper, qLower);</span>
  851 |     | <span class='neutral'></span>
  852 |     | <span class='neutral'>    assembly {</span>
  853 |     | <span class='unexecuted'>      mstore(pointer, shl(192, logPrice0))</span>
  854 |     | <span class='neutral'>    }</span>
  855 |     | <span class='unexecuted'>    pointer += 8;</span>
  856 |     | <span class='neutral'></span>
  857 |     | <span class='unexecuted'>    uint256 k = 0;</span>
  858 |     | <span class='unexecuted'>    while (true) {</span>
  859 |     | <span class='neutral'>      assembly {</span>
  860 |     | <span class='unexecuted'>        mstore(pointer, shl(192, logPrice1))</span>
  861 |     | <span class='neutral'>      }</span>
  862 |     | <span class='unexecuted'>      pointer += 8;</span>
  863 |     | <span class='neutral'></span>
  864 |     | <span class='unexecuted'>      if (k == curveLengthLimit(seed_curve.length)) break;</span>
  865 |     | <span class='neutral'></span>
  866 |     | <span class='unexecuted'>      if (</span>
  867 |     | <span class='unexecuted'>        min(logPrice0, logPrice1) == max(logPrice0, logPrice1) - epsilonX59</span>
  868 |     | <span class='unexecuted'>      ) break;</span>
  869 |     | <span class='neutral'></span>
  870 |     | <span class='unexecuted'>      (logPrice0, logPrice1) = (</span>
  871 |     | <span class='unexecuted'>        logPrice1,</span>
  872 |     | <span class='unexecuted'>        get_a_logPrice_in_between(</span>
  873 |     | <span class='unexecuted'>          seed_curve[k],</span>
  874 |     | <span class='unexecuted'>          min(logPrice0, logPrice1) + epsilonX59,</span>
  875 |     | <span class='unexecuted'>          max(logPrice0, logPrice1) - epsilonX59</span>
  876 |     | <span class='neutral'>        )</span>
  877 |     | <span class='neutral'>      );</span>
  878 |     | <span class='neutral'></span>
  879 |     | <span class='unexecuted'>      ++k;</span>
  880 |     | <span class='neutral'>    }</span>
  881 |     | <span class='neutral'>    </span>
  882 |     | <span class='unexecuted'>    {</span>
  883 |     | <span class='unexecuted'>      Index length;</span>
  884 |     | <span class='neutral'>      assembly {</span>
  885 |     | <span class='unexecuted'>        length := k</span>
  886 |     | <span class='neutral'>      }</span>
  887 |     | <span class='unexecuted'>      setCurveLength(length + twoIndex);</span>
  888 |     | <span class='neutral'>    }</span>
  889 |     | <span class='neutral'></span>
  890 |     | <span class='unexecuted'>    setFreeMemoryPointer(pointer + 64);</span>
  891 |     | <span class='neutral'>  }</span>
  892 |     | <span class='neutral'></span>
  893 |     | <span class='neutral'>  /// @notice This function calculates &#39;originToOvershoot&#39; for a swap from</span>
  894 |     | <span class='neutral'>  /// &#39;getCurve().member(getKernelLength() - oneIndex)&#39; to</span>
  895 |     | <span class='neutral'>  /// &#39;getCurve().member(zeroIndex)&#39;.</span>
  896 |     | <span class='unexecuted'>  X216 public originToOvershoot_reference;</span>
  897 |     | <span class='unexecuted'>  function _originToOvershoot() private {</span>
  898 |     | <span class='unexecuted'>    originToOvershoot_reference = zeroX216;</span>
  899 |     | <span class='unexecuted'>    for (</span>
  900 |     | <span class='unexecuted'>      Index index = zeroIndex;</span>
  901 |     | <span class='unexecuted'>      index &lt; getKernelLength() - oneIndex;</span>
  902 |     | <span class='unexecuted'>      index = index + oneIndex</span>
  903 |     | <span class='unexecuted'>    ) {</span>
  904 |     | <span class='unexecuted'>      (X15 c0, X59 b0, , ) = getKernel().member(index);</span>
  905 |     | <span class='unexecuted'>      (X15 c1, X59 b1, , ) = getKernel().member(index + oneIndex);</span>
  906 |     | <span class='unexecuted'>      if (</span>
  907 |     | <span class='unexecuted'>        getCurve().member(zeroIndex) &lt;= getCurve().member(oneIndex)</span>
  908 |     | <span class='neutral'>      ) {</span>
  909 |     | <span class='unexecuted'>        b0 = getCurve().member(oneIndex) - b0;</span>
  910 |     | <span class='unexecuted'>        b1 = getCurve().member(oneIndex) - b1;</span>
  911 |     | <span class='neutral'>      } else {</span>
  912 |     | <span class='unexecuted'>        b0 = b0 + getCurve().member(oneIndex);</span>
  913 |     | <span class='unexecuted'>        b1 = b1 + getCurve().member(oneIndex);</span>
  914 |     | <span class='neutral'>      }</span>
  915 |     | <span class='unexecuted'>      originToOvershoot_reference = originToOvershoot_reference + </span>
  916 |     | <span class='unexecuted'>        outgoing_reference(c0, c1, b0, b1, b0, b1);</span>
  917 |     | <span class='neutral'>    }</span>
  918 |     | <span class='neutral'>  }</span>
  919 |     | <span class='neutral'></span>
  920 |     | <span class='neutral'>  /// @notice This function calculates &#39;incomingCurrentToTarget&#39;,</span>
  921 |     | <span class='neutral'>  /// &#39;currentToOrigin&#39;, and &#39;currentToTarget&#39; for a swap from</span>
  922 |     | <span class='neutral'>  /// &#39;getCurve().member(getKernelLength() - oneIndex)&#39; to</span>
  923 |     | <span class='neutral'>  /// &#39;getCurve().member(zeroIndex)&#39;.</span>
  924 |     | <span class='unexecuted'>  X216 public incomingCurrentToTarget_reference;</span>
  925 |     | <span class='unexecuted'>  X216 public currentToOrigin_reference;</span>
  926 |     | <span class='unexecuted'>  X216 public currentToTarget_reference;</span>
  927 |     | <span class='unexecuted'>  function _integrals() private {</span>
  928 |     | <span class='unexecuted'>    incomingCurrentToTarget_reference = zeroX216;</span>
  929 |     | <span class='unexecuted'>    currentToOrigin_reference = zeroX216;</span>
  930 |     | <span class='unexecuted'>    currentToTarget_reference = zeroX216;</span>
  931 |     | <span class='neutral'></span>
  932 |     | <span class='unexecuted'>    Index iIndex = getCurveLength() - oneIndex;</span>
  933 |     | <span class='unexecuted'>    X59 begin = getCurve().member(iIndex);</span>
  934 |     | <span class='unexecuted'>    X59 origin = getCurve().member(iIndex);</span>
  935 |     | <span class='unexecuted'>    X59 end = getCurve().member(iIndex);</span>
  936 |     | <span class='unexecuted'>    while(iIndex &gt;= oneIndex) {</span>
  937 |     | <span class='unexecuted'>      iIndex = iIndex - oneIndex;</span>
  938 |     | <span class='unexecuted'>      begin = origin;</span>
  939 |     | <span class='unexecuted'>      origin = end;</span>
  940 |     | <span class='unexecuted'>      end = getCurve().member(iIndex);</span>
  941 |     | <span class='unexecuted'>      for (</span>
  942 |     | <span class='unexecuted'>        Index jIndex = zeroIndex;</span>
  943 |     | <span class='unexecuted'>        jIndex &lt; getKernelLength() - oneIndex;</span>
  944 |     | <span class='unexecuted'>        jIndex = jIndex + oneIndex</span>
  945 |     | <span class='unexecuted'>      ) {</span>
  946 |     | <span class='unexecuted'>        (X15 c0, X59 b0, , ) = getKernel().member(jIndex);</span>
  947 |     | <span class='unexecuted'>        (X15 c1, X59 b1, , ) = getKernel().member(jIndex + oneIndex);</span>
  948 |     | <span class='unexecuted'>        X59 from;</span>
  949 |     | <span class='unexecuted'>        X59 to;</span>
  950 |     | <span class='unexecuted'>        if (end &lt; begin) {</span>
  951 |     | <span class='unexecuted'>          b0 = origin - b0;</span>
  952 |     | <span class='unexecuted'>          b1 = origin - b1;</span>
  953 |     | <span class='unexecuted'>          from = min(begin, b0);</span>
  954 |     | <span class='unexecuted'>          to = max(end, b1);</span>
  955 |     | <span class='unexecuted'>          if (from &lt; to) continue;</span>
  956 |     | <span class='neutral'>        } else {</span>
  957 |     | <span class='unexecuted'>          b0 = origin + b0;</span>
  958 |     | <span class='unexecuted'>          b1 = origin + b1;</span>
  959 |     | <span class='unexecuted'>          from = max(begin, b0);</span>
  960 |     | <span class='unexecuted'>          to = min(end, b1);</span>
  961 |     | <span class='unexecuted'>          if (to &lt; from) continue;</span>
  962 |     | <span class='neutral'>        }</span>
  963 |     | <span class='unexecuted'>        if (</span>
  964 |     | <span class='unexecuted'>          (getCurve().member(zeroIndex) &lt;= getCurve().member(oneIndex))</span>
  965 |     | <span class='neutral'>           == </span>
  966 |     | <span class='unexecuted'>          (end &lt; begin)</span>
  967 |     | <span class='neutral'>        ) {</span>
  968 |     | <span class='unexecuted'>          incomingCurrentToTarget_reference = </span>
  969 |     | <span class='unexecuted'>            incomingCurrentToTarget_reference + </span>
  970 |     | <span class='unexecuted'>            incoming_reference(c0, c1, b0, b1, from, to);</span>
  971 |     | <span class='unexecuted'>          currentToTarget_reference = </span>
  972 |     | <span class='unexecuted'>            currentToTarget_reference + </span>
  973 |     | <span class='unexecuted'>            outgoing_reference(c0, c1, b0, b1, from, to);</span>
  974 |     | <span class='neutral'>        } else {</span>
  975 |     | <span class='unexecuted'>          currentToOrigin_reference = </span>
  976 |     | <span class='unexecuted'>            currentToOrigin_reference + </span>
  977 |     | <span class='unexecuted'>            outgoing_reference(c0, c1, b0, b1, from, to);</span>
  978 |     | <span class='neutral'>        }</span>
  979 |     | <span class='neutral'>      }</span>
  980 |     | <span class='neutral'>    }</span>
  981 |     | <span class='neutral'>  }</span>
  982 |     | <span class='neutral'></span>
  983 |     | <span class='neutral'>  // This function builds a random curve and a random kernel and returns them</span>
  984 |     | <span class='neutral'>  // as returndata.</span>
  985 |     | <span class='unexecuted'>  function _build(</span>
  986 |     | <span class='neutral'>    X59 qSpacing,</span>
  987 |     | <span class='neutral'>    bool[3] calldata seed_base,</span>
  988 |     | <span class='neutral'>    uint64[3] calldata seed_boundaries,</span>
  989 |     | <span class='neutral'>    uint88[] calldata seed_kernel,</span>
  990 |     | <span class='neutral'>    uint64[] calldata seed_curve</span>
  991 |     | <span class='neutral'>  ) private {</span>
  992 |     | <span class='neutral'>    // The lower boundary of active interval is chosen between &#39;qSpacing&#39; and</span>
  993 |     | <span class='neutral'>    // &#39;thirtyTwoX59 - qSpacing - qSpacing&#39;.</span>
  994 |     | <span class='unexecuted'>    X59 qLower = get_a_logPrice_in_between(</span>
  995 |     | <span class='unexecuted'>      seed_boundaries[1],</span>
  996 |     | <span class='unexecuted'>      qSpacing + epsilonX59,</span>
  997 |     | <span class='unexecuted'>      thirtyTwoX59 - epsilonX59 - qSpacing - qSpacing</span>
  998 |     | <span class='neutral'>    );</span>
  999 |     | <span class='neutral'></span>
 1000 |     | <span class='neutral'>    // We build a kernel and places it in memory.</span>
 1001 |     | <span class='unexecuted'>    uint256 smallestPointer = _sortedX59(</span>
 1002 |     | <span class='unexecuted'>      seed_kernel,</span>
 1003 |     | <span class='unexecuted'>      seed_boundaries[2],</span>
 1004 |     | <span class='unexecuted'>      qSpacing</span>
 1005 |     | <span class='neutral'>    );</span>
 1006 |     | <span class='unexecuted'>    _buildKernel(</span>
 1007 |     | <span class='unexecuted'>      seed_kernel,</span>
 1008 |     | <span class='unexecuted'>      qSpacing,</span>
 1009 |     | <span class='unexecuted'>      seed_base[0],</span>
 1010 |     | <span class='unexecuted'>      seed_base[1],</span>
 1011 |     | <span class='unexecuted'>      kernelLengthLimit(seed_kernel.length),</span>
 1012 |     | <span class='unexecuted'>      smallestPointer,</span>
 1013 |     | <span class='unexecuted'>      _sortedX15(seed_kernel)</span>
 1014 |     | <span class='neutral'>    );</span>
 1015 |     | <span class='neutral'></span>
 1016 |     | <span class='neutral'>    // We build a curve and places it in memory.</span>
 1017 |     | <span class='unexecuted'>    _buildCurve(seed_curve, seed_base[2], qLower, qLower + qSpacing);</span>
 1018 |     | <span class='neutral'></span>
 1019 |     | <span class='neutral'>    // calculates &#39;originToOvershoot&#39; for a swap from</span>
 1020 |     | <span class='neutral'>    // &#39;getCurve().member(getKernelLength() - oneIndex)&#39; to</span>
 1021 |     | <span class='neutral'>    // &#39;getCurve().member(zeroIndex)&#39;.</span>
 1022 |     | <span class='unexecuted'>    _originToOvershoot();</span>
 1023 |     | <span class='neutral'></span>
 1024 |     | <span class='neutral'>    // calculates &#39;incomingCurrentToTarget&#39;,</span>
 1025 |     | <span class='neutral'>    // &#39;currentToOrigin&#39;, and &#39;currentToTarget&#39; for a swap from</span>
 1026 |     | <span class='neutral'>    // &#39;getCurve().member(getKernelLength() - oneIndex)&#39; to</span>
 1027 |     | <span class='neutral'>    // &#39;getCurve().member(zeroIndex)&#39;.</span>
 1028 |     | <span class='unexecuted'>    _integrals();</span>
 1029 |     | <span class='neutral'></span>
 1030 |     | <span class='neutral'>    // Returns the generated curve and kernel as returndata.</span>
 1031 |     | <span class='neutral'>    {</span>
 1032 |     | <span class='unexecuted'>      Curve curve = getCurve();</span>
 1033 |     | <span class='unexecuted'>      Index length = getCurveLength();</span>
 1034 |     | <span class='neutral'>      assembly {</span>
 1035 |     | <span class='unexecuted'>        return(_pointers_, sub(add(curve, shl(3, length)), _pointers_))</span>
 1036 |     | <span class='neutral'>      }</span>
 1037 |     | <span class='neutral'>    }</span>
 1038 |     | <span class='neutral'>  }</span>
 1039 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/echidna/IntegralTest.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./FuzzUtilities.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>using PriceLibrary for uint256;</span>
   7 |     | <span class='neutral'>using IntegralLibrary for uint256;</span>
   8 |     | <span class='neutral'>using IntegralLibrary for X216;</span>
   9 |     | <span class='neutral'></span>
  10 | *r  | <span class='executed'>contract IntegralTest {</span>
  11 | *   | <span class='executed'>  function integral_setter_getter_test(uint216 seed) public pure {</span>
  12 | *   | <span class='executed'>    X216 value = get_an_integral(seed);</span>
  13 | *   | <span class='executed'>    uint256 pointer = get_an_integral_pointer();</span>
  14 | *   | <span class='executed'>    pointer.setIntegral(value);</span>
  15 | *   | <span class='executed'>    assert(value == pointer.integral());</span>
  16 |     | <span class='neutral'>  }</span>
  17 |     | <span class='neutral'></span>
  18 | *   | <span class='executed'>  function integral_increment_decrement_test(</span>
  19 |     | <span class='neutral'>    uint216 seed0,</span>
  20 |     | <span class='neutral'>    uint216 seed1</span>
  21 | *   | <span class='executed'>  ) public pure {</span>
  22 | *   | <span class='executed'>    X216 value0 = get_an_integral(seed0);</span>
  23 | *   | <span class='executed'>    X216 value1 = get_an_integral(seed1);</span>
  24 | *   | <span class='executed'>    (value0, value1) = (value0 &lt;= value1) ? (value0, value1) : (value1, value0);</span>
  25 |     | <span class='neutral'></span>
  26 | *   | <span class='executed'>    uint256 pointer = get_an_integral_pointer();</span>
  27 | *   | <span class='executed'>    pointer.setIntegral(value1);</span>
  28 |     | <span class='neutral'></span>
  29 | *   | <span class='executed'>    pointer.decrementIntegral(value0);</span>
  30 | *   | <span class='executed'>    assert(value1 - value0 == pointer.integral());</span>
  31 |     | <span class='neutral'></span>
  32 | *   | <span class='executed'>    pointer.incrementIntegral(value0);</span>
  33 | *   | <span class='executed'>    assert(value1 == pointer.integral());</span>
  34 |     | <span class='neutral'>  }</span>
  35 |     | <span class='neutral'></span>
  36 | *   | <span class='executed'>  function evaluate_test(</span>
  37 |     | <span class='neutral'>    uint16 seed_c0,</span>
  38 |     | <span class='neutral'>    uint16 seed_c1,</span>
  39 |     | <span class='neutral'>    uint64 seed_b0,</span>
  40 |     | <span class='neutral'>    uint64 seed_b1,</span>
  41 |     | <span class='neutral'>    bool left,</span>
  42 |     | <span class='neutral'>    uint64 seed_q</span>
  43 | *   | <span class='executed'>  ) public pure {</span>
  44 | *   | <span class='executed'>    X15 c0 = get_a_height(seed_c0);</span>
  45 | *   | <span class='executed'>    X15 c1 = get_a_height(seed_c1);</span>
  46 | *   | <span class='executed'>    (c0, c1) = (c0 &lt; c1) ? (c0, c1) : (c1, c0);</span>
  47 | *   | <span class='executed'>    X59 b0 = get_a_logPrice_in_between(</span>
  48 | *   | <span class='executed'>      seed_b0,</span>
  49 |     | <span class='neutral'>      epsilonX59,</span>
  50 | *   | <span class='executed'>      thirtyTwoX59 - epsilonX59 - epsilonX59</span>
  51 |     | <span class='neutral'>    );</span>
  52 | *   | <span class='executed'>    X59 b1 = get_a_logPrice_in_between(</span>
  53 | *   | <span class='executed'>      seed_b1, b0 + epsilonX59,</span>
  54 | *   | <span class='executed'>      thirtyTwoX59 - epsilonX59</span>
  55 |     | <span class='neutral'>    );</span>
  56 | *   | <span class='executed'>    (b0, b1) = left ? (b0, b1) : (b1, b0);</span>
  57 | *   | <span class='executed'>    X59 q = get_a_logPrice_in_between(seed_q, b0, b1);</span>
  58 |     | <span class='neutral'></span>
  59 | *   | <span class='executed'>    (X216 sqrt0, X216 sqrtInverse0) = b0.exp();</span>
  60 | *   | <span class='executed'>    (X216 sqrt1, X216 sqrtInverse1) = b1.exp();</span>
  61 | *   | <span class='executed'>    uint256 segmentCoordinates = get_a_segment_pointer();</span>
  62 | *   | <span class='executed'>    segmentCoordinates.storePrice(c0, b0, sqrt0, sqrtInverse0);</span>
  63 | *   | <span class='executed'>    (segmentCoordinates + 64).storePrice(c1, b1, sqrt1, sqrtInverse1);</span>
  64 |     | <span class='neutral'></span>
  65 | *   | <span class='executed'>    (X216 sqrt, X216 sqrtInverse) = q.exp();</span>
  66 | *   | <span class='executed'>    uint256 targetPrice = get_a_price_pointer();</span>
  67 | *   | <span class='executed'>    targetPrice.storePrice(q, sqrt, sqrtInverse);</span>
  68 |     | <span class='neutral'></span>
  69 | *   | <span class='executed'>    assert(</span>
  70 | *   | <span class='executed'>      segmentCoordinates.evaluate(targetPrice) == </span>
  71 | *   | <span class='executed'>        evaluate_reference(c0, c1, b0, b1, q)</span>
  72 |     | <span class='neutral'>    );</span>
  73 |     | <span class='neutral'>  }</span>
  74 |     | <span class='neutral'></span>
  75 | *   | <span class='executed'>  function outgoing_incoming_test(</span>
  76 |     | <span class='neutral'>    uint16 seed_c0,</span>
  77 |     | <span class='neutral'>    uint16 seed_c1,</span>
  78 |     | <span class='neutral'>    uint64 seed_b0,</span>
  79 |     | <span class='neutral'>    uint64 seed_b1,</span>
  80 |     | <span class='neutral'>    bool direction,</span>
  81 |     | <span class='neutral'>    uint64 seed_from,</span>
  82 |     | <span class='neutral'>    uint64 seed_to</span>
  83 | *   | <span class='executed'>  ) public pure {</span>
  84 | *   | <span class='executed'>    X59 b0 = get_a_logPrice_in_between(</span>
  85 | *   | <span class='executed'>      seed_b0,</span>
  86 |     | <span class='neutral'>      epsilonX59,</span>
  87 | *   | <span class='executed'>      thirtyTwoX59 - epsilonX59 - epsilonX59</span>
  88 |     | <span class='neutral'>    );</span>
  89 | *   | <span class='executed'>    X59 b1 = get_a_logPrice_in_between(</span>
  90 | *   | <span class='executed'>      seed_b1,</span>
  91 | *   | <span class='executed'>      b0 + epsilonX59,</span>
  92 | *   | <span class='executed'>      thirtyTwoX59 - epsilonX59</span>
  93 |     | <span class='neutral'>    );</span>
  94 | *   | <span class='executed'>    (b0, b1) = direction ? (b0, b1) : (b1, b0);</span>
  95 | *   | <span class='executed'>    X15 c0 = get_a_height(seed_c0);</span>
  96 | *   | <span class='executed'>    X15 c1 = get_a_height(seed_c1);</span>
  97 | *   | <span class='executed'>    uint256 segmentCoordinates = get_a_segment_pointer();</span>
  98 | *   | <span class='executed'>    uint256 fromPrice = get_a_price_pointer();</span>
  99 | *   | <span class='executed'>    uint256 toPrice = get_a_price_pointer();</span>
 100 | *   | <span class='executed'>    X59 from = get_a_logPrice_in_between(seed_from, b0, b1);</span>
 101 | *   | <span class='executed'>    X59 to = get_a_logPrice_in_between(seed_to, b0, b1);</span>
 102 | *   | <span class='executed'>    {</span>
 103 | *   | <span class='executed'>      (c0, c1) = (c0 &lt; c1) ? (c0, c1) : (c1, c0);</span>
 104 | *   | <span class='executed'>      (from, to) = (from &lt; to) ? (from, to) : (to, from);</span>
 105 | *   | <span class='executed'>      (from, to) = direction ? (from, to) : (to, from);</span>
 106 |     | <span class='neutral'></span>
 107 | *   | <span class='executed'>      (X216 sqrt0, X216 sqrtInverse0) = b0.exp();</span>
 108 | *   | <span class='executed'>      (X216 sqrt1, X216 sqrtInverse1) = b1.exp();</span>
 109 | *   | <span class='executed'>      segmentCoordinates.storePrice(c0, b0, sqrt0, sqrtInverse0);</span>
 110 | *   | <span class='executed'>      (segmentCoordinates + 64).storePrice(c1, b1, sqrt1, sqrtInverse1);</span>
 111 |     | <span class='neutral'></span>
 112 | *   | <span class='executed'>      (X216 sqrt, X216 sqrtInverse) = from.exp();</span>
 113 | *   | <span class='executed'>      fromPrice.storePrice(from, sqrt, sqrtInverse);</span>
 114 |     | <span class='neutral'></span>
 115 | *   | <span class='executed'>      (sqrt, sqrtInverse) = to.exp();</span>
 116 | *   | <span class='executed'>      toPrice.storePrice(to, sqrt, sqrtInverse);</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 | *   | <span class='executed'>    assert(</span>
 120 | *   | <span class='executed'>      approximatelyEqual(</span>
 121 | *   | <span class='executed'>        segmentCoordinates.outgoing(fromPrice, toPrice),</span>
 122 | *   | <span class='executed'>        outgoing_reference(c0, c1, b0, b1, from, to),</span>
 123 | *   | <span class='executed'>        16</span>
 124 |     | <span class='neutral'>      )</span>
 125 |     | <span class='neutral'>    );</span>
 126 |     | <span class='neutral'></span>
 127 | *   | <span class='executed'>    assert(</span>
 128 | *   | <span class='executed'>      approximatelyEqual(</span>
 129 | *   | <span class='executed'>        segmentCoordinates.incoming(fromPrice, toPrice),</span>
 130 | *   | <span class='executed'>        incoming_reference(c0, c1, b0, b1, from, to),</span>
 131 | *   | <span class='executed'>        16</span>
 132 |     | <span class='neutral'>      )</span>
 133 |     | <span class='neutral'>    );</span>
 134 |     | <span class='neutral'>  }</span>
 135 |     | <span class='neutral'></span>
 136 | *   | <span class='executed'>  function shift_test(</span>
 137 |     | <span class='neutral'>    uint256 seed_integral,</span>
 138 |     | <span class='neutral'>    uint64 seed_price0,</span>
 139 |     | <span class='neutral'>    uint64 seed_price1</span>
 140 | *   | <span class='executed'>  ) public pure {</span>
 141 | *   | <span class='executed'>    X216 integralValue = X216.wrap(int256(</span>
 142 | *   | <span class='executed'>      seed_integral % uint256(X216.unwrap(expInverse8X216 * expInverse8X216))</span>
 143 |     | <span class='neutral'>    ));</span>
 144 |     | <span class='neutral'></span>
 145 | *   | <span class='executed'>    X59 price0 = get_a_logPrice_in_between(</span>
 146 | *   | <span class='executed'>      seed_price0,</span>
 147 |     | <span class='neutral'>      epsilonX59,</span>
 148 | *   | <span class='executed'>      thirtyTwoX59 - epsilonX59</span>
 149 |     | <span class='neutral'>    );</span>
 150 | *   | <span class='executed'>    (X216 sqrt0, X216 sqrtInverse0) = price0.exp();</span>
 151 | *   | <span class='executed'>    uint256 pointer0 = get_a_price_pointer();</span>
 152 | *   | <span class='executed'>    pointer0.storePrice(price0, sqrt0, sqrtInverse0);</span>
 153 |     | <span class='neutral'></span>
 154 | *   | <span class='executed'>    X59 price1 = get_a_logPrice_in_between(</span>
 155 | *   | <span class='executed'>      seed_price1,</span>
 156 |     | <span class='neutral'>      epsilonX59,</span>
 157 | *   | <span class='executed'>      thirtyTwoX59 - epsilonX59</span>
 158 |     | <span class='neutral'>    );</span>
 159 | *   | <span class='executed'>    (X216 sqrt1, X216 sqrtInverse1) = price1.exp();</span>
 160 | *   | <span class='executed'>    uint256 pointer1 = get_a_price_pointer();</span>
 161 | *   | <span class='executed'>    pointer1.storePrice(price1, sqrt1, sqrtInverse1);</span>
 162 |     | <span class='neutral'></span>
 163 | *   | <span class='executed'>    assert(</span>
 164 | *   | <span class='executed'>      approximatelyEqual(</span>
 165 | *   | <span class='executed'>        integralValue.shift(pointer0, pointer1, false),</span>
 166 | *   | <span class='executed'>        shift_reference(</span>
 167 | *   | <span class='executed'>          integralValue,</span>
 168 | *   | <span class='executed'>          sqrtInverse0,</span>
 169 | *   | <span class='executed'>          sqrtInverse1</span>
 170 |     | <span class='neutral'>        ),</span>
 171 | *   | <span class='executed'>        2 ** 32</span>
 172 |     | <span class='neutral'>      )</span>
 173 |     | <span class='neutral'>    );</span>
 174 |     | <span class='neutral'></span>
 175 | *   | <span class='executed'>    assert(</span>
 176 | *   | <span class='executed'>      approximatelyEqual(</span>
 177 | *   | <span class='executed'>        integralValue.shift(pointer0, pointer1, true),</span>
 178 | *   | <span class='executed'>        shift_reference(</span>
 179 | *   | <span class='executed'>          integralValue,</span>
 180 | *   | <span class='executed'>          sqrt0,</span>
 181 | *   | <span class='executed'>          sqrt1</span>
 182 |     | <span class='neutral'>        ),</span>
 183 | *   | <span class='executed'>        2 ** 32</span>
 184 |     | <span class='neutral'>      )</span>
 185 |     | <span class='neutral'>    );</span>
 186 |     | <span class='neutral'>  }</span>
 187 |     | <span class='neutral'>}</span>

</code>
<br />


/home/training/contracts/utilities/Curve.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {
   5 |     |   _spacing_,
   6 |     |   getCurveLength,
   7 |     |   setLogPriceCurrent,
   8 |     |   setCurveLength
   9 |     | } from "./Memory.sol";
  10 |     | import {
  11 |     |   Index,
  12 |     |   zeroIndex,
  13 |     |   oneIndex,
  14 |     |   twoIndex,
  15 |     |   maxCurveIndex
  16 |     | } from "./Index.sol";
  17 |     | import {PriceLibrary} from "./Price.sol";
  18 |     | import {
  19 |     |   X59,
  20 |     |   min,
  21 |     |   max,
  22 |     |   zeroX59,
  23 |     |   thirtyTwoX59,
  24 |     |   minLogSpacing
  25 |     | } from "./X59.sol";
  26 |     | import {
  27 |     |   LogSpacingIsTooSmall,
  28 |     |   BlankIntervalsShouldBeAvoided,
  29 |     |   InvalidCurveArrangement,
  30 |     |   CurveIndexOutOfRange
  31 |     | } from "./Errors.sol";
  32 |     | 
  33 |     | // The curve sequence comprises 64 bit logarithmic prices in the form of
  34 |     | //
  35 |     | //  '(2 ** 59) * (16 + qHistorical)'
  36 |     | //
  37 |     | // where
  38 |     | //
  39 |     | //  'qHistorical := log(pHistorical / pOffset)'.
  40 |     | //
  41 |     | // Hence, each slot of the curve sequence consists of up to four members. The
  42 |     | // curve sequence should have at least two members. The first and the second
  43 |     | // members are 'qLower' and 'qUpper' (i.e., boundaries of the active liquidity
  44 |     | // interval) with the order depending on the pool's history. The last member is
  45 |     | // always 'qCurrent'. Consider the following curve sequence:
  46 |     | // 
  47 |     | //  'q[0], q[1], q[2], ..., q[l - 1]'
  48 |     | //
  49 |     | // where 'l' is the number of members. In order for the above sequence to be
  50 |     | // considered valid, we should have:
  51 |     | //
  52 |     | //  'min(q[i - 1], q[i - 2]) < q[i] < max(q[i - 1], q[i - 2])'.
  53 |     | //
  54 |     | // This ordering rule is verified upon initialization of any pool and it is
  55 |     | // preserved by each amendment to the curve sequence.
  56 |     | type Curve is uint256;
  57 |     | 
  58 |     | using PriceLibrary for uint16;
  59 |     | using CurveLibrary for Curve global;
  60 |     | 
  61 |     | library CurveLibrary {
  62 |     |   /// @notice Returns the member of the curve sequence corresponding to the
  63 |     |   /// given index.
  64 |     |   ///
  65 |     |   /// Index out-of-range should be avoided externally.
  66 |     |   function member(
  67 |     |     Curve curve,
  68 |     |     Index index
  69 |     |   ) internal pure returns (
  70 |     |     X59 q
  71 |     |   ) {
  72 |     |     assembly {
  73 |     |       // Each member of the curve sequence is '64 bits == 8 bytes' which is why
  74 |     |       // we are shifting index by '3' bits (i.e., we are multiplying index by
  75 |     |       // '8 == 2 ** 3'). We load the memory slot whose most significant 64 bits
  76 |     |       // host the member that we are interested in. Then, we shift the content
  77 |     |       // by 192 bits to the right in order to discard the remaining bits.
  78 |     |       //
  79 |     |       //       ----------------------------------------------------
  80 |     |       //       | 64 bit member to be loaded | 192 additional bits |
  81 |     |       //       +---------------------------------------------------
  82 |     |       //       |
  83 |     |       //    pointer == curve + (index << 3)
  84 |     |       //
  85 |     |       // The addition is safe because index out-of-range is avoided externally.
  86 |     |       q := shr(192, mload(add(curve, shl(3, index))))
  87 |     |     }
  88 |     |   }
  89 |     | 
  90 |     |   /// @notice Returns the leftmost and rightmost members of the curve sequence.
  91 |     |   function boundaries(
  92 |     |     Curve curve
  93 |     |   ) internal pure returns (
  94 |     |     X59 qLower,
  95 |     |     X59 qUpper
  96 |     |   ) {
  97 |     |     // The first and the second members of the curve sequence are loaded.
  98 |     |     // Index-out-of-range is not possible because the curve sequence has at
  99 |     |     // least two members.
 100 |     |     qLower = curve.member(zeroIndex);
 101 |     |     qUpper = curve.member(oneIndex);
 102 |     | 
 103 |     |     // The two boundaries are arranged in order.
 104 |     |     //
 105 |     |     // Signed comparison is valid because both values are nonnegative and 
 106 |     |     // do not exceed '2 ** 64' since each one is loaded from 64 bits of memory.
 107 |     |     (qLower, qUpper) = (qUpper <= qLower) ? 
 108 |     |                        (qUpper, qLower) : 
 109 |     |                        (qLower, qUpper);
 110 |     |   }
 111 |     | 
 112 |     |   /// @notice Validates an initial curve provided by the pool creator.
 113 |     |   function validate(
 114 |     |     Curve curve
 115 |     |   ) internal pure returns (
 116 |     |     X59 qLower,
 117 |     |     X59 qUpper
 118 |     |   ) {
 119 |     |     // The first and the second members of the curve sequence to be verified
 120 |     |     // are loaded. The curve sequence is read from an 'uint256[]' calldata
 121 |     |     // array, whose length is non-zero due to the custom error
 122 |     |     // 'CurveLengthIsZero()'. Hence, index out of range is not possible at this
 123 |     |     // point.
 124 |     |     X59 q0 = curve.member(zeroIndex);
 125 |     |     X59 q1 = curve.member(oneIndex);
 126 |     |     
 127 |     |     // The output of 'member' is always non-negative and never exceeds 
 128 |     |     // '2 ** 64' (read from 64 bits of memory). Hence, signed comparison is
 129 |     |     // valid.
 130 |     |     (qLower, qUpper) = (q0 <= q1) ? (q0, q1) : (q1, q0);
 131 |     | 
 132 |     |     // Underflow is not possible due to the above rearrangement of 'qLower' and
 133 |     |     // 'qUpper'.
 134 |     |     X59 qSpacing = qUpper - qLower;
 135 |     | 
 136 |     |     // This is a one time calculation of 'sqrtSpacing' and 
 137 |     |     // 'sqrtInverseSpacing'. They will be used later for swaps.
 138 |     |     _spacing_.storePrice(qSpacing);
 139 |     | 
 140 |     |     // Since both sides are non-negative and less than '2 ** 64', all three 
 141 |     |     // signed comparisons are valid.
 142 |     |     require(qSpacing >= minLogSpacing, LogSpacingIsTooSmall(qSpacing));
 143 |     |     require(
 144 |     |       qLower > qSpacing,
 145 |     |       BlankIntervalsShouldBeAvoided(qLower, qUpper)
 146 |     |     );
 147 |     | 
 148 |     |     // Underflow is not possible because 'qSpacing' does not exceed '64' bits.
 149 |     |     // Hence, 'qSpacing <= (2 ** 64) - 1 < thirtyTwoX59'.
 150 |     |     require(
 151 |     |       qUpper < thirtyTwoX59 - qSpacing,
 152 |     |       BlankIntervalsShouldBeAvoided(qLower, qUpper)
 153 |     |     );
 154 |     | 
 155 |     |     Index length = twoIndex;
 156 |     |     while (true) {
 157 |     |       // This may be an out-of-range access which is intentional, because we
 158 |     |       // break before using 'q2' if 'length' is out of range.
 159 |     |       X59 q2 = curve.member(length);
 160 |     | 
 161 |     |       // During initialization of a pool, the provided 'curve' is always
 162 |     |       // followed by at least '64' bits of '0'. Hence, this indicates that we
 163 |     |       // have reached the end of the curve.
 164 |     |       if (q2 == zeroX59) break;
 165 |     | 
 166 |     |       // Here, we are checking the requirement:
 167 |     |       //
 168 |     |       //  'min(q0, q1) < q2 < max(q0, q1)'
 169 |     |       //
 170 |     |       // The output of 'member' is always non-negative and never exceeds 64
 171 |     |       // bits (loaded from 64 bits of memory). Hence signed comparisons are
 172 |     |       // valid.
 173 |     |       if ((q2 <= q0) || (q1 <= q2)) {
 174 |     |         if ((q2 <= q1) || (q0 <= q2)) {
 175 |     |           revert InvalidCurveArrangement(q0, q1, q2);
 176 |     |         }
 177 |     |       }
 178 |     | 
 179 |     |       // The two most recent members are shifted so that a new member can be
 180 |     |       // loaded as 'q2'.
 181 |     |       q0 = q1;
 182 |     |       q1 = q2;
 183 |     | 
 184 |     |       // This addition is safe and never exceeds the '2 ** 256 - 1' limit.
 185 |     |       length = length + oneIndex;
 186 |     |     }
 187 |     | 
 188 |     |     // The length of the given curve should not exceed 'maxCurveIndex'.
 189 |     |     require(length <= maxCurveIndex, CurveIndexOutOfRange(length));
 190 |     | 
 191 |     |     // 'q1' is the last valid member of the curve and therefore, it is set in
 192 |     |     // memory as 'qCurrent'.
 193 |     |     setLogPriceCurrent(q1);
 194 |     | 
 195 |     |     // The 'length' of the curve is stored in its appropriate memory location.
 196 |     |     // Due to the above check, this value is less than '2 ** 16' and can be
 197 |     |     // safely stored in the allocated 2 bytes of memory space.
 198 |     |     setCurveLength(length);
 199 |     |   }
 200 |     | 
 201 |     |   /// @notice Generates a new curve with two members and stores its memory
 202 |     |   /// pointer in the appropriate memory location.
 203 |     |   ///
 204 |     |   /// 'qCurrent' and 'qOther' should be positive and smaller than 
 205 |     |   /// 'thirtyTwoX59'.
 206 |     |   function newCurve(
 207 |     |     Curve curve,
 208 |     |     X59 qCurrent,
 209 |     |     X59 qOther
 210 |     |   ) internal pure {
 211 |     |     assembly {
 212 |     |       mstore(
 213 |     |         curve,
 214 |     |         or(
 215 |     |           // 'qOther' is written in the first place.
 216 |     |           shl(192, qOther),
 217 |     |           // 'qCurrent' is written in the second place.
 218 |     |           shl(128, qCurrent)
 219 |     |         )
 220 |     |       )
 221 |     |     }
 222 |     | 
 223 |     |     // The new length is stored in the allocated memory location.
 224 |     |     setCurveLength(twoIndex);
 225 |     |   }
 226 |     | 
 227 |     |   /// @notice Amends the curve by adding a new member.
 228 |     |   /// @param q is the given logarithmic price to be added to the curve
 229 |     |   /// sequence.
 230 |     |   /// 'q' must be positive and less than '2 ** 64'.
 231 |     |   function amend(
 232 |     |     Curve curve,
 233 |     |     X59 q
 234 |     |   ) internal pure {
 235 |     |     // The first and second members of the curve are loaded.
 236 |     |     // Index out of range is not possible because the curve has at least two 
 237 |     |     // members.
 238 |     |     X59 q0 = curve.member(zeroIndex);
 239 |     |     X59 q1 = curve.member(oneIndex);
 240 |     | 
 241 |     |     // If 'q' is not within the current active interval, then a new curve
 242 |     |     // sequence is constructed. Signed comparison is valid because 'q0', 'q1',
 243 |     |     // and 'q' are nonnegative and do not exceed 64 bits.
 244 |     |     if (q <= min(q0, q1)) {
 245 |     |       newCurve(curve, min(q0, q1), max(q0, q1));
 246 |     |       return;
 247 |     |     }
 248 |     |     if (max(q0, q1) <= q) {
 249 |     |       newCurve(curve, max(q0, q1), min(q0, q1));
 250 |     |       return;
 251 |     |     }
 252 |     | 
 253 |     |     // The length of the curve is loaded from the memory.
 254 |     |     Index length = getCurveLength();
 255 |     | 
 256 |     |     // Every member of the curve is exhausted until either the following rule
 257 |     |     // is violated or runs out of members:
 258 |     |     //
 259 |     |     // 'min(q[k - 1], q[k - 2]) < q[k] < max(q[k - 1], q[k - 2])'.
 260 |     |     //
 261 |     |     // Then, 'q' is written in the corresponding place and the rest of that
 262 |     |     // slot is cleared.
 263 |     |     Index index = oneIndex;
 264 |     |     while (true) {
 265 |     |       // Is 'q' between 'q0' and 'q1'? If so, we proceed forward, otherwise,
 266 |     |       // 'q' is written in place of 'q1' and the rest of that slot is cleared.
 267 |     |       // Signed comparisons are valid because 'q0', 'q1', and 'q' are
 268 |     |       // non-negative and do not exceed 64 bits.
 269 |     |       if ((q0 < q1) ? (q < q1) : (q1 < q)) {
 270 |     |         // This addition is safe and never exceeds the '2 ** 256 - 1' limit.
 271 |     |         index = index + oneIndex;
 272 |     |         q0 = q1;
 273 |     |         if (index < length) {
 274 |     |           // Index out-of-range is not possible due to the above check.
 275 |     |           q1 = curve.member(index);
 276 |     |         } else {
 277 |     |           break;
 278 |     |         }
 279 |     |       } else {
 280 |     |         break;
 281 |     |       }
 282 |     |     }
 283 |     | 
 284 |     |     // 'q' is added to the end.
 285 |     |     // This is not an out-of-range addition because one additional slot is
 286 |     |     // always reserved for the amendment of the curve. A maximum of 2
 287 |     |     // amendments occur per swap.
 288 |     |     assembly {
 289 |     |       mstore(add(curve, shl(3, index)), shl(192, q))
 290 |     |     }
 291 |     | 
 292 |     |     // 'index + oneIndex' must not exceed 'maxIndex'.
 293 |     |     require(index < maxCurveIndex, CurveIndexOutOfRange(index));
 294 |     | 
 295 |     |     // Lastly, 'curveLength' is updated.
 296 |     |     // Due to the above check, this value is less than '2 ** 16' and can be
 297 |     |     // safely stored in the allocated 2 bytes of memory space.
 298 |     |     setCurveLength(index + oneIndex);
 299 |     |   }
 300 |     | }

/home/training/contracts/utilities/Errors.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {Index} from "./Index.sol";
   5 |     | import {X15} from "./X15.sol";
   6 |     | import {X47} from "./X47.sol";
   7 |     | import {X59} from "./X59.sol";
   8 |     | import {X111} from "./X111.sol";
   9 |     | import {X127} from "./X127.sol";
  10 |     | import {X208} from "./X208.sol";
  11 |     | import {X216} from "./X216.sol";
  12 |     | import {Tag} from "./Tag.sol";
  13 |     | 
  14 |     | /// @notice Thrown in case of overflow when attempting to calculate
  15 |     | /// '(a * b) / denominator'.
  16 |     | error MulDivOverflow(uint256 a, uint256 b, uint256 denominator);
  17 |     | 
  18 |     | /// @notice Thrown in case of overflow or underflow when attempting to
  19 |     | /// calculate 'a + b'.
  20 |     | error SafeAddFailed(X127 a, X127 b);
  21 |     | 
  22 |     | /// @notice Thrown when balance exceeds 'type(uint128).max'.
  23 |     | error BalanceOverflow(uint256 balance);
  24 |     | 
  25 |     | /// @notice Thrown when safe cast into an int256 overflows.
  26 |     | error SafeCastOverflow(uint256 value);
  27 |     | 
  28 |     | /// @notice Thrown when the given 'qSpacing' is less than 'minLogSpacing'.
  29 |     | error LogSpacingIsTooSmall(X59 qSpacing);
  30 |     | 
  31 |     | /// @notice Thrown when attempting to initialize a curve sequence on blank
  32 |     | /// intervals.
  33 |     | error BlankIntervalsShouldBeAvoided(X59 qLower, X59 qUpper);
  34 |     | 
  35 |     | /// @notice Thrown when 'curveLength' is zero upon initialization.
  36 |     | error CurveLengthIsZero();
  37 |     | 
  38 |     | /// @notice Each member of the curve sequence should be in-between the
  39 |     | /// preceding two members. Thrown when a given initial curve sequence violates
  40 |     | /// this rule.
  41 |     | error InvalidCurveArrangement(X59 q0, X59 q1, X59 q2);
  42 |     | 
  43 |     | /// @notice Thrown when 'curveLength' is out of range.
  44 |     | error CurveIndexOutOfRange(Index length);
  45 |     | 
  46 |     | /// @notice Thrown in case of overflow when attempting to calculate 
  47 |     | ///
  48 |     | /// 'amount := ceiling(
  49 |     | ///
  50 |     | ///     shares *
  51 |     | ///
  52 |     | ///     (getZeroForOne() ? sqrtOffset : sqrtInverseOffset) * 
  53 |     | ///
  54 |     | ///      multiplier
  55 |     | ///     ------------
  56 |     | ///       2 ** 208
  57 |     | ///  )'.
  58 |     | error SafeOutOfRangeAmountOverflow(
  59 |     |   X127 sqrtOffsetOrSqrtInverseOffset,
  60 |     |   X208 growthMultiplier,
  61 |     |   int256 shares
  62 |     | );
  63 |     | 
  64 |     | /// @notice Thrown in case of overflow when attempting to calculate 
  65 |     | ///
  66 |     | /// 'amount := ceiling(
  67 |     | ///
  68 |     | ///     (zeroOrOne ? sqrtOffset : sqrtInverseOffset) * 
  69 |     | ///
  70 |     | ///      liquidity      integral
  71 |     | ///     ----------- * -------------
  72 |     | ///       2 ** 111     outgoingMax
  73 |     | ///  )'.
  74 |     | error SafeInRangeAmountOverflow(
  75 |     |   X127 sqrtOffsetOrSqrtInverseOffset,
  76 |     |   X216 integral,
  77 |     |   X111 liquidity,
  78 |     |   X216 outgoingMax,
  79 |     |   uint256 outgoingMaxModularInverse
  80 |     | );
  81 |     | 
  82 |     | /// @notice Thrown when the second horizontal coordinate of a given kernel is
  83 |     | /// '0'. In this case, we have a vertical jump at the origin which limits
  84 |     | /// liquidity growth.
  85 |     | error SecondHorizontalCoordinateIsZero();
  86 |     | 
  87 |     | /// @notice The horizontal coordinates should be monotonically non-decreasing.
  88 |     | error NonMonotonicHorizontalCoordinates(X59 q_i, X59 q_j);
  89 |     | 
  90 |     | /// @notice The vertical coordinates should be monotonically non-decreasing.
  91 |     | error NonMonotonicVerticalCoordinates(X15 c_i, X15 c_j);
  92 |     | 
  93 |     | /// @notice There should not be repetitive points.
  94 |     | error RepetitiveKernelPoints(X15 c_i, X59 q_i);
  95 |     | 
  96 |     | /// @notice Thrown when the horizontal coordinates of a non-vertical and 
  97 |     | /// non-horizontal segment are closer than '2 ** 32'.
  98 |     | error SlopeTooHigh(X59 q_i, X59 q_j);
  99 |     | 
 100 |     | /// @notice Thrown when the horizontal coordinates of a given 'kernelCompact'
 101 |     | /// exceeds 'qSpacing'.
 102 |     | error HorizontalCoordinatesMayNotExceedLogSpacing(X59 q_j, X59 qSpacing);
 103 |     | 
 104 |     | /// @notice There should not be three repetitive horizontal coordinates. A 
 105 |     | /// vertical jump (i.e., discontinuity) is permitted and can be constructed
 106 |     | /// via two repetitive horizontal coordinates. However, three repetitive
 107 |     | /// horizontal coordinates are always redundant and should be avoided.
 108 |     | error RepetitiveHorizontalCoordinates(X59 q_i);
 109 |     | 
 110 |     | /// @notice There should not be three repetitive vertical coordinates. A 
 111 |     | /// horizontal segment (i.e., constant range) is permitted and can be 
 112 |     | /// constructed via two repetitive vertical coordinates. However, three
 113 |     | /// repetitive vertical coordinates are always redundant and should be
 114 |     | /// avoided.
 115 |     | error RepetitiveVerticalCoordinates(X15 c_i);
 116 |     | 
 117 |     | /// @notice Thrown when 'kernelLength' is out of range.
 118 |     | error KernelIndexOutOfRange(Index length);
 119 |     | 
 120 |     | /// @notice The last vertical coordinate should be equal to 'oneX15'.
 121 |     | error LastVerticalCoordinateMismatch(X15 c_j);
 122 |     | 
 123 |     | /// @notice Thrown when growth exceeds maximum permitted value of 'maxGrowth'.
 124 |     | error GrowthOverflow();
 125 |     | 
 126 |     | /// @notice Thrown when accrued growth portion values exceed '2 ** 104 - 1'.
 127 |     | error AccruedGrowthPortionOverflow(X127 accruedValue);
 128 |     | 
 129 |     | /// @notice Thrown when given flags are invalid or not consistent with hook.
 130 |     | error InvalidFlags(uint256);
 131 |     | 
 132 |     | /// @notice Thrown when the numerical search for outgoing target fails which 
 133 |     | /// should never heappen.
 134 |     | error SearchingForOutgoingTargetFailed();
 135 |     | 
 136 |     | /// @notice Thrown when the numerical search for incoming target fails which
 137 |     | /// should never heappen.
 138 |     | error SearchingForIncomingTargetFailed();
 139 |     | 
 140 |     | /// @notice Thrown when the numerical search for overshoot fails which should
 141 |     | /// never heappen.
 142 |     | error SearchingForOvershootFailed();
 143 |     | 
 144 |     | /// @notice Thrown if attempting to unlock the protocol while already unlocked.
 145 |     | error AlreadyUnlocked(address currentCaller);
 146 |     | 
 147 |     | /// @notice Thrown when any of the following methods are invoked prior to the
 148 |     | /// protocol being unlocked:
 149 |     | ///
 150 |     | ///   'INofeeswap.clear'
 151 |     | ///   'INofeeswap.take'
 152 |     | ///   'INofeeswap.settle'
 153 |     | ///   'INofeeswap.transferTransientBalanceFrom'
 154 |     | ///   'INofeeswap.modifyBalance'
 155 |     | ///   'INofeeswap.swap'
 156 |     | ///   'INofeeswapDelegatee.modifyPosition'
 157 |     | ///   'INofeeswapDelegatee.donate'
 158 |     | ///
 159 |     | error ProtocolIsLocked();
 160 |     | 
 161 |     | /// @notice Thrown when attempting to perform the following operations on a 
 162 |     | /// pool which is locked:
 163 |     | ///
 164 |     | ///   'INofeeswap.swap'
 165 |     | ///   'INofeeswapDelegatee.modifyPosition'
 166 |     | ///   'INofeeswapDelegatee.donate'
 167 |     | ///   'INofeeswapDelegatee.modifyKernel'
 168 |     | ///   'INofeeswapDelegatee.modifyPoolGrowthPortion'
 169 |     | ///   'INofeeswapDelegatee.updateGrowthPortions'
 170 |     | ///   'INofeeswapDelegatee.collectPool'
 171 |     | ///   'INofeeswapDelegatee.collectProtocol'
 172 |     | ///
 173 |     | error PoolIsLocked(uint256 poolId);
 174 |     | 
 175 |     | /// @notice Thrown when the deployment of static parameters fail.
 176 |     | error DeploymentFailed();
 177 |     | 
 178 |     | /// @notice Thrown when the method 'redeployStaticParamsAndKernel' is run
 179 |     | /// externally.
 180 |     | error CannotRedeployStaticParamsAndKernelExternally();
 181 |     | 
 182 |     | /// @notice Thrown when attempting to sync protocol's reserve of native token.
 183 |     | error NativeTokenCannotBeSynced();
 184 |     | 
 185 |     | /// @notice Thrown when the spender allowance for a tag is insufficient.
 186 |     | error InsufficientPermission(address spender, Tag tag);
 187 |     | 
 188 |     | /// @notice Thrown when the total number of shares accross all liquidity
 189 |     | /// intervals exceed '2 ** 127 - 1'.
 190 |     | error SharesGrossOverflow(int256 sharesGross);
 191 |     | 
 192 |     | /// @notice Thrown when attempting to access a pool which does not exist.
 193 |     | error PoolDoesNotExist(uint256 poolId);
 194 |     | 
 195 |     | /// @notice Thrown when the owner balance for a tag is insufficient.
 196 |     | error InsufficientBalance(address owner, Tag tag);
 197 |     | 
 198 |     | /// @notice Throws when Sentinel response is invalid.
 199 |     | error InvalidSentinelResponse(bytes4 response);
 200 |     | 
 201 |     | /// @notice Thrown when the given 'zeroForOne' is not in agreement with 
 202 |     | /// 'logPriceLimitOffsetted'.
 203 |     | error InvalidDirection(X59 current, X59 limit);
 204 |     | 
 205 |     | /// @notice Thrown when attempting to initialize a pool that already exists.
 206 |     | error PoolExists(uint256 poolId);
 207 |     | 
 208 |     | /// @notice Thrown when 'log(pOffset)' is not within the range '[-89, +89]'.
 209 |     | error LogOffsetOutOfRange(X59 qOffset);
 210 |     | 
 211 |     | /// @notice Thrown when the given tags are not in the correct order, i.e.,
 212 |     | /// 'tag0 < tag1'.
 213 |     | error TagsOutOfOrder(Tag tag0, Tag tag1);
 214 |     | 
 215 |     | /// @notice Thrown when a given growth portion is greater than one.
 216 |     | error InvalidGrowthPortion(X47 poolGrowthPortion);
 217 |     | 
 218 |     | /// @notice Thrown when a given logarithmic price does not belong to the range
 219 |     | /// '[log(pOffset) - 16 + 1 / (2 ** 59), log(pOffset) + 16 - 1 / (2 ** 59)]'.
 220 |     | error LogPriceOutOfRange(X59 logPrice);
 221 |     | 
 222 |     | /// @notice Thrown when attempting to mint/burn a position with zero shares or
 223 |     | /// when the number of shares does not belong to 
 224 |     | /// '[- type(int128).max, type(int128).max]'.
 225 |     | error InvalidNumberOfShares(int256 shares);
 226 |     | 
 227 |     | /// @notice Thrown when attempting to initialize a pool with 'poolId == 0'.
 228 |     | error PoolIdCannotBeZero();
 229 |     | 
 230 |     | /// @notice Thrown when attempting to access protocol operations via an
 231 |     | /// unauthorized address.
 232 |     | error OnlyByProtocol(address attemptingAddress, address protocolAddress);
 233 |     | 
 234 |     | /// @notice Thrown when attempting to access pool operations via an
 235 |     | /// unauthorized address.
 236 |     | error OnlyByPoolOwner(address attemptingAddress, address poolOwnerAddress);
 237 |     | 
 238 |     | /// @notice Thrown when attempting to mint/burn a position with invalid
 239 |     | /// lower bound which is not equal to interval boundaries modulo 'qSpacing'.
 240 |     | error LogPriceMinIsNotSpaced(X59 logPriceMin);
 241 |     | 
 242 |     | /// @notice Thrown when attempting to mint/burn a position with invalid
 243 |     | /// upper bound which is not equal to interval boundaries modulo 'qSpacing'.
 244 |     | error LogPriceMaxIsNotSpaced(X59 logPriceMax);
 245 |     | 
 246 |     | /// @notice Thrown when attempting to mint/burn a position with invalid
 247 |     | /// lower bound which is not greater than 'qSpacing'
 248 |     | error LogPriceMinIsInBlankArea(X59 logPriceMin);
 249 |     | 
 250 |     | /// @notice Thrown when attempting to mint/burn a position with invalid
 251 |     | /// lower bound which is not less than 'thirtyTwoX59 - qSpacing'.
 252 |     | error LogPriceMaxIsInBlankArea(X59 logPriceMax);
 253 |     | 
 254 |     | /// @notice Thrown when the given logPrices for a position are not in the
 255 |     | /// correct order.
 256 |     | error LogPricesOutOfOrder(X59 logPriceMin, X59 logPriceMax);
 257 |     | 
 258 |     | /// @notice Thrown when attempting donate to a pool whose donate flag is not 
 259 |     | /// active.
 260 |     | error DonateIsNotAllowed(uint256 poolId);
 261 |     | 
 262 |     | /// @notice Thrown when attempting to perform a donate to an empty interval.
 263 |     | error CannotDonateToEmptyInterval();
 264 |     | 
 265 |     | /// @notice Thrown when attempting to change an immutable kernel.
 266 |     | error ImmutableKernel(uint256 poolId);
 267 |     | 
 268 |     | /// @notice Thrown when attempting to change an immutable poolGrowthPortion.
 269 |     | error ImmutablePoolGrowthPortion(uint256 poolId);
 270 |     | 
 271 |     | /// @notice Thrown when attempting to make a delegate call to the protocol.
 272 |     | error NoDelegateCall(address context);
 273 |     | 
 274 |     | /// @notice Thrown when transient balances are not cleared.
 275 |     | error OutstandingAmount();
 276 |     | 
 277 |     | /// @notice Thrown when attempting to transfer NofeeAssets to address 0.
 278 |     | error CannotTransferToAddressZero();
 279 |     | 
 280 |     | /// @notice Thrown when the amount to be cleared is not equal to the transient
 281 |     | /// balance of 'msg.sender'.
 282 |     | error NotEqualToTransientBalance(int256 currentBalance);
 283 |     | 
 284 |     | /// @notice Thrown when the size of 'hookData' exceeds 'type(uint16).max'.
 285 |     | error HookDataTooLong(uint256 hookDataByteCount);
 286 |     | 
 287 |     | /// @notice Thrown when attempting to transfer ownership to address 0.
 288 |     | error AdminCannotBeAddressZero();
 289 |     | 
 290 |     | /// @notice Thrown when attempting to settle a tag with nonzero 'msg.value'.
 291 |     | error MsgValueIsNonZero(uint256 msgValue);
 292 |     | 
 293 |     | /// @notice Thrown when attempting to mint a position after burning it in the
 294 |     | /// same transaction.
 295 |     | error CannotMintAfterBurning(uint256 poolId, X59 qMin, X59 qMax);

/home/training/contracts/utilities/FullMath.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {MulDivOverflow} from "./Errors.sol";
   5 |     | 
   6 |     | /// @title Contains 512-bit multiplication and division functions
   7 |     | /// Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
   8 |     | /// for several functions in this library.
   9 |     | library FullMathLibrary {
  10 |     |   ///                           _____   _____   _____
  11 |     |   /// @notice 512-bit addition 'r1 r0 = a1 a0 + b1 b0'.
  12 |     |   /// Overflow should be avoided externally.
  13 |     |   /// @param a0 Least significant 256 bits of the first number.
  14 |     |   /// @param a1 Most significant 256 bits of the first number.
  15 |     |   /// @param b0 Least significant 256 bits of the second number.
  16 |     |   /// @param b1 Most significant 256 bits of the second number.
  17 |     |   /// @return r0 Least significant 256 bits of the addition.
  18 |     |   /// @return r1 Most significant 256 bits of the addition.
  19 |     |   function add512(
  20 |     |     uint256 a0,
  21 |     |     uint256 a1,
  22 |     |     uint256 b0,
  23 |     |     uint256 b1
  24 |     |   ) internal pure returns (
  25 |     |     uint256 r0,
  26 |     |     uint256 r1
  27 |     |   ) {
  28 |     |     //      s0
  29 |     |     //      a1 a0
  30 |     |     // +    b1 b0
  31 |     |     // -----------
  32 |     |     //      r1 r0
  33 |     |     //
  34 |     |     // where 's0 := lt(r0, a0)'.
  35 |     |     assembly {
  36 |     |       r0 := add(a0, b0)
  37 |     |       r1 := add(
  38 |     |         add(a1, b1),
  39 |     |         // 'r0 < a0' indicates that the addition 'a0 + b0' has overflowed. In
  40 |     |         // this case '1' needs to be added to the most significant 256 bits of
  41 |     |         // the output.
  42 |     |         lt(r0, a0)
  43 |     |       )
  44 |     |     }
  45 |     |   }
  46 |     | 
  47 |     |   ///                              _____   _____   _____
  48 |     |   /// @notice 512-bit subtraction 'r1 r0 = a1 a0 - b1 b0'.
  49 |     |   /// Underflow should be avoided externally.
  50 |     |   /// @param a0 Least significant 256 bits of the minuend.
  51 |     |   /// @param a1 Most significant 256 bits of the minuend.
  52 |     |   /// @param b0 Least significant 256 bits of the subtrahend.
  53 |     |   /// @param b1 Most significant 256 bits of the subtrahend.
  54 |     |   /// @return r0 Least significant 256 bits of the subtraction.
  55 |     |   /// @return r1 Most significant 256 bits of the subtraction.
  56 |     |   function sub512(
  57 |     |     uint256 a0,
  58 |     |     uint256 a1,
  59 |     |     uint256 b0,
  60 |     |     uint256 b1
  61 |     |   ) internal pure returns (
  62 |     |     uint256 r0,
  63 |     |     uint256 r1
  64 |     |   ) {
  65 |     |     //      a1 a0
  66 |     |     // -    b1 b0
  67 |     |     // -----------
  68 |     |     //      s1 r0
  69 |     |     // -    s0
  70 |     |     // -----------
  71 |     |     //      r1 r0
  72 |     |     //
  73 |     |     // where 's0 := lt(a0, b0)' and 's1 := (a1 - b1) % (2 ** 256)'.
  74 |     |     assembly {
  75 |     |       r0 := sub(a0, b0)
  76 |     |       r1 := sub(
  77 |     |         sub(a1, b1),
  78 |     |         // 'a0 < b0' indicates that the subtraction 'a0 - b0' has underflowed.
  79 |     |         // In this case '1' needs to be subtracted from the most significant
  80 |     |         // 256 bits of the output.
  81 |     |         lt(a0, b0)
  82 |     |       )
  83 |     |     }
  84 |     |   }
  85 |     | 
  86 |     |   ///                           ___________
  87 |     |   /// @notice 512-bit multiply 'prod1 prod0 = a * b'.
  88 |     |   /// @param a The multiplicand.
  89 |     |   /// @param b The multiplier.
  90 |     |   /// @return prod0 Least significant 256 bits of the product.
  91 |     |   /// @return prod1 Most significant 256 bits of the product.
  92 | *   |   function mul512(
  93 |     |     uint256 a,
  94 |     |     uint256 b
  95 |     |   ) internal pure returns (
  96 | *   |     uint256 prod0, 
  97 | *   |     uint256 prod1
  98 |     |   ) {
  99 | *   |     assembly {
 100 |     |       // 'mm := a * b - (2 ** 256 - 1) * q'
 101 | *   |       let mm := mulmod(a, b, not(0))
 102 |     | 
 103 |     |       // 'prod0 := a * b - (2 ** 256) * p'
 104 | *   |       prod0 := mul(a, b)
 105 |     | 
 106 | *   |       prod1 := sub(
 107 |     |         // 'mm - prod0 == q'.
 108 | *   |         sub(mm, prod0),
 109 |     |         //               a * b                 a * b
 110 |     |         // p == floor(----------) <= floor(--------------) == q
 111 |     |         //             2 ** 256             2 ** 256 - 1
 112 |     |         //
 113 |     |         // On the other hand, since
 114 |     |         //
 115 |     |         //      a * b          a * b                  a * b
 116 |     |         // -------------- - ---------- == ----------------------------- < 1
 117 |     |         //  2 ** 256 - 1     2 ** 256      (2 ** 256) * (2 ** 256 - 1)
 118 |     |         //
 119 |     |         // we have 'q - p <= 1'.
 120 |     |         //
 121 |     |         // Hence, either 'p == q' or 'p == q - 1'.
 122 |     |         //
 123 |     |         // If 'p == q', then 'mm - prod0 == q >= 0'.
 124 |     |         // If 'p == q - 1', then 'prod0 - mm == (2 ** 256) - q > 0'.
 125 |     |         //
 126 |     |         // Since 'p == q' and 'p == q - 1' are mutually exclusive, we can argue
 127 |     |         // that:
 128 |     |         //
 129 |     |         // 'p == q' if and only if 'mm >= prod0'.
 130 |     |         // 'p == q - 1' if and only if 'mm < prod0'.
 131 |     |         //
 132 |     |         // Hence, in the latter case, we should subtract by '1'.
 133 | *   |         lt(mm, prod0)
 134 |     |       )
 135 |     |     }
 136 |     |   }
 137 |     | 
 138 |     |   /// @notice Calculates (a * b) / denominator when 
 139 |     |   /// 'a * b < denominator * (denominator - 1)'.
 140 |     |   /// @param a The multiplicand.
 141 |     |   /// @param b The multiplier.
 142 |     |   /// @param denominator The divisor.
 143 |     |   /// @return result '(a * b) / denominator'.
 144 | *   |   function cheapMulDiv(
 145 |     |     uint256 a,
 146 |     |     uint256 b,
 147 |     |     uint256 denominator
 148 |     |   ) internal pure returns (
 149 | *   |     uint256 result
 150 |     |   ) {
 151 |     |     assembly {
 152 | *   |       result := sub(denominator, 1)
 153 |     | 
 154 |     |       // 's := a * b - q * (denominator - 1)'
 155 |     |       // 'r := a * b - p * denominator'
 156 |     |       // 's - r == p * denominator == p' [mod (denominator - 1)]
 157 | *   |       result := addmod(
 158 | *   |         mulmod(a, b, result),
 159 |     |         // This subtraction is safe because 
 160 |     |         // '(a * b) % denominator <= denominator - 1'.
 161 | *   |         sub(result, mulmod(a, b, denominator)),
 162 | *   |         result
 163 |     |       )
 164 |     |       // Notice that 'result <= denominator - 1' and because of the input
 165 |     |       // requirement, we have 'p = (a * b) / denominator <= denominator - 1'.
 166 |     |       // Hence, 'result == s - r == p'.
 167 |     |     }
 168 |     |   }
 169 |     | 
 170 |     |   /// @notice Calculates the modular inverse of an odd number modulo '2 ** 256'
 171 |     |   /// Input should be odd.
 172 |     |   /// @param value The number whose modular inverse to be calculated.
 173 |     |   /// @return inverse A 256-bit inverse satisfying
 174 |     |   /// 'value * inverse == 1' [mod 2 ** 256].
 175 | *   |   function modularInverse(
 176 |     |     uint256 value
 177 |     |   ) internal pure returns (
 178 | *   |     uint256 inverse
 179 |     |   ) {
 180 |     |     unchecked {
 181 |     |       // Compute the inverse by starting with a seed that is correct for four
 182 |     |       // bits. That is, 'value * inverse = 1' [mod 2 ** 4].
 183 | *   |       inverse = 3 * value ^ 2;
 184 |     |       // Now use Newton-Raphson iterations to improve the precision. Thanks to
 185 |     |       // Hensel's lifting lemma, this also works in modular arithmetic,
 186 |     |       // doubling the correct bits in each step.
 187 | *   |       inverse *= 2 - value * inverse;
 188 | *   |       inverse *= 2 - value * inverse;
 189 | *   |       inverse *= 2 - value * inverse;
 190 | *   |       inverse *= 2 - value * inverse;
 191 | *   |       inverse *= 2 - value * inverse;
 192 | *   |       inverse *= 2 - value * inverse;
 193 |     |     }
 194 |     |   }
 195 |     | 
 196 |     |   ///                          ________
 197 |     |   /// @notice 768-bit multiply q2 q1 q0 = a * b * c
 198 |     |   /// @param a The multiplicand.
 199 |     |   /// @param b The first multiplier.
 200 |     |   /// @param c The second multiplier.
 201 |     |   /// @return q0 Least significant 256 bits of the product.
 202 |     |   /// @return q1 Middle 256 bits of the product.
 203 |     |   /// @return q2 Most significant 256 bits of the product.
 204 |     |   function mul768(
 205 |     |     uint256 a,
 206 |     |     uint256 b,
 207 |     |     uint256 c
 208 |     |   ) internal pure returns (
 209 |     |     uint256 q0,
 210 |     |     uint256 q1,
 211 |     |     uint256 q2
 212 |     |   ) {
 213 |     |     //          a
 214 |     |     // x        b
 215 |     |     // -----------
 216 |     |     //      q1 q0
 217 |     |     // x        c
 218 |     |     // -----------
 219 |     |     //   ss 
 220 |     |     //      mm q0
 221 |     |     // + q2 q1  0
 222 |     |     // -----------
 223 |     |     //   q2 q1 q0
 224 |     |     //
 225 |     |     uint256 mm;
 226 |     |     (q0, q1) = mul512(a, b);
 227 |     |     (q1, q2) = mul512(q1, c);
 228 |     |     (q0, mm) = mul512(q0, c);
 229 |     |     assembly {
 230 |     |       q1 := add(q1, mm)
 231 |     |       // 'q1 < mm' indicates that the above addition has overflowed (i.e.,
 232 |     |       // 'ss == 1') and hence, '1' needs to be added to the most significant
 233 |     |       // 256 bits of the product.
 234 |     |       q2 := add(q2, lt(q1, mm))
 235 |     |     }
 236 |     |   }
 237 |     | 
 238 |     |   /// @notice Calculates 
 239 |     |   ///
 240 |     |   ///         a * b * c
 241 |     |   /// 'min(----------------, 2 ** 216 - 1)'
 242 |     |   ///       d * (2 ** 143)
 243 |     |   ///
 244 |     |   /// with full precision when 'a * b * c != 0'.
 245 |     |   /// @param a The multiplicand.
 246 |     |   /// @param b The first multiplier.
 247 |     |   /// @param c The second multiplier.
 248 |     |   /// @param d The denominator.
 249 |     |   /// @param roundUp Whether to round up the result.
 250 |     |   /// @return result The output value '(a * b * c) / (d * (2 ** 143))' which is
 251 |     |   /// capped by '2 ** 216 - 1'.
 252 |     |   function mulDiv(
 253 |     |     uint256 a,
 254 |     |     uint256 b,
 255 |     |     uint256 c,
 256 |     |     uint256 d,
 257 |     |     bool roundUp
 258 |     |   ) internal pure returns (
 259 |     |     uint256 result
 260 |     |   ) {
 261 |     |     unchecked {
 262 |     |       // ________
 263 |     |       // q2 q1 q0 = a * b * c
 264 |     |       (uint256 q0, uint256 q1, uint256 q2) = mul768(a, b, c);
 265 |     | 
 266 |     |       // If 'q2 >= (1 << 103)', then the output is greater than or equal to
 267 |     |       //
 268 |     |       //  (2 ** 103) * (2 ** 256) * (2 ** 256)
 269 |     |       // -------------------------------------- == 2 ** 216
 270 |     |       //        (2 ** 256) * (2 ** 143)
 271 |     |       //
 272 |     |       // In this case, '2 ** 216 - 1' should be returned.
 273 |     |       if (q2 >= (1 << 103)) return ((1 << 216) - 1);
 274 |     | 
 275 |     |       // Divide the numerator by '2 ** 143'
 276 |     |       (q2, q1) = (
 277 |     |         (q2 << 113) | (q1 >> 143),
 278 |     |         (q1 << 113) | (q0 >> 143)
 279 |     |       );
 280 |     | 
 281 |     |       // Calculating the remainder of the numerator modulo 'd'.
 282 |     |       uint256 r;
 283 |     |       assembly {
 284 |     |         r := addmod(
 285 |     |           addmod(q1, q2, d), // (q1 + q2) % d
 286 |     |           mulmod(q2, not(0), d), // (q2 * (2 ** 256 - 1)) % d
 287 |     |           d
 288 |     |         ) // (q1 + q2 * (2 ** 256)) % d
 289 |     |       }
 290 |     |       
 291 |     |       //                         _____
 292 |     |       // 'r' is subtracted from 'q2 q1'.
 293 |     |       assembly {
 294 |     |         // 'q1 < r' indicates that the subtraction 'q1 - r' underflows.
 295 |     |         // In this case '1' needs to be subtracted from q2.
 296 |     |         q2 := sub(q2, lt(q1, r))
 297 |     |         q1 := sub(q1, r)
 298 |     |       }
 299 |     | 
 300 |     |       // Determines whether to return '2 ** 216 - 1'.
 301 |     |       //                _____
 302 |     |       // Check whether 'q2 q1 >= (2 ** 256) * d'.
 303 |     |       if (q2 >= d) return ((1 << 216) - 1);
 304 |     | 
 305 |     |       // 'd' is factored into an odd part and a power of two. 
 306 |     |       // Then, the numerator is divided by the power of two.
 307 |     |       {
 308 |     |         // This is the largest power of two that 'd' is divisible by.
 309 |     |         uint256 twos = (0 - d) & d;
 310 |     |         assembly {
 311 |     |           // Dividing 'd' by 'twos'.
 312 |     |           d := div(d, twos)
 313 |     | 
 314 |     |           //           _____
 315 |     |           // Dividing 'q2 q1' by 'twos' and storing the least significant '256'
 316 |     |           // bits in 'q1'.
 317 |     |           q1 := or(
 318 |     |             div(q1, twos), // 'q1 / (2 ** k)'
 319 |     |             mul(
 320 |     |               q2,
 321 |     |               add(
 322 |     |                 div(
 323 |     |                   sub(0, twos), // '2 ** 256 - 2 ** k'
 324 |     |                   twos // '2 ** k'
 325 |     |                 ), // '2 ** (256 - k) - 1'
 326 |     |                 1
 327 |     |               ) // '(2 ** (256 - k)) % (2 ** 256)'
 328 |     |             ) // '(q2 * (2 ** (256 - k))) % (2 ** 256)'
 329 |     |           ) // '(q2 * (2 ** (256 - k)) + q1 / (2 ** k)) % (2 ** 256)'
 330 |     |         }
 331 |     |       }
 332 |     | 
 333 |     |       // The result can now be calculated precisely using modular inverse.
 334 |     |       // Let 'di := modularInverse(d)'.
 335 |     |       //
 336 |     |       //  _____
 337 |     |       // 'q2 q1 == d * result'
 338 |     |       // '(2 ** 256) * q2 + q1 == d * result'
 339 |     |       // 'di * (2 ** 256) * q2 + di * q1 == di * d * result'
 340 |     |       // 'di * (2 ** 256) * q2 + di * q1 == ((2 ** 256) * k + 1) * result'
 341 |     |       // 'di * q1 == result' [mod 2 ** 256]
 342 |     |       result = modularInverse(d) * q1;
 343 |     | 
 344 |     |       // If either of the remainders are positive, then the result should be
 345 |     |       // rounded up.
 346 |     |       if (roundUp) {
 347 |     |         if ((q0 & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) > 0 || r > 0) {
 348 |     |           ++result;
 349 |     |         }
 350 |     |       }
 351 |     | 
 352 |     |       // Determines whether to return '2 ** 216 - 1'.
 353 |     |       if (result >= (1 << 216)) return ((1 << 216) - 1);
 354 |     |     }
 355 |     |   }
 356 |     | 
 357 |     |   /// @notice Calculates
 358 |     |   ///
 359 |     |   ///      a * b * c
 360 |     |   /// '----------------'
 361 |     |   ///   d * (2 ** 111)
 362 |     |   ///
 363 |     |   /// with full precision. Overflows if the result exceeds 'type(int256).max'.
 364 |     |   /// 'e' must be the modular inverse of 'd / (2 ** k)' where 'k' is the
 365 |     |   /// largest power of two within 'd'.
 366 |     |   /// We should have 'a * b * c != 0' and 'd != 0'.
 367 |     |   /// @param a The multiplicand.
 368 |     |   /// @param b The first multiplier.
 369 |     |   /// @param c The second multiplier.
 370 |     |   /// @param d The denominator.
 371 |     |   /// @param e Modular inverse of the odd part of the denominator.
 372 |     |   /// @param roundUp Whether to round up the result.
 373 |     |   /// @return result The output value '(a * b * c) / (d * (2 ** 111))' if there
 374 |     |   /// is no overflow.
 375 |     |   /// @return overflow Whether the result overflows.
 376 |     |   function mulDiv(
 377 |     |     uint256 a,
 378 |     |     uint256 b,
 379 |     |     uint256 c,
 380 |     |     uint256 d,
 381 |     |     uint256 e,
 382 |     |     bool roundUp
 383 |     |   ) internal pure returns (
 384 |     |     uint256 result,
 385 |     |     bool overflow
 386 |     |   ) {
 387 |     |     unchecked {
 388 |     |       // ________
 389 |     |       // q2 q1 q0 = a * b * c
 390 |     |       (uint256 q0, uint256 q1, uint256 q2) = mul768(a, b, c);
 391 |     | 
 392 |     |       // If 'q2 >= (1 << 111)', then the output is greater than or equal to
 393 |     |       //
 394 |     |       //  (2 ** 111) * (2 ** 256) * (2 ** 256)
 395 |     |       // -------------------------------------- == 2 ** 256
 396 |     |       //        (2 ** 256) * (2 ** 111)
 397 |     |       //
 398 |     |       // In this case, we return overflow.
 399 |     |       if (q2 >= (1 << 111)) return (0, true);
 400 |     | 
 401 |     |       // Divide the numerator by '2 ** 111'
 402 |     |       (q2, q1) = (
 403 |     |         (q2 << 145) | (q1 >> 111),
 404 |     |         (q1 << 145) | (q0 >> 111)
 405 |     |       );
 406 |     | 
 407 |     |       // Calculating the remainder of the numerator modulo 'd'.
 408 |     |       uint256 r;
 409 |     |       assembly {
 410 |     |         r := addmod(
 411 |     |           addmod(q1, q2, d), // (q1 + q2) % d
 412 |     |           mulmod(q2, not(0), d), // (q2 * (2 ** 256 - 1)) % d
 413 |     |           d
 414 |     |         ) // (q1 + q2 * (2 ** 256)) % d
 415 |     |       }
 416 |     | 
 417 |     |       //                         _____
 418 |     |       // 'r' is subtracted from 'q2 q1'.
 419 |     |       assembly {
 420 |     |         // 'q1 < r' indicates that the subtraction 'q1 - r' underflowes.
 421 |     |         // In this case '1' needs to be subtracted from q2.
 422 |     |         q2 := sub(q2, lt(q1, r))
 423 |     |         q1 := sub(q1, r)
 424 |     |       }
 425 |     | 
 426 |     |       // Determines whether to return overflow.
 427 |     |       // The following equality is satisfied if and only if
 428 |     |       //
 429 |     |       //      a * b * c
 430 |     |       // '---------------- >= (2 ** 256)'
 431 |     |       //   d * (2 ** 111)
 432 |     |       //
 433 |     |       if (q2 >= d) return (0, true);
 434 |     | 
 435 |     |       // 'd' is factored into an odd part and a power of two and the numerator
 436 |     |       // is divided by the power of two.
 437 |     |       d = (0 - d) & d;
 438 |     |       assembly {
 439 |     |         q1 := or(
 440 |     |           div(q1, d), // q1 / (2 ** k)
 441 |     |           mul(
 442 |     |             q2,
 443 |     |             add(
 444 |     |               div(
 445 |     |                 sub(0, d), // '2 ** 256 - 2 ** k'
 446 |     |                 d // '2 ** k'
 447 |     |               ), // '2 ** (256 - k) - 1'
 448 |     |               1
 449 |     |             ) // '(2 ** (256 - k)) % (2 ** 256)'
 450 |     |           ) // '(q2 * (2 ** (256 - k))) % (2 ** 256)'
 451 |     |         ) // '(q2 * (2 ** (256 - k)) + q1 / (2 ** k)) % (2 ** 256)'
 452 |     |       }
 453 |     | 
 454 |     |       // The result can now be calculated precisely using 'e'.
 455 |     |       //  _____
 456 |     |       // 'q2 q1 == d * result'
 457 |     |       // '(2 ** 256) * q2 + q1 == d * result'
 458 |     |       // 'e * (2 ** 256) * q2 + e * q1 == e * d * result'
 459 |     |       // 'e * (2 ** 256) * q2 + e * q1 == ((2 ** 256) * k + 1) * result'
 460 |     |       // 'e * q1 == result' [mod 2 ** 256]
 461 |     |       result = e * q1;
 462 |     | 
 463 |     |       // If either of the remainders are positive, then the result should be
 464 |     |       // rounded up.
 465 |     |       if (roundUp) {
 466 |     |         if ((q0 & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFF) > 0 || r > 0) {
 467 |     |           ++result;
 468 |     |         }
 469 |     |       }
 470 |     | 
 471 |     |       // Determines whether to overflow.
 472 |     |       if (result >= (1 << 255)) return (0, true);
 473 |     |     }
 474 |     |   }
 475 |     | 
 476 |     |   /// @notice Calculates floor((a * b) / denominator) with full precision.
 477 |     |   /// Overflow should be avoided externally.
 478 |     |   /// @param a The multiplicand
 479 |     |   /// @param b The multiplier
 480 |     |   /// @param denominator The divisor
 481 |     |   /// @return result The 256-bit result
 482 | *   |   function mulDiv(
 483 |     |     uint256 a,
 484 |     |     uint256 b,
 485 |     |     uint256 denominator
 486 |     |   ) internal pure returns (
 487 | *   |     uint256 result
 488 |     |   ) {
 489 |     |     unchecked {
 490 |     |       //                   ___________
 491 |     |       // 512-bit multiply 'prod1 prod0 = a * b'
 492 |     |       // Compute the product mod 2**256 and mod 2 ** 256 - 1
 493 |     |       // then use the Chinese Remainder Theorem to reconstruct
 494 |     |       // the 512 bit result. The result is stored in two 256
 495 |     |       // variables such that product = prod1 * (2 ** 256) + prod0
 496 | *   |       (uint256 prod0, uint256 prod1) = mul512(a, b);
 497 |     | 
 498 |     |       // Short circuit 256 by 256 division
 499 |     |       // This saves gas when a * b is small, at the cost of making the
 500 |     |       // large case a bit more expensive. Depending on your use case you
 501 |     |       // may want to remove this short circuit and always go through the
 502 |     |       // 512 bit path.
 503 | *   |       if (prod1 == 0) {
 504 |     |         assembly {
 505 | *   |           result := div(prod0, denominator)
 506 |     |         }
 507 | *   |         return result;
 508 |     |       }
 509 |     |       
 510 |     |       ///////////////////////////////////////////////
 511 |     |       // 512 by 256 division.
 512 |     |       ///////////////////////////////////////////////
 513 |     | 
 514 |     |       //                                                        ___________
 515 |     |       // Make division exact by subtracting the remainder from 'prod1 prod0'
 516 |     |       // Compute remainder using mulmod
 517 |     |       // Note mulmod(_, _, 0) == 0
 518 | *   |       uint256 remainder;
 519 |     |       assembly {
 520 | *   |         remainder := mulmod(a, b, denominator)
 521 |     |       }
 522 |     | 
 523 |     |       // Subtract 256 bit number from 512 bit number
 524 |     |       assembly {
 525 | *   |         prod1 := sub(prod1, gt(remainder, prod0))
 526 | *   |         prod0 := sub(prod0, remainder)
 527 |     |       }
 528 |     |       
 529 |     |       // Factor powers of two out of denominator
 530 |     |       // Compute largest power of two-divisor of denominator.
 531 |     |       // Always >= 1 unless the denominator is zero, then twos is zero.
 532 | *   |       uint256 twos = (0 - denominator) & denominator;
 533 |     |       // Divide denominator by power of two
 534 |     |       assembly {
 535 | *   |         denominator := div(denominator, twos)
 536 |     |       }
 537 |     |       
 538 |     |       //         ___________
 539 |     |       // Divide 'prod1 prod0' by the factors of two
 540 |     |       assembly {
 541 | *   |         prod0 := div(prod0, twos)
 542 |     |       }
 543 |     |       // Shift in bits from prod1 into prod0. For this we need
 544 |     |       // to flip `twos` such that it is 2**256 / twos.
 545 |     |       // If twos is zero, then it becomes one
 546 |     |       assembly {
 547 | *   |         twos := add(div(sub(0, twos), twos), 1)
 548 |     |       }
 549 | *   |       prod0 |= prod1 * twos;
 550 |     |       
 551 |     |       // Invert denominator mod 2**256
 552 |     |       // Now that denominator is an odd number, it has an inverse
 553 |     |       // modulo 2**256 such that denominator * inv = 1 mod 2**256.
 554 |     |       // Compute the inverse by starting with a seed that is correct
 555 |     |       // correct for four bits. That is, denominator * inv = 1 mod 2**4
 556 |     |       // If denominator is zero the inverse starts with 2
 557 |     |       // Now use Newton-Raphson iteration to improve the precision.
 558 |     |       // Thanks to Hensel's lifting lemma, this also works in modular
 559 |     |       // arithmetic, doubling the correct bits in each step.
 560 | *   |       uint256 inv = modularInverse(denominator);
 561 |     |       // If denominator is zero, inv is now 128
 562 |     |       
 563 |     |       // Because the division is now exact we can divide by multiplying
 564 |     |       // with the modular inverse of the denominator. This will give us the
 565 |     |       // correct result modulo 2**256. Since the preconditions guarantee
 566 |     |       // that the outcome is less than 2**256, this is the final result.
 567 |     |       // We don't need to compute the high bits of the result and prod1
 568 |     |       // is no longer required.
 569 | *   |       result = prod0 * inv;
 570 | *   |       return result;
 571 |     |     }
 572 |     |   }
 573 |     | 
 574 |     |   /// @notice Calculates ceiling((a * b) / denominator) with full precision.
 575 |     |   /// Overflow should be avoided externally.
 576 |     |   /// @param a The multiplicand
 577 |     |   /// @param b The multiplier
 578 |     |   /// @param denominator The divisor
 579 |     |   /// @return result The 256-bit result
 580 |     |   function mulDivRoundUp(
 581 |     |     uint256 a,
 582 |     |     uint256 b,
 583 |     |     uint256 denominator
 584 |     |   ) internal pure returns (uint256 result) {
 585 |     |     result = mulDiv(a, b, denominator);
 586 |     |     // The result is incremented if 'a * b' is not divisible by 'denominator'.
 587 |     |     assembly {
 588 |     |       result := add(result, gt(mulmod(a, b, denominator), 0))
 589 |     |     }
 590 |     |   }
 591 |     | 
 592 |     |   /// @notice Calculates floor((a * b) / denominator) with full precision.
 593 |     |   /// Throws in case of overflow.
 594 |     |   /// @param a The multiplicand
 595 |     |   /// @param b The multiplier
 596 |     |   /// @param denominator The divisor
 597 |     |   /// @return result The 256-bit result
 598 |     |   function safeMulDiv(
 599 |     |     uint256 a,
 600 |     |     uint256 b,
 601 |     |     uint256 denominator
 602 |     |   ) internal pure returns (uint256 result) {
 603 |     |     (, uint256 prod1) = mul512(a, b);
 604 |     |     require(prod1 < denominator, MulDivOverflow(a, b, denominator));
 605 |     |     result = mulDiv(a, b, denominator);
 606 |     |   }
 607 |     | 
 608 |     |   /// @notice Calculates ceiling((a * b) / denominator) with full precision.
 609 |     |   /// Throws in case of overflow.
 610 |     |   /// @param a The multiplicand
 611 |     |   /// @param b The multiplier
 612 |     |   /// @param denominator The divisor
 613 |     |   /// @return result The 256-bit result
 614 |     |   function safeMulDivRoundUp(
 615 |     |     uint256 a,
 616 |     |     uint256 b,
 617 |     |     uint256 denominator
 618 |     |   ) internal pure returns (uint256 result) {
 619 |     |     // The result is incremented if 'a * b' is not divisible by 'denominator'.
 620 |     |     assembly {
 621 |     |       result := gt(mulmod(a, b, denominator), 0)
 622 |     |     }
 623 |     |     result += safeMulDiv(a, b, denominator);
 624 |     |   }
 625 |     | }

/home/training/contracts/utilities/Index.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | // Type index is used to enumerate members of the curve and kernel.
   5 |     | type Index is uint256;
   6 |     | 
   7 |     | Index constant zeroIndex = Index.wrap(0);
   8 |     | Index constant oneIndex = Index.wrap(1);
   9 |     | Index constant twoIndex = Index.wrap(2);
  10 |     | Index constant threeIndex = Index.wrap(3);
  11 |     | Index constant maxCurveIndex = Index.wrap(type(uint16).max);
  12 |     | Index constant maxKernelIndex = Index.wrap(1020);
  13 |     | 
  14 |     | using {equals as ==, notEquals as !=} for Index global;
  15 |     | using {lessThan as <, greaterThan as >} for Index global;
  16 |     | using {lessThanOrEqualTo as <=, greaterThanOrEqualTo as >=} for Index global;
  17 |     | using {add as +, sub as -} for Index global;
  18 |     | 
  19 |     | function equals(
  20 |     |   Index value0,
  21 |     |   Index value1
  22 |     | ) pure returns (
  23 |     |   bool result
  24 |     | ) {
  25 |     |   assembly {
  26 |     |     result := eq(value0, value1)
  27 |     |   }
  28 |     | }
  29 |     | 
  30 |     | function notEquals(
  31 |     |   Index value0,
  32 |     |   Index value1
  33 |     | ) pure returns (
  34 |     |   bool result
  35 |     | ) {
  36 |     |   return !(value0 == value1);
  37 |     | }
  38 |     | 
  39 |     | function lessThan(
  40 |     |   Index value0,
  41 |     |   Index value1
  42 |     | ) pure returns (
  43 |     |   bool result
  44 |     | ) {
  45 |     |   assembly {
  46 |     |     result := lt(value0, value1)
  47 |     |   }
  48 |     | }
  49 |     | 
  50 |     | function greaterThan(
  51 |     |   Index value0,
  52 |     |   Index value1
  53 |     | ) pure returns (
  54 |     |   bool result
  55 |     | ) {
  56 |     |   assembly {
  57 |     |     result := gt(value0, value1)
  58 |     |   }
  59 |     | }
  60 |     | 
  61 |     | function lessThanOrEqualTo(
  62 |     |   Index value0,
  63 |     |   Index value1
  64 |     | ) pure returns (
  65 |     |   bool result
  66 |     | ) {
  67 |     |   return !(value0 > value1);
  68 |     | }
  69 |     | 
  70 |     | function greaterThanOrEqualTo(
  71 |     |   Index value0,
  72 |     |   Index value1
  73 |     | ) pure returns (
  74 |     |   bool result
  75 |     | ) {
  76 |     |   return !(value0 < value1);
  77 |     | }
  78 |     | 
  79 |     | // Overflow should be avoided externally.
  80 |     | function add(
  81 |     |   Index value0,
  82 |     |   Index value1
  83 |     | ) pure returns (
  84 |     |   Index result
  85 |     | ) {
  86 |     |   assembly {
  87 |     |     result := add(value0, value1)
  88 |     |   }
  89 |     | }
  90 |     | 
  91 |     | // Underflow should be avoided externally.
  92 |     | function sub(
  93 |     |   Index value0,
  94 |     |   Index value1
  95 |     | ) pure returns (
  96 |     |   Index result
  97 |     | ) {
  98 |     |   assembly {
  99 |     |     result := sub(value0, value1)
 100 |     |   }
 101 |     | }
 102 |     | 
 103 |     | function min(
 104 |     |   Index value0,
 105 |     |   Index value1
 106 |     | ) pure returns (
 107 |     |   Index result
 108 |     | ) {
 109 |     |   return (value0 < value1) ? value0 : value1;
 110 |     | }
 111 |     | 
 112 |     | function max(
 113 |     |   Index value0,
 114 |     |   Index value1
 115 |     | ) pure returns (
 116 |     |   Index result
 117 |     | ) {
 118 |     |   return (value0 < value1) ? value1 : value0;
 119 |     | }
 120 |     | 
 121 |     | library IndexLibrary {
 122 |     |   /// @notice Returns the current 16-bit index of the curve or kernel under 
 123 |     |   /// exploration given the corresponding pointer.
 124 |     |   ///
 125 |     |   /// 'pointer' should be a constant value.
 126 |     |   function getIndex(
 127 |     |     uint256 pointer
 128 |     |   ) internal pure returns (
 129 |     |     Index value
 130 |     |   ) {
 131 |     |     assembly {
 132 |     |       // First, the memory slot whose most significant 16 bits host the index
 133 |     |       // is loaded and then the least significant 240 bits are discarded.
 134 |     |       value := shr(240, mload(pointer))
 135 |     |     }
 136 |     |   }
 137 |     | 
 138 |     |   /// @notice Increases a 16-bit index stored in memory by one, given a 
 139 |     |   /// pointer. The new value for the index is then returned.
 140 |     |   /// Overflow should be avoided externally.
 141 |     |   ///
 142 |     |   /// 'pointer' should be a constant value.
 143 |     |   function incrementIndex(
 144 |     |     uint256 pointer
 145 |     |   ) internal pure returns (
 146 |     |     Index value
 147 |     |   ) {
 148 |     |     assembly {
 149 |     |       // Index is the most significant 16 bit. Hence, to increment it we need
 150 |     |       // to add the slot by '2 ** 240'.
 151 |     |       value := add(mload(pointer), shl(240, 1))
 152 |     |       mstore(pointer, value)
 153 |     | 
 154 |     |       // Then, the least significant 240 bits are discarded and the resulting
 155 |     |       // value is returned.
 156 |     |       value := shr(240, value)
 157 |     |     }
 158 |     |   }
 159 |     | 
 160 |     |   /// @notice Decreases a 16-bit index stored in memory by one, given a 
 161 |     |   /// pointer. The new value for the index is then returned.
 162 |     |   /// Underflow should be avoided externally.
 163 |     |   ///
 164 |     |   /// 'pointer' should be a constant value.
 165 |     |   function decrementIndex(
 166 |     |     uint256 pointer
 167 |     |   ) internal pure returns (
 168 |     |     Index value
 169 |     |   ) {
 170 |     |     assembly {
 171 |     |       // Index is the most significant 16 bit. Hence, to decrement it we need
 172 |     |       // to subtract the slot by '2 ** 240'.
 173 |     |       value := sub(mload(pointer), shl(240, 1))
 174 |     |       mstore(pointer, value)
 175 |     | 
 176 |     |       // Then, the least significant 240 bits are discarded and the resulting
 177 |     |       // value is returned.
 178 |     |       value := shr(240, value)
 179 |     |     }
 180 |     |   }
 181 |     | }

/home/training/contracts/utilities/Integral.sol
    1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
    2 |     | pragma solidity ^0.8.28;
    3 |     | 
    4 |     | import {zeroX15, X15} from "./X15.sol";
    5 |     | import {twoX59, X59} from "./X59.sol";
    6 |     | import {X74} from "./X74.sol";
    7 |     | import {zeroX216, X216} from "./X216.sol";
    8 |     | import {PriceLibrary} from "./Price.sol";
    9 |     | 
   10 |     | // (2 ** 240) * exp(-8)
   11 |     | uint256 constant EXP_INV_8_X240 = 
   12 | *   |   0x00000015FC21041027ACBBFCD46780FEE71EAD23FBCB7F4A81E58767EF801A32;
   13 |     | 
   14 |     | library IntegralLibrary {
   15 |     |   using PriceLibrary for uint256;
   16 |     | 
   17 |     |   /// @notice Let 'l' and 'u' denote the logarithmic prices whose offset binary
   18 |     |   /// 'X59' representation is stored in the pointers 'price0' and 'price1',
   19 |     |   /// respectively. In other words, define:
   20 |     |   ///
   21 |     |   ///               price0.log()                         price1.log()
   22 |     |   ///  l := - 16 + --------------    and    u := - 16 + --------------
   23 |     |   ///                 2 ** 59                              2 ** 59
   24 |     |   /// -------------------------------------------------------------------------
   25 |     |   /// If 'left == false' this function transforms the given integral
   26 |     |   ///
   27 |     |   ///             / u
   28 |     |   ///            |      -h/2
   29 |     |   ///  input :=  |     e     f(h - l) dh
   30 |     |   ///            |
   31 |     |   ///           / l
   32 |     |   ///
   33 |     |   /// to the following:
   34 |     |   ///
   35 |     |   ///     / u                                     / u
   36 |     |   ///    |      +h/2                 +(l + u)/2  |      -h/2
   37 |     |   ///    |     e     f(u - h) dh == e            |     e     f(h - l) dh ==
   38 |     |   ///    |                                       |
   39 |     |   ///   / l                                     / l
   40 |     |   ///
   41 |     |   ///  exp(+ l / 2) * exp(+ u / 2) * input ==
   42 |     |   ///
   43 |     |   ///  (2**216) * exp(-8+l/2) * (2**216) * exp(-8+u/2) * input
   44 |     |   /// --------------------------------------------------------- == 
   45 |     |   ///                     (2 ** 432) * exp(-16)
   46 |     |   ///
   47 |     |   ///  (2**216) * exp(-16+(l+16)/2) * (2**216) * exp(-16+(u+16)/2) * input
   48 |     |   /// --------------------------------------------------------------------- == 
   49 |     |   ///                       (2 ** 432) * exp(-16)
   50 |     |   ///
   51 |     |   ///  price0.sqrt(true) * price1.sqrt(true) * input
   52 |     |   /// -----------------------------------------------
   53 |     |   ///             (2 ** 432) * exp(-16)
   54 |     |   ///
   55 |     |   /// -------------------------------------------------------------------------
   56 |     |   /// If 'left == true' the integral
   57 |     |   ///
   58 |     |   ///             / u
   59 |     |   ///            |      +h/2
   60 |     |   ///  input :=  |     e     f(u - h) dh
   61 |     |   ///            |
   62 |     |   ///           / l
   63 |     |   ///
   64 |     |   /// is transformed to 
   65 |     |   ///
   66 |     |   ///     / u                                     / u
   67 |     |   ///    |      -h/2                 -(l + u)/2  |      +h/2
   68 |     |   ///    |     e     f(h - l) dh == e            |     e     f(u - h) dh == 
   69 |     |   ///    |                                       |
   70 |     |   ///   / l                                     / l
   71 |     |   ///
   72 |     |   ///  exp(- l / 2) * exp(- u / 2) * input ==
   73 |     |   ///
   74 |     |   ///  (2**216) * exp(-8-l/2) * (2**216) * exp(-8-u/2) * input
   75 |     |   /// --------------------------------------------------------- == 
   76 |     |   ///                     (2 ** 432) * exp(-16)
   77 |     |   ///
   78 |     |   ///  (2**216) * exp(-(l+16)/2) * (2**216) * exp(-(u+16)/2) * input
   79 |     |   /// --------------------------------------------------------------- == 
   80 |     |   ///                      (2 ** 432) * exp(-16)
   81 |     |   ///
   82 |     |   ///  price0.sqrt(false) * price1.sqrt(false) * input
   83 |     |   /// -------------------------------------------------
   84 |     |   ///              (2 ** 432) * exp(-16)
   85 |     |   ///
   86 |     |   /// -------------------------------------------------------------------------
   87 |     |   /// The following approximation is used:
   88 |     |   ///
   89 |     |   ///            1                   b * c * d
   90 |     |   /// ----------------------- ~ --------------------
   91 |     |   ///  (2 ** 432) * exp(-16)     (2 ** 256 - 1) * a
   92 |     |   ///
   93 |     |   /// where
   94 |     |   ///
   95 |     |   /// 'a == 0x5BC2A24E50A66D39C35A9132C33F2FC50A1B99389D5455E78A7CF7EF8894E4CD'
   96 |     |   /// 'b == 0x4BC3287B', 'c == 0xCEF6AE8685', 'd == 0xCB21E499'.
   97 |     |   ///
   98 |     |   /// 'integralInput' should be non-negative and less than 'oneX216'.
   99 | *   |   function shift(
  100 |     |     X216 integralInput,
  101 |     |     uint256 price0,
  102 |     |     uint256 price1,
  103 |     |     bool left
  104 |     |   ) internal pure returns (
  105 | *   |     X216 shiftedIntegral
  106 |     |   ) {
  107 |     |     // This boolean determines whether 'sqrt' or 'sqrtInverse' is returned by
  108 |     |     // 'PriceLibrary'.
  109 | *   |     bool right = !left;
  110 | *   |     X216 p0 = price0.sqrt(right);
  111 | *   |     X216 p1 = price1.sqrt(right);
  112 |     |     assembly {
  113 |     |       // All three multiplications are safe because 'integralInput', 'p0' and
  114 |     |       // 'p1' are read from 216 bits of memory and the outputs fit within 256
  115 |     |       // bits.
  116 | *   |       integralInput := mul(0x4BC3287B, integralInput) // b * integralInput
  117 | *   |       p0 := mul(0xCEF6AE8685, p0) // c * price0.sqrt(right)
  118 | *   |       p1 := mul(0xCB21E499, p1) // d * price1.sqrt(right)
  119 |     | 
  120 |     |       // Next, we calculate
  121 |     |       // 'p0 * p1 / a == c * d * price0.sqrt(right) * price1.sqrt(right) / a'.
  122 |     |       // Let 's := p0 * p1 - (2 ** 256) * q'.
  123 |     |       // Let 'r := p0 * p1 - a * p'.
  124 |     |       // Then 's - r == a * p' [mod 2 ** 256]
  125 |     |       //
  126 |     |       // The output does not exceed 249 bits because both 'price0.sqrt(right)'
  127 |     |       // and 'price1.sqrt(right)' are less than 'oneX216' and:
  128 |     |       // 'c * d * (1 << 216) * (1 << 216) / a < 2 ** 249'.
  129 | *   |       shiftedIntegral := mul(
  130 |     |         // s - r
  131 | *   |         sub(
  132 |     |           // s
  133 | *   |           mul(p0, p1),
  134 |     |           // r
  135 | *   |           mulmod(
  136 | *   |             p0,
  137 | *   |             p1,
  138 |     |             // a
  139 | *   |             0x5BC2A24E50A66D39C35A9132C33F2FC50A1B99389D5455E78A7CF7EF8894E4CD
  140 |     |           )
  141 |     |         ),
  142 |     |         // modularInverse(a, 2 ** 256)
  143 | *   |         0x7082326D62B7EF4D06861F13C21DD192C8044B19A121205B7DC63C2642B5A805
  144 |     |       )
  145 |     | 
  146 |     |       // Multiplication by 'integralInput / (2 ** 256 - 1)'
  147 | *   |       shiftedIntegral := sub(
  148 |     |         // r == x * y - (2 ** 256 - 1) * q
  149 | *   |         mulmod(shiftedIntegral, integralInput, not(0)),
  150 |     |         // s == x * y - (2 ** 256) * p
  151 | *   |         mul(shiftedIntegral, integralInput)
  152 |     |       )
  153 |     |     }
  154 | *   |     return shiftedIntegral;
  155 |     |   }
  156 |     | 
  157 |     |   /// @notice Returns an integral value given its memory pointer.
  158 |     |   /// Notice that due to an 'exp(-8) / 2' factor, integral values are always
  159 |     |   /// less than 'oneX216'. This is because:
  160 |     |   ///
  161 |     |   ///               / +16                         / +16
  162 |     |   ///   exp(-8)    |      +h/2        exp(-8)    |      -h/2
  163 |     |   ///  --------- x |     e     dh == --------- x |     e     dh < 1
  164 |     |   ///      2       |                     2       |
  165 |     |   ///             / -16                         / -16
  166 |     |   ///
  167 | *   |   function integral(
  168 |     |     uint256 pointer
  169 |     |   ) internal pure returns (
  170 | *   |     X216 value
  171 |     |   ) {
  172 |     |     assembly {
  173 |     |       // The slot whose most significant 160 bits host the integral value is
  174 |     |       // loaded and then the least significant 40 bits are discarded via a 40
  175 |     |       // bit shift to the right.
  176 | *   |       value := shr(40, mload(pointer))
  177 |     |     }
  178 |     |   }
  179 |     | 
  180 |     |   /// @notice Writes an integral value in a memory pointer.
  181 |     |   /// 'pointer' should not be less than '32'.
  182 |     |   /// 'integralValue' should be less than 'oneX216'.
  183 | *   |   function setIntegral(
  184 |     |     uint256 pointer,
  185 |     |     X216 integralValue
  186 |     |   ) internal pure {
  187 | *   |     assembly {
  188 |     |       // The preceding slot is cached so that it can be restored after we place
  189 |     |       // the integral value in the appropriate memory location.
  190 |     |       // The subtraction is safe because of the input requirement on 'pointer'.
  191 | *   |       let precedingPointer := sub(pointer, 32)
  192 | *   |       let precedingSlot := mload(precedingPointer)
  193 |     | 
  194 |     |       // We move 5 bytes backward (40 bits) to point to the slot whose least
  195 |     |       // significant 216 bits are supposed to host 'integralValue'.
  196 |     |       // '216 - 256' bits == '-40' bits == '-5' bytes.
  197 | *   |       mstore(sub(pointer, 5), integralValue)
  198 |     | 
  199 |     |       // The preceding slot is restored.
  200 | *   |       mstore(precedingPointer, precedingSlot)
  201 |     |     }
  202 |     |   }
  203 |     | 
  204 |     |   /// @notice Adds a given increment to an integral stored in the given memory 
  205 |     |   /// pointer.
  206 |     |   /// Overflow should be avoided externally.
  207 | *   |   function incrementIntegral(
  208 |     |     uint256 pointer,
  209 |     |     X216 increment
  210 |     |   ) internal pure {
  211 |     |     assembly {
  212 |     |       // The increment is shifted to the left by 40 bits to be added to the
  213 |     |       // integral value in memory. In other words, the following slot is
  214 |     |       // loaded:
  215 |     |       //
  216 |     |       //   +-------------------+----------------------------------------------+
  217 |     |       //   | 216 bit integral  | 40 additional bits that should remain intact |
  218 |     |       //   +-------------------+----------------------------------------------+
  219 |     |       //   |
  220 |     |       // pointer
  221 |     |       //
  222 |     |       // and added to:
  223 |     |       //
  224 |     |       //   +-------------------+----------------------------------------------+
  225 |     |       //   | 216 bit increment |          40 additional zero bits             |
  226 |     |       //   +-------------------+----------------------------------------------+
  227 |     |       //
  228 |     |       // The result is then stored in memory using the same pointer.
  229 |     |       // The addition is safe because overflow is handled externally.
  230 | *   |       mstore(pointer, add(mload(pointer), shl(40, increment)))
  231 |     |     }
  232 |     |   }
  233 |     | 
  234 |     |   /// @notice Subtracts a given decrement from an integral stored in the given
  235 |     |   /// memory pointer.
  236 |     |   /// Underflow should be avoided externally.
  237 | *   |   function decrementIntegral(
  238 |     |     uint256 pointer,
  239 |     |     X216 decrement
  240 |     |   ) internal pure {
  241 |     |     assembly {
  242 |     |       // The decrement is shifted to the left by 40 bits to be subtracted from
  243 |     |       // the integral value in memory. In other words, the following slot is
  244 |     |       // loaded:
  245 |     |       //
  246 |     |       //   --------------------------------------------------------------------
  247 |     |       //   | 216 bit integral  | 40 additional bits that should remain intact |
  248 |     |       //   +-------------------------------------------------------------------
  249 |     |       //   |
  250 |     |       // pointer
  251 |     |       //
  252 |     |       // and the following value is subtracted from the loaded slot:
  253 |     |       //
  254 |     |       //   --------------------------------------------------------------------
  255 |     |       //   | 216 bit increment |          40 additional zero bits             |
  256 |     |       //   --------------------------------------------------------------------
  257 |     |       //
  258 |     |       // The result is then stored in memory using the same pointer.
  259 |     |       // The subtraction is safe because underflow is handled externally.
  260 | *   |       mstore(pointer, sub(mload(pointer), shl(40, decrement)))
  261 |     |     }
  262 |     |   }
  263 |     | 
  264 |     |   /// @notice Let 'q' denote the logarithmic price whose offset binary 'X59'
  265 |     |   /// representation is stored in the pointer 'targetPrice'. In other words,
  266 |     |   /// define:
  267 |     |   ///
  268 |     |   ///               targetPrice.log()
  269 |     |   ///  q := - 16 + -------------------
  270 |     |   ///                   2 ** 59
  271 |     |   ///
  272 |     |   /// Additionally, let '(b0, c0)' and '(b1, c1)' represent the segment
  273 |     |   /// coordinates to be loaded from the memory via the pointers
  274 |     |   /// 'coordinates0 := segmentCoordinates' and
  275 |     |   /// 'coordinates1 := segmentCoordinates + 64', respectively. More precisely:
  276 |     |   ///
  277 |     |   ///                coordinates0.log()           coordinates0.height()
  278 |     |   ///  b0 := - 16 + --------------------,  c0 := -----------------------
  279 |     |   ///                     2 ** 59                        2 ** 15
  280 |     |   ///
  281 |     |   ///                coordinates1.log()           coordinates1.height()
  282 |     |   ///  b1 := - 16 + --------------------,  c1 := -----------------------
  283 |     |   ///                     2 ** 59                        2 ** 15
  284 |     |   ///
  285 |     |   /// -------------------------------------------------------------------------
  286 |     |   /// This function evaluates the following and returns the resulting
  287 |     |   /// value in 'X216' representation:
  288 |     |   ///
  289 |     |   ///                                      c1 - c0
  290 |     |   ///  (2 ** 216) * (exp(-8) / 2) * (c0 + --------- (q - b0))
  291 |     |   ///                                      b1 - b0
  292 |     |   ///
  293 |     |   /// We should have: 'c0 <= c1 <= oneX15'.
  294 |     |   /// We should have: 'min(b0, b1) <= q <= max(b0, b1) < thirtyTwoX59'.
  295 |     |   /// We should have: 'b0 != b1'.
  296 | *   |   function evaluate(
  297 |     |     uint256 segmentCoordinates,
  298 |     |     uint256 targetPrice
  299 |     |   ) internal pure returns (
  300 | *   |     X216 value
  301 |     |   ) {
  302 |     |     // Loads the segment coordinates from the memory. '(b0, c0)' are loaded
  303 |     |     // using 'pointer = segmentCoordinates' and '(b1, c1)' are loaded using
  304 |     |     // 'pointer = segmentCoordinates + 64'.
  305 | *   |     (X59 b0, X59 b1, X15 c0, X15 c1) = segmentCoordinates.segment();
  306 |     | 
  307 |     |     // In this case, because of the input requirement 'c0 <= c1', we have 
  308 |     |     // 'c0 == c1 == zeroX15' and the output should be 'zeroX216'.
  309 | *   |     if (c1 == zeroX15) return value;
  310 |     | 
  311 |     |     // If 'c1 == c0', we multiply 'c0' by 'exp(-8) / 2' and return.
  312 |     |     // The multiplication is safe because 'c0' is a 16 bit (read from memory) 
  313 |     |     // non-negative value and 'EXP_INV_8_X240' is 229 bits.
  314 | *   |     if (c1 == c0) {
  315 |     |       assembly {
  316 |     |         // The last '40' bits are discarded because
  317 |     |         // '216 - 240 - 15 - 1 == - 40', where '216' appears because the output
  318 |     |         // should follow the 'X216' representation, '240' cancels the 
  319 |     |         // '1 << 240' factor in 'EXP_INV_8_X240', '15' cancels the 'X15'
  320 |     |         // representation of 'c0', and '1' accounts for the denominator of
  321 |     |         // 'exp(-8) / 2'.
  322 | *   |         value := shr(40, mul(c0, EXP_INV_8_X240))
  323 |     |       }
  324 | *   |       return value;
  325 |     |     }
  326 |     | 
  327 |     |     // If 'b1 == q', the solution is equal to:
  328 |     |     //
  329 |     |     //                                      c1 - c0
  330 |     |     //  (2 ** 216) * (exp(-8) / 2) * (c0 + --------- (b1 - b0)) ==
  331 |     |     //                                      b1 - b0
  332 |     |     //
  333 |     |     //  (2 ** 216) * (exp(-8) / 2) * c1
  334 |     |     //
  335 |     |     // Hence, we just multiply 'c1' by 'exp(-8) / 2' and return.
  336 |     |     // The multiplication is safe because 'c1' is a 16 bit (read from memory) 
  337 |     |     // non-negative value and 'EXP_INV_8_X240' is 229 bits.
  338 | *   |     if (b1 == targetPrice.log()) {
  339 |     |       assembly {
  340 |     |         // As argued above, the last '40' bits are discarded because
  341 |     |         // '216 - 240 - 15 - 1 == - 40', where '216' appears because the output
  342 |     |         // should follow the 'X216' representation, '240' cancels the 
  343 |     |         // '1 << 240' factor in 'EXP_INV_8_X240', '15' cancels the 'X15'
  344 |     |         // representation of 'c1', and '1' accounts for the denominator of
  345 |     |         // 'exp(-8) / 2'.
  346 | *   |         value := shr(40, mul(c1, EXP_INV_8_X240))
  347 |     |       }
  348 | *   |       return value;
  349 |     |     }
  350 |     | 
  351 |     |     // If 'b1 < b0', the subtraction 'b0 - b1' is safe and the subtraction
  352 |     |     // 'b0 - targetPrice.log()' is also safe due to the input requirement:
  353 |     |     // 'q <= max(b0, b1)'.
  354 |     |     //
  355 |     |     // If 'b1 >= b0', the subtraction 'b1 - b0' is safe and the subtraction
  356 |     |     // 'targetPrice.log() - b0' is also safe due to the input requirement:
  357 |     |     // 'min(b0, b1) <= q'.
  358 |     |     //
  359 |     |     // The subtraction 'c1 - c0' is safe because of the input requirement
  360 |     |     // 'c0 <= c1'. The multiplication is also safe because '|q - b0|' and
  361 |     |     // 'c1 - c0' are both non-negative and occupy up to '64' and '16' bits,
  362 |     |     // respectively.
  363 |     |     //
  364 |     |     // The signed comparison of 'b0' and 'b1' is valid because both are 64 bit
  365 |     |     // (read from memory) non-negative values.
  366 | *   |     (X59 db, X74 numerator) = (b1 < b0) ? 
  367 | *   |       (b0 - b1, (b0 - targetPrice.log()).times(c1 - c0)) : 
  368 | *   |       (b1 - b0, (targetPrice.log() - b0).times(c1 - c0));
  369 |     | 
  370 |     |     // Next, we calculate 
  371 |     |     // '(exp(-8) / 2) * (c0 + |q - b0| * (c1 - c0) / db)'
  372 |     |     // where 'db = |b1 - b0|'.
  373 | *   |     assembly {
  374 |     |       // The 320 bit product 'EXP_INV_8_X240 * numerator' is calculated first, 
  375 |     |       // where 'numerator = |q - b0| * (c1 - c0)'.
  376 |     | 
  377 |     |       // The least significant 192-bits of the product 
  378 |     |       // 'EXP_INV_8_X240 * numerator'. This multiplication is in 'X314'
  379 |     |       // representation because '240 + 74 == 314'.
  380 | *   |       let lsbitsX314 := mulmod(EXP_INV_8_X240, numerator, shl(192, 1))
  381 |     | 
  382 |     |       // The most significant 128-bits of the product 
  383 |     |       // 'EXP_INV_8_X240 * numerator'.
  384 |     |       // 'r == EXP_INV_8_X240 * numerator - (2 ** 192 - 1) * q'
  385 |     |       // 'lsbitsX314 == EXP_INV_8_X240 * numerator - (2 ** 192) * p'
  386 |     |       // 'r - lsbitsX314 == p' [mod 2 ** 192 - 1]
  387 | *   |       let msbitsX314 := addmod(
  388 |     |         // r
  389 | *   |         mulmod(EXP_INV_8_X240, numerator, sub(shl(192, 1), 1)),
  390 |     |         // 0 - lsbitsX314 [mod 2 ** 192 - 1]
  391 |     |         // The subtraction is safe because 'lsbitsX314' does not exceed 192
  392 |     |         // bits.
  393 | *   |         sub(sub(shl(192, 1), 1), lsbitsX314),
  394 | *   |         sub(shl(192, 1), 1)
  395 |     |       )
  396 |     | 
  397 |     |       // Here, we perform the division by 'db' via the simple long division
  398 |     |       // algorithm, i.e., '(2 ** 192) * msbitsX314 + lsbitsX314' divided by
  399 |     |       // 'db' becomes:
  400 |     |       //
  401 |     |       //                 q1X255         q0X255
  402 |     |       //      ---------------------------------
  403 |     |       // db   |      msbitsX314     lsbitsX314
  404 |     |       //      |
  405 |     |       //            q1X255 * db 
  406 |     |       //        -------------------------------
  407 |     |       //        msbitsX314 % db     lsbitsX314
  408 |     |       //
  409 |     |       //                           q0X255 * db
  410 |     |       //        -------------------------------
  411 |     |       //                                     r
  412 |     |       //
  413 |     |       // where 
  414 |     |       // 'r := (msbitsX314 * (2 ** 192) + lsbitsX314) % db'
  415 |     |       // 'q1X255 := msbitsX314 / db'
  416 |     |       // 'q0X255 := ((msbits % db) * (2 ** 192) + lsbitsX314) / db'
  417 | *   |       let quotientX255 := add(
  418 |     |         // First, we calculate 'q1X255 << 192' which the more significant part
  419 |     |         // of the quotient.
  420 |     |         //
  421 |     |         // The division 'msbitsX314 / db' is safe because 'db != 0' due to an
  422 |     |         // input requirement.
  423 |     |         //
  424 |     |         // The 192-bit shift does not overflow because '|q - b0| <= db' and
  425 |     |         // therefore:
  426 |     |         // 
  427 |     |         // 'msbitsX314 / db =
  428 |     |         //  ((EXP_INV_8_X240 * |q - b0| * (c1 - c0)) >> 192) / db <= 
  429 |     |         //  ((EXP_INV_8_X240 * db * (c1 - c0)) >> 192) / db == 
  430 |     |         //  ((EXP_INV_8_X240 * (c1 - c0)) >> 192) <
  431 |     |         //  (2 ** (229 + 16)) >> 192 == 2 ** 53'
  432 |     |         //
  433 |     |         // Hence, 'msbitsX314 / db' does not exceed '53' bits.
  434 | *   |         shl(192, div(msbitsX314, db)),
  435 |     |         // Then, we calculate 'q0X255' which the least significant 192 bits of
  436 |     |         // the quotientX255.
  437 |     |         //
  438 |     |         // The division by 'db' is safe because 'db != 0' due to an input
  439 |     |         // requirement.
  440 | *   |         div(
  441 |     |           // The addition is safe because 'lsbitsX314' and 'db' do not exceed
  442 |     |           // '192' and '64 'bits, respectively.
  443 | *   |           add(
  444 |     |             // The shift does not overflow because 
  445 |     |             // 'msbitsX314 % db < db < 2 ** 64'.
  446 | *   |             shl(192, mod(msbitsX314, db)),
  447 | *   |             lsbitsX314
  448 |     |           ),
  449 | *   |           db
  450 |     |         )
  451 |     |       )
  452 |     | 
  453 |     |       // Lastly, we need to add '(exp(-8) / 2) * c0'.
  454 |     |       //
  455 |     |       // This addition is also safe because:
  456 |     |       //
  457 |     |       //        c1 - c0                    c1 - c0
  458 |     |       //  c0 + --------- (q - b0) <= c0 + --------- (b1 - b0) <= c1
  459 |     |       //        b1 - b0                    b1 - b0
  460 |     |       //
  461 |     |       // Hence the output of 'add' is bounded by 'mul(c1, EXP_INV_8_X240)'
  462 |     |       // which does not overflow because 'c1 <= oneX15' and 'EXP_INV_8_X240'
  463 |     |       // has 229 bits.
  464 |     |       //
  465 |     |       // As argued above, the last '40' bits are discarded because
  466 |     |       // '216 - 240 - 15 - 1 == - 40', where '216' appears because the output
  467 |     |       // should follow the 'X216' representation, '240' cancels the 
  468 |     |       // '1 << 240' factor in 'EXP_INV_8_X240', '15' cancels the 'X15'
  469 |     |       // representation of 'c0' and 'c1', and '1' accounts for the denominator
  470 |     |       // of 'exp(-8) / 2'.
  471 | *   |       value := shr(40, add(mul(c0, EXP_INV_8_X240), quotientX255))
  472 |     |     }
  473 |     |   }
  474 |     | 
  475 |     |   /// @notice Let 'f' and 't' denote the logPrice values whose offset binary
  476 |     |   /// 'X59' representation is stored in the pointers 'from' and 'to',
  477 |     |   /// respectively. In other words, define:
  478 |     |   ///
  479 |     |   ///               from.log()                          to.log()
  480 |     |   ///  f := - 16 + ------------    and    t := - 16 + ------------
  481 |     |   ///                2 ** 59                            2 ** 59
  482 |     |   ///
  483 |     |   /// Additionally, let '(b0, c0)' and '(b1, c1)' represent the segment
  484 |     |   /// coordinates to be loaded from the memory via the pointers
  485 |     |   /// 'coordinates0' and 'coordinates1 := coordinates0 + 64', respectively.
  486 |     |   /// More precisely:
  487 |     |   ///
  488 |     |   ///               coordinates0.log()           coordinates0.height()
  489 |     |   /// b0 := - 16 + --------------------,  c0 := -----------------------
  490 |     |   ///                    2 ** 59                        2 ** 15
  491 |     |   ///
  492 |     |   ///               coordinates1.log()           coordinates1.height()
  493 |     |   /// b1 := - 16 + --------------------,  c1 := -----------------------
  494 |     |   ///                    2 ** 59                        2 ** 15
  495 |     |   ///
  496 |     |   /// -------------------------------------------------------------------------
  497 |     |   /// If 'f < t' this function calculates:
  498 |     |   ///
  499 |     |   ///                                / t
  500 |     |   ///                               |     -h/2         c1 - c0
  501 |     |   ///  (2 ** 216) * (exp(-8) / 2) * |    e      (c0 + --------- (h - b0)) dh
  502 |     |   ///                               |                  b1 - b0
  503 |     |   ///                              / f
  504 |     |   ///
  505 |     |   /// In this case, the following closed-form formula is used:
  506 |     |   ///
  507 |     |   ///  (2 ** 216) * exp(-8) * (
  508 |     |   ///                                          c1 - c0
  509 |     |   ///    c0 * (exp(- f / 2) - exp(- t / 2)) + --------- * 
  510 |     |   ///                                          b1 - b0
  511 |     |   ///
  512 |     |   ///    ((f - b0 + 2) * exp(- f / 2) - (t - b0 + 2) * exp(- t / 2))
  513 |     |   ///  )
  514 |     |   ///
  515 |     |   ///  == c0 * ((2 ** 216) * exp(- 8 - f / 2) - (2 ** 216) * exp(- 8 - t / 2))
  516 |     |   ///
  517 |     |   ///       c1 - c0
  518 |     |   ///    + --------- * ((f - b0 + 2) * (2 ** 216) * exp(- 8 - f / 2) - 
  519 |     |   ///       b1 - b0
  520 |     |   ///                   (t - b0 + 2) * (2 ** 216) * exp(- 8 - t / 2))
  521 |     |   ///
  522 |     |   ///  == c0 * (from.sqrt(false) - to.sqrt(false))
  523 |     |   ///
  524 |     |   ///       c1 - c0
  525 |     |   ///    + --------- * ((f - b0 + 2) * from.sqrt(false) - 
  526 |     |   ///       b1 - b0
  527 |     |   ///                   (t - b0 + 2) * to.sqrt(false))
  528 |     |   ///
  529 |     |   /// -------------------------------------------------------------------------
  530 |     |   /// If 't < f' this function calculates:
  531 |     |   ///
  532 |     |   ///                                / f
  533 |     |   ///                               |     +h/2         c1 - c0
  534 |     |   ///  (2 ** 216) * (exp(-8) / 2) * |    e      (c0 + --------- (b0 - h)) dh
  535 |     |   ///                               |                  b0 - b1
  536 |     |   ///                              / t
  537 |     |   ///
  538 |     |   /// In this case, the following closed-form formula is used:
  539 |     |   ///
  540 |     |   ///  (2 ** 216) * exp(-8) * (
  541 |     |   ///                                          c1 - c0
  542 |     |   ///    c0 * (exp(+ f / 2) - exp(+ t / 2)) + --------- * 
  543 |     |   ///                                          b0 - b1
  544 |     |   ///
  545 |     |   ///    ((b0 - f + 2) * exp(+ f / 2) - (b0 - t + 2) * exp(+ t / 2))
  546 |     |   ///  )
  547 |     |   ///
  548 |     |   ///  == c0 * ((2 ** 216) * exp(- 8 + f / 2) - (2 ** 216) * exp(- 8 + t / 2))
  549 |     |   ///
  550 |     |   ///       c1 - c0
  551 |     |   ///    + --------- * ((b0 - f + 2) * (2 ** 216) * exp(- 8 + f / 2) - 
  552 |     |   ///       b0 - b1
  553 |     |   ///                   (b0 - t + 2) * (2 ** 216) * exp(- 8 + t / 2))
  554 |     |   ///
  555 |     |   ///  == c0 * (from.sqrt(true) - to.sqrt(true))
  556 |     |   ///
  557 |     |   ///       c1 - c0
  558 |     |   ///    + --------- * ((b0 - f + 2) * from.sqrt(true) - 
  559 |     |   ///       b0 - b1
  560 |     |   ///                   (b0 - t + 2) * to.sqrt(true))
  561 |     |   ///
  562 |     |   /// -------------------------------------------------------------------------
  563 |     |   /// We should have: 'c0 <= c1 <= oneX15'.
  564 |     |   ///
  565 |     |   /// If 't < f' then we should have: 'b1 <= t < f <= b0 < thirtyTwoX59'
  566 |     |   ///
  567 |     |   /// If 'f < t' then we should have: 'b0 <= f < t <= b1 < thirtyTwoX59'
  568 |     |   ///
  569 | *   |   function outgoing(
  570 |     |     uint256 coordinate0,
  571 |     |     uint256 from,
  572 |     |     uint256 to
  573 |     |   ) internal pure returns (
  574 | *   |     X216 result
  575 |     |   ) {
  576 |     |     // The following values will be defined and loaded from the memory.
  577 | *   |     X15 c0;
  578 | *   |     X216 sqrtFrom;
  579 | *   |     X216 sqrtTo;
  580 | *   |     X59 db;
  581 | *   |     X74 from_times_dc;
  582 | *   |     X74 to_times_dc;
  583 | *   |     {
  584 |     |       // First, we load the two integral boundaries.
  585 | *   |       X59 logFrom = from.log();
  586 | *   |       X59 logTo = to.log();
  587 |     | 
  588 |     |       // The special case of 'logFrom == logTo' is handled here. In this case
  589 |     |       // the result is equal to 'zeroX216'.
  590 | *   |       if (logFrom == logTo) return zeroX216;
  591 |     | 
  592 |     |       // The pointer to the second price is derived.
  593 | *   |       uint256 coordinate1;
  594 |     |       unchecked {
  595 | *   |         coordinate1 = coordinate0 + 64;
  596 |     |       }
  597 |     | 
  598 |     |       // 'c0' is loaded from the memory.
  599 | *   |       c0 = coordinate0.height();
  600 |     | 
  601 |     |       // 'c1' is loaded from the memory and temporarily placed in 'dc'.
  602 | *   |       X15 dc = coordinate1.height();
  603 |     | 
  604 |     |       // In this case, because of the input requirement 'c0 <= c1', we have 
  605 |     |       // 'c0 == c1 == zeroX15' and the output should be 'zeroX216'.
  606 | *   |       if (dc == zeroX15) return zeroX216;
  607 |     | 
  608 |     |       // 'dc' represents the vertical length of the segment that characterizes
  609 |     |       // the function that we are integrating. The subtraction is safe due to
  610 |     |       // the input requirement 'c0 <= c1'.
  611 | *   |       dc = dc - c0;
  612 |     | 
  613 |     |       // As explained above, depending on the value of 'left', we either use
  614 |     |       // '(from.sqrt(false), to.sqrt(false))' or
  615 |     |       // '(from.sqrt(true), to.sqrt(true))'.
  616 | *   |       bool left = logTo < logFrom;
  617 | *   |       sqrtFrom = from.sqrt(left);
  618 | *   |       sqrtTo = to.sqrt(left);
  619 |     | 
  620 |     |       // If 'c1 == c0' we simply return
  621 |     |       // 'c0 * (from.sqrt(false) - to.sqrt(false)) / (2 ** 15)'
  622 |     |       // for 'left == false' or 
  623 |     |       // 'c0 * (from.sqrt(true) - to.sqrt(true)) / (2 ** 15)'
  624 |     |       // for 'left == true'.
  625 |     |       //
  626 |     |       // The subtraction is safe, because if 'f <= t' then
  627 |     |       // 'left == false' and we have 'exp(- 8 - t / 2) <= exp(-8 - f / 2)'
  628 |     |       // which concludes 'to.sqrt(left) <= from.sqrt(left)'.
  629 |     |       //
  630 |     |       // On the other hand, if 't < f' then 'left == true' and we have
  631 |     |       // 'exp(- 8 + t / 2) < exp(- 8 + f / 2)' which concludes
  632 |     |       // 'to.sqrt(left) < from.sqrt(left)'.
  633 |     |       //
  634 |     |       // The multiplication is safe because 'c0' and 'sqrtFrom - sqrtTo' are
  635 |     |       // nonnegative values which do not exceed '16' and '216' bits, 
  636 |     |       // respectively.
  637 |     |       //
  638 |     |       // We shift the result by 15 bits to the right to cancel the 'X15'
  639 |     |       // representation of 'c0'.
  640 | *   |       if (dc == zeroX15) {
  641 |     |         assembly {
  642 | *   |           result := shr(15, mul(c0, sub(sqrtFrom, sqrtTo)))
  643 |     |         }
  644 | *   |         return result;
  645 |     |       }
  646 |     | 
  647 |     |       // 'b0' is loaded from memory and temporarily placed in 'db'.
  648 | *   |       db = coordinate0.log();
  649 |     | 
  650 |     |       // Next, if 'left == true', we calculate 
  651 |     |       // '(b0 - logFrom + 2) * dc' and '(b0 - logTo + 2) * dc'. 
  652 |     |       // If 'left == false', we calculate 
  653 |     |       // '(logFrom - b0 + 2) * dc' and '(logTo - b0 + 2) * dc'.
  654 |     |       //
  655 |     |       // The subtractions are safe due to the input requirements. Because if
  656 |     |       // 'left == false', we have 'b0 <= logFrom' and 'b0 <= logTo'.
  657 |     |       // Additionally, if 'left == true', we have 'logFrom <= b0' and
  658 |     |       // 'logTo <= b0'.
  659 |     |       //
  660 |     |       // The additions with 'twoX59' are safe, because in all cases the two
  661 |     |       // terms that are being added are less than '2 ** 64'.
  662 |     |       //
  663 |     |       // The multiplications are safe, because in all cases the inputs are
  664 |     |       // non-negative and the output does not exceed 81 bits.
  665 | *   |       (from_times_dc, to_times_dc) = left ? 
  666 | *   |         ((db - logFrom + twoX59).times(dc), (db - logTo + twoX59).times(dc)) : 
  667 | *   |         ((logFrom - db + twoX59).times(dc), (logTo - db + twoX59).times(dc));
  668 |     |       
  669 |     |       // 'db' represents the horizontal length of the segment that
  670 |     |       // characterizes the function that we are integrating. The subtractions
  671 |     |       // are safe due to the input requirements. Because if 'left == false',
  672 |     |       // we have 'b0 <= b1' and if 'left == true', we have 'b0 >= b1'.
  673 | *   |       db = left ? db - coordinate1.log() : coordinate1.log() - db;
  674 |     |     }
  675 |     | 
  676 | *   |     assembly {
  677 |     |       // The least significant 192-bits of the product 
  678 |     |       // 'from_times_dc * sqrtFrom' which is in 'X290' representation because
  679 |     |       // 'from_times_dc' is 'X74' and 'sqrtFrom' is 'X216'.
  680 | *   |       let lsbits0X290 := mulmod(from_times_dc, sqrtFrom, shl(192, 1))
  681 |     | 
  682 |     |       // The least significant 192-bits of the product 
  683 |     |       // 'to_times_dc * sqrtTo' which is in 'X290' representation because
  684 |     |       // 'to_times_dc' is 'X74' and 'sqrtTo' is 'X216'.
  685 | *   |       let lsbits1X290 := mulmod(to_times_dc, sqrtTo, shl(192, 1))
  686 |     | 
  687 |     |       // Next, we calculate 
  688 |     |       // 'sqrtFrom * from_times_dc - sqrtTo * to_times_dc'.
  689 |     |       //
  690 |     |       // Next, we are going to prove that the subtraction is safe:
  691 |     |       //
  692 |     |       // If 'f < t', We are calculating
  693 |     |       //
  694 |     |       // y := ((f - b0 + 2) * exp(- f / 2) - (t - b0 + 2) * exp(- t / 2)) * dc
  695 |     |       //
  696 |     |       // In this case, because '(q + 2) * exp(-q / 2)' is a decreasing function
  697 |     |       // within the interval '(0, +oo)', the expression
  698 |     |       // 
  699 |     |       // (f - b0 + 2) * exp(-(f - b0) / 2) - (t - b0 + 2) * exp(-(t - b0) / 2)
  700 |     |       //
  701 |     |       // is non-negative which concludes that 'y' is also non-negative. Hence,
  702 |     |       // the subtraction is safe.
  703 |     |       //
  704 |     |       // If 't < f', We are calculating
  705 |     |       //
  706 |     |       // y := ((b0 - f + 2) * exp(+ f / 2) - (b0 - t + 2) * exp(+ t / 2)) * dc
  707 |     |       //
  708 |     |       // In this case, because '(q + 2) * exp(-q / 2)' is a decreasing function
  709 |     |       // within the interval '(0, +oo)', the expression
  710 |     |       // 
  711 |     |       // (b0 - f + 2) * exp(-(b0 - f) / 2) - (b0 - t + 2) * exp(-(b0 - t) / 2)
  712 |     |       //
  713 |     |       // is non-negative which concludes that 'y' is also non-negative. Hence,
  714 |     |       // the subtraction is safe.
  715 |     | 
  716 |     |       // The least significant 192-bits of 
  717 |     |       // 'sqrtFrom * from_times_dc - sqrtTo * to_times_dc' which may underflow
  718 |     |       // in which case '1' will be subtracted from 'msbitsX290'.
  719 |     |       // The subtraction is safe because 'lsbits1X290' is less than '1 << 192'.
  720 | *   |       let lsbitsX290 := addmod(
  721 | *   |         lsbits0X290,
  722 | *   |         sub(shl(192, 1), lsbits1X290),
  723 | *   |         shl(192, 1)
  724 |     |       )
  725 |     | 
  726 |     |       // The most significant 128-bits of 
  727 |     |       // 'sqrtFrom * from_times_dc - sqrtTo * to_times_dc'
  728 | *   |       let msbitsX290 := sub(
  729 |     |         // 'x == to_times_dc * sqrtTo - (2 ** 192) * a'
  730 |     |         // 'y == from_times_dc * sqrtFrom - (2 ** 192 - 1) * b'
  731 |     |         // 'z == from_times_dc * sqrtFrom - (2 ** 192) * c'
  732 |     |         // 'w == to_times_dc * sqrtTo - (2 ** 192 - 1) * d'
  733 |     |         //
  734 |     |         // 'x + y - z - w == b - d' [mod 2 ** 192]
  735 | *   |         sub(
  736 | *   |           add(
  737 | *   |             lsbits1X290,
  738 | *   |             mulmod(from_times_dc, sqrtFrom, sub(shl(192, 1), 1))
  739 |     |           ),
  740 | *   |           add(
  741 | *   |             lsbits0X290,
  742 | *   |             mulmod(to_times_dc, sqrtTo, sub(shl(192, 1), 1))
  743 |     |           )
  744 |     |         ),
  745 |     |         // 'lsbits0X290 < lsbits1X290' indicates that 'lsbits' has underflowed.
  746 |     |         // In this case, we need to subtract 'msbitsX290' by '1'.
  747 | *   |         lt(lsbits0X290, lsbits1X290)
  748 |     |       )
  749 |     | 
  750 |     |       // Next, we calculate:
  751 |     |       //
  752 |     |       // '(from_times_dc * sqrtFrom - to_times_dc * sqrtTo) / db'
  753 |     |       //
  754 |     |       // Here, we perform the division by 'db' via the simple long division
  755 |     |       //                   _____________________
  756 |     |       // algorithm, i.e., 'msbitsX290 lsbitsX290' divided by 'db' becomes:
  757 |     |       //
  758 |     |       //                 q1X231           q0X231
  759 |     |       //      -----------------------------------
  760 |     |       // db   |      msbitsX290       lsbitsX290
  761 |     |       //      |
  762 |     |       //            q1X231 * db 
  763 |     |       //        ---------------------------------
  764 |     |       //        msbitsX290 % db       lsbitsX290
  765 |     |       //
  766 |     |       //                             q0X231 * db
  767 |     |       //        ---------------------------------
  768 |     |       //                                       r
  769 |     |       //
  770 |     |       // where
  771 |     |       // 'r := (msbitsX290 * (2 ** 192) + lsbitsX290) % db'
  772 |     |       // 'q1X231 := msbitsX290 / db'
  773 |     |       // 'q0X231 := ((msbitsX290 % db) * (2 ** 192) + lsbitsX290) / db'
  774 |     |       //
  775 |     |       // Next, we will prove that 'msbitsX290 / db < 2 ** 50' which will be
  776 |     |       // useful later. If 'f < t' (the other side can be argued similarly), we
  777 |     |       // have:
  778 |     |       //
  779 |     |       //  (2 ** 192) * msbitsX290 + lsbitsX290
  780 |     |       // -------------------------------------- ==
  781 |     |       //      (2 ** (290 - 59)) * (b1 - b0)
  782 |     |       //
  783 |     |       //   (2 ** 192) * msbitsX290 + lsbitsX290
  784 |     |       //  --------------------------------------
  785 |     |       //                2 ** 290
  786 |     |       // ---------------------------------------- ==
  787 |     |       //                b1 - b0
  788 |     |       //               ---------
  789 |     |       //                2 ** 59
  790 |     |       //
  791 |     |       //  ((f - b0 + 2) * exp(- f / 2) - (t - b0 + 2) * exp(- t / 2)) * dc
  792 |     |       // ------------------------------------------------------------------ <=
  793 |     |       //                              b1 - b0
  794 |     |       //
  795 |     |       //  ((f - b0 + 2) * exp(- f / 2) - (t - b0 + 2) * exp(- t / 2)) * dc
  796 |     |       // ------------------------------------------------------------------ ==
  797 |     |       //                               t - f
  798 |     |       //
  799 |     |       //  g(t - b0) - g(f - b0)
  800 |     |       // ----------------------- * exp(- b0 / 2) * dc ==
  801 |     |       //   (t - b0) - (f - b0)
  802 |     |       //
  803 |     |       //  g'(z) * exp(- b0 / 2) * dc <= exp(-1) * exp(- b0 / 2) * dc < 
  804 |     |       //  exp(7) < 2 ** 11
  805 |     |       //
  806 |     |       // where 'g(q) := - (q + 2) * exp(-q / 2)' and 'z' is some arbitrary 
  807 |     |       // point within the interval '(0, +oo)' whose existence is guaranteed
  808 |     |       // thanks to the mean value theorem.
  809 |     |       //
  810 |     |       // Due to the above argument, we have 'msbitsX290 / db <= 2 ** 50'.
  811 | *   |       let quotientX231 := add(
  812 |     |         // First, we calculate 'q1X231 << 192' which the more significant part
  813 |     |         // of the quotientX231.
  814 |     |         //
  815 |     |         // The division 'msbits / db' is safe because 'db != 0' due to an input
  816 |     |         // requirement.
  817 |     |         //
  818 |     |         // The 192 bit shift to the left is safe because we have proven that
  819 |     |         // 'msbitsX290 / db <= 2 ** 50'.
  820 | *   |         shl(192, div(msbitsX290, db)),
  821 |     |         // Then, we calculate 'q0X231' which is the least significant 192 bits
  822 |     |         // of 'quotientX231'.
  823 |     |         //
  824 |     |         // The division by 'db' is safe because 'db != 0' due to an input
  825 |     |         // requirement.
  826 | *   |         div(
  827 | *   |           add(
  828 |     |             // The shift does not overflow because 
  829 |     |             // 'msbitsX290 % db < db < 2 ** 64'.
  830 | *   |             shl(192, mod(msbitsX290, db)),
  831 | *   |             lsbitsX290
  832 |     |           ),
  833 | *   |           db
  834 |     |         )
  835 |     |       )
  836 |     | 
  837 |     |       // Lastly, the following value is calculated:
  838 |     |       //
  839 |     |       // 'c0 * (from.sqrt(left) - to.sqrt(left)) + quotient'
  840 |     |       //
  841 |     |       // The addition does not overflow and does not exceed '216' bits because
  842 |     |       // the output integral is equal to:
  843 |     |       //
  844 |     |       //                                / t
  845 |     |       //                               |     -h/2         c1 - c0
  846 |     |       //  (2 ** 216) * (exp(-8) / 2) * |    e      (c0 + --------- (h - b0)) dh
  847 |     |       //                               |                  b1 - b0
  848 |     |       //                              / f
  849 |     |       //
  850 |     |       //                                   / 16
  851 |     |       //                                  |     -h/2
  852 |     |       //  <= (2 ** 216) * (exp(-8) / 2) * |    e      dh < (2 ** 216) - 1
  853 |     |       //                                  |
  854 |     |       //                                 / -16
  855 |     |       //
  856 |     |       // The subtraction is safe, because if 'f <= t' then
  857 |     |       // 'left == false' and we have 'exp(- 8 - t / 2) <= exp(-8 - f / 2)'
  858 |     |       // which concludes 'to.sqrt(left) <= from.sqrt(left)'
  859 |     |       //
  860 |     |       // On the other hand, if 't < f' then 'left == true' and we have
  861 |     |       // 'exp(- 8 + t / 2) < exp(- 8 + f / 2)' which concludes
  862 |     |       // 'to.sqrt(left) < from.sqrt(left)'.
  863 |     |       //
  864 |     |       // The multiplication is safe because 'c0' and 'sqrtFrom - sqrtTo' are
  865 |     |       // nonnegative values which do not exceed '16' and '216' bits, 
  866 |     |       // respectively.
  867 |     |       //
  868 |     |       // We shift the result by 15 bits to the right to cancel the 'X15'
  869 |     |       // representation of 'c0' and 'dc'.
  870 | *   |       result := shr(15, add(mul(c0, sub(sqrtFrom, sqrtTo)), quotientX231))
  871 |     |     }
  872 |     |   }
  873 |     | 
  874 |     |   /// @notice Let 'f' and 't' denote the logPrice values whose offset binary
  875 |     |   /// 'X59' representation is stored in the pointers 'from' and 'to',
  876 |     |   /// respectively. In other words, define:
  877 |     |   ///
  878 |     |   ///               from.log()                          to.log()
  879 |     |   ///  f := - 16 + ------------    and    t := - 16 + ------------
  880 |     |   ///                2 ** 59                            2 ** 59
  881 |     |   ///
  882 |     |   /// Let '(b0, c0)' and '(b1, c1)' represent the segment coordinates to be
  883 |     |   /// loaded from the memory using 'coordinate0' and 'coordinate0 + 64',
  884 |     |   /// respectively.
  885 |     |   ///
  886 |     |   /// Additionally, let '(b0, c0)' and '(b1, c1)' represent the segment
  887 |     |   /// coordinates to be loaded from the memory via the pointers
  888 |     |   /// 'coordinates0' and 'coordinates1 := coordinates0 + 64', respectively.
  889 |     |   /// More precisely:
  890 |     |   ///
  891 |     |   ///               coordinates0.log()           coordinates0.height()
  892 |     |   /// b0 := - 16 + --------------------,  c0 := -----------------------
  893 |     |   ///                    2 ** 59                        2 ** 15
  894 |     |   ///
  895 |     |   ///               coordinates1.log()           coordinates1.height()
  896 |     |   /// b1 := - 16 + --------------------,  c1 := -----------------------
  897 |     |   ///                    2 ** 59                        2 ** 15
  898 |     |   ///
  899 |     |   /// -------------------------------------------------------------------------
  900 |     |   /// If 'f < t' this function calculates:
  901 |     |   ///
  902 |     |   ///                                / t
  903 |     |   ///                               |     +h/2         c1 - c0
  904 |     |   ///  (2 ** 216) * (exp(-8) / 2) * |    e      (c0 + --------- (h - b0)) dh
  905 |     |   ///                               |                  b1 - b0
  906 |     |   ///                              / f
  907 |     |   ///
  908 |     |   /// In this case, the following closed-form formula is used:
  909 |     |   ///
  910 |     |   ///  (2 ** 216) * exp(-8) * (
  911 |     |   ///                                          c1 - c0
  912 |     |   ///    c1 * (exp(+ t / 2) - exp(+ f / 2)) - --------- * 
  913 |     |   ///                                          b1 - b0
  914 |     |   ///
  915 |     |   ///    ((b1 - t + 2) * exp(+ t / 2) - (b1 - f + 2) * exp(+ f / 2))
  916 |     |   ///  )
  917 |     |   ///
  918 |     |   ///  == c1 * ((2 ** 216) * exp(- 8 + t / 2) - (2 ** 216) * exp(- 8 + f / 2))
  919 |     |   ///
  920 |     |   ///       c1 - c0
  921 |     |   ///    - --------- * ((b1 - t + 2) * (2 ** 216) * exp(- 8 + t / 2) - 
  922 |     |   ///       b1 - b0
  923 |     |   ///                   (b1 - f + 2) * (2 ** 216) * exp(- 8 + f / 2))
  924 |     |   ///
  925 |     |   ///  == c1 * (to.sqrt(true) - from.sqrt(true))
  926 |     |   ///
  927 |     |   ///       c1 - c0
  928 |     |   ///    - --------- * ((b1 - t + 2) * to.sqrt(true) - 
  929 |     |   ///       b1 - b0
  930 |     |   ///                   (b1 - f + 2) * from.sqrt(true))
  931 |     |   ///
  932 |     |   /// -------------------------------------------------------------------------
  933 |     |   /// If 't < f' this function calculates:
  934 |     |   ///
  935 |     |   ///                                / f
  936 |     |   ///                               |     -h/2         c1 - c0
  937 |     |   ///  (2 ** 216) * (exp(-8) / 2) * |    e      (c0 + --------- (b0 - h)) dh
  938 |     |   ///                               |                  b0 - b1
  939 |     |   ///                              / t
  940 |     |   ///
  941 |     |   /// In this case, the following closed-form formula is used:
  942 |     |   ///
  943 |     |   ///  (2 ** 216) * exp(-8) * (
  944 |     |   ///                                          c1 - c0
  945 |     |   ///    c1 * (exp(- t / 2) - exp(- f / 2)) - --------- * 
  946 |     |   ///                                          b0 - b1
  947 |     |   ///
  948 |     |   ///    ((t - b1 + 2) * exp(- t / 2) - (f - b1 + 2) * exp(- f / 2))
  949 |     |   ///  )
  950 |     |   ///
  951 |     |   ///  == c1 * ((2 ** 216) * exp(- 8 - t / 2) - (2 ** 216) * exp(- 8 - f / 2))
  952 |     |   ///
  953 |     |   ///       c1 - c0
  954 |     |   ///    - --------- * ((t - b1 + 2) * (2 ** 216) * exp(- 8 - t / 2) - 
  955 |     |   ///       b0 - b1
  956 |     |   ///                   (f - b1 + 2) * (2 ** 216) * exp(- 8 - f / 2))
  957 |     |   ///
  958 |     |   ///  == c1 * (to.sqrt(false) - from.sqrt(false))
  959 |     |   ///
  960 |     |   ///       c1 - c0
  961 |     |   ///    - --------- * ((t - b1 + 2) * to.sqrt(false) - 
  962 |     |   ///       b0 - b1
  963 |     |   ///                   (f - b1 + 2) * from.sqrt(false))
  964 |     |   ///
  965 |     |   /// -------------------------------------------------------------------------
  966 |     |   /// We should have: 'c0 <= c1 <= oneX15'.
  967 |     |   ///
  968 |     |   /// If 't < f' then we should have: 'b1 <= t < f <= b0 < thirtyTwoX59'
  969 |     |   ///
  970 |     |   /// If 'f < t' then we should have: 'b0 <= f < t <= b1 < thirtyTwoX59'
  971 |     |   ///
  972 | *   |   function incoming(
  973 |     |     uint256 coordinate0,
  974 |     |     uint256 from,
  975 |     |     uint256 to
  976 |     |   ) internal pure returns (
  977 | *   |     X216 result
  978 |     |   ) {
  979 |     |     // The following values will be defined and loaded from the memory.
  980 | *   |     X15 c1;
  981 | *   |     X216 sqrtFrom;
  982 | *   |     X216 sqrtTo;
  983 | *   |     X59 db;
  984 | *   |     X74 from_times_dc;
  985 | *   |     X74 to_times_dc;
  986 | *   |     {
  987 |     |       // First, we load the integral boundaries.
  988 | *   |       X59 logFrom = from.log();
  989 | *   |       X59 logTo = to.log();
  990 |     | 
  991 |     |       // The special case of 'logFrom == logTo' is handled here. In this case
  992 |     |       // the result is equal to 'zeroX216'.
  993 | *   |       if (logFrom == logTo) return zeroX216;
  994 |     | 
  995 | *   |       {
  996 |     |         // The pointer to the second price is derived.
  997 | *   |         uint256 coordinate1;
  998 |     |         unchecked {
  999 | *   |           coordinate1 = coordinate0 + 64;
 1000 |     |         }
 1001 |     | 
 1002 |     |         // 'c1' is loaded from the memory.
 1003 | *   |         c1 = coordinate1.height();
 1004 |     | 
 1005 |     |         // In this case, because of the input requirement 'c0 <= c1', we have 
 1006 |     |         // 'c0 == c1 == zeroX15' and the output should be 'zeroX216'.
 1007 | *   |         if (c1 == zeroX15) return result;
 1008 |     | 
 1009 |     |         // 'b1' is loaded from the memory and temporarily placed in 'db'.
 1010 | *   |         db = coordinate1.log();
 1011 |     |       }
 1012 |     | 
 1013 |     |       // As explained above, depending on the value of 'left', we either use
 1014 |     |       // '(from.sqrt(false), to.sqrt(false))' or
 1015 |     |       // '(from.sqrt(true), to.sqrt(true))'.
 1016 | *   |       bool left = logTo < logFrom;
 1017 | *   |       sqrtFrom = from.sqrt(!left);
 1018 | *   |       sqrtTo = to.sqrt(!left);
 1019 |     | 
 1020 | *   |       {
 1021 |     |         // 'c0' is loaded from the memory and temporarily placed in 'dc'.
 1022 | *   |         X15 dc = coordinate0.height();
 1023 |     | 
 1024 |     |         // If 'c1 == c0' we simply return
 1025 |     |         // 'c1 * (to.sqrt(true) - from.sqrt(true)) / (2 ** 15)'
 1026 |     |         // for 'left == false' or 
 1027 |     |         // 'c1 * (to.sqrt(false) - from.sqrt(false)) / (2 ** 15)'
 1028 |     |         // for 'left == true'.
 1029 |     |         //
 1030 |     |         // The subtraction is safe, because if 'f <= t' then
 1031 |     |         // 'left == false' and we have 'exp(- 8 + f / 2) <= exp(-8 + t / 2)'
 1032 |     |         // which concludes 'from.sqrt(!left) <= to.sqrt(!left)'
 1033 |     |         //
 1034 |     |         // On the other hand, if 't < f' then 'left == true' and we have
 1035 |     |         // 'exp(- 8 - f / 2) < exp(- 8 - t / 2)' which concludes
 1036 |     |         // 'from.sqrt(!left) < to.sqrt(!left)'.
 1037 |     |         //
 1038 |     |         // The multiplication is safe because 'c1' and 'sqrtTo - sqrtFrom' are
 1039 |     |         // nonnegative values which do not exceed '16' and '216' bits, 
 1040 |     |         // respectively.
 1041 |     |         //
 1042 |     |         // We shift the result by 15 bits to the right to cancel the 'X15'
 1043 |     |         // representation of 'c1'.
 1044 | *   |         if (c1 == dc) {
 1045 |     |           assembly {
 1046 | *   |             result := shr(15, mul(c1, sub(sqrtTo, sqrtFrom)))
 1047 |     |           }
 1048 | *   |           return result;
 1049 |     |         }
 1050 |     | 
 1051 |     |         // 'dc' represents the vertical length of the segment that
 1052 |     |         // characterizes the function that we are integrating. The subtraction
 1053 |     |         // is safe due to the input requirement 'c0 <= c1'.
 1054 | *   |         dc = c1 - dc;
 1055 |     | 
 1056 |     |         // Next, if 'left == true', we calculate 
 1057 |     |         // '(logFrom - b1 + 2) * dc' and '(logTo - b1 + 2) * dc'. 
 1058 |     |         // If 'left == false', we calculate 
 1059 |     |         // '(b1 - logFrom + 2) * dc' and '(b1 - logTo + 2) * dc'.
 1060 |     |         //
 1061 |     |         // The subtractions are safe due to the input requirements. Because if
 1062 |     |         // 'left == false', we have 'logFrom <= b1' and 'logTo <= b1'.
 1063 |     |         // Additionally, if 'left == true', we have 'b1 <= logFrom' and
 1064 |     |         // 'b1 <= logTo'.
 1065 |     |         //
 1066 |     |         // The additions with 'twoX59' are safe, because in all cases the two
 1067 |     |         // terms that are being added are less than '2 ** 64'.
 1068 |     |         //
 1069 |     |         // The multiplications are safe, because in all cases the inputs are
 1070 |     |         // non-negative and the output does not exceed 81 bits.
 1071 | *   |         (from_times_dc, to_times_dc) = left ? (
 1072 | *   |           (logFrom - db + twoX59).times(dc),
 1073 | *   |           (logTo - db + twoX59).times(dc)
 1074 |     |         ) : (
 1075 | *   |           (db - logFrom + twoX59).times(dc),
 1076 | *   |           (db - logTo + twoX59).times(dc)
 1077 |     |         );
 1078 |     |       }
 1079 |     | 
 1080 |     |       // 'db' represents the horizontal length of the segment that
 1081 |     |       // characterizes the function that we are integrating. The subtractions
 1082 |     |       // are safe due to the input requirements. Because if 'left == false',
 1083 |     |       // we have 'b0 <= b1' and if 'left == true', we have 'b0 >= b1'.
 1084 | *   |       db = left ? coordinate0.log() - db : db - coordinate0.log();
 1085 |     |     }
 1086 |     | 
 1087 | *   |     assembly {
 1088 |     |       // The least significant 192-bits of the product 
 1089 |     |       // 'from_times_dc * sqrtFrom' which is in 'X290' representation because
 1090 |     |       // 'from_times_dc' is 'X74' and 'sqrtFrom' is 'X216'.
 1091 | *   |       let lsbits0X290 := mulmod(from_times_dc, sqrtFrom, shl(192, 1))
 1092 |     | 
 1093 |     |       // The least significant 192-bits of the product 
 1094 |     |       // 'to_times_dc * sqrtTo' which is in 'X290' representation because
 1095 |     |       // 'to_times_dc' is 'X74' and 'sqrtTo' is 'X216'.
 1096 | *   |       let lsbits1X290 := mulmod(to_times_dc, sqrtTo, shl(192, 1))
 1097 |     | 
 1098 |     |       // Next, we calculate 
 1099 |     |       // 'sqrtTo * to_times_dc - sqrtFrom * from_times_dc'.
 1100 |     |       //
 1101 |     |       // Next, we are going to prove that the subtraction is safe:
 1102 |     |       //
 1103 |     |       // If 'f < t', We are calculating
 1104 |     |       //
 1105 |     |       // y := ((b1 - t + 2) * exp(+ t / 2) - (b1 - f + 2) * exp(+ f / 2)) * dc
 1106 |     |       //
 1107 |     |       // In this case, because '(q + 2) * exp(-q / 2)' is a decreasing function
 1108 |     |       // within the interval '(0, +oo)', the expression
 1109 |     |       // 
 1110 |     |       // (b1 - t + 2) * exp(-(b1 - t) / 2) - (b1 - f + 2) * exp(-(b1 - f) / 2)
 1111 |     |       //
 1112 |     |       // is non-negative which concludes that 'y' is also non-negative. Hence,
 1113 |     |       // the subtraction is safe.
 1114 |     |       //
 1115 |     |       // If 't < f', We are calculating
 1116 |     |       //
 1117 |     |       // y := ((t - b1 + 2) * exp(- t / 2) - (f - b1 + 2) * exp(- f / 2)) * dc
 1118 |     |       //
 1119 |     |       // In this case, because '(q + 2) * exp(-q / 2)' is a decreasing function
 1120 |     |       // within the interval '(0, +oo)', the expression
 1121 |     |       // 
 1122 |     |       // (t - b1 + 2) * exp(-(t - b1) / 2) - (f - b1 + 2) * exp(-(f - b1) / 2)
 1123 |     |       //
 1124 |     |       // is non-negative which concludes that 'y' is also non-negative. Hence,
 1125 |     |       // the subtraction is safe.
 1126 |     | 
 1127 |     |       // The least significant 192-bits of 
 1128 |     |       // 'sqrtTo * to_times_dc - sqrtFrom * from_times_dc' which may underflow
 1129 |     |       // in which case '1' will be subtracted from 'msbitsX290'.
 1130 |     |       // The subtraction is safe because 'lsbits0X290' is less than '1 << 192'.
 1131 | *   |       let lsbitsX290 := addmod(
 1132 | *   |         lsbits1X290,
 1133 | *   |         sub(shl(192, 1), lsbits0X290),
 1134 | *   |         shl(192, 1)
 1135 |     |       )
 1136 |     | 
 1137 |     |       // The most significant 128-bits of 
 1138 |     |       // 'sqrtTo * to_times_dc - sqrtFrom * from_times_dc'.
 1139 | *   |       let msbitsX290 := sub(
 1140 |     |         // 'x == from_times_dc * sqrtFrom - (2 ** 192) * a'
 1141 |     |         // 'y == to_times_dc * sqrtTo - (2 ** 192 - 1) * b'
 1142 |     |         // 'z == to_times_dc * sqrtTo - (2 ** 192) * c'
 1143 |     |         // 'w == from_times_dc * sqrtFrom - (2 ** 192 - 1) * d'
 1144 |     |         //
 1145 |     |         // 'x + y - z - w == b - d (mod 2 ** 192)'
 1146 | *   |         sub(
 1147 | *   |           add(
 1148 | *   |             lsbits0X290,
 1149 | *   |             mulmod(to_times_dc, sqrtTo, sub(shl(192, 1), 1))
 1150 |     |           ),
 1151 | *   |           add(
 1152 | *   |             lsbits1X290,
 1153 | *   |             mulmod(from_times_dc, sqrtFrom, sub(shl(192, 1), 1))
 1154 |     |           )
 1155 |     |         ),
 1156 |     |         // 'lsbits1X290 < lsbits0X290' indicates that 'lsbits' has underflowed.
 1157 |     |         // In this case, we need to subtract 'msbitsX290' by '1'.
 1158 | *   |         lt(lsbits1X290, lsbits0X290)
 1159 |     |       )
 1160 |     | 
 1161 |     |       // Next, we calculate:
 1162 |     |       //
 1163 |     |       // '(sqrtTo * to_times_dc - sqrtFrom * from_times_dc) / db'
 1164 |     |       //
 1165 |     |       // Here, we perform the division by 'db' via the simple long division
 1166 |     |       //                   _____________________
 1167 |     |       // algorithm, i.e., 'msbitsX290 lsbitsX290' divided by 'db' becomes:
 1168 |     |       //
 1169 |     |       //                 q1X231           q0X231
 1170 |     |       //      -----------------------------------
 1171 |     |       // db   |      msbitsX290       lsbitsX290
 1172 |     |       //      |
 1173 |     |       //            q1X231 * db 
 1174 |     |       //        ---------------------------------
 1175 |     |       //        msbitsX290 % db       lsbitsX290
 1176 |     |       //
 1177 |     |       //                             q0X231 * db
 1178 |     |       //        ---------------------------------
 1179 |     |       //                                       r
 1180 |     |       //
 1181 |     |       // where
 1182 |     |       // 'r := (msbitsX290 * (2 ** 192) + lsbitsX290) % db'
 1183 |     |       // 'q1X231 := msbitsX290 / db'
 1184 |     |       // 'q0X231 := ((msbitsX290 % db) * (2 ** 192) + lsbitsX290) / db'
 1185 |     |       //
 1186 |     |       // Next, we will prove that 'msbitsX290 / db < 2 ** 50' which will be
 1187 |     |       // useful later. If 'f < t' (the other side can be argued similarly), we
 1188 |     |       // have:
 1189 |     |       //
 1190 |     |       //  (2 ** 192) * msbitsX290 + lsbitsX290
 1191 |     |       // -------------------------------------- ==
 1192 |     |       //      (2 ** (290 - 59)) * (b1 - b0)
 1193 |     |       //
 1194 |     |       //   (2 ** 192) * msbitsX290 + lsbitsX290
 1195 |     |       //  --------------------------------------
 1196 |     |       //                2 ** 290
 1197 |     |       // ---------------------------------------- ==
 1198 |     |       //                b1 - b0
 1199 |     |       //               ---------
 1200 |     |       //                2 ** 59
 1201 |     |       //
 1202 |     |       //  ((b1 - t + 2) * exp(+ t / 2) - (b1 - f + 2) * exp(+ f / 2)) * dc
 1203 |     |       // ------------------------------------------------------------------ <=
 1204 |     |       //                              b1 - b0
 1205 |     |       //
 1206 |     |       //  ((b1 - t + 2) * exp(+ t / 2) - (b1 - f + 2) * exp(+ f / 2)) * dc
 1207 |     |       // ------------------------------------------------------------------ ==
 1208 |     |       //                               t - f
 1209 |     |       //
 1210 |     |       //  g(b1 - t) - g(b1 - f)
 1211 |     |       // ----------------------- * exp(+ b1 / 2) * dc ==
 1212 |     |       //   (b1 - t) - (b1 - f)
 1213 |     |       //
 1214 |     |       //  g'(z) * exp(+ b1 / 2) * dc <= exp(-1) * exp(8) * dc < exp(7)
 1215 |     |       //  < 2 ** 11
 1216 |     |       //
 1217 |     |       // where 'g(q) := - (q + 2) * exp(-q / 2)' and 'z' is some arbitrary 
 1218 |     |       // point within the interval '(0, +oo)' whose existence is guaranteed
 1219 |     |       // thanks to the mean value theorem.
 1220 |     |       //
 1221 |     |       // Due to the above argument, we have 'msbitsX290 / db <= 2 ** 50'.
 1222 | *   |       let quotientX231 := add(
 1223 |     |         // First, we calculate 'q1X231 << 192' which the more significant part
 1224 |     |         // of the quotientX231.
 1225 |     |         //
 1226 |     |         // The division 'msbits / db' is safe because 'db != 0' due to an input
 1227 |     |         // requirement.
 1228 |     |         //
 1229 |     |         // The 192 bit shift to the left is safe because we have proven that
 1230 |     |         // 'msbitsX290 / db <= 2 ** 50'.
 1231 | *   |         shl(192, div(msbitsX290, db)),
 1232 |     |         // Then, we calculate 'q0X231' which is the least significant 192 bits
 1233 |     |         // of 'quotientX231'.
 1234 |     |         //
 1235 |     |         // The division by 'db' is safe because 'db != 0' due to an input
 1236 |     |         // requirement.
 1237 | *   |         div(
 1238 | *   |           add(
 1239 |     |             // The shift does not overflow because 
 1240 |     |             // 'msbitsX290 % db < db < 2 ** 64'.
 1241 | *   |             shl(192, mod(msbitsX290, db)),
 1242 | *   |             lsbitsX290
 1243 |     |           ),
 1244 | *   |           db
 1245 |     |         )
 1246 |     |       )
 1247 |     | 
 1248 |     |       // Lastly, the following value is calculated:
 1249 |     |       //
 1250 |     |       // 'c1 * (to.sqrt(!left) - from.sqrt(!left)) - quotient'
 1251 |     |       //
 1252 |     |       // The inner subtraction is safe, because if 'f <= t' then
 1253 |     |       // 'left == false' and we have 'exp(- 8 + f / 2) <= exp(- 8 + t / 2)'
 1254 |     |       // which concludes 'from.sqrt(!left) <= to.sqrt(!left)'
 1255 |     |       //
 1256 |     |       // On the other hand, if 't < f' then 'left == true' and we have
 1257 |     |       // 'exp(- 8 - f / 2) < exp(- 8 - t / 2)' which concludes
 1258 |     |       // 'from.sqrt(!left) < to.sqrt(!left)'.
 1259 |     |       //
 1260 |     |       // The multiplication is safe because 'c1' and 'sqrtTo - sqrtFrom' are
 1261 |     |       // nonnegative values which do not exceed '16' and '216' bits, 
 1262 |     |       // respectively.
 1263 |     |       //
 1264 |     |       // The outer subtraction is safe because the output integral is
 1265 |     |       // non-negative. Underflow due to rounding error is also impossible
 1266 |     |       // because the lowest possible value for an incoming integral
 1267 |     |       // corresponds to 
 1268 |     |       //
 1269 |     |       // 'c0 := 0'
 1270 |     |       // 'c1 := 1 / (2 ** 15)'
 1271 |     |       // 'b0 := - 16 + 1 / (2 ** 59)'
 1272 |     |       // 'b1 := + 16 - 1 / (2 ** 59)'
 1273 |     |       // 'f := - 16 + 1 / (2 ** 59)'
 1274 |     |       // 't := - 16 + 2 / (2 ** 59)'
 1275 |     |       //
 1276 |     |       // leading to
 1277 |     |       //                               / t
 1278 |     |       //                              |     +h/2         c1 - c0
 1279 |     |       // (2 ** 216) * (exp(-8) / 2) * |    e      (c0 + --------- (h - b0)) dh
 1280 |     |       //                              |                  b1 - b0
 1281 |     |       //                             / f
 1282 |     |       //
 1283 |     |       // ~= 8502917395809738
 1284 |     |       //
 1285 |     |       // which does not underflow.
 1286 |     |       //
 1287 |     |       // We shift the result by 15 bits to the right to cancel the 'X15'
 1288 |     |       // representation of 'c1' and 'dc'.
 1289 | *   |       result := shr(15, sub(mul(c1, sub(sqrtTo, sqrtFrom)), quotientX231))
 1290 |     |     }
 1291 |     |   }
 1292 |     | }

/home/training/contracts/utilities/Interval.sol
    1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
    2 |     | pragma solidity ^0.8.28;
    3 |     | 
    4 |     | import {
    5 |     |   _current_,
    6 |     |   _origin_,
    7 |     |   _begin_,
    8 |     |   _end_,
    9 |     |   _target_,
   10 |     |   _overshoot_,
   11 |     |   _total0_,
   12 |     |   _total1_,
   13 |     |   _forward0_,
   14 |     |   _forward1_,
   15 |     |   _indexKernelTotal_,
   16 |     |   _indexKernelForward_,
   17 |     |   _indexCurve_,
   18 |     |   _currentToTarget_,
   19 |     |   _incomingCurrentToTarget_,
   20 |     |   _originToOvershoot_,
   21 |     |   _currentToOrigin_,
   22 |     |   _targetToOvershoot_,
   23 |     |   _currentToOvershoot_,
   24 |     |   _interval_,
   25 |     |   _spacing_,
   26 |     |   _endOfInterval_,
   27 |     |   getCurve,
   28 |     |   getLogPriceLimitOffsetted,
   29 |     |   getCurveLength,
   30 |     |   getKernel,
   31 |     |   getDirection,
   32 |     |   getIntegralLimit,
   33 |     |   getZeroForOne,
   34 |     |   getExactInput,
   35 |     |   getLogPriceLimitOffsettedWithinInterval,
   36 |     |   getLogPriceCurrent,
   37 |     |   setZeroForOne,
   38 |     |   setCurveLength,
   39 |     |   setOutgoingMax,
   40 |     |   setOutgoingMaxModularInverse,
   41 |     |   setIncomingMax,
   42 |     |   setCurve,
   43 |     |   setLogPriceLimitOffsetted,
   44 |     |   setIntegralLimit,
   45 |     |   setIndexCurve,
   46 |     |   setDirection,
   47 |     |   setLogPriceLimitOffsettedWithinInterval,
   48 |     |   setIntegral0,
   49 |     |   setIntegral1
   50 |     | } from "./Memory.sol";
   51 |     | import {Index, zeroIndex, oneIndex, IndexLibrary} from "./Index.sol";
   52 |     | import {X15} from "./X15.sol";
   53 |     | import {X59, min, max, zeroX59, twoX59, epsilonX59} from "./X59.sol";
   54 |     | import {X74} from "./X74.sol";
   55 |     | import {
   56 |     |   X216,
   57 |     |   min,
   58 |     |   max,
   59 |     |   zeroX216,
   60 |     |   oneX216,
   61 |     |   epsilonX216,
   62 |     |   expInverse8X216
   63 |     | } from "./X216.sol";
   64 |     | import {FullMathLibrary} from "./FullMath.sol";
   65 |     | import {Curve} from "./Curve.sol";
   66 |     | import {Kernel} from "./Kernel.sol";
   67 |     | import {IntegralLibrary} from "./Integral.sol";
   68 |     | import {PriceLibrary} from "./Price.sol";
   69 |     | import {
   70 |     |   SearchingForOutgoingTargetFailed,
   71 |     |   SearchingForIncomingTargetFailed,
   72 |     |   SearchingForOvershootFailed
   73 |     | } from "./Errors.sol";
   74 |     | 
   75 |     | using PriceLibrary for uint16;
   76 |     | using IndexLibrary for uint16;
   77 |     | using IntegralLibrary for uint16;
   78 |     | using IntegralLibrary for X216;
   79 |     | 
   80 |     | /// @notice In order to perform a swap within the current active liquidity
   81 |     | /// interval, the following parameters should be set in memory:
   82 |     | ///
   83 |     | /// - 'logPriceLimitOffsettedWithinInterval'
   84 |     | /// - 'indexCurve'
   85 |     | /// - 'direction'
   86 |     | /// - 'current'
   87 |     | /// - 'origin'
   88 |     | /// - 'begin'
   89 |     | /// - 'end'
   90 |     | /// - 'target'
   91 |     | /// - 'total0'
   92 |     | /// - 'total1'
   93 |     | ///
   94 |     | /// where the description of each parameter is given in 'Memory.sol'. This
   95 |     | /// function initiates the 'swapWithin' method of 'Swap.sol' by setting the
   96 |     | /// above parameters.
   97 |     | function initiateInterval() pure {
   98 |     |   // We first load the memory pointer for the curve sequence from the memory.
   99 |     |   Curve curve = getCurve();
  100 |     | 
  101 |     |   // The value set as 'logPriceLimitOffsetted' may be outside of the current
  102 |     |   // active liquidity interval. In such cases, we first need to perform a swap
  103 |     |   // towards the current interval boundary and then we transition to a new
  104 |     |   // interval. In order to perform the former step, 'logPriceLimitOffsetted'
  105 |     |   // needs to be capped by the boundaries of the current active liquidity
  106 |     |   // interval.
  107 |     |   {
  108 |     |     // To this end, the first two members of the curve sequence are loaded. As
  109 |     |     // explained in 'Curve.sol', the first two members are the boundaries of
  110 |     |     // the current active liquidity interval.
  111 |     |     (X59 qLower, X59 qUpper) = curve.boundaries();
  112 |     | 
  113 |     |     // Signed comparison is valid here because:
  114 |     |     //
  115 |     |     // '0 < qLower < 2 ** 64',
  116 |     |     // '0 < qUpper < 2 ** 64',
  117 |     |     // '0 < getLogPriceLimitOffsetted() < 2 ** 64'.
  118 |     |     //
  119 |     |     // Each of the above values are offsetted logarithmic prices that occupy
  120 |     |     // exactly '64' bits in memory.
  121 |     |     //
  122 |     |     // The resulting value is also between '0' and '2 ** 64' and can be safely
  123 |     |     // stored within the allocated '64' bits of memory.
  124 |     |     setLogPriceLimitOffsettedWithinInterval(
  125 |     |       min(max(qLower, getLogPriceLimitOffsetted()), qUpper)
  126 |     |     );
  127 |     |   }
  128 |     | 
  129 |     |   // As explained in 'Curve.sol', the length of the curve sequence is always
  130 |     |   // greater than or equal to '2'. Hence, subtraction is safe here.
  131 |     |   Index indexCurve = getCurveLength() - oneIndex;
  132 |     | 
  133 |     |   // When performing a swap within the current active liquidity interval, we
  134 |     |   // explore members of the curve sequence by starting from the last member.
  135 |     |   // Hence, the initial index should point to the last member, which is how
  136 |     |   // 'indexCurve' is chosen. The very first execution of the method
  137 |     |   // 'movePhase()' reduces 'indexCurve' to 'getCurveLength() - twoIndex' which
  138 |     |   // refers to the very first phase of 'w(.)' to be explored.
  139 |     |   //
  140 |     |   // The value of 'indexCurve' is less than 'getCurveLength()' and therefore
  141 |     |   // does not exceed '2' bytes. Hence, it can be safely stored in the allocated
  142 |     |   // 2 bytes of memory.
  143 |     |   setIndexCurve(indexCurve);
  144 |     | 
  145 |     |   // Index out of range is not possible because 'indexCurve' refers to the last
  146 |     |   // member of the curve which is the current offsetted logarithmic price as
  147 |     |   // explained in 'Curve.sol'.
  148 |     |   X59 current = curve.member(indexCurve);
  149 |     | 
  150 |     |   // As explained in 'Memory.sol', the curve sequence leads to a function
  151 |     |   // 'w : [qLower, qUpper] -> [0, qSpacing]' which is composed of 'phases'. For
  152 |     |   // example, let 'qLower, qUpper, qCurrent' represent the curve sequence.
  153 |     |   // Then, 'w(q)' can be plotted as follows:
  154 |     |   //
  155 |     |   //          ^
  156 |     |   //  spacing |\
  157 |     |   //          | \
  158 |     |   //          |  \
  159 |     |   //          |   \
  160 |     |   //          |    \
  161 |     |   //          |     \
  162 |     |   //          |      \
  163 |     |   //          |               /
  164 |     |   //          |              /
  165 |     |   //          |             /
  166 |     |   //          |            /
  167 |     |   //          |           /
  168 |     |   //          |          /
  169 |     |   //          |         /
  170 |     |   //          |        /
  171 |     |   //        0 +-------+--------+
  172 |     |   //       qLower  qCurrent  qUpper
  173 |     |   //
  174 |     |   // See 'Memory.sol' for the precise definition of 'w(q)'. In general, the
  175 |     |   // very first 'phase' to be explored corresponds to the segment in between
  176 |     |   // 'curve.member(getCurveLength() - oneIndex)' and 
  177 |     |   // 'curve.member(getCurveLength() - twoIndex)'. In this example, the first
  178 |     |   // phase is within '(qCurrent, qUpper)'.
  179 |     |   //
  180 |     |   // Here, the direction of the initial 'phase' to be explored is determined
  181 |     |   // and its opposite is set in memory. If
  182 |     |   // '(2 ** 59) * (16 + qCurrent) < curve.member(indexCurve - oneIndex)', then
  183 |     |   // the direction is towards '+oo' and we should store 'true'. Alternatively
  184 |     |   // if '(2 ** 59) * (16 + qCurrent) > curve.member(indexCurve - oneIndex)',
  185 |     |   // then the direction is towards '-oo' and we should store 'false'. Notice
  186 |     |   // that members of the curve sequence may never be equal. Lastly, we store
  187 |     |   // the opposite so that after the first execution of 'movePhase()' the
  188 |     |   // direction is corrected. As explained in 'Memory.sol' regardless of the
  189 |     |   // value for 'zeroForOne' (i.e., whether the swap is towards '+oo' or '-oo'),
  190 |     |   // we flip the direction flag every time that we move to a new 'phase',
  191 |     |   // because consecutive phases have opposite directions. In the above example,
  192 |     |   // the direction of the very first 'phase' within '(qCurrent, qUpper)' is
  193 |     |   // towards '+oo' and the direction of the second 'phase' within
  194 |     |   // '(qLower, qCurrent)' is towards '-oo', i.e., 'false' and 'true',
  195 |     |   // respectively. We store the opposite of the direction for the first
  196 |     |   // 'phase', so that the first run of the function 'movePhase()' would change
  197 |     |   // the direction to the intended value.
  198 |     |   //
  199 |     |   // Subtraction is safe because the length of the curve is always greater than
  200 |     |   // or equal to '2' and hence,
  201 |     |   // 'indexCurve - oneIndex == getCurveLength() - twoIndex >= zeroIndex'.
  202 |     |   //
  203 |     |   // Signed comparison is valid here because both sides are members of curve
  204 |     |   // that are nonnegative and less than '2 ** 64'.
  205 |     |   setDirection(current < curve.member(indexCurve - oneIndex));
  206 |     | 
  207 |     |   // Next, the values '(2 ** 216) * exp(- 8 - qCurrent / 2)' and
  208 |     |   // '(2 ** 216) * exp(- 8 + qCurrent / 2)' are determined and stored in memory
  209 |     |   // along with '(2 ** 59) * (16 + qCurrent)'. The resulting values are then
  210 |     |   // copied as initial points for 'qOrigin', 'qBegin', 'qEnd', 'qTarget',
  211 |     |   // 'qTotal0', and 'qTotal1'.
  212 |     |   //
  213 |     |   // The requirements of store price are satisfied because 'qCurrent' is a 
  214 |     |   // member of the curve sequence and may never exceed '64' bits. Additionally,
  215 |     |   // the value for all of the pointers below is a constant greater than '32'.
  216 |     |   //
  217 |     |   // The definition for the content of each memory pointer is given in
  218 |     |   // 'Memory.sol'.
  219 |     |   _current_.storePrice(current);
  220 |     |   _origin_.copyPrice(_current_);
  221 |     |   _begin_.copyPrice(_current_);
  222 |     |   _end_.copyPrice(_current_);
  223 |     |   _target_.copyPrice(_current_);
  224 |     |   // Notice that according to 'PriceLibrary' one can copy the content of a
  225 |     |   // price pointer to a price with height which is what we are doing here.
  226 |     |   _total0_.copyPrice(_current_);
  227 |     |   _total1_.copyPrice(_current_);
  228 |     | }
  229 |     | 
  230 |     | /// @notice Increments 'indexKernelTotal' and substitutes 'total0' with
  231 |     | /// 'total1'. Lastly, loads a new breakpoint from the kernel and stores its
  232 |     | /// resultant with 'qOrigin' into the price pointer '_total1_'.
  233 |     | ///
  234 |     | /// ---------------------------------------------------------------------------
  235 |     | ///
  236 |     | /// Overflow of 'indexKernelTotal' and index out of range should be avoided
  237 |     | /// externally.
  238 |     | function moveBreakpointTotal() pure {
  239 |     |   // A swap can be interpreted as a price movement. The precise value for
  240 |     |   // 'qTarget' may be determined from 'logPriceLimit' or we may need to
  241 |     |   // determine that based on 'amountSpecified'. We also need to keep track of
  242 |     |   // the outgoing and incoming amounts as we move from the 'qCurrent' to
  243 |     |   // 'qTarget'. As explained in 'Memory.sol', in the definitions for 'amount0'
  244 |     |   // and 'amount1', if 'zeroForOne == false', the outgoing and incoming amounts
  245 |     |   // are proportional to:
  246 |     |   //
  247 |     |   //                           - 8     / qTarget
  248 |     |   //    currentToTarget      e        |    - h / 2
  249 |     |   //  '----------------- := ------- * |  e         k(w(h)) dh'.
  250 |     |   //       2 ** 216            2      |
  251 |     |   //                                 / qCurrent
  252 |     |   //
  253 |     |   //                                   - 8     / qTarget
  254 |     |   //    incomingCurrentToTarget      e        |    + h / 2
  255 |     |   //  '------------------------- := ------- * |  e         k(w(h)) dh',
  256 |     |   //           2 ** 216                2      |
  257 |     |   //                                         / qCurrent
  258 |     |   //
  259 |     |   // and if 'zeroForOne == true', the outgoing and incoming amounts are
  260 |     |   // proportional to:
  261 |     |   //
  262 |     |   //                           - 8     / qCurrent
  263 |     |   //    currentToTarget      e        |    + h / 2
  264 |     |   //  '----------------- := ------- * |  e         k(w(h)) dh',
  265 |     |   //       2 ** 216            2      |
  266 |     |   //                                 / qTarget
  267 |     |   //
  268 |     |   //                                   - 8     / qCurrent
  269 |     |   //    incomingCurrentToTarget      e        |    - h / 2
  270 |     |   //  '------------------------- := ------- * |  e         k(w(h)) dh'.
  271 |     |   //            2 ** 216               2      |
  272 |     |   //                                         / qTarget
  273 |     |   //
  274 |     |   // Hence, in order to keep track of the outgoing and incoming amounts, we
  275 |     |   // need to keep track of the two integrals, 'currentToTarget' and 
  276 |     |   // 'incomingCurrentToTarget'. Remember that both functions 'k' and 'w' are
  277 |     |   // piecewise linear. As a result, 'k(w(h))' is also piecewise linear. In
  278 |     |   // order to keep track of the integrals, we proceed from 'qCurrent' to
  279 |     |   // 'qTarget' piece by piece. At each step, we take the outgoing and incoming
  280 |     |   // integrals of the piece under exploration using 'IntegralLibrary' and
  281 |     |   // increment the total integrals 'currentToTarget' and
  282 |     |   // 'incomingCurrentToTarget' with the resulting values.
  283 |     |   // 
  284 |     |   // To this end, we need to keep track of the pieces for both 'w' and 'k'.
  285 |     |   // As explained in 'Memory.sol', each piece of the function 'w' is regarded
  286 |     |   // as a 'phase' and the current phase under exploration can be characterized
  287 |     |   // by the following three members of the curve sequence:
  288 |     |   //
  289 |     |   //  - 'qEnd := q[indexCurve]',
  290 |     |   //
  291 |     |   //  - 'qOrigin := q[indexCurve + 1]',
  292 |     |   //
  293 |     |   //  - 'q[indexCurve + 2]',
  294 |     |   //
  295 |     |   // where the out of range member 'q[curveLength]' is assigned the same value
  296 |     |   // as the last member 'q[curveLength - 1]'.
  297 |     |   //
  298 |     |   // 'q[indexCurve + 2]' is where the 'phase' starts. 'qEnd' is where the phase
  299 |     |   // ends. If 'q[indexCurve + 2] < qEnd' then the 'phase' under exploration in
  300 |     |   // the diagram of 'w(.)' corresponds to a segment whose extension intersects
  301 |     |   // with the horizontal axis at 'qOrigin' with the angle '+45' degrees. In
  302 |     |   // this case, 'getDirection() == false' and 'w(h) := h - qOrigin'. If
  303 |     |   // 'qBegin > qEnd' then the 'phase' under exploration in the diagram of
  304 |     |   // 'w(.)' corresponds to a segment whose extension intersects with the
  305 |     |   // horizontal axis at 'qOrigin' with the angle '+135' degrees. In this case,
  306 |     |   // 'w(h) := qOrigin - h' and 'getDirection() == true'.
  307 |     |   //
  308 |     |   // As we move from 'qCurrent' towards the destination of the swap, we may
  309 |     |   // need to move from one 'phase' to the next. Let
  310 |     |   // '(qEnd, qOrigin, q[indexCurve + 2])' represent the current 'phase' under
  311 |     |   // exploration. If 'q[indexCurve + 2] < qEnd' ('getDirection() == false'),
  312 |     |   // then we have
  313 |     |   //
  314 |     |   //  'k(w(h)) == k(h - qOrigin)' for every 'q[indexCurve + 2] < h < qEnd'.
  315 |     |   //
  316 |     |   // If 'qEnd < q[indexCurve + 2]' ('getDirection() == true'), then we have
  317 |     |   //
  318 |     |   //  'k(w(h)) == k(qOrigin - h)' for every 'qEnd < h < q[indexCurve + 2]'.
  319 |     |   //
  320 |     |   // But 'k : [0, qSpacing] -> [0, 1]' is also piecewise linear. Now that we
  321 |     |   // fixed one phase of the function 'w' and everything is with respect to the
  322 |     |   // function 'k', we need to account for every piece of 'k' within 
  323 |     |   //
  324 |     |   //  '(q[indexCurve + 2] - qOrigin, qEnd - qOrigin)'
  325 |     |   //
  326 |     |   // or
  327 |     |   //
  328 |     |   //  '(qEnd - qOrigin, q[indexCurve + 2] - qOrigin)',
  329 |     |   //
  330 |     |   // depending on the direction. 'indexKernelTotal' is the index that we use
  331 |     |   // for this purpose. At first, it is equal to 'zeroIndex' and it is
  332 |     |   // incremented by 'oneIndex' every time that this function is called.
  333 |     |   //
  334 |     |   // Let
  335 |     |   //
  336 |     |   //  'b0 := b[indexKernelTotal]',
  337 |     |   //  'c0 := c[indexKernelTotal]',
  338 |     |   //
  339 |     |   // represent the horizontal and vertical coordinates of the kernel breakpoint
  340 |     |   // corresponding to 'indexKernelTotal', respectively (prior to it being
  341 |     |   // incremented). Let
  342 |     |   //
  343 |     |   //  'b1 := b[indexKernelTotal + oneIndex]',
  344 |     |   //  'c1 := c[indexKernelTotal + oneIndex]',
  345 |     |   //
  346 |     |   // represent the vertical and horizontal coordinates of the kernel breakpoint
  347 |     |   // corresponding to 'indexKernelTotal + oneIndex'.
  348 |     |   // 
  349 |     |   // If 'q[indexCurve + 2] < qEnd', then we want to integrate
  350 |     |   //
  351 |     |   //  'exp(- h / 2) * k(h - qOrigin)'
  352 |     |   //
  353 |     |   // and
  354 |     |   //
  355 |     |   //  'exp(+ h / 2) * k(h - qOrigin)'
  356 |     |   //
  357 |     |   // between the two breakpoints characterized by 'indexKernelTotal' and
  358 |     |   // 'indexKernelTotal + oneIndex'. If 'qEnd < q[indexCurve + 2]', then we want
  359 |     |   // to integrate
  360 |     |   //
  361 |     |   //  'exp(- h / 2) * k(qOrigin - h)'
  362 |     |   //
  363 |     |   // and
  364 |     |   //
  365 |     |   //  'exp(+ h / 2) * k(qOrigin - h)'
  366 |     |   //
  367 |     |   // between the two breakpoints characterized by 'indexKernelTotal' and
  368 |     |   // 'indexKernelTotal + oneIndex'.
  369 |     |   //
  370 |     |   // To that end, the first step is to shift the two breakpoints by 'qOrigin'.
  371 |     |   // The memory spaces 'total0' and 'total1' keep track of these shifted
  372 |     |   // breakpoints. In other words, 'total0' and 'total1' are the breakpoints for
  373 |     |   // 'k(h - qOrigin)' or 'k(qOrigin - h)', depending on the direction.
  374 |     |   //
  375 |     |   // As explained in 'Memory.sol', each one of 'total0' and 'total1' are prices
  376 |     |   // with height and each one occupies '64' bytes in memory via the layout
  377 |     |   // explained in 'Price.sol'.
  378 |     |   //
  379 |     |   // If 'q[indexCurve + 2] < qEnd', we have:
  380 |     |   // 
  381 |     |   //  '_total0_.height() := (2 ** 15) * c0'
  382 |     |   //  '_total1_.height() := (2 ** 15) * c1'
  383 |     |   //  '_total0_.log() := (2 ** 59) * (16 + qOrigin + b0)'
  384 |     |   //  '_total1_.log() := (2 ** 59) * (16 + qOrigin + b1)'
  385 |     |   // 
  386 |     |   // If 'qEnd < q[indexCurve + 2]', we have:
  387 |     |   //
  388 |     |   //  '_total0_.height() := (2 ** 15) * c0'
  389 |     |   //  '_total1_.height() := (2 ** 15) * c1'
  390 |     |   //  '_total0_.log() := (2 ** 59) * (16 + qOrigin - b0)'
  391 |     |   //  '_total1_.log() := (2 ** 59) * (16 + qOrigin - b1)'
  392 |     |   //
  393 |     |   // The values for '_total0_.sqrt(false)', '_total1_.sqrt(false)',
  394 |     |   // '_total0_.sqrt(true)', and '_total1_.sqrt(true)' are calculated
  395 |     |   // accordingly to mirror the above logarithmic values.
  396 |     |   //
  397 |     |   // Now, in order to move from one pair of breakpoints to the next we first
  398 |     |   // replace the '64' bytes of 'total0' with the '64' bytes of 'total1' so that
  399 |     |   // 'total1' can be used for the next shifted price to be calculated.
  400 |     |   _total0_.copyPriceWithHeight(_total1_);
  401 |     | 
  402 |     |   // Then, we calculate the new content of 'total1' as described above using
  403 |     |   // the function 'impose' from 'KernelLibrary'.
  404 |     |   //
  405 |     |   // Index out of range for 'indexKernelTotal' is avoided externally.
  406 |     |   //
  407 |     |   // Next, we are going to prove that:
  408 |     |   //
  409 |     |   //  '0 < (2 ** 59) * (16 + qOrigin + b1) < 2 ** 64',
  410 |     |   //  '0 < (2 ** 59) * (16 + qOrigin - b1) < 2 ** 64',
  411 |     |   //
  412 |     |   // as required by 'impose' in 'Kernel.sol'.
  413 |     |   //
  414 |     |   // Let 'pLower' and 'pUpper' denote the minimum and maximum price in the
  415 |     |   // active liquidity interval, respectively and define
  416 |     |   //
  417 |     |   //  'qLower := log(pLower / pOffset)',
  418 |     |   //  'qUpper := log(pUpper / pOffset)'.
  419 |     |   //
  420 |     |   // Let 'qSpacing := qUpper - qLower' denote the length of every liquidity
  421 |     |   // interval. Upon initializing a pool, the given curve sequence is validated
  422 |     |   // by the method 'validate' in 'Curve.sol'.
  423 |     |   //
  424 |     |   // When validating the curve sequence, the custom
  425 |     |   // error 'BlankIntervalsShouldBeAvoided' ensures that '16 + qLower' is
  426 |     |   // greater than 'qSpacing' and '16 + qUpper' is smaller than '32 - qSpacing'.
  427 |     |   // As a result, every member 'q' of the initial curve sequence
  428 |     |   // satisfies:
  429 |     |   // 
  430 |     |   //  'qSpacing < 16 + q < 32 - qSpacing'
  431 |     |   // 
  432 |     |   // In addition, the method 'setSwapParams' in 'Swap.sol' ensures that
  433 |     |   // 'qTarget' for every swap is also bounded by both
  434 |     |   // 'qSpacing + 1 / (2 ** 59)' and '32 - 1 / (2 ** 59) - qSpacing'.
  435 |     |   // This ensures that the above inequality is always satisfied for every
  436 |     |   // member of the curve and not only the initial curve.
  437 |     |   //
  438 |     |   // Now, since 'qOrigin' is a member of the curve sequence, we also have:
  439 |     |   //
  440 |     |   //  'qSpacing < 16 + qOrigin < 32 - qSpacing'
  441 |     |   //
  442 |     |   // Hence,
  443 |     |   //
  444 |     |   //  '0 < (2 ** 59) * (16 + qOrigin) <= (2 ** 59) * (16 + qOrigin + b1)
  445 |     |   //     < (2 ** 59) * (32 - qSpacing + b1) <= (2 ** 59) * 32 == 2 ** 64'
  446 |     |   //
  447 |     |   // where '0 < (2 ** 59) * (16 + qOrigin)' is because 'qOrigin' is a member of
  448 |     |   // the curve and 'b1 <= qSpacing' is concluded from the custom error
  449 |     |   // 'HorizontalCoordinatesMayNotExceedLogSpacing' when validating kernel in
  450 |     |   // 'KernelCompact.sol'.
  451 |     |   //
  452 |     |   // Additionally,
  453 |     |   //
  454 |     |   //  '2 ** 64 >  (2 ** 59) * (16 + qOrigin)
  455 |     |   //           >= (2 ** 59) * (16 + qOrigin - b1)
  456 |     |   //           >  (2 ** 59) * (qSpacing - b1) >= 0'
  457 |     |   //
  458 |     |   // where '(2 ** 59) * (16 + qOrigin) < 2 ** 64' is because 'qOrigin' is a
  459 |     |   // member of the curve and 'b1 <= qSpacing' is concluded from the custom
  460 |     |   // error 'HorizontalCoordinatesMayNotExceedLogSpacing' when validating kernel
  461 |     |   // in 'KernelCompact.sol'.
  462 |     |   //
  463 |     |   // Lastly, '_total1_' is a fixed value greater than '34'.
  464 |     |   //
  465 |     |   // Therefore, the input requirements of 'impose' are satisfied.
  466 |     |   getKernel().impose(
  467 |     |     // The resulting values are stored using the pointer '_total1_'.
  468 |     |     _total1_,
  469 |     |     // 'qOrigin' is used as the base price for the shift.
  470 |     |     _origin_,
  471 |     |     // The incremented index is safely stored in the allocated 2 bytes of
  472 |     |     // memory because overflow of 'indexKernelTotal' is avoided externally.
  473 |     |     _indexKernelTotal_.incrementIndex(),
  474 |     |     // Since the phase is fixed, the current direction is used for this shift.
  475 |     |     getDirection()
  476 |     |   );
  477 |     | }
  478 |     | 
  479 |     | /// @notice Increments 'indexKernelForward' and substitutes 'forward0' with
  480 |     | /// 'forward1'. Lastly, loads a new breakpoint from the kernel and stores its
  481 |     | /// resultant with 'qTarget' into the memory space 'forward1'.
  482 |     | ///
  483 |     | /// ---------------------------------------------------------------------------
  484 |     | ///
  485 |     | /// Overflow of 'indexKernelForward' and index out of range should be avoided
  486 |     | /// externally.
  487 |     | function moveBreakpointForward() pure {
  488 |     |   // In order to perform a swap within the active liquidity interval, we first
  489 |     |   // determine 'qTarget' as well as the outgoing and incoming amounts. After
  490 |     |   // this step, we need to construct a new curve sequence in preparation for
  491 |     |   // the next swap. To that end, we amend the curve sequence. The process of
  492 |     |   // amending is explained in 'Curve.sol'. Each amendment involves potentially
  493 |     |   // disposing a number of members from the end of the curve sequence and then
  494 |     |   // adding a new member to the end.
  495 |     |   //
  496 |     |   // As explained in 'Memory.sol', in the definition of 'overshoot', each swap
  497 |     |   // involves a maximum of two amendments. We first amend the curve sequence
  498 |     |   // with 'qOvershoot'. Then, we amend the resulting curve sequence with
  499 |     |   // 'qTarget' so that the last member becomes 'qTarget'. The purpose of
  500 |     |   // amending with 'qOvershoot' is to ensure that the conservation of reserves
  501 |     |   // is maintained. In other words, we want to have:
  502 |     |   // 
  503 |     |   //  'totalReserveOfTag0Before == totalReserveOfTag0After',
  504 |     |   //  'totalReserveOfTag1Before == totalReserveOfTag1After'.
  505 |     |   //
  506 |     |   // In order to satisfy the two equations above, we need two variables. One is
  507 |     |   // 'growth', which increases with every swap. But since we have two
  508 |     |   // equations, we need another degree of freedom in the choice for the new
  509 |     |   // curve sequence. This is why we resort to the notion of 'overshoot'. The
  510 |     |   // reason behind 'overshoot' is further explained in 'Memory.sol'.
  511 |     |   //
  512 |     |   // Consider the new curve sequence which is amended by both 'qOvershoot' and
  513 |     |   // then 'qTarget'. Construct 'wAmended' accordingly using the formula given
  514 |     |   // in 'Memory.sol'. By canceling the first variable 'growth', the search for
  515 |     |   // 'qOvershoot' boils down to solving the following equation:
  516 |     |   //
  517 |     |   //      / qTarget                         / qUpper
  518 |     |   //     |   + h/2                         |   - h/2
  519 |     |   //     |  e      k(wAmended(h)) dh       |  e      k(wAmended(h)) dh
  520 |     |   //     |                                 |
  521 |     |   //    / qLower                          / qTarget
  522 |     |   //  '------------------------------ == ------------------------------'.
  523 |     |   //         / qTarget                         / qUpper
  524 |     |   //        |    + h/2                        |    - h/2
  525 |     |   //        |  e       k(w(h)) dh             |  e       k(w(h)) dh
  526 |     |   //        |                                 |
  527 |     |   //       / qLower                          / qTarget
  528 |     |   //
  529 |     |   // For simplicity, consider the case 'zeroForOne == false'. In this case,
  530 |     |   //
  531 |     |   //                     /  k(w(h))            if  qOvershoot < h < qUpper
  532 |     |   //  'k(wAmended(h)) = |   k(h - qTarget)     if  qTarget < h < qOvershoot '
  533 |     |   //                    |   k(qOvershoot - h)  if  qOrigin < h < qTarget
  534 |     |   //                     \  k(w(h))            if  qLower < h < qOrigin
  535 |     |   //
  536 |     |   // which means that
  537 |     |   //
  538 |     |   //     / qUpper
  539 |     |   //    |   - h / 2
  540 |     |   //  ' |  e        k(wAmended(h)) dh ==
  541 |     |   //    |
  542 |     |   //   / qTarget
  543 |     |   //
  544 |     |   //     / qOvershoot                    / qUpper
  545 |     |   //    |   - h / 2                     |   - h / 2
  546 |     |   //    |  e        k(h - qTarget) dh + |  e        k(w(h)) dh '.
  547 |     |   //    |                               |
  548 |     |   //   / qTarget                       / qOvershoot
  549 |     |   //
  550 |     |   // Hence, we need to integrate 'exp(-h / 2) * k(h - qTarget)' from 'qTarget'
  551 |     |   // to 'qOvershoot'.
  552 |     |   // 
  553 |     |   // Remember that at this stage, 'qOvershoot' is still an unknown value which
  554 |     |   // will be determined via numerical search. More precisely, after 'qTarget'
  555 |     |   // is determined, we keep moving forward in the same direction until we find
  556 |     |   // the precise value for 'qOvershoot'. But as we move forward, we need to
  557 |     |   // keep track of the integral
  558 |     |   //
  559 |     |   //     / qOvershoot
  560 |     |   //    |   - h / 2
  561 |     |   //  ' |  e        k(h - qTarget) dh
  562 |     |   //    |
  563 |     |   //   / qTarget
  564 |     |   //
  565 |     |   // To this end, we enumerate pieces of 'k' one by one and
  566 |     |   // 'indexKernelForward' is the index that we use for this purpose. At first,
  567 |     |   // before the start of the search for 'qOvershoot', this index is equal to
  568 |     |   // 'zeroIndex' and it is incremented by 'oneIndex' everytime that the present
  569 |     |   // function is called.
  570 |     |   //
  571 |     |   // Let
  572 |     |   //
  573 |     |   //  'b0 := b[indexKernelForward]',
  574 |     |   //  'c0 := c[indexKernelForward]',
  575 |     |   //
  576 |     |   // represent the horizontal and vertical coordinates of the kernel breakpoint
  577 |     |   // corresponding to 'indexKernelForward', respectively (prior to it being
  578 |     |   // incremented). Let
  579 |     |   //
  580 |     |   //  'b1 := b[indexKernelForward + oneIndex]',
  581 |     |   //  'c1 := c[indexKernelForward + oneIndex]',
  582 |     |   //
  583 |     |   // represent the vertical and horizontal coordinates of the kernel breakpoint
  584 |     |   // corresponding to 'indexKernelForward + oneIndex'.
  585 |     |   // 
  586 |     |   // If 'zeroForOne == false', then we want to integrate 
  587 |     |   //
  588 |     |   //  'exp(- h / 2) * k(h - qTarget)'
  589 |     |   //
  590 |     |   // between the two breakpoints that are characterized by 'indexKernelForward'
  591 |     |   // and 'indexKernelForward + oneIndex'. If 'zeroForOne == true', then we want
  592 |     |   // to integrate
  593 |     |   //
  594 |     |   //  'exp(+ h / 2) * k(qTarget - h)'
  595 |     |   //
  596 |     |   // between the two breakpoints characterized by 'indexKernelForward' and
  597 |     |   // 'indexKernelForward + oneIndex'.
  598 |     |   //
  599 |     |   // To that end, the first step is to shift the two breakpoints by 'qTarget'.
  600 |     |   // The memory spaces 'forward0' and 'forward1' keep track of these shifted
  601 |     |   // breakpoints. In other words, 'forward0' and 'forward1' are the breakpoints
  602 |     |   // for 'k(h - qTarget)' or 'k(qTarget - h)', depending on 'zeroForOne'.
  603 |     |   //
  604 |     |   // As explained in 'Memory.sol', each one of 'forward0' and 'forward1' are
  605 |     |   // prices with height and each one occupies '64' bytes in memory via the
  606 |     |   // layout explained in 'Price.sol'.
  607 |     |   //
  608 |     |   // If 'zeroForOne == false', we have:
  609 |     |   // 
  610 |     |   //  '_forward0_.height() := (2 ** 15) * c0'
  611 |     |   //  '_forward1_.height() := (2 ** 15) * c1'
  612 |     |   //  '_forward0_.log() := (2 ** 59) * (16 + qTarget + b0)'
  613 |     |   //  '_forward1_.log() := (2 ** 59) * (16 + qTarget + b1)'
  614 |     |   // 
  615 |     |   // If 'zeroForOne == true', we have:
  616 |     |   //
  617 |     |   //  '_forward0_.height() := (2 ** 15) * c0'
  618 |     |   //  '_forward1_.height() := (2 ** 15) * c1'
  619 |     |   //  '_forward0_.log() := (2 ** 59) * (16 + qTarget - b0)'
  620 |     |   //  '_forward1_.log() := (2 ** 59) * (16 + qTarget - b1)'
  621 |     |   //
  622 |     |   // The values for 'forward0.sqrt(false)', 'forward1.sqrt(false)',
  623 |     |   // 'forward0.sqrt(true)', and 'forward1.sqrt(true)' are calculated
  624 |     |   // accordingly to mirror the above logarithmic prices.
  625 |     |   //
  626 |     |   // Now, in order to move from one pair of breakpoints to the next we first
  627 |     |   // replace the '64' bytes of 'forward0' with the '64' bytes of 'forward1' so
  628 |     |   // that 'forward1' can be used for the next shifted price to be calculated.
  629 |     |   _forward0_.copyPriceWithHeight(_forward1_);
  630 |     | 
  631 |     |   // Then we calculate the new value for 'forward1' as described above using
  632 |     |   // the function 'impose' from 'KernelLibrary'.
  633 |     |   //
  634 |     |   // Index out of range for 'indexKernelForward' is avoided externally.
  635 |     |   //
  636 |     |   // Next, we are going to prove that:
  637 |     |   //
  638 |     |   //  '0 < (2 ** 59) * (16 + qTarget - b1) < 2 ** 64'
  639 |     |   //  '0 < (2 ** 59) * (16 + qTarget + b1) < 2 ** 64'
  640 |     |   //
  641 |     |   // as required by 'impose' in 'Kernel.sol' for cases 'left == false' and
  642 |     |   // 'left == true', respectively.
  643 |     |   //
  644 |     |   // Let 'pLower' and 'pUpper' denote the minimum and maximum price in the
  645 |     |   // active liquidity interval, respectively and define
  646 |     |   //
  647 |     |   //  'qLower := log(pLower / pOffset)',
  648 |     |   //  'qUpper := log(pUpper / pOffset)'.
  649 |     |   //
  650 |     |   // Let 'qSpacing := qUpper - qLower' denote the length of every liquidity
  651 |     |   // interval. Upon initializing a pool, the given curve sequence is validated
  652 |     |   // by the method 'validate' in 'Curve.sol'. When validating the curve
  653 |     |   // sequence, the custom error 'BlankIntervalsShouldBeAvoided' ensures that
  654 |     |   // '16 + qLower' is greater than 'qSpacing' and '16 + qUpper' is smaller than
  655 |     |   // '32 - qSpacing'. As a result, every member 'q' of the initial curve
  656 |     |   // sequence satisfies:
  657 |     |   // 
  658 |     |   //  'qSpacing < 16 + q < 32 - qSpacing'
  659 |     |   // 
  660 |     |   // In addition, the method 'setSwapParams' in 'Swap.sol' ensures that
  661 |     |   // 'qTarget' for every swap is also bounded by both
  662 |     |   // 'qSpacing + 1 / (2 ** 59)' and '32 - 1 / (2 ** 59) - qSpacing'.
  663 |     |   // This ensures that the above inequality is always satisfied for every
  664 |     |   // member of the curve and not only the initial curve.
  665 |     |   //
  666 |     |   // Remember that 'logPriceLimitOffsettedWithinInterval' is capped by both
  667 |     |   // 'qLower' and 'qUpper' in 'initiateInterval'. Hence, if
  668 |     |   // 'zeroForOne == false':
  669 |     |   //
  670 |     |   //  'qLower <= qCurrent <= qTarget <= qLimit <= qUpper'
  671 |     |   //
  672 |     |   // and if 'zeroForOne == true':
  673 |     |   //
  674 |     |   //  'qLower <= qLimit <= qTarget <= qCurrent <= qUpper'
  675 |     |   //
  676 |     |   // which means that in both cases:
  677 |     |   //
  678 |     |   //  'qSpacing < 16 + qLower <= 16 + qTarget <= 16 + qUpper < 32 - qSpacing'.
  679 |     |   //
  680 |     |   // Put simply, since at this stage we are swapping within the current active
  681 |     |   // interval, then the target belongs to the current active interval.
  682 |     |   //
  683 |     |   // Hence,
  684 |     |   //
  685 |     |   //  '0 <  (2 ** 59) * (16 + qLower)
  686 |     |   //     <= (2 ** 59) * (16 + qTarget)
  687 |     |   //     <= (2 ** 59) * (16 + qTarget + b1)
  688 |     |   //     <  (2 ** 59) * (32 - qSpacing + b1)
  689 |     |   //     <= (2 ** 59) * 32 == 2 ** 64'
  690 |     |   //
  691 |     |   // where '0 < (2 ** 59) * (16 + qLower)' is because 'qLower' is a member of
  692 |     |   // the curve sequence and 'b1 <= qSpacing' is concluded from the custom error
  693 |     |   // 'HorizontalCoordinatesMayNotExceedLogSpacing' when validating kernel in
  694 |     |   // 'KernelCompact.sol'.
  695 |     |   //
  696 |     |   // Additionally,
  697 |     |   //
  698 |     |   //  '2 ** 64 >  (2 ** 59) * (16 + qUpper)
  699 |     |   //           >= (2 ** 59) * (16 + qTarget)
  700 |     |   //           >= (2 ** 59) * (16 + qTarget - b1)
  701 |     |   //           >  (2 ** 59) * (qSpacing - b1) >= 0'
  702 |     |   //
  703 |     |   // where '(2 ** 59) * (16 + qUpper) < 2 ** 64' is because 'qUpper' is a
  704 |     |   // member of the curve sequence and 'b1 <= qSpacing' is concluded from the
  705 |     |   // custom error 'HorizontalCoordinatesMayNotExceedLogSpacing' when validating
  706 |     |   // kernel in 'KernelCompact.sol'.
  707 |     |   //
  708 |     |   // Lastly, '_forward1_' is a fixed value greater than '34'.
  709 |     |   //
  710 |     |   // Therefore, the input requirements of 'impose' are satisfied.
  711 |     |   getKernel().impose(
  712 |     |     // The resulting values are stored using the pointer '_forward1_'.
  713 |     |     _forward1_,
  714 |     |     // 'target' is used as the base price for the shift.
  715 |     |     _target_,
  716 |     |     // The incremented index is safely stored in the allocated 2 bytes of
  717 |     |     // memory because overflow of 'indexKernelForward' is avoided externally.
  718 |     |     _indexKernelForward_.incrementIndex(),
  719 |     |     // In other words, if 'getZeroForOne() == false', we have
  720 |     |     // 'qTarget <= qOvershoot' and we keep track of the breakpoints for
  721 |     |     // 'k(h - qTarget)'. If 'getZeroForOne() == true', we have
  722 |     |     // 'qOvershoot <= qTarget' and we keep track of the breakpoints for
  723 |     |     // 'k(qTarget - h)'. Hence, the direction of the shift should be aligned
  724 |     |     // with 'getZeroForOne()'.
  725 |     |     getZeroForOne()
  726 |     |   );
  727 |     | }
  728 |     | 
  729 |     | /// @notice This function transitions from one 'phase' of the curve sequence to
  730 |     | /// the next one.
  731 |     | ///
  732 |     | /// To this end, 'direction' is flipped. 'indexCurve' is decremented. 'begin'
  733 |     | /// is replaced with 'origin'. 'origin' is replaced with 'end'. A new member of
  734 |     | /// the curve sequence is loaded using the decremented index and is stored in
  735 |     | /// 'end'. Lastly, 'total0' and 'total1' are recalculated based on the new
  736 |     | /// 'origin'.
  737 |     | ///
  738 |     | /// ---------------------------------------------------------------------------
  739 |     | ///
  740 |     | /// Underflow of 'indexCurve' should be avoided externally.
  741 |     | ///
  742 |     | /// Underflow and index out of range for 'indexKernelTotal - oneIndex' should
  743 |     | /// be avoided externally.
  744 |     | ///
  745 |     | /// Index out of range for 'indexKernelTotal' should be avoided externally.
  746 |     | function movePhase() pure returns (bool direction) {
  747 |     |   // As explained in 'Memory.sol' and earlier in this script, a swap within the
  748 |     |   // active liquidity interval can be seen as a movement in price from
  749 |     |   // 'qCurrent' to 'qTarget'. In order to determine the outgoing and incoming
  750 |     |   // amounts for a swap, we need to integrate a number of piecewise functions
  751 |     |   // from 'qCurrent' to 'qTarget'.
  752 |     |   //
  753 |     |   // One of these functions is 'w(.)' whose pieces need to be examined one by
  754 |     |   // one. 'w(.)' is constructed from the curve sequence as explained in
  755 |     |   // 'Memory.sol'. Every piece of the function 'w(.)' is regarded as a 'phase'.
  756 |     |   // As explained above, a 'phase' corresponds to three consecutive members of
  757 |     |   // the curve sequence:
  758 |     |   //
  759 |     |   //  - 'qEnd := q[indexCurve]',
  760 |     |   //
  761 |     |   //  - 'qOrigin := q[indexCurve + 1]',
  762 |     |   //
  763 |     |   //  - 'q[indexCurve + 2]'.
  764 |     |   //
  765 |     |   // where the out of range member 'q[curveLength]' is assigned the same value
  766 |     |   // as the last member 'q[curveLength - 1]'.
  767 |     |   //
  768 |     |   // If 'q[indexCurve + 2] < qEnd', we have
  769 |     |   //
  770 |     |   //  'w(q) == q - qOrigin' for every 'q[indexCurve + 2] < q < qEnd'.
  771 |     |   //
  772 |     |   // If 'qEnd < q[indexCurve + 2]', we have
  773 |     |   //
  774 |     |   //  'w(q) == qOrigin - q' for every 'qEnd < q < q[indexCurve + 2]'.
  775 |     |   //
  776 |     |   // Initially, (i.e., for the very first 'phase') we have:
  777 |     |   //
  778 |     |   //  - 'indexCurve == curveLength - 2',
  779 |     |   //
  780 |     |   //  - 'qEnd := q[indexCurve] == q[curveLength - 2]',
  781 |     |   //
  782 |     |   //  - 'qOrigin := q[indexCurve + 1] == q[curveLength - 1]',
  783 |     |   //
  784 |     |   //  - 'q[indexCurve + 2] := q[curveLength] == q[curveLength - 1]'.
  785 |     |   //
  786 |     |   // Then, with each call to the present function, 'indexCurve' is decremented
  787 |     |   // and the following three members of the curve sequence are used to
  788 |     |   // characterize the current phase:
  789 |     |   //
  790 |     |   //  - 'qEnd := q[indexCurve]',
  791 |     |   //
  792 |     |   //  - 'qOrigin := q[indexCurve + 1]',
  793 |     |   //
  794 |     |   //  - 'q[indexCurve + 2]'.
  795 |     |   //
  796 |     |   // Hence, in order to move from a 'phase' to the next one, we need to copy
  797 |     |   // the content of 'origin' to 'begin', then copy the content of 'end' to
  798 |     |   // 'origin', and lastly, we need to load a new member from the curve sequence
  799 |     |   // corresponding to the decremented index.
  800 |     |   //
  801 |     |   // Index out of range for 'indexCurve' is avoided externally.
  802 |     |   //
  803 |     |   // The requirements of 'storePrice' are satisfied because '_end_' is a
  804 |     |   // constant greater than '32' and
  805 |     |   // 'getCurve().member(_indexCurve_.decrementIndex())' is a member of the
  806 |     |   // curve which is positive and less than '2 ** 64'.
  807 |     |   _begin_.copyPrice(_origin_);
  808 |     |   _origin_.copyPrice(_end_);
  809 |     |   _end_.storePrice(getCurve().member(_indexCurve_.decrementIndex()));
  810 |     | 
  811 |     |   // Next, we need to flip the direction flag. Let the triplet
  812 |     |   //
  813 |     |   //  'q[indexCurve + 1]', 'q[indexCurve + 2]', 'q[indexCurve + 3]'
  814 |     |   //
  815 |     |   // represent the 'phase' prior to the above update and let
  816 |     |   //
  817 |     |   //  'q[indexCurve]', 'q[indexCurve + 1]', 'q[indexCurve + 2]'
  818 |     |   //
  819 |     |   // represent the new 'phase'.
  820 |     |   //
  821 |     |   // Remember that the curve sequence is constructed in such a way that every
  822 |     |   // member is in between the preceding two members. As explained in
  823 |     |   // 'Curve.sol', this ordering rule is always preserved with every amendment
  824 |     |   // of the curve sequence. Hence, we have:
  825 |     |   //
  826 |     |   //  'min(q[indexCurve + 1], q[indexCurve + 2]) <
  827 |     |   //
  828 |     |   //   q[indexCurve + 3] <
  829 |     |   //
  830 |     |   //   max(q[indexCurve + 1], q[indexCurve + 2])'
  831 |     |   //
  832 |     |   // and
  833 |     |   //
  834 |     |   //  'min(q[indexCurve], q[indexCurve + 1]) < 
  835 |     |   //
  836 |     |   //   q[indexCurve + 2] < 
  837 |     |   //
  838 |     |   //   max(q[indexCurve], q[indexCurve + 1])'.
  839 |     |   //
  840 |     |   // Now, consider the following two possibilities:
  841 |     |   //
  842 |     |   //  - If
  843 |     |   //
  844 |     |   //      'q[indexCurve] < q[indexCurve + 1]',
  845 |     |   //
  846 |     |   //    then the second inequality boils down to
  847 |     |   //
  848 |     |   //      'q[indexCurve] < q[indexCurve + 2] < q[indexCurve + 1]',
  849 |     |   //
  850 |     |   //    and, consequently, the first inequality boils do
  851 |     |   //
  852 |     |   //      'q[indexCurve + 2] < q[indexCurve + 3] < q[indexCurve + 1]'.
  853 |     |   //
  854 |     |   //    Hence, we have
  855 |     |   //
  856 |     |   //      'q[indexCurve] < q[indexCurve + 2]',
  857 |     |   //      'q[indexCurve + 3] < q[indexCurve + 1]',
  858 |     |   //
  859 |     |   //    and therefore, the old phase and the new phase have opposite
  860 |     |   //    directions.
  861 |     |   //
  862 |     |   //  - If
  863 |     |   //
  864 |     |   //      'q[indexCurve + 1] < q[indexCurve]',
  865 |     |   //
  866 |     |   //    then the second inequality boils down to
  867 |     |   //
  868 |     |   //      'q[indexCurve + 1] < q[indexCurve + 2] < q[indexCurve]',
  869 |     |   //
  870 |     |   //    and, consequently, the first inequality boils do
  871 |     |   //
  872 |     |   //      'q[indexCurve + 1] < q[indexCurve + 3] < q[indexCurve + 2]'.
  873 |     |   //
  874 |     |   //    Hence, we have
  875 |     |   //
  876 |     |   //      'q[indexCurve + 2] < q[indexCurve]',
  877 |     |   //      'q[indexCurve + 1] < q[indexCurve + 3]',
  878 |     |   //
  879 |     |   //    and therefore, in this case, the old phase and the new phase have
  880 |     |   //    opposite directions as well.
  881 |     |   //
  882 |     |   // So, in both cases as we transition to a new 'phase', the direction should
  883 |     |   // be flipped. The resulting boolean is stored in memory and it is also
  884 |     |   // cached to be given as output and to be used later in the present function.
  885 |     |   setDirection(direction = !getDirection());
  886 |     | 
  887 |     |   // Fetch the memory pointer for the kernel from the memory.
  888 |     |   Kernel kernel = getKernel();
  889 |     |   Index indexKernelTotal = _indexKernelTotal_.getIndex();
  890 |     | 
  891 |     |   // Let 'b0' and 'b1' represent the horizontal coordinates of the kernel
  892 |     |   // breakpoint corresponding to 'indexKernelTotal - oneIndex' and
  893 |     |   // 'indexKernelTotal', respectively.
  894 |     |   //
  895 |     |   // Remember that if 'direction == false', we have:
  896 |     |   // 
  897 |     |   //  '_total0_.log() := (2 ** 59) * (16 + qOrigin + b0)',
  898 |     |   //  '_total1_.log() := (2 ** 59) * (16 + qOrigin + b1)',
  899 |     |   // 
  900 |     |   // and if 'direction == true', we have:
  901 |     |   //
  902 |     |   //  '_total0_.log() := (2 ** 59) * (16 + qOrigin - b0)',
  903 |     |   //  '_total1_.log() := (2 ** 59) * (16 + qOrigin - b1)'.
  904 |     |   //
  905 |     |   // Since the 'direction' and 'qOrigin' have been revised, we need to
  906 |     |   // recalculate the content of both 'total0' and 'total1' using the function
  907 |     |   // 'impose' from the 'KernelLibrary'.
  908 |     |   //
  909 |     |   // Index out of range for 'indexKernelTotal' is avoided externally.
  910 |     |   //
  911 |     |   // The subtraction 'indexKernelTotal - oneIndex' is safe because underflow is
  912 |     |   // avoided externally.
  913 |     |   //
  914 |     |   // As explained in 'moveBreakpointTotal' we should also prove that:
  915 |     |   //
  916 |     |   //  '0 < (2 ** 59) * (16 + qOrigin - b0) < 2 ** 64'
  917 |     |   //  '0 < (2 ** 59) * (16 + qOrigin + b0) < 2 ** 64'
  918 |     |   //  '0 < (2 ** 59) * (16 + qOrigin - b1) < 2 ** 64'
  919 |     |   //  '0 < (2 ** 59) * (16 + qOrigin + b1) < 2 ** 64'
  920 |     |   //
  921 |     |   // as required by 'impose' in 'Kernel.sol'.
  922 |     |   //
  923 |     |   // Let 'pLower' and 'pUpper' denote the minimum and maximum price in the
  924 |     |   // active liquidity interval, respectively and define
  925 |     |   //
  926 |     |   //  'qLower := log(pLower / pOffset)',
  927 |     |   //  'qUpper := log(pUpper / pOffset)'.
  928 |     |   //
  929 |     |   // Let 'qSpacing := qUpper - qLower' denote the length of every liquidity
  930 |     |   // interval. Upon initializing a pool, the given curve sequence is validated
  931 |     |   // by the method 'validate' in 'Curve.sol'. When validating the curve
  932 |     |   // sequence, the custom error 'BlankIntervalsShouldBeAvoided' ensures that
  933 |     |   // '16 + qLower' is greater than 'qSpacing' and '16 + qUpper' is smaller than
  934 |     |   // '32 - qSpacing'. As a result, every member 'q' of the initial curve
  935 |     |   // sequence satisfies:
  936 |     |   // 
  937 |     |   //  'qSpacing < 16 + q < 32 - qSpacing'.
  938 |     |   // 
  939 |     |   // In addition, the method 'setSwapParams' in 'Swap.sol' ensures that
  940 |     |   // 'qTarget' for every swap is also bounded by both
  941 |     |   // 'qSpacing + 1 / (2 ** 59)' and '32 - 1 / (2 ** 59) - qSpacing'.
  942 |     |   // This ensures that the above inequality is always satisfied for every
  943 |     |   // member of the curve and not only the initial curve.
  944 |     |   //
  945 |     |   // Now, since 'qOrigin' is a member of the curve sequence, we also have:
  946 |     |   //
  947 |     |   //  'qSpacing < 16 + qOrigin < 32 - qSpacing'.
  948 |     |   //
  949 |     |   // Hence,
  950 |     |   //
  951 |     |   //  '0 < (2 ** 59) * (16 + qOrigin) <= (2 ** 59) * (16 + qOrigin + b0)
  952 |     |   //     < (2 ** 59) * (32 - qSpacing + b0) <= (2 ** 59) * 32 == 2 ** 64',
  953 |     |   //
  954 |     |   //  '0 < (2 ** 59) * (16 + qOrigin) <= (2 ** 59) * (16 + qOrigin + b1)
  955 |     |   //     < (2 ** 59) * (32 - qSpacing + b1) <= (2 ** 59) * 32 == 2 ** 64',
  956 |     |   //
  957 |     |   // where '0 < (2 ** 59) * (16 + qOrigin)' is because 'qOrigin' is a member of
  958 |     |   // the curve and 'b0 <= qSpacing' and 'b1 <= qSpacing' are concluded from the
  959 |     |   // custom error 'HorizontalCoordinatesMayNotExceedLogSpacing' when validating
  960 |     |   // kernel in 'KernelCompact.sol'.
  961 |     |   //
  962 |     |   // Additionally,
  963 |     |   //
  964 |     |   //  '2 ** 64 >  (2 ** 59) * (16 + qOrigin)
  965 |     |   //           >= (2 ** 59) * (16 + qOrigin - b0) 
  966 |     |   //           >  (2 ** 59) * (qSpacing - b0)
  967 |     |   //           >= 0'
  968 |     |   //
  969 |     |   //  '2 ** 64 >  (2 ** 59) * (16 + qOrigin)
  970 |     |   //           >= (2 ** 59) * (16 + qOrigin - b1)
  971 |     |   //           >  (2 ** 59) * (qSpacing - b1)
  972 |     |   //           >= 0'
  973 |     |   //
  974 |     |   // where '(2 ** 59) * (16 + qOrigin) < 2 ** 64' is because 'qOrigin' is a
  975 |     |   // member of the curve sequence and 'b0 <= qSpacing' and 'b1 <= qSpacing'
  976 |     |   // are concluded from the custom error
  977 |     |   // 'HorizontalCoordinatesMayNotExceedLogSpacing' when validating kernel in
  978 |     |   // 'KernelCompact.sol'.
  979 |     |   //
  980 |     |   // Lastly, both '_total0_' and '_total1_' are fixed values greater than '34'.
  981 |     |   //
  982 |     |   // Therefore, in both cases, the input requirements of 'impose' are
  983 |     |   // satisfied.
  984 |     |   kernel.impose(
  985 |     |     // The resulting values are stored using the pointer '_total0_'.
  986 |     |     _total0_,
  987 |     |     // The new value for 'qOrigin' is used as the base price for the shift.
  988 |     |     _origin_,
  989 |     |     // 'total0' corresponds to the kernel breakpoint
  990 |     |     // 'indexKernelTotal - oneIndex'.
  991 |     |     indexKernelTotal - oneIndex,
  992 |     |     // The flipped direction is used for this shift.
  993 |     |     direction
  994 |     |   );
  995 |     |   kernel.impose(
  996 |     |     // The resulting values are stored using the pointer '_total1_'.
  997 |     |     _total1_,
  998 |     |     // The new value for 'qOrigin' is used as the base price for the shift.
  999 |     |     _origin_,
 1000 |     |     // 'total1' corresponds to the kernel breakpoint 'indexKernelTotal'.
 1001 |     |     indexKernelTotal,
 1002 |     |     // The flipped direction is used for this shift.
 1003 |     |     direction
 1004 |     |   );
 1005 |     | }
 1006 |     | 
 1007 |     | /// @notice If 'left == false' this function increments 'qOvershoot' by
 1008 |     | /// '1 / (2 ** 59)'. If 'left == true' this function decrements 'qOvershoot'
 1009 |     | /// by '1 / (2 ** 59)'.
 1010 |     | ///
 1011 |     | /// Let 'q' denote an arbitrary member of the curve sequence with index 'i'.
 1012 |     | /// Then, 'curve.member(i)' is a positive value read from 64 bits of memory.
 1013 |     | /// Hence,
 1014 |     | ///
 1015 |     | ///  '1 <= curve.member(indexLower) <= (2 ** 64) - 1'
 1016 |     | ///
 1017 |     | ///  '1 <= (2 ** 59) * (16 + q) <= (2 ** 64) - 1'
 1018 |     | ///
 1019 |     | ///  '1 / (2 ** 59) <= 16 + q <= 32 - 1 / (2 ** 59)'
 1020 |     | ///
 1021 |     | ///  '- 16 + 1 / (2 ** 59) <= q <= + 16 - 1 / (2 ** 59)'
 1022 |     | ///
 1023 |     | /// The above inequality will be used to prove the safety of operations in this
 1024 |     | /// function.
 1025 |     | ///
 1026 |     | /// ---------------------------------------------------------------------------
 1027 |     | ///
 1028 |     | /// If 'left == false' then 'qOvershoot + 1 / (2 ** 59) <= qUpper' should be
 1029 |     | /// enforced externally.
 1030 |     | ///
 1031 |     | /// If 'left == true' then 'qLower <= qOvershoot - 1 / (2 ** 59)' should be
 1032 |     | /// enforced externally.
 1033 |     | function moveOvershootByEpsilon(
 1034 |     |   bool left
 1035 |     | ) pure {
 1036 |     |   // '_overshoot_' is a constant which is greater than '32'.
 1037 |     |   //
 1038 |     |   // In both cases, we will argue that
 1039 |     |   //
 1040 |     |   //  - the resulting value for '(2 ** 59) * (16 + qOvershoot)' is nonnegative
 1041 |     |   //    and less than '2 ** 64', and
 1042 |     |   //
 1043 |     |   //  - both square root values are nonnegative and less than 'one216'.
 1044 |     |   //
 1045 |     |   // Hence, the requirements of 'storePrice' are satisfied.
 1046 |     |   left ? _overshoot_.storePrice(
 1047 |     |     // The subtraction is safe, because in this case, we have
 1048 |     |     //
 1049 |     |     //  '0 <  (2 ** 59) * (16 + qLower)
 1050 |     |     //     <= (2 ** 59) * (16 + qOvershoot - 1 / (2 ** 59))
 1051 |     |     //
 1052 |     |     // where the first inequality is because 'qLower' is a member of the curve
 1053 |     |     // sequence and the second inequality is enforced externally.
 1054 |     |     //
 1055 |     |     // Additionally, because
 1056 |     |     //
 1057 |     |     //  '_overshoot_.log() == (2 ** 59) * (16 + qOvershoot)'
 1058 |     |     //
 1059 |     |     // is read from 64 bits of memory,
 1060 |     |     //
 1061 |     |     //  '_overshoot_.log() - epsilonX59 == 
 1062 |     |     //   (2 ** 59) * (16 + qOvershoot - 1 / (2 ** 59))'
 1063 |     |     //
 1064 |     |     // can be safely stored in 64 bits of memory as well.
 1065 |     |     _overshoot_.log() - epsilonX59,
 1066 |     |     // Here, we calculate:
 1067 |     |     //
 1068 |     |     //  '(2 ** 216) * exp(- 8 - qOvershoot / 2 + 1 / (2 ** 60)) ==
 1069 |     |     //   (2 ** 216) * exp(- 8 - qOvershoot / 2) * exp(1 / (2 ** 60)) ==
 1070 |     |     //   _overshoot_.sqrt(false) * exp(1 / (2 ** 60))'
 1071 |     |     //
 1072 |     |     // '_overshoot_.sqrt(false)' is a nonnegative value which is read from 216
 1073 |     |     // bits of memory. Additionally, since
 1074 |     |     // 'qLower <= qOvershoot - 1 / (2 ** 59)' is enforced externally, we have:
 1075 |     |     //
 1076 |     |     //  '(2 ** 216) * exp(- 8 - qOvershoot / 2 + 1 / (2 ** 60)) ==
 1077 |     |     //   (2 ** 216) * exp(- (16 + qOvershoot - 1 / (2 ** 59)) / 2) <=
 1078 |     |     //   (2 ** 216) * exp(- (16 + qLower) / 2) <=
 1079 |     |     //   (2 ** 216) * exp(- 1 / (2 ** 60))'
 1080 |     |     //
 1081 |     |     // which means, that
 1082 |     |     //
 1083 |     |     //  '(2 ** 216) * exp(- 8 - qOvershoot / 2 + 1 / (2 ** 60))'
 1084 |     |     //
 1085 |     |     // does not exceed 216 bits and overflow of
 1086 |     |     // '_overshoot_.sqrt(false).multiplyByExpEpsilon()' is impossible.
 1087 |     |     //
 1088 |     |     // Hence, the requirements of 'multiplyByExpEpsilon' are satisfied.
 1089 |     |     _overshoot_.sqrt(false).multiplyByExpEpsilon(),
 1090 |     |     // Here, we calculate:
 1091 |     |     //
 1092 |     |     //  '(2 ** 216) * exp(- 8 + qOvershoot / 2 - 1 / (2 ** 60)) ==
 1093 |     |     //   (2 ** 216) * exp(- 8 + qOvershoot / 2) / exp(1 / (2 ** 60)) ==
 1094 |     |     //   _overshoot_.sqrt(true) / exp(1 / (2 ** 60))'
 1095 |     |     //
 1096 |     |     // Since '_overshoot_.sqrt(true)' is a nonnegative value which is read
 1097 |     |     // from 216 bits of memory, the requirement of 'divideByExpEpsilon' is
 1098 |     |     // satisfied.
 1099 |     |     _overshoot_.sqrt(true).divideByExpEpsilon()
 1100 |     |   ) : _overshoot_.storePrice(
 1101 |     |     // The addition is safe, because in this case, we have
 1102 |     |     //
 1103 |     |     //  '(2 ** 59) * (16 + qOvershoot + 1 / (2 ** 59)) <=
 1104 |     |     //   (2 ** 59) * (16 + qUpper) < 2 ** 64
 1105 |     |     //
 1106 |     |     // where the first inequality is enforced externally and the second
 1107 |     |     // inequality is because 'qUpper' is a member of the curve sequence.
 1108 |     |     //
 1109 |     |     // Additionally, due to the above argument,
 1110 |     |     // '(2 ** 59) * (16 + qOvershoot + 1 / (2 ** 59))' fits within 64 bits and
 1111 |     |     // can be safely stored in 64 bits of memory.
 1112 |     |     _overshoot_.log() + epsilonX59,
 1113 |     |     // Here, we calculate:
 1114 |     |     //
 1115 |     |     //  '(2 ** 216) * exp(- 8 - qOvershoot / 2 - 1 / (2 ** 60)) ==
 1116 |     |     //   (2 ** 216) * exp(- 8 - qOvershoot / 2) / exp(1 / (2 ** 60)) ==
 1117 |     |     //   _overshoot_.sqrt(false) / exp(1 / (2 ** 60))'
 1118 |     |     //
 1119 |     |     // Since '_overshoot_.sqrt(false)' is a nonnegative value which is read
 1120 |     |     // from 216 bits of memory, the requirement of 'divideByExpEpsilon' is
 1121 |     |     // satisfied.
 1122 |     |     _overshoot_.sqrt(false).divideByExpEpsilon(),
 1123 |     |     // Here, we calculate:
 1124 |     |     //
 1125 |     |     //  '(2 ** 216) * exp(- 8 + qOvershoot / 2 + 1 / (2 ** 60)) ==
 1126 |     |     //   (2 ** 216) * exp(- 8 + qOvershoot / 2) * exp(1 / (2 ** 60)) ==
 1127 |     |     //   _overshoot_.sqrt(true) * exp(1 / (2 ** 60))'
 1128 |     |     //
 1129 |     |     // '_overshoot_.sqrt(true)' is a nonnegative value which is read from 216
 1130 |     |     // bits of memory. Additionally, since
 1131 |     |     // 'qOvershoot + 1 / (2 ** 59) <= qUpper' is enforced externally, we have:
 1132 |     |     //
 1133 |     |     //  '(2 ** 216) * exp(- 8 + qOvershoot / 2 + 1 / (2 ** 60)) <=
 1134 |     |     //   (2 ** 216) * exp(- (16 - qOvershoot - 1 / (2 ** 59)) / 2) <=
 1135 |     |     //   (2 ** 216) * exp(- (16 - qUpper) / 2) <=
 1136 |     |     //   (2 ** 216) * exp(- 1 / (2 ** 60)) < oneX216'
 1137 |     |     //
 1138 |     |     // which means, that
 1139 |     |     //
 1140 |     |     //  '(2 ** 216) * exp(- 8 + qOvershoot / 2 + 1 / (2 ** 60))'
 1141 |     |     //
 1142 |     |     // does not exceed 216 bits and overflow of
 1143 |     |     // '_overshoot_.sqrt(true).multiplyByExpEpsilon()' is impossible.
 1144 |     |     //
 1145 |     |     // Hence, the requirements of 'multiplyByExpEpsilon' are satisfied.
 1146 |     |     _overshoot_.sqrt(true).multiplyByExpEpsilon()
 1147 |     |   );
 1148 |     | }
 1149 |     | 
 1150 |     | /// @notice For the case 'exactInput == false', i.e., when the specified amount
 1151 |     | /// is outgoing, this function performs a Halley search to determine 'qTarget'
 1152 |     | /// based on 'integralLimit'. As explained in 'Memory.sol', 'integralLimit' is
 1153 |     | /// is derived from 'amountSpecified'.
 1154 |     | ///
 1155 |     | /// Let
 1156 |     | ///
 1157 |     | ///  'cTotal0 := c[indexKernelTotal - 1]',
 1158 |     | ///  'cTotal1 := c[indexKernelTotal]',
 1159 |     | ///
 1160 |     | /// represent the vertical coordinates of the kernel breakpoints corresponding
 1161 |     | /// to 'indexKernelTotal - 1' and 'indexKernelTotal', respectively. As
 1162 |     | /// explained in 'Memory.sol', the memory spaces that are pointed to by
 1163 |     | /// '_total0_' and '_total1_' host the following vertical coordinates:
 1164 |     | ///
 1165 |     | ///  '_total0_.height() := (2 ** 15) * cTotal0',
 1166 |     | ///  '_total1_.height() := (2 ** 15) * cTotal1'.
 1167 |     | ///
 1168 |     | /// Additionally, if 'getDirection() == false', define
 1169 |     | ///
 1170 |     | ///  'qTotal0 := qOrigin + b[indexKernelTotal - 1]',
 1171 |     | ///  'qTotal1 := qOrigin + b[indexKernelTotal]',
 1172 |     | ///
 1173 |     | /// and if 'getDirection() == true', define
 1174 |     | ///
 1175 |     | ///  'qTotal0 := qOrigin - b[indexKernelTotal - 1]',
 1176 |     | ///  'qTotal1 := qOrigin - b[indexKernelTotal]',
 1177 |     | ///
 1178 |     | /// as the shifted horizontal coordinates of the kernel breakpoint
 1179 |     | /// corresponding to 'indexKernelTotal - 1' and 'indexKernelTotal',
 1180 |     | /// respectively. Hence, the memory spaces that are pointed to by '_total0_'
 1181 |     | /// and '_total1_' host the following horizontal coordinates as well:
 1182 |     | /// 
 1183 |     | ///  '_total0_.log() := (2 ** 59) * (16 + qTotal0)',
 1184 |     | ///  '_total1_.log() := (2 ** 59) * (16 + qTotal1)',
 1185 |     | /// 
 1186 |     | /// Let 'qBegin' and 'qCurrent' represent the offsetted logarithmic prices that
 1187 |     | /// are hosted by the memory pointers '_begin_' and '_current_', i.e.,
 1188 |     | ///
 1189 |     | ///  '_begin_.log() == (2 ** 59) * (16 + qBegin)',
 1190 |     | ///  '_current_.log() == (2 ** 59) * (16 + qCurrent)'.
 1191 |     | ///
 1192 |     | /// At this stage, 'qTarget' is not yet determined. Hence, if 
 1193 |     | /// 'getZeroForOne() == false', we have:
 1194 |     | ///
 1195 |     | ///                           - 8     / qBegin
 1196 |     | ///    currentToTarget      e        |    - h / 2
 1197 |     | ///  '----------------- := ------- * |  e         k(w(h)) dh'
 1198 |     | ///       2 ** 216            2      |
 1199 |     | ///                                 / qCurrent
 1200 |     | ///
 1201 |     | /// and we want to determine 'qTarget' based on the following equation:
 1202 |     | ///
 1203 |     | ///                              - 8     / qTarget
 1204 |     | ///    getIntegralLimit()      e        |    - h / 2
 1205 |     | ///  '-------------------- == ------- * |  e         k(w(h)) dh',
 1206 |     | ///         2 ** 216             2      |
 1207 |     | ///                                    / qCurrent
 1208 |     | ///
 1209 |     | /// which is equivalent to
 1210 |     | ///
 1211 |     | ///    getIntegralLimit() - currentToTarget
 1212 |     | ///  '-------------------------------------- == 
 1213 |     | ///                  2 ** 216
 1214 |     | ///
 1215 |     | ///      - 8     / qTarget
 1216 |     | ///    e        |    - h / 2
 1217 |     | ///   ------- * |  e         k(w(h)) dh == 
 1218 |     | ///      2      |
 1219 |     | ///            / qBegin
 1220 |     | ///
 1221 |     | ///      - 8     / qTarget
 1222 |     | ///    e        |    - h / 2             cTotal1 - cTotal0
 1223 |     | ///   ------- * |  e         (cTotal0 + ------------------- (h - qTotal0)) dh'.
 1224 |     | ///      2      |                        qTotal1 - qTotal0
 1225 |     | ///            / qBegin
 1226 |     | ///
 1227 |     | /// Hence, we define
 1228 |     | ///
 1229 |     | ///  'outgoingLimit := getIntegralLimit() - currentToTarget'.
 1230 |     | ///
 1231 |     | /// and solve
 1232 |     | ///
 1233 |     | ///      - 8     / qBegin + x
 1234 |     | ///    e        |   - h / 2             cTotal1 - cTotal0
 1235 |     | ///  '------- * |  e        (cTotal0 + ------------------- (h - qTotal0)) dh
 1236 |     | ///      2      |                       qTotal1 - qTotal0
 1237 |     | ///            / qBegin
 1238 |     | ///
 1239 |     | ///       outgoingLimit
 1240 |     | ///   == ---------------'
 1241 |     | ///         2 ** 216
 1242 |     | ///
 1243 |     | /// with respect to 'x' and then we store
 1244 |     | ///
 1245 |     | ///  'qTarget := qBegin + x'.
 1246 |     | ///
 1247 |     | /// in the memory spaces that are pointed to by '_target_' and '_overshoot_'.
 1248 |     | ///
 1249 |     | /// Similarly, if 'getZeroForOne() == true', we solve the equation:
 1250 |     | ///
 1251 |     | ///      - 8     / qBegin
 1252 |     | ///    e        |   + h / 2             cTotal1 - cTotal0
 1253 |     | ///  '------- * |  e        (cTotal0 + ------------------- (qTotal0 - h)) dh
 1254 |     | ///      2      |                       qTotal0 - qTotal1
 1255 |     | ///            / qBegin - x
 1256 |     | ///
 1257 |     | ///       outgoingLimit
 1258 |     | ///   == ---------------'
 1259 |     | ///         2 ** 216
 1260 |     | ///
 1261 |     | /// with respect to 'x' and then we store:
 1262 |     | ///
 1263 |     | ///  'qTarget := qBegin - x'.
 1264 |     | ///
 1265 |     | /// in the memory spaces that are pointed to by '_target_' and '_overshoot_'.
 1266 |     | ///
 1267 |     | /// For simplicity, consider the first case of 'getZeroForOne() == false',
 1268 |     | /// since the second case 'getZeroForOne() == true' can be argued similarly.
 1269 |     | /// Define:
 1270 |     | ///
 1271 |     | ///  'q2 := 2 * (cTotal1 - cTotal0)'
 1272 |     | ///
 1273 |     | ///  'q1 := cTotal1 * (2 - qTotal0 + qBegin) - 
 1274 |     | ///         cTotal0 * (2 - qTotal1 + qBegin)'
 1275 |     | ///
 1276 |     | ///  'q0 := 2 * 
 1277 |     | ///
 1278 |     | ///                                      outgoingLimit
 1279 |     | ///         (q1 - (qTotal1 - qTotal0) * --------------- * exp(+ qBegin / 2))'
 1280 |     | ///                                         2 ** 216
 1281 |     | ///
 1282 |     | /// Then the equation can be cast as 'f(x) == 0' where
 1283 |     | ///
 1284 |     | ///  '      f(x) == + ((cTotal1 - cTotal0) * x + q1) * exp(- x / 2) - q0 / 2'
 1285 |     | ///
 1286 |     | ///      d f(x)
 1287 |     | ///  '  -------- == - ((cTotal1 - cTotal0) * x + q1 - q2) * exp(- x / 2) / 2'
 1288 |     | ///       d x
 1289 |     | ///
 1290 |     | ///                                                                 - x / 2
 1291 |     | ///    d^2 f(x)                                                   e
 1292 |     | ///  '---------- == + ((cTotal1 - cTotal0) * x + q1 - q2 - q2) * -----------'
 1293 |     | ///     d x^2                                                         4
 1294 |     | ///
 1295 |     | /// Define:
 1296 |     | ///
 1297 |     | ///  'g(x) == (cTotal1 - cTotal0) * x + q1 - q2'
 1298 |     | ///
 1299 |     | ///  'h(x) == (cTotal1 - cTotal0) * x + q1 - (q0 / 2) * exp(+ x / 2)'
 1300 |     | ///
 1301 |     | /// To solve our equation, we perform the following Halley's search:
 1302 |     | ///
 1303 |     | ///  'x = x + 
 1304 |     | ///                             4 * (h(x) / g(x))
 1305 |     | ///   ----------------------------------------------------------------------'
 1306 |     | ///    2 - (h(x) / g(x)) + 2 * (h(x) / g(x)) * ((cTotal1 - cTotal0) / g(x))
 1307 |     | ///
 1308 |     | /// --------------------------------------------------------------------------- 
 1309 |     | ///
 1310 |     | /// Underflow of 'getIntegralLimit() - _currentToTarget_.integral()' should be
 1311 |     | /// avoided externally.
 1312 |     | ///
 1313 |     | /// We should have 'getDirection() == getZeroForOne()'.
 1314 |     | ///
 1315 |     | /// @return exactAmount Whether the search is performed.
 1316 |     | ///
 1317 |     | /// Let 'qTarget' represent the existing value stored in the memory space which
 1318 |     | /// is pointed to by '_target_' (prior to calling this function). As explained
 1319 |     | /// in 'Memory.sol', we have:
 1320 |     | ///
 1321 |     | ///   'qTarget := (
 1322 |     | ///                 getDirection() == getZeroForOne()
 1323 |     | ///               ) ? (
 1324 |     | ///                 getDirection() ? 
 1325 |     | ///                 max(max(qEnd, qTotal1), qLimitWithinInterval) : 
 1326 |     | ///                 min(min(qEnd, qTotal1), qLimitWithinInterval)
 1327 |     | ///               ) : (
 1328 |     | ///                 getDirection() ? 
 1329 |     | ///                 max(qEnd, qTotal1) : 
 1330 |     | ///                 min(qEnd, qTotal1)
 1331 |     | ///               )',
 1332 |     | ///
 1333 |     | /// Additionally, because of the input requirement
 1334 |     | ///
 1335 |     | ///   'getDirection() == getZeroForOne()',
 1336 |     | ///
 1337 |     | /// the above equation is equivalent to:
 1338 |     | ///
 1339 |     | ///   'qTarget := getDirection() ? 
 1340 |     | ///               max(max(qEnd, qTotal1), qLimitWithinInterval) : 
 1341 |     | ///               min(min(qEnd, qTotal1), qLimitWithinInterval)'.
 1342 |     | ///
 1343 |     | /// If 'getZeroForOne() == false', then the current 'qTarget' is an upper bound
 1344 |     | /// for the unknown value 'qBegin + x' and the numerical search for 'x' is
 1345 |     | /// performed within the range '0' to 'qTarget - qBegin'. In this case, we
 1346 |     | /// first need to check the following inequality:
 1347 |     | ///
 1348 |     | ///      - 8     / qTarget
 1349 |     | ///    e        |   - h / 2             cTotal1 - cTotal0
 1350 |     | ///  '------- * |  e        (cTotal0 + ------------------- (h - qTotal0)) dh
 1351 |     | ///      2      |                       qTotal1 - qTotal0
 1352 |     | ///            / qBegin
 1353 |     | ///
 1354 |     | ///      outgoingLimit
 1355 |     | ///   < ---------------'.
 1356 |     | ///        2 ** 216
 1357 |     | ///
 1358 |     | /// If satisfied, then the outgoing integral across the entire range does not
 1359 |     | /// reach 'outgoingLimit / (2 ** 216)', which means that there is no solution.
 1360 |     | /// In this case, we simply return the value for the above integral in 'X216'
 1361 |     | /// representation along with 'exactAmount == false'.
 1362 |     | ///
 1363 |     | /// Similarly, if 'getZeroForOne == true', then 'qTarget' is a lower bound for
 1364 |     | /// the unknown value 'qTarget == qBegin - x' and the numerical search for 'x'
 1365 |     | /// is performed within the range '0' to 'qBegin - qTarget'. In this case,
 1366 |     | /// we first need to check the following inequality:
 1367 |     | ///
 1368 |     | ///      - 8     / qBegin
 1369 |     | ///    e        |   + h / 2             cTotal1 - cTotal0
 1370 |     | ///  '------- * |  e        (cTotal0 + ------------------- (qTotal0 - h)) dh
 1371 |     | ///      2      |                       qTotal0 - qTotal1
 1372 |     | ///            / qTarget
 1373 |     | ///
 1374 |     | ///      outgoingLimit
 1375 |     | ///   < ---------------'.
 1376 |     | ///        2 ** 216
 1377 |     | ///
 1378 |     | /// If satisfied, then the outgoing integral across the entire range does not
 1379 |     | /// reach 'outgoingLimit / (2 ** 216)', which means that there is no solution.
 1380 |     | /// In this case, we simply return the value for the above integral in 'X216'
 1381 |     | /// representation along with 'exactAmount == false'.
 1382 |     | ///
 1383 |     | /// @return outgoing Integral increment to be added to
 1384 |     | /// 'currentToTarget / (2 ** 216)', i.e.,
 1385 |     | ///
 1386 |     | ///      - 8     / qTarget
 1387 |     | ///    e        |   - h / 2             cTotal1 - cTotal0
 1388 |     | ///  '------- * |  e        (cTotal0 + ------------------- (h - qTotal0)) dh'
 1389 |     | ///      2      |                       qTotal1 - qTotal0
 1390 |     | ///            / qBegin
 1391 |     | ///
 1392 |     | /// if 'getZeroForOne() == false' and
 1393 |     | ///
 1394 |     | ///      - 8     / qBegin
 1395 |     | ///    e        |   + h / 2             cTotal1 - cTotal0
 1396 |     | ///  '------- * |  e        (cTotal0 + ------------------- (qTotal0 - h)) dh'
 1397 |     | ///      2      |                       qTotal0 - qTotal1
 1398 |     | ///            / qTarget
 1399 |     | ///
 1400 |     | /// if 'getZeroForOne() == true'.
 1401 |     | ///
 1402 |     | /// If 'exactAmount == false', this value is equal to the outgoing integral
 1403 |     | /// across the entire search range and if the search is performed, this value
 1404 |     | /// is equal to the left hand side of the equation that we are solving.
 1405 |     | function searchOutgoingTarget() pure returns (
 1406 |     |   bool exactAmount,
 1407 |     |   X216 outgoing
 1408 |     | ) {
 1409 |     |   // First, we subtract 'currentToTarget' from 'getIntegralLimit()' in order to
 1410 |     |   // get 'outgoingLimit'.
 1411 |     |   //
 1412 |     |   // Subtraction is safe because underflow is handled externally.
 1413 |     |   X216 outgoingLimit = getIntegralLimit() - _currentToTarget_.integral();
 1414 |     | 
 1415 |     |   // The next step is to see if the integral taken across the entire search
 1416 |     |   // range between 'qBegin' and 'qTarget' exceeds 'outgoingLimit' or not. If it
 1417 |     |   // does not, then we simply stop the search and return the resulting integral
 1418 |     |   // along with 'exactAmount == false'.
 1419 |     |   //
 1420 |     |   // As defined in 'Memory.sol', we have
 1421 |     |   //
 1422 |     |   //  'qBegin := getDirection() ? 
 1423 |     |   //             min(q[indexCurve + 2], qTotal0) : 
 1424 |     |   //             max(q[indexCurve + 2], qTotal0)',
 1425 |     |   //
 1426 |     |   //  'qTarget := (
 1427 |     |   //                getDirection() == getZeroForOne()
 1428 |     |   //              ) ? (
 1429 |     |   //                getDirection() ? 
 1430 |     |   //                max(max(qEnd, qTotal1), qLimitWithinInterval) : 
 1431 |     |   //                min(min(qEnd, qTotal1), qLimitWithinInterval)
 1432 |     |   //              ) : (
 1433 |     |   //                getDirection() ? 
 1434 |     |   //                max(qEnd, qTotal1) : 
 1435 |     |   //                min(qEnd, qTotal1)
 1436 |     |   //              )
 1437 |     |   //           == getDirection() ? 
 1438 |     |   //              max(max(qEnd, qTotal1), qLimitWithinInterval) : 
 1439 |     |   //              min(min(qEnd, qTotal1), qLimitWithinInterval)
 1440 |     |   //
 1441 |     |   // which implies that if 'getDirection() == false', then
 1442 |     |   //
 1443 |     |   //  'qTotal0 <= qBegin <= qTarget <= qTotal1'.
 1444 |     |   //
 1445 |     |   // and if 'getDirection() == true', then
 1446 |     |   //
 1447 |     |   //  'qTotal1 <= qTarget <= qBegin <= qTotal0'.
 1448 |     |   //
 1449 |     |   // Additionally, since the vertical coordinates of kernel are monotonic, we
 1450 |     |   // have 'cTotal0 <= cTotal1' and the input requirements of 'outgoing' are
 1451 |     |   // satisfied.
 1452 |     |   outgoing = _total0_.outgoing(_begin_, _target_);
 1453 |     |   // Signed comparison is valid because:
 1454 |     |   //
 1455 |     |   //  - the output of 'outgoing' is always a nonnegative value which is less
 1456 |     |   //    than 'oneX216'.
 1457 |     |   //
 1458 |     |   //  - 'outgoingLimit <= getIntegralLimit() < one216', and
 1459 |     |   //
 1460 |     |   //  - 'getIntegralLimit() >= zeroX216' because of the first input
 1461 |     |   //    requirement.
 1462 |     |   if (outgoing <= outgoingLimit) return (false, outgoing);
 1463 |     | 
 1464 |     |   // 'zeroForOne' is loaded from the memory.
 1465 |     |   bool left = getZeroForOne();
 1466 |     | 
 1467 |     |   // '|qTotal1 - qTotal0|' is calculated once and used throughout the search.
 1468 |     |   //
 1469 |     |   // As we argued before, if 'left == false', then
 1470 |     |   //
 1471 |     |   //  'qTotal0 <= qBegin <= qTarget <= qTotal1'.
 1472 |     |   //
 1473 |     |   // and if 'left == true', then
 1474 |     |   //
 1475 |     |   //  'qTotal1 <= qTarget <= qBegin <= qTotal0'.
 1476 |     |   X59 db = left ? 
 1477 |     |     _total0_.log() - _total1_.log() : 
 1478 |     |     _total1_.log() - _total0_.log();
 1479 |     | 
 1480 |     |   // 'cTotal1 - cTotal0' is calculated once and used throughout the search.
 1481 |     |   //
 1482 |     |   // The subtraction is safe because 'total0' and 'total1' correspond to the
 1483 |     |   // kernel breakpoints 'indexKernelTotal - oneIndex' and 'indexKernelTotal',
 1484 |     |   // respectively, and the vertical coordinates of kernel breakpoints are
 1485 |     |   // monotonically non-decreasing due to the custom error
 1486 |     |   // 'NonMonotonicVerticalCoordinates' in 'KernelCompact.sol'.
 1487 |     |   X15 dc = _total1_.height() - _total0_.height();
 1488 |     | 
 1489 |     |   // Next we calculate
 1490 |     |   //
 1491 |     |   //  'q2 := 2 * (cTotal1 - cTotal0)'
 1492 |     |   //
 1493 |     |   // The multiplication is safe because 'twoX59' is positive and the output
 1494 |     |   // does not exceed '64 + 16 == 80' bits.
 1495 |     |   X74 q2 = twoX59.times(dc);
 1496 |     | 
 1497 |     |   // The second coefficient is calculated as
 1498 |     |   //
 1499 |     |   // 'q1 := (cTotal1 - cTotal0) * (2 + |qBegin - qTotal0|)
 1500 |     |   //      + cTotal0 * |qTotal1 - qTotal0|'
 1501 |     | 
 1502 |     |   // The multiplication 'db.times(_total0_.height())' is safe because the
 1503 |     |   // output does not exceed 80 bits.
 1504 |     |   //
 1505 |     |   // The addition is safe because neither 'q2' nor
 1506 |     |   // 'db.times(_total0_.height())' do not exceed 80 bits.
 1507 |     |   X74 q1 = q2 + db.times(_total0_.height());
 1508 |     | 
 1509 |     |   // The subtractions are safe because of the last input requirement and the
 1510 |     |   // fact that
 1511 |     |   //
 1512 |     |   //  'getDirection() == getZeroForOne() == left'.
 1513 |     |   //
 1514 |     |   // Lastly, the additions are safe because neither values exceed 81 bits.
 1515 |     |   q1 = left ? 
 1516 |     |     q1 + (_total0_.log() - _begin_.log()).times(dc) : 
 1517 |     |     q1 + (_begin_.log() - _total0_.log()).times(dc);
 1518 |     | 
 1519 |     |   // Next, in order to compute 'q0', if 'left == false', we calculate:
 1520 |     |   //
 1521 |     |   //        outgoingLimit          db
 1522 |     |   //  '---------------------- * --------- * exp(+ qBegin / 2) ==
 1523 |     |   //    (2 ** 216) * exp(-8)     2 ** 59
 1524 |     |   //
 1525 |     |   //    outgoingLimit * db * ((2 ** 216) * exp(- 8 + qBegin / 2))
 1526 |     |   //   ----------------------------------------------------------- ==
 1527 |     |   //                  (2 ** (216 + 59)) * exp(-16)
 1528 |     |   //
 1529 |     |   //    outgoingLimit * db * _begin_.sqrt(true)
 1530 |     |   //   -----------------------------------------'
 1531 |     |   //         (2 ** (216 + 59)) * exp(-16)
 1532 |     |   //
 1533 |     |   // and if 'left == true', we calculate:
 1534 |     |   //
 1535 |     |   //        outgoingLimit          db
 1536 |     |   //  '---------------------- * --------- * exp(- qBegin / 2) ==
 1537 |     |   //    (2 ** 216) * exp(-8)     2 ** 59
 1538 |     |   //
 1539 |     |   //    outgoingLimit * db * ((2 ** 216) * exp(- 8 - qBegin / 2))
 1540 |     |   //   ----------------------------------------------------------- ==
 1541 |     |   //                  (2 ** (216 + 59)) * exp(-16)
 1542 |     |   //
 1543 |     |   //    outgoingLimit * db * _begin_.sqrt(false)
 1544 |     |   //   ------------------------------------------'.
 1545 |     |   //          (2 ** (216 + 59)) * exp(-16)
 1546 |     |   //
 1547 |     |   // The three inputs of 'mulDivByExpInv16' are non-negative and overflow is
 1548 |     |   // not possible because
 1549 |     |   //
 1550 |     |   //    outgoingLimit * db * _begin_.sqrt(!left)
 1551 |     |   //  '------------------------------------------ < 
 1552 |     |   //          (2 ** (216 + 59)) * exp(-16)
 1553 |     |   //
 1554 |     |   //    (2 ** 216) * (2 ** 64) * (2 ** 216)
 1555 |     |   //   ------------------------------------- == 
 1556 |     |   //       (2 ** (216 + 59)) * exp(-16)
 1557 |     |   //
 1558 |     |   //   32 * exp(16) * oneX216 < 2 ** 256 - 1'.
 1559 |     |   //
 1560 |     |   // Hence, the requirements of 'mulDivByExpInv16' are satisfied.
 1561 |     |   //
 1562 |     |   // Additionally, 'toX216' does not overflow because 'q1' does not exceed
 1563 |     |   // '81' bits.
 1564 |     |   //
 1565 |     |   // Next, we need to prove that the subtraction is safe. Consider the case of
 1566 |     |   // 'getDirection() == false' as the other case can be argued similarly. To
 1567 |     |   // that end, we need to show that
 1568 |     |   //
 1569 |     |   //      q1             outgoingLimit          db
 1570 |     |   //  '--------- >= ---------------------- * --------- * exp(+ qBegin / 2)'.
 1571 |     |   //    2 ** 74      (2 ** 216) * exp(-8)     2 ** 59
 1572 |     |   //
 1573 |     |   // Or equivalently:
 1574 |     |   //
 1575 |     |   //  'cTotal1 * (2 - qTotal0 + qBegin) - cTotal0 * (2 - qTotal1 + qBegin) >=
 1576 |     |   //
 1577 |     |   //        outgoingLimit          db
 1578 |     |   //   ---------------------- * --------- * exp(+ qBegin / 2)'.
 1579 |     |   //    (2 ** 216) * exp(-8)     2 ** 59
 1580 |     |   //
 1581 |     |   // Notice that due to our prior check,
 1582 |     |   //
 1583 |     |   //       outgoingLimit
 1584 |     |   //  '----------------------'
 1585 |     |   //    exp(-8) * (2 ** 216)
 1586 |     |   //
 1587 |     |   // does not exceed
 1588 |     |   //
 1589 |     |   //         / qTarget
 1590 |     |   //    1   |   - h / 2             cTotal1 - cTotal0
 1591 |     |   //  '---  |  e        (cTotal0 + ------------------- (h - qTotal0)) dh'
 1592 |     |   //    2   |                       qTotal1 - qTotal0
 1593 |     |   //       / qBegin
 1594 |     |   //
 1595 |     |   // which is equal to:
 1596 |     |   //
 1597 |     |   //  'cTotal0 * (exp(- qBegin / 2) - exp(- qTarget / 2)) +
 1598 |     |   //
 1599 |     |   //    cTotal1 - cTotal0
 1600 |     |   //   ------------------- * (
 1601 |     |   //    qTotal1 - qTotal0
 1602 |     |   //
 1603 |     |   //     (qBegin - qTotal0 + 2) * exp(- qBegin / 2) - 
 1604 |     |   //     (qTarget - qTotal0 + 2) * exp(- qTarget / 2)
 1605 |     |   //   )'
 1606 |     |   //
 1607 |     |   // Hence, we need to prove that
 1608 |     |   //
 1609 |     |   //  'cTotal1 * (2 - qTotal0 + qBegin) - cTotal0 * (2 - qTotal1 + qBegin) >=
 1610 |     |   //
 1611 |     |   //   (qTotal1 - qTotal0) * exp(+ qBegin / 2) * (
 1612 |     |   //
 1613 |     |   //     cTotal0 * (exp(- qBegin / 2) - exp(- qTarget / 2)) + 
 1614 |     |   //
 1615 |     |   //      cTotal1 - cTotal0
 1616 |     |   //     ------------------- * (
 1617 |     |   //      qTotal1 - qTotal0
 1618 |     |   //
 1619 |     |   //       (qBegin - qTotal0 + 2) * exp(- qBegin/2) - 
 1620 |     |   //       (qTarget - qTotal0 + 2) * exp(- qTarget/2)
 1621 |     |   //     )
 1622 |     |   //   )'
 1623 |     |   //
 1624 |     |   // which is equivalent to:
 1625 |     |   //
 1626 |     |   //  '(2 + qTarget - qTotal0) * (cTotal1 - cTotal0) + 
 1627 |     |   //   cTotal0 * (qTotal1 - qTotal0) >= 0'.
 1628 |     |   //
 1629 |     |   // As we have already proven, if 'getDirection() == false', then
 1630 |     |   //
 1631 |     |   //  'qTotal0 <= qBegin <= qTarget <= qTotal1'.
 1632 |     |   //
 1633 |     |   // which means that the subtraction is safe.
 1634 |     |   X216 q0 = 
 1635 |     |     q1.toX216() - db.mulDivByExpInv16(_begin_.sqrt(!left), outgoingLimit);
 1636 |     |   // The following addition is also safe, because
 1637 |     |   // 
 1638 |     |   //       q0           q1
 1639 |     |   //  '---------- <= --------- == 
 1640 |     |   //    2 ** 216      2 ** 74
 1641 |     |   //
 1642 |     |   //   cTotal1 * (2 - qTotal0 + qBegin) - cTotal0 * (2 - qTotal1 + qBegin) <= 
 1643 |     |   //
 1644 |     |   //   (cTotal1 - cTotal0) * (2 + qBegin) + 
 1645 |     |   //
 1646 |     |   //   cTotal0 * qTotal1 - cTotal1 * qTotal0 <= 
 1647 |     |   //
 1648 |     |   //   1 * (2 + 16) + 1 * 16 + 1 * 16 <= 50
 1649 |     |   //
 1650 |     |   // which concludes that 'q0' does not take more than 222-bits in 'X216'
 1651 |     |   // representation.
 1652 |     |   q0 = q0 + q0;
 1653 |     | 
 1654 |     |   // The initial value for 'x' is calculated here. The subtractions are safe
 1655 |     |   // because as we argued before, if 'left == false', then
 1656 |     |   //
 1657 |     |   //  'qTotal0 <= qBegin <= qTarget <= qTotal1'
 1658 |     |   //
 1659 |     |   // and if 'left == true', then
 1660 |     |   //
 1661 |     |   //  'qTotal1 <= qTarget <= qBegin <= qTotal0'.
 1662 |     |   X59 xLimit = 
 1663 |     |     left ? _begin_.log() - _target_.log() : _target_.log() - _begin_.log();
 1664 |     | 
 1665 |     |   // All three inputs of 'cheapMulDiv' are non-negative.
 1666 |     |   //
 1667 |     |   // Due to the prior check, 'outgoingLimit < outgoing'. Additionally, we have
 1668 |     |   //
 1669 |     |   //  '|_begin_.log() - _target_.log()| <= 2 ** 64 - 1 < 
 1670 |     |   //
 1671 |     |   //   75557863725914323375445 <= (2 ** 216) * 
 1672 |     |   //
 1673 |     |   //                                      1
 1674 |     |   //      - 8     / 16                --------- - 0
 1675 |     |   //    e        |   - h / 2           2 ** 15
 1676 |     |   //   ------- * |  e           (0 + ---------------  * (h + 16)) dh <
 1677 |     |   //      2      |                     16 - (- 16)
 1678 |     |   //            / 16 - 1 / (2 ** 59)
 1679 |     |   //
 1680 |     |   //   outgoing'.
 1681 |     |   //
 1682 |     |   // Here, '75557863725914323375445' is the minimum value for an outgoing
 1683 |     |   // integral. Hence, we have:
 1684 |     |   //
 1685 |     |   //  'xLimit * outgoingLimit < outgoing * (outgoing - 1)'
 1686 |     |   //
 1687 |     |   // and the requirement of 'cheapMulDiv' is met.
 1688 |     |   //
 1689 |     |   // Signed comparison is valid because the first term is a positive constant
 1690 |     |   // and the second term is non-negative.
 1691 |     |   X59 x = max(epsilonX59, xLimit.cheapMulDiv(outgoingLimit, outgoing));
 1692 |     | 
 1693 |     |   while (true) {
 1694 |     |     // For each iteration, we evaluate 'g(x)' and 'h(x)' in 'X74' and 'X216'
 1695 |     |     // representations, respectively.
 1696 |     |     //
 1697 |     |     // 'x.times(dc)' is safe because 'x' is not less than 'epsilonX59' due to
 1698 |     |     // the above check and we have already checked that 'dc' is nonnegative.
 1699 |     |     //
 1700 |     |     // The addition 'x.times(dc) + q1' is safe because both values do not
 1701 |     |     // exceed 81-bits.
 1702 |     |     //
 1703 |     |     // Next, we prove the requirements of 'cheapMulDiv'.
 1704 |     |     //
 1705 |     |     // Upon initializing a pool, the given curve sequence is validated by the
 1706 |     |     // method 'validate' in 'Curve.sol'. When validating the curve sequence,
 1707 |     |     // the custom error 'BlankIntervalsShouldBeAvoided' ensures that:
 1708 |     |     // 
 1709 |     |     //  'qSpacing < 16 + qLower < 16 + qUpper < 32 - qSpacing'
 1710 |     |     //
 1711 |     |     // Hence,
 1712 |     |     //
 1713 |     |     //  '32 - qSpacing > 16 + qUpper == 16 + qLower + qSpacing > 2 * qSpacing'
 1714 |     |     //
 1715 |     |     // which concludes:
 1716 |     |     //
 1717 |     |     //  '|_target_.log() - _begin_.log()| / (2 ** 59) <= qSpacing < 32 / 3'.
 1718 |     |     //
 1719 |     |     // Due to the above arguments, the input requirements of 'expInverse' are
 1720 |     |     // satisfied because 'x' is not less than 'epsilonX59' and
 1721 |     |     //
 1722 |     |     //  'x <= |_target_.log() - _begin_.log()| < (2 ** 64) / 3'.
 1723 |     |     //
 1724 |     |     // Hence,
 1725 |     |     //
 1726 |     |     //  'x.expInverse() == (2 ** 256) * exp(- x / (2 ** 60))
 1727 |     |     //                  >= (2 ** 256) * exp(- qSpacing / 2)
 1728 |     |     //                  >= (2 ** 256) * exp(- 16 / 3) > 2 ** 248.
 1729 |     |     //
 1730 |     |     // On the other hand, 'q0' is non-negative and may not be more than
 1731 |     |     // 223-bits as we argued before.
 1732 |     |     //
 1733 |     |     // Hence, the input requirement of 'cheapMulDiv' is satisfied because
 1734 |     |     // the number of bits for 'q0 * (1 << 255)' does not exceed the number of
 1735 |     |     // bits for 'x.expInverse()', i.e.,
 1736 |     |     //
 1737 |     |     //  '223 bits + 255 bits < 248 bits + 248 bits'.
 1738 |     |     //
 1739 |     |     // The subtraction 'g - q2' is safe because:
 1740 |     |     //
 1741 |     |     //  'g(x) := (cTotal1 - cTotal0) * x + q1 - q2
 1742 |     |     //
 1743 |     |     //        == (cTotal1 - cTotal0) * x + 
 1744 |     |     //           cTotal1 * (2 - qTotal0 + qBegin) - 
 1745 |     |     //           cTotal0 * (2 - qTotal1 + qBegin) - 
 1746 |     |     //           2 * (cTotal1 - cTotal0)
 1747 |     |     //
 1748 |     |     //        == (cTotal1 - cTotal0) * (x + qBegin) + 
 1749 |     |     //           cTotal0 * qTotal1 - cTotal1 * qTotal0
 1750 |     |     //
 1751 |     |     //        == (cTotal1 - cTotal0) * (x + qBegin - qTotal0) + 
 1752 |     |     //           cTotal0 * (qTotal1 - qTotal0)
 1753 |     |     //
 1754 |     |     //        >= (cTotal1 - cTotal0) * x >= 1 / ((2 ** 15) * (2 ** 59)) > 0'
 1755 |     |     //
 1756 |     |     // where 'qBegin >= qTotal0' is concluded from the last input requirement.
 1757 |     |     // Also, 'cTotal1 - cTotal0 >= 1 / (2 ** 15)' is concluded from the initial
 1758 |     |     // check for the determination of 'exactAmount', because if
 1759 |     |     // 'cTotal1 == cTotal0 == 0', then we have 'exactAmount == false' and this
 1760 |     |     // part of the code would not be reached. Hence, 'g' is positive which will
 1761 |     |     // be used later.
 1762 |     |     //
 1763 |     |     // The subtraction 'g.toX216() - q0.cheapMulDiv(1 << 255, x.expInverse())'
 1764 |     |     // is unsafe and may be negative.
 1765 |     |     X74 g = x.times(dc) + q1;
 1766 |     |     X216 h = g.toX216() - q0.cheapMulDiv(1 << 255, x.expInverse());
 1767 |     |     g = g - q2;
 1768 |     | 
 1769 |     |     // Next, we calculate the following Halley step:
 1770 |     |     //
 1771 |     |     //                            2 * (h(x) / g(x))
 1772 |     |     //  'step = -----------------------------------------------------'
 1773 |     |     //           1 - (h(x) / g(x)) / 2 + (h(x) / g(x)) * (dc / g(x))
 1774 |     |     //
 1775 |     |     // in 'X59' representation.
 1776 |     |     //
 1777 |     |     // The numerator is in 'X142' representation.
 1778 |     |     // The denominator is in 'X83' representation.
 1779 |     |     X59 step;
 1780 |     |     uint256 denominator;
 1781 |     |     assembly {
 1782 |     |       // The division is safe because 'g' is positive as we argued before.
 1783 |     |       let h_over_g_X142 := sdiv(h, g) // h(x) / g(x)
 1784 |     |       denominator := sub(
 1785 |     |         shl(83, 1), // oneX83
 1786 |     |         sub(
 1787 |     |           // Here, 'h_over_g_X142' is shifted to the right by
 1788 |     |           // '60 == 142 - 83 + 1' bits where '1' appears because we are
 1789 |     |           // dividing by two. '142' appears because we are casting from the 
 1790 |     |           // 'X142' representation and '83' appears because we are casting to  
 1791 |     |           // the 'X83' representation.
 1792 |     |           sar(60, h_over_g_X142), // (h(x) / g(x)) / 2
 1793 |     |           sdiv(mul(h_over_g_X142, dc), g) // (h(x) / g(x)) * (dc / g(x))
 1794 |     |         )
 1795 |     |       ) // 1 - (h(x) / g(x)) / 2 + (h(x) / g(x)) * (dc / g(x))
 1796 |     |       step := sdiv(
 1797 |     |         add(h_over_g_X142, h_over_g_X142), // 2 * (h(x) / g(x))
 1798 |     |         denominator
 1799 |     |       )
 1800 |     |     }
 1801 |     | 
 1802 |     |     if (step == zeroX59) {
 1803 |     |       require(denominator != 0, SearchingForOutgoingTargetFailed());
 1804 |     |       break;
 1805 |     |     }
 1806 |     | 
 1807 |     |     // The solution is capped by 'epsilonX59' and 'xLimit'. Hence, we do not
 1808 |     |     // need to argue whether the addition 'x + step' is safe or not.
 1809 |     |     x = min(max(epsilonX59, x + step), xLimit);
 1810 |     |   }
 1811 |     | 
 1812 |     |   // The subtraction and the addition are safe because if 'left == false':
 1813 |     |   //
 1814 |     |   //  '0 < x <= xLimit := qTarget - qBegin',
 1815 |     |   //
 1816 |     |   // and if 'left == true':
 1817 |     |   //
 1818 |     |   //  '0 < x <= xLimit := qBegin - qTarget'.
 1819 |     |   //
 1820 |     |   x = left ? _begin_.log() - x : _begin_.log() + x;
 1821 |     | 
 1822 |     |   // The output should be stored in both of the memory spaces that are pointed
 1823 |     |   // to by '_overshoot_' and '_target_'.
 1824 |     |   //
 1825 |     |   // The requirements of 'storePrice' and 'outgoing' are satisfied because
 1826 |     |   //
 1827 |     |   //  'min(qBegin, qTarget) <= x <= max(qBegin, qTarget)'.
 1828 |     |   //
 1829 |     |   _overshoot_.storePrice(x);
 1830 |     | 
 1831 |     |   // As argued before, if 'getDirection() == false', then
 1832 |     |   //
 1833 |     |   //  'qTotal0 <= qBegin <= qOvershoot <= qTarget <= qTotal1'.
 1834 |     |   //
 1835 |     |   // and if 'getDirection() == true', then
 1836 |     |   //
 1837 |     |   //  'qTotal1 <= qTarget <= qOvershoot <= qBegin <= qTotal0'.
 1838 |     |   //
 1839 |     |   // Additionally, since the vertical coordinates of kernel are monotonic, we
 1840 |     |   // have 'cTotal0 <= cTotal1' and the input requirements of 'outgoing' are
 1841 |     |   // satisfied.
 1842 |     |   outgoing = _total0_.outgoing(_begin_, _overshoot_);
 1843 |     | 
 1844 |     |   // 'x' is moved forward to ensure that the resulting integral is an over
 1845 |     |   // approximation.
 1846 |     |   while (outgoing < outgoingLimit) {
 1847 |     |     // The addition and the subtraction are safe here because:
 1848 |     |     //
 1849 |     |     //  'outgoingLimit < _total0_.outgoing(_begin_, _target_)'.
 1850 |     |     //
 1851 |     |     // Hence, the loop is stopped before we reach 'qTarget'.
 1852 |     |     x = left ? x - epsilonX59 : x + epsilonX59;
 1853 |     | 
 1854 |     |     // Due to the above argument, if 'left == false' then
 1855 |     |     //
 1856 |     |     //  'qOvershoot + 1 / (2 ** 59) < qTarget <= qUpper'
 1857 |     |     //
 1858 |     |     // and if 'left == true' then
 1859 |     |     //
 1860 |     |     //  'qLower <= qTarget < qOvershoot - 1 / (2 ** 59)'.
 1861 |     |     //
 1862 |     |     // Hence the input requirements of 'moveOvershootByEpsilon' are satisfied.
 1863 |     |     moveOvershootByEpsilon(left);
 1864 |     | 
 1865 |     |     // As argued before, if 'getDirection() == false', then
 1866 |     |     //
 1867 |     |     //  'qTotal0 <= qBegin <= qOvershoot <= qTarget <= qTotal1'.
 1868 |     |     //
 1869 |     |     // and if 'getDirection() == true', then
 1870 |     |     //
 1871 |     |     //  'qTotal1 <= qTarget <= qOvershoot <= qBegin <= qTotal0'.
 1872 |     |     //
 1873 |     |     // Additionally, since the vertical coordinates of kernel are monotonic, we
 1874 |     |     // have 'cTotal0 <= cTotal1' and the input requirements of 'outgoing' are
 1875 |     |     // satisfied.
 1876 |     |     outgoing = _total0_.outgoing(_begin_, _overshoot_);
 1877 |     |   }
 1878 |     | 
 1879 |     |   // The output should be stored in both of the memory spaces that are pointed
 1880 |     |   // to by '_overshoot_' and '_target_'.
 1881 |     |   _target_.copyPrice(_overshoot_);
 1882 |     | 
 1883 |     |   return (true, outgoing);
 1884 |     | }
 1885 |     | 
 1886 |     | /// @notice For the case 'exactInput == true', i.e., when the specified amount
 1887 |     | /// is incoming, this function performs a Halley search to determine 'qTarget'
 1888 |     | /// based on 'integralLimit'. As explained in 'Memory.sol', 'integralLimit' is
 1889 |     | /// is derived from 'amountSpecified'.
 1890 |     | ///
 1891 |     | /// Let
 1892 |     | ///
 1893 |     | ///  'cTotal0 := c[indexKernelTotal - 1]',
 1894 |     | ///  'cTotal1 := c[indexKernelTotal]',
 1895 |     | ///
 1896 |     | /// represent the vertical coordinates of the kernel breakpoints corresponding
 1897 |     | /// to 'indexKernelTotal - 1' and 'indexKernelTotal', respectively. As
 1898 |     | /// explained in 'Memory.sol', the memory spaces that are pointed to by
 1899 |     | /// '_total0_' and '_total1_' host the following vertical coordinates:
 1900 |     | ///
 1901 |     | ///  '_total0_.height() := (2 ** 15) * cTotal0',
 1902 |     | ///  '_total1_.height() := (2 ** 15) * cTotal1'.
 1903 |     | ///
 1904 |     | /// Additionally, if 'getDirection() == false', define
 1905 |     | ///
 1906 |     | ///  'qTotal0 := qOrigin + b[indexKernelTotal - 1]',
 1907 |     | ///  'qTotal1 := qOrigin + b[indexKernelTotal]',
 1908 |     | ///
 1909 |     | /// and if 'getDirection() == true', define
 1910 |     | ///
 1911 |     | ///  'qTotal0 := qOrigin - b[indexKernelTotal - 1]',
 1912 |     | ///  'qTotal1 := qOrigin - b[indexKernelTotal]',
 1913 |     | ///
 1914 |     | /// as the shifted horizontal coordinates of the kernel breakpoint
 1915 |     | /// corresponding to 'indexKernelTotal - 1' and 'indexKernelTotal',
 1916 |     | /// respectively. Hence, the memory spaces that are pointed to by '_total0_'
 1917 |     | /// and '_total1_' host the following horizontal coordinates as well:
 1918 |     | /// 
 1919 |     | ///  '_total0_.log() := (2 ** 59) * (16 + qTotal0)',
 1920 |     | ///  '_total1_.log() := (2 ** 59) * (16 + qTotal1)',
 1921 |     | /// 
 1922 |     | /// Let 'qBegin' and 'qCurrent' represent the offsetted logarithmic prices that
 1923 |     | /// are hosted by the memory pointers '_begin_' and '_current_', i.e.,
 1924 |     | ///
 1925 |     | ///  '_begin_.log() == (2 ** 59) * (16 + qBegin)',
 1926 |     | ///  '_current_.log() == (2 ** 59) * (16 + qCurrent)'.
 1927 |     | ///
 1928 |     | /// At this stage, 'qTarget' is not yet determined. Hence, if 
 1929 |     | /// 'getZeroForOne() == false', we have:
 1930 |     | ///
 1931 |     | ///                                   - 8     / qBegin
 1932 |     | ///    incomingCurrentToTarget      e        |    + h / 2
 1933 |     | ///  '------------------------- := ------- * |  e         k(w(h)) dh'
 1934 |     | ///           2 ** 216                2      |
 1935 |     | ///                                         / qCurrent
 1936 |     | ///
 1937 |     | /// and we want to determine 'qTarget' based on the following equation:
 1938 |     | ///
 1939 |     | ///                              - 8     / qTarget
 1940 |     | ///    getIntegralLimit()      e        |    + h / 2
 1941 |     | ///  '-------------------- == ------- * |  e         k(w(h)) dh',
 1942 |     | ///         2 ** 216             2      |
 1943 |     | ///                                    / qCurrent
 1944 |     | ///
 1945 |     | /// which is equivalent to
 1946 |     | ///
 1947 |     | ///    getIntegralLimit() - incomingCurrentToTarget
 1948 |     | ///  '---------------------------------------------- == 
 1949 |     | ///                      2 ** 216
 1950 |     | ///
 1951 |     | ///      - 8     / qTarget
 1952 |     | ///    e        |    + h / 2
 1953 |     | ///   ------- * |  e         k(w(h)) dh == 
 1954 |     | ///      2      |
 1955 |     | ///            / qBegin
 1956 |     | ///
 1957 |     | ///      - 8     / qTarget
 1958 |     | ///    e        |    + h / 2             cTotal1 - cTotal0
 1959 |     | ///   ------- * |  e         (cTotal0 + ------------------- (h - qTotal0)) dh'.
 1960 |     | ///      2      |                        qTotal1 - qTotal0
 1961 |     | ///            / qBegin
 1962 |     | ///
 1963 |     | /// Hence, we define
 1964 |     | ///
 1965 |     | ///  'incomingLimit := getIntegralLimit() - incomingCurrentToTarget'.
 1966 |     | ///
 1967 |     | /// and solve
 1968 |     | ///
 1969 |     | ///      - 8     / qBegin + x
 1970 |     | ///    e        |   + h / 2             cTotal1 - cTotal0
 1971 |     | ///  '------- * |  e        (cTotal0 + ------------------- (h - qTotal0)) dh
 1972 |     | ///      2      |                       qTotal1 - qTotal0
 1973 |     | ///            / qBegin
 1974 |     | ///
 1975 |     | ///       incomingLimit
 1976 |     | ///   == ---------------'
 1977 |     | ///         2 ** 216
 1978 |     | ///
 1979 |     | /// with respect to 'x' and then we store
 1980 |     | ///
 1981 |     | ///  'qTarget := qBegin + x'.
 1982 |     | ///
 1983 |     | /// in the memory spaces that are pointed to by '_target_' and '_overshoot_'.
 1984 |     | ///
 1985 |     | /// Similarly, if 'getZeroForOne() == true', we solve the equation:
 1986 |     | ///
 1987 |     | ///      - 8     / qBegin
 1988 |     | ///    e        |   - h / 2             cTotal1 - cTotal0
 1989 |     | ///  '------- * |  e        (cTotal0 + ------------------- (qTotal0 - h)) dh
 1990 |     | ///      2      |                       qTotal0 - qTotal1
 1991 |     | ///            / qBegin - x
 1992 |     | ///
 1993 |     | ///       incomingLimit
 1994 |     | ///   == ---------------'
 1995 |     | ///         2 ** 216
 1996 |     | ///
 1997 |     | /// with respect to 'x' and then we store:
 1998 |     | ///
 1999 |     | ///  'qTarget := qBegin - x'.
 2000 |     | ///
 2001 |     | /// in the memory spaces that are pointed to by '_target_' and '_overshoot_'.
 2002 |     | ///
 2003 |     | /// For simplicity, consider the first case of 'getZeroForOne() == false',
 2004 |     | /// since the second case 'getZeroForOne() == true' can be argued similarly.
 2005 |     | /// Define:
 2006 |     | ///
 2007 |     | ///  'q2 := 2 * (cTotal1 - cTotal0)'
 2008 |     | ///
 2009 |     | ///  'q1 := cTotal1 * (2 + qTotal0 - qBegin) - 
 2010 |     | ///         cTotal0 * (2 + qTotal1 - qBegin)'
 2011 |     | ///
 2012 |     | ///                                     incomingLimit
 2013 |     | ///  'q0 := q1 - (qTotal1 - qTotal0) * --------------- * exp(- qBegin / 2)'
 2014 |     | ///                                        2 ** 216
 2015 |     | ///
 2016 |     | /// Then the equation can be cast as 'f(x) == 0', where
 2017 |     | ///
 2018 |     | ///  '  f(x) == + ((cTotal1 - cTotal0) * x - q1) * exp(x / 2) + q0'
 2019 |     | ///
 2020 |     | ///  ' f'(x) == + ((cTotal1 - cTotal0) * x - q1 + q2) * exp(x / 2) / 2'
 2021 |     | ///
 2022 |     | ///  'f''(x) == + ((cTotal1 - cTotal0) * x - q1 + q2 + q2) * exp(x / 2) / 4'
 2023 |     | ///
 2024 |     | /// Define:
 2025 |     | ///
 2026 |     | ///  'g(x) == (cTotal1 - cTotal0) * x - q1 + q2'
 2027 |     | ///
 2028 |     | ///  'h(x) == (cTotal1 - cTotal0) * x - q1 + q0 * exp(- x / 2)'
 2029 |     | ///
 2030 |     | /// To solve our equation, we perform the following Halley's search:
 2031 |     | ///
 2032 |     | /// 'x = x - 
 2033 |     | ///                            4 * (h(x) / g(x))
 2034 |     | ///  ----------------------------------------------------------------------'
 2035 |     | ///   2 - (h(x) / g(x)) - 2 * (h(x) / g(x)) * ((cTotal1 - cTotal0) / g(x))
 2036 |     | ///
 2037 |     | /// --------------------------------------------------------------------------- 
 2038 |     | ///
 2039 |     | /// Underflow of 'getIntegralLimit() - _incomingCurrentToTarget_.integral()'
 2040 |     | /// should be avoided externally.
 2041 |     | ///
 2042 |     | /// We should have 'getDirection() == getZeroForOne()'.
 2043 |     | ///
 2044 |     | /// @return exactAmount Whether the search is performed.
 2045 |     | ///
 2046 |     | /// Let 'qTarget' represent the existing value stored in the memory space which
 2047 |     | /// is pointed to by '_target_' (prior to calling this function). As explained
 2048 |     | /// in 'Memory.sol', we have:
 2049 |     | ///
 2050 |     | ///   'qTarget := (
 2051 |     | ///                 getDirection() == getZeroForOne()
 2052 |     | ///               ) ? (
 2053 |     | ///                 getDirection() ? 
 2054 |     | ///                 max(max(qEnd, qTotal1), qLimitWithinInterval) : 
 2055 |     | ///                 min(min(qEnd, qTotal1), qLimitWithinInterval)
 2056 |     | ///               ) : (
 2057 |     | ///                 getDirection() ? 
 2058 |     | ///                 max(qEnd, qTotal1) : 
 2059 |     | ///                 min(qEnd, qTotal1)
 2060 |     | ///               )',
 2061 |     | ///
 2062 |     | /// Additionally, because of the input requirement
 2063 |     | ///
 2064 |     | ///   'getDirection() == getZeroForOne()',
 2065 |     | ///
 2066 |     | /// the above equation is equivalent to:
 2067 |     | ///
 2068 |     | ///   'qTarget := getDirection() ? 
 2069 |     | ///               max(max(qEnd, qTotal1), qLimitWithinInterval) : 
 2070 |     | ///               min(min(qEnd, qTotal1), qLimitWithinInterval)'.
 2071 |     | ///
 2072 |     | /// If 'getZeroForOne() == false', then the current 'qTarget' is an upper bound
 2073 |     | /// for the unknown value 'qBegin + x' and the numerical search for 'x' is
 2074 |     | /// performed within the range '0' to 'qTarget - qBegin'. In this case, we
 2075 |     | /// first need to check the following inequality:
 2076 |     | ///
 2077 |     | ///      - 8     / qTarget
 2078 |     | ///    e        |   + h / 2             cTotal1 - cTotal0
 2079 |     | ///  '------- * |  e        (cTotal0 + ------------------- (h - qTotal0)) dh
 2080 |     | ///      2      |                       qTotal1 - qTotal0
 2081 |     | ///            / qBegin
 2082 |     | ///
 2083 |     | ///      incomingLimit
 2084 |     | ///   < ---------------'.
 2085 |     | ///        2 ** 216
 2086 |     | ///
 2087 |     | /// If satisfied, then the incoming integral across the entire range does not
 2088 |     | /// reach 'incomingLimit / (2 ** 216)', which means that there is no solution.
 2089 |     | /// In this case, we simply return the value for the above integral in 'X216'
 2090 |     | /// representation along with 'exactAmount == false'.
 2091 |     | ///
 2092 |     | /// Similarly, if 'getZeroForOne == true', then 'qTarget' is a lower bound for
 2093 |     | /// the unknown value 'qTarget == qBegin - x' and the numerical search for 'x'
 2094 |     | /// is performed within the range '0' to 'qBegin - qTarget'. In this case,
 2095 |     | /// we first need to check the following inequality:
 2096 |     | ///
 2097 |     | ///      - 8     / qBegin
 2098 |     | ///    e        |   + h / 2             cTotal1 - cTotal0
 2099 |     | ///  '------- * |  e        (cTotal0 + ------------------- (qTotal0 - h)) dh
 2100 |     | ///      2      |                       qTotal0 - qTotal1
 2101 |     | ///            / qTarget
 2102 |     | ///
 2103 |     | ///      incomingLimit
 2104 |     | ///   < ---------------'.
 2105 |     | ///        2 ** 216
 2106 |     | ///
 2107 |     | /// If satisfied, then the incoming integral across the entire range does not
 2108 |     | /// reach 'incomingLimit / (2 ** 216)', which means that there is no solution.
 2109 |     | /// In this case, we simply return the value for the above integral in 'X216'
 2110 |     | /// representation along with 'exactAmount == false'.
 2111 |     | ///
 2112 |     | /// @return incoming Integral increment to be added to
 2113 |     | /// 'incomingCurrentToTarget / (2 ** 216)', i.e.,
 2114 |     | ///
 2115 |     | ///      - 8     / qTarget
 2116 |     | ///    e        |   + h / 2             cTotal1 - cTotal0
 2117 |     | ///  '------- * |  e        (cTotal0 + ------------------- (h - qTotal0)) dh'
 2118 |     | ///      2      |                       qTotal1 - qTotal0
 2119 |     | ///            / qBegin
 2120 |     | ///
 2121 |     | /// if 'getZeroForOne() == false' and
 2122 |     | ///
 2123 |     | ///      - 8     / qBegin
 2124 |     | ///    e        |   - h / 2             cTotal1 - cTotal0
 2125 |     | ///  '------- * |  e        (cTotal0 + ------------------- (qTotal0 - h)) dh'
 2126 |     | ///      2      |                       qTotal0 - qTotal1
 2127 |     | ///            / qTarget
 2128 |     | ///
 2129 |     | /// if 'getZeroForOne() == true'.
 2130 |     | ///
 2131 |     | /// If 'exactAmount == false', this value is equal to the incoming integral
 2132 |     | /// across the entire search range and if the search is performed, this value
 2133 |     | /// is equal to the left hand side of the equation that we are solving.
 2134 |     | function searchIncomingTarget() pure returns (
 2135 |     |   bool exactAmount,
 2136 |     |   X216 incoming
 2137 |     | ) {
 2138 |     |   // First, we subtract 'incomingCurrentToTarget' from 'getIntegralLimit()' in
 2139 |     |   // order to get 'incomingLimit'.
 2140 |     |   //
 2141 |     |   // Subtraction is safe because underflow is handled externally.
 2142 |     |   X216 incomingLimit = 
 2143 |     |     getIntegralLimit() - _incomingCurrentToTarget_.integral();
 2144 |     | 
 2145 |     |   // The next step is to see if the integral taken across the entire search
 2146 |     |   // range between 'qBegin' and 'qTarget' exceeds 'incomingLimit' or not. If it
 2147 |     |   // does not, then we simply stop the search and return the resulting integral
 2148 |     |   // along with 'exactAmount == false'.
 2149 |     |   //
 2150 |     |   // As defined in 'Memory.sol', we have
 2151 |     |   //
 2152 |     |   //  'qBegin := getDirection() ? 
 2153 |     |   //             min(q[indexCurve + 2], qTotal0) : 
 2154 |     |   //             max(q[indexCurve + 2], qTotal0)',
 2155 |     |   //
 2156 |     |   //  'qTarget := (
 2157 |     |   //                getDirection() == getZeroForOne()
 2158 |     |   //              ) ? (
 2159 |     |   //                getDirection() ? 
 2160 |     |   //                max(max(qEnd, qTotal1), qLimitWithinInterval) : 
 2161 |     |   //                min(min(qEnd, qTotal1), qLimitWithinInterval)
 2162 |     |   //              ) : (
 2163 |     |   //                getDirection() ? 
 2164 |     |   //                max(qEnd, qTotal1) : 
 2165 |     |   //                min(qEnd, qTotal1)
 2166 |     |   //              )
 2167 |     |   //           == getDirection() ? 
 2168 |     |   //              max(max(qEnd, qTotal1), qLimitWithinInterval) : 
 2169 |     |   //              min(min(qEnd, qTotal1), qLimitWithinInterval)
 2170 |     |   //
 2171 |     |   // which implies that if 'getDirection() == false', then
 2172 |     |   //
 2173 |     |   //  'qTotal0 <= qBegin <= qTarget <= qTotal1'.
 2174 |     |   //
 2175 |     |   // and if 'getDirection() == true', then
 2176 |     |   //
 2177 |     |   //  'qTotal1 <= qTarget <= qBegin <= qTotal0'.
 2178 |     |   //
 2179 |     |   // Additionally, since the vertical coordinates of kernel are monotonic, we
 2180 |     |   // have 'cTotal0 <= cTotal1' and the input requirements of 'incoming' are
 2181 |     |   // satisfied.
 2182 |     |   incoming = _total0_.incoming(_begin_, _target_);
 2183 |     |   // Signed comparison is valid because:
 2184 |     |   //
 2185 |     |   //  - the output of 'incoming' is always a nonnegative value which is less
 2186 |     |   //    than 'oneX216'.
 2187 |     |   //
 2188 |     |   //  - 'incomingLimit <= getIntegralLimit() < one216', and
 2189 |     |   //
 2190 |     |   //  - 'getIntegralLimit() >= zeroX216' because of the first input
 2191 |     |   //    requirement.
 2192 |     |   if (incoming <= incomingLimit) return (false, incoming);
 2193 |     | 
 2194 |     |   // 'zeroForOne' is loaded from the memory.
 2195 |     |   bool left = getZeroForOne();
 2196 |     | 
 2197 |     |   // '|qTotal1 - qTotal0|' is calculated once and used throughout the search.
 2198 |     |   //
 2199 |     |   // As we argued before, if 'left == false', then
 2200 |     |   //
 2201 |     |   //  'qTotal0 <= qBegin <= qTarget <= qTotal1'.
 2202 |     |   //
 2203 |     |   // and if 'left == true', then
 2204 |     |   //
 2205 |     |   //  'qTotal1 <= qTarget <= qBegin <= qTotal0'.
 2206 |     |   X59 db = left ? 
 2207 |     |     _total0_.log() - _total1_.log() : 
 2208 |     |     _total1_.log() - _total0_.log();
 2209 |     | 
 2210 |     |   // 'cTotal1 - cTotal0' is calculated once and used throughout the search.
 2211 |     |   //
 2212 |     |   // The subtraction is safe because 'total0' and 'total1' correspond to the
 2213 |     |   // kernel breakpoints 'indexKernelTotal - oneIndex' and 'indexKernelTotal',
 2214 |     |   // respectively, and the vertical coordinates of kernel breakpoints are
 2215 |     |   // monotonically non-decreasing due to the custom error
 2216 |     |   // 'NonMonotonicVerticalCoordinates' in 'KernelCompact.sol'.
 2217 |     |   X15 dc = _total1_.height() - _total0_.height();
 2218 |     | 
 2219 |     |   // Next we calculate
 2220 |     |   //
 2221 |     |   //  'q2 := 2 * (cTotal1 - cTotal0)'
 2222 |     |   //
 2223 |     |   // The multiplication is safe because 'twoX59' is positive and the output
 2224 |     |   // does not exceed '64 + 16 == 80' bits.
 2225 |     |   X74 q2 = twoX59.times(dc);
 2226 |     | 
 2227 |     |   // The second coefficient is calculated as
 2228 |     |   //
 2229 |     |   // 'q1 := (cTotal1 - cTotal0) * (2 + |qTotal1 - qBegin|)
 2230 |     |   //      - cTotal1 * |qTotal1 - qTotal0|'
 2231 |     | 
 2232 |     |   // The multiplication 'db.times(_total1_.height())' is safe because the
 2233 |     |   // output does not exceed 80 bits.
 2234 |     |   //
 2235 |     |   // The subtraction is unsafe and 'q1' may be negative.
 2236 |     |   X74 q1 = q2 - db.times(_total1_.height());
 2237 |     | 
 2238 |     |   // The subtractions are safe because of the last input requirement and the
 2239 |     |   // fact that
 2240 |     |   //
 2241 |     |   //  'getDirection() == getZeroForOne() == left'.
 2242 |     |   //
 2243 |     |   // Lastly, the additions are safe because neither values exceed 81 bits.
 2244 |     |   q1 = left ? 
 2245 |     |     q1 + (_begin_.log() - _total1_.log()).times(dc) : 
 2246 |     |     q1 + (_total1_.log() - _begin_.log()).times(dc);
 2247 |     | 
 2248 |     |   // Next, in order to compute 'q0', if 'left == false', we calculate:
 2249 |     |   //
 2250 |     |   //        incomingLimit          db
 2251 |     |   //  '---------------------- * --------- * exp(- qBegin / 2) ==
 2252 |     |   //    (2 ** 216) * exp(-8)     2 ** 59
 2253 |     |   //
 2254 |     |   //    incomingLimit * db * ((2 ** 216) * exp(- 8 - qBegin / 2))
 2255 |     |   //   ----------------------------------------------------------- ==
 2256 |     |   //                  (2 ** (216 + 59)) * exp(-16)
 2257 |     |   //
 2258 |     |   //    incomingLimit * db * _begin_.sqrt(false)
 2259 |     |   //   ------------------------------------------'
 2260 |     |   //          (2 ** (216 + 59)) * exp(-16)
 2261 |     |   //
 2262 |     |   // and if 'left == true', we calculate:
 2263 |     |   //
 2264 |     |   //        incomingLimit          db
 2265 |     |   //  '---------------------- * --------- * exp(+ qBegin / 2) ==
 2266 |     |   //    (2 ** 216) * exp(-8)     2 ** 59
 2267 |     |   //
 2268 |     |   //    incomingLimit * db * ((2 ** 216) * exp(- 8 + qBegin / 2))
 2269 |     |   //   ----------------------------------------------------------- ==
 2270 |     |   //                  (2 ** (216 + 59)) * exp(-16)
 2271 |     |   //
 2272 |     |   //    incomingLimit * db * _begin_.sqrt(true)
 2273 |     |   //   -----------------------------------------'.
 2274 |     |   //          (2 ** (216 + 59)) * exp(-16)
 2275 |     |   //
 2276 |     |   // The three inputs of 'mulDivByExpInv16' are non-negative and overflow is
 2277 |     |   // not possible because
 2278 |     |   //
 2279 |     |   //    incomingLimit * db * _begin_.sqrt(left)
 2280 |     |   //  '----------------------------------------- < 
 2281 |     |   //          (2 ** (216 + 59)) * exp(-16)
 2282 |     |   //
 2283 |     |   //    (2 ** 216) * (2 ** 64) * (2 ** 216)
 2284 |     |   //   ------------------------------------- == 
 2285 |     |   //       (2 ** (216 + 59)) * exp(-16)
 2286 |     |   //
 2287 |     |   //   32 * exp(16) * oneX216 < 2 ** 256 - 1'.
 2288 |     |   //
 2289 |     |   // Hence, the requirements of 'mulDivByExpInv16' are satisfied.
 2290 |     |   //
 2291 |     |   // Additionally, 'toX216' does not overflow because
 2292 |     |   //
 2293 |     |   //  '- (2 ** 80) < q1 < + (2 ** 80)'.
 2294 |     |   //
 2295 |     |   // The subtraction is unsafe and may be negative.
 2296 |     |   X216 q0 = 
 2297 |     |     q1.toX216() - db.mulDivByExpInv16(_begin_.sqrt(left), incomingLimit);
 2298 |     | 
 2299 |     |   // The initial value for 'x' is calculated here. The subtractions are safe
 2300 |     |   // because as we argued before, if 'left == false', then
 2301 |     |   //
 2302 |     |   //  'qTotal0 <= qBegin <= qTarget <= qTotal1'
 2303 |     |   //
 2304 |     |   // and if 'left == true', then
 2305 |     |   //
 2306 |     |   //  'qTotal1 <= qTarget <= qBegin <= qTotal0'.
 2307 |     |   X59 xLimit = 
 2308 |     |     left ? _begin_.log() - _target_.log() : _target_.log() - _begin_.log();
 2309 |     | 
 2310 |     |   X59 x = xLimit;
 2311 |     |   if (X59.unwrap(xLimit) <= X216.unwrap(incoming)) {
 2312 |     |     // All three inputs of 'cheapMulDiv' are non-negative.
 2313 |     |     //
 2314 |     |     // Due to the prior check, 'incomingLimit < incoming'. Additionally, due to
 2315 |     |     // the above condition, we have 'xLimit <= incoming'. Hence,
 2316 |     |     //
 2317 |     |     //  'xLimit * incomingLimit < incoming * (incoming - 1)'
 2318 |     |     //
 2319 |     |     // and the requirement of 'cheapMulDiv' is met.
 2320 |     |     //
 2321 |     |     // Signed comparison is valid because the first term is a positive constant
 2322 |     |     // and the second term is non-negative.
 2323 |     |     x = max(epsilonX59, xLimit.cheapMulDiv(incomingLimit, incoming));
 2324 |     |   }
 2325 |     | 
 2326 |     |   while (true) {
 2327 |     |     // For each iteration, we evaluate 'g(x)' and 'h(x)' in 'X74' and 'X216'
 2328 |     |     // representations, respectively.
 2329 |     |     //
 2330 |     |     // 'x.times(dc)' is safe because 'x' is not less than 'epsilonX59' due to
 2331 |     |     // the above check and we have already checked that 'dc' is nonnegative.
 2332 |     |     //
 2333 |     |     // 'g.toX216()' is safe because:
 2334 |     |     //
 2335 |     |     //   '- (2 ** 81) < x.times(dc) - q1 < + (2 ** 81)'.
 2336 |     |     //
 2337 |     |     // The input requirements of 'expInverse' are satisfied because 'x' is not
 2338 |     |     // less than 'epsilonX59' and
 2339 |     |     //
 2340 |     |     //  'x <= |_target_.log() - _begin_.log()| < (2 ** 64) / 3'.
 2341 |     |     //
 2342 |     |     // Additionally,
 2343 |     |     //
 2344 |     |     //  'x.expInverse() == (2 ** 256) * exp(- x / (2 ** 60))
 2345 |     |     //                  >= (2 ** 256) * exp(- qSpacing / 2)
 2346 |     |     //                  >= (2 ** 256) * exp(- 16 / 3) > 2 ** 248
 2347 |     |     //
 2348 |     |     // Hence,
 2349 |     |     //
 2350 |     |     //  '(x.expInverse() >> 40) < oneX216'
 2351 |     |     //
 2352 |     |     // which means that casting to 'int256' is safe and the product
 2353 |     |     //
 2354 |     |     //  'q0 * X216.wrap(int256(x.expInverse() >> 40))'
 2355 |     |     //
 2356 |     |     // does not overflow.
 2357 |     |     //
 2358 |     |     // However, the addition
 2359 |     |     //
 2360 |     |     //   'h = g.toX216() + q0 * X216.wrap(int256(x.expInverse() >> 40))'
 2361 |     |     //
 2362 |     |     // is unsafe and 'h' may be negative.
 2363 |     |     //
 2364 |     |     // On the other hand, the addition 'g + q2' is safe and the outcome is
 2365 |     |     // positive because
 2366 |     |     //
 2367 |     |     //   'g(x) := (cTotal1 - cTotal0) * x - q1 + q2
 2368 |     |     //
 2369 |     |     //         == (cTotal1 - cTotal0) * x + 
 2370 |     |     //            2 * (cTotal1 - cTotal0) - 
 2371 |     |     //            (cTotal1 - cTotal0) * (2 + |qTotal1 - qBegin|) + 
 2372 |     |     //            cTotal1 * |qTotal1 - qTotal0|
 2373 |     |     //
 2374 |     |     //         == (cTotal1 - cTotal0) * x + 
 2375 |     |     //            cTotal0 * |qTotal1 - qBegin| + 
 2376 |     |     //            cTotal1 * (|qTotal1 - qTotal0| - |qTotal1 - qBegin|)
 2377 |     |     //
 2378 |     |     //         > (cTotal1 - cTotal0) * x >= 1 / ((2 ** 15) * (2 ** 59)) > 0'
 2379 |     |     //
 2380 |     |     // where the first inequality is concluded from the fact that, if
 2381 |     |     // 'left == false', then
 2382 |     |     //
 2383 |     |     //  'qTotal0 <= qBegin <= qTarget <= qTotal1'
 2384 |     |     //
 2385 |     |     // and if 'left == true', then
 2386 |     |     //
 2387 |     |     //  'qTotal1 <= qTarget <= qBegin <= qTotal0'.
 2388 |     |     //
 2389 |     |     // Also, 'cTotal1 - cTotal0 >= 1 / (2 ** 15)' is concluded from the initial
 2390 |     |     // check for the determination of 'exactAmount', because if
 2391 |     |     // 'cTotal1 == cTotal0 == 0', then we have 'exactAmount == false' and this
 2392 |     |     // part of the code would not be reached. Hence, 'g' is positive which will
 2393 |     |     // be used later.
 2394 |     |     X74 g = x.times(dc) - q1;
 2395 |     |     X216 h = g.toX216() + q0 * X216.wrap(int256(x.expInverse() >> 40));
 2396 |     |     g = g + q2;
 2397 |     | 
 2398 |     |     // Next, we calculate the following Halley step:
 2399 |     |     //
 2400 |     |     //                           2 * (h(x) / g(x))
 2401 |     |     //  'step = -----------------------------------------------------'
 2402 |     |     //           1 - (h(x) / g(x)) / 2 - (h(x) / g(x)) * (dc / g(x))
 2403 |     |     //
 2404 |     |     // in 'X59' representation.
 2405 |     |     //
 2406 |     |     // The numerator is in 'X142' representation.
 2407 |     |     // The denominator is in 'X83' representation.
 2408 |     |     X59 step;
 2409 |     |     uint256 denominator;
 2410 |     |     assembly {
 2411 |     |       // The division is safe because 'g' is positive as we argued before.
 2412 |     |       let h_over_g_X142 := sdiv(h, g) // h(x) / g(x)
 2413 |     |       denominator := sub(
 2414 |     |         shl(83, 1), // oneX83
 2415 |     |         add(
 2416 |     |           // Here, 'h_over_g_X142' is shifted to the right by
 2417 |     |           // '60 == 142 - 83 + 1' bits where '1' appears because we are
 2418 |     |           // dividing by two. '142' appears because we are casting from the 
 2419 |     |           // 'X142' representation and '83' appears because we are casting to  
 2420 |     |           // the 'X83' representation.
 2421 |     |           sar(60, h_over_g_X142), // (h(x) / g(x)) / 2
 2422 |     |           sdiv(mul(h_over_g_X142, dc), g) // (h(x) / g(x)) * (dc / g(x))
 2423 |     |         )
 2424 |     |       ) // 1 - (h(x) / g(x)) / 2 - (h(x) / g(x)) * (dc / g(x))
 2425 |     |       step := sdiv(
 2426 |     |         add(h_over_g_X142, h_over_g_X142), // 2 * (h(x) / g(x))
 2427 |     |         denominator
 2428 |     |       )
 2429 |     |     }
 2430 |     | 
 2431 |     |     if (step == zeroX59) {
 2432 |     |       require(denominator != 0, SearchingForIncomingTargetFailed());
 2433 |     |       break;
 2434 |     |     }
 2435 |     | 
 2436 |     |     // The solution is capped by 'epsilonX59' and 'xLimit'. Hence, we do not
 2437 |     |     // need to argue whether the addition 'x - step' is safe or not.
 2438 |     |     x = min(max(epsilonX59, x - step), xLimit);
 2439 |     |   }
 2440 |     | 
 2441 |     |   // The subtraction and the addition are safe because if 'left == false':
 2442 |     |   //
 2443 |     |   //  '0 < x <= xLimit := qTarget - qBegin',
 2444 |     |   //
 2445 |     |   // and if 'left == true':
 2446 |     |   //
 2447 |     |   //  '0 < x <= xLimit := qBegin - qTarget'.
 2448 |     |   //
 2449 |     |   x = min(x + epsilonX59, xLimit);
 2450 |     |   x = left ? _begin_.log() - x : _begin_.log() + x;
 2451 |     | 
 2452 |     |   // The output should be stored in both of the memory spaces that are pointed
 2453 |     |   // to by '_overshoot_' and '_target_'.
 2454 |     |   //
 2455 |     |   // The requirements of 'storePrice' and 'incoming' are satisfied because
 2456 |     |   //
 2457 |     |   //  'min(qBegin, qTarget) <= x <= max(qBegin, qTarget)'.
 2458 |     |   //
 2459 |     |   _overshoot_.storePrice(x);
 2460 |     | 
 2461 |     |   // As argued before, if 'getDirection() == false', then
 2462 |     |   //
 2463 |     |   //  'qTotal0 <= qBegin <= qOvershoot <= qTarget <= qTotal1'.
 2464 |     |   //
 2465 |     |   // and if 'getDirection() == true', then
 2466 |     |   //
 2467 |     |   //  'qTotal1 <= qTarget <= qOvershoot <= qBegin <= qTotal0'.
 2468 |     |   //
 2469 |     |   // Additionally, since the vertical coordinates of kernel are monotonic, we
 2470 |     |   // have 'cTotal0 <= cTotal1' and the input requirements of 'incoming' are
 2471 |     |   // satisfied.
 2472 |     |   incoming = _total0_.incoming(_begin_, _overshoot_);
 2473 |     | 
 2474 |     |   // 'x' is moved backward to ensure that the resulting integral is an under
 2475 |     |   // approximation.
 2476 |     |   while (incoming > incomingLimit) {
 2477 |     |     // All safety requirements are satisfied here, because:
 2478 |     |     //
 2479 |     |     //  'incomingLimit < _total0_.incoming(_begin_, _target_)'.
 2480 |     |     //
 2481 |     |     // Hence, the loop is stopped before we reach 'qTarget'.
 2482 |     |     x = left ? x + epsilonX59 : x - epsilonX59;
 2483 |     | 
 2484 |     |     // Due to the above argument, if 'left == false' then
 2485 |     |     //
 2486 |     |     //  'qOvershoot + 1 / (2 ** 59) < qTarget <= qUpper'
 2487 |     |     //
 2488 |     |     // and if 'left == true' then
 2489 |     |     //
 2490 |     |     //  'qLower <= qTarget < qOvershoot - 1 / (2 ** 59)'.
 2491 |     |     //
 2492 |     |     // Hence the input requirements of 'moveOvershootByEpsilon' are satisfied.
 2493 |     |     moveOvershootByEpsilon(!left);
 2494 |     | 
 2495 |     |     // As argued before, if 'getDirection() == false', then
 2496 |     |     //
 2497 |     |     //  'qTotal0 <= qBegin <= qOvershoot <= qTarget <= qTotal1'.
 2498 |     |     //
 2499 |     |     // and if 'getDirection() == true', then
 2500 |     |     //
 2501 |     |     //  'qTotal1 <= qTarget <= qOvershoot <= qBegin <= qTotal0'.
 2502 |     |     //
 2503 |     |     // Additionally, since the vertical coordinates of kernel are monotonic, we
 2504 |     |     // have 'cTotal0 <= cTotal1' and the input requirements of 'incoming' are
 2505 |     |     // satisfied.
 2506 |     |     incoming = _total0_.incoming(_begin_, _overshoot_);
 2507 |     |   }
 2508 |     | 
 2509 |     |   // The output should be stored in both of the memory spaces that are pointed
 2510 |     |   // to by '_overshoot_' and '_target_'.
 2511 |     |   _target_.copyPrice(_overshoot_);
 2512 |     | 
 2513 |     |   return (true, incoming);
 2514 |     | }
 2515 |     | 
 2516 |     | /// @notice Enumerates the pieces of the liquidity distribution function
 2517 |     | /// 'k(w(.))' in search for the logarithmic price 'qTarget' which satisfies
 2518 |     | /// either of the following two conditions:
 2519 |     | ///
 2520 |     | ///  - 'qLimitWithinInterval == qTarget', or
 2521 |     | ///
 2522 |     | ///  - 'integralLimit == (
 2523 |     | ///       getExactInput() ? incomingCurrentToTarget : currentToTarget
 2524 |     | ///     )'.
 2525 |     | ///
 2526 |     | /// As explained in 'Memory.sol', the boundaries of the current piece under
 2527 |     | /// exploration is given as:
 2528 |     | ///
 2529 |     | ///  'qBegin := getDirection() ? 
 2530 |     | ///             min(q[indexCurve + 2], qTotal0) : 
 2531 |     | ///             max(q[indexCurve + 2], qTotal0)',
 2532 |     | ///
 2533 |     | ///  'qTarget := (
 2534 |     | ///                getDirection() == getZeroForOne()
 2535 |     | ///              ) ? (
 2536 |     | ///                getDirection() ? 
 2537 |     | ///                max(max(qEnd, qTotal1), qLimitWithinInterval) : 
 2538 |     | ///                min(min(qEnd, qTotal1), qLimitWithinInterval)
 2539 |     | ///              ) : (
 2540 |     | ///                getDirection() ? 
 2541 |     | ///                max(qEnd, qTotal1) : 
 2542 |     | ///                min(qEnd, qTotal1)
 2543 |     | ///              )'.
 2544 |     | ///
 2545 |     | /// The present function transitions to the next piece of 'k(w(.))' by updating 
 2546 |     | /// the appropriate values in memory and by incrementing the following
 2547 |     | /// integrals:
 2548 |     | ///  
 2549 |     | ///  - 'currentToTarget',
 2550 |     | ///
 2551 |     | ///  - 'incomingCurrentToTarget',
 2552 |     | ///
 2553 |     | ///  - 'currentToOrigin',
 2554 |     | ///
 2555 |     | ///  - 'originToOvershoot'.
 2556 |     | ///
 2557 |     | /// --------------------------------------------------------------------------- 
 2558 |     | ///
 2559 |     | /// The underflow of
 2560 |     | ///
 2561 |     | ///  'getIntegralLimit() - getExactInput() ? 
 2562 |     | ///                        _incomingCurrentToTarget_.integral() : 
 2563 |     | ///                        _currentToTarget_.integral()'
 2564 |     | ///
 2565 |     | /// should be avoided externally.
 2566 |     | ///
 2567 |     | /// Out of range values for 'indexKernelTotal' should be avoided externally.
 2568 |     | ///
 2569 |     | /// Underflow of 'indexCurve' should be avoided externally.
 2570 |     | function moveTarget() pure returns (
 2571 |     |   bool stop
 2572 |     | ) {
 2573 |     |   // According to the above definitions for 'qBegin' and 'qTarget', if
 2574 |     |   // 'getDirection() == false', then we have:
 2575 |     |   //
 2576 |     |   //  'qTotal0 <= qBegin <= qTarget <= qTotal1'.
 2577 |     |   //
 2578 |     |   // In this case, if 'qTarget == qTotal1' as illustrated below,
 2579 |     |   //
 2580 |     |   //      +---------+---------+
 2581 |     |   //      |         |         |
 2582 |     |   //   qTotal0   qBegin    qTotal1
 2583 |     |   //                          |
 2584 |     |   //                       qTarget
 2585 |     |   //
 2586 |     |   // then 'indexKernelTotal' is incremented and the next piece of 'k(.)' is
 2587 |     |   // loaded and stored in the memory spaces that are pointed to by '_total0_'
 2588 |     |   // and '_total1_':
 2589 |     |   //
 2590 |     |   //      +---------+---------+-------------------+
 2591 |     |   //                |         |                   |
 2592 |     |   //             qBegin    qTotal0             qTotal1
 2593 |     |   //                          |
 2594 |     |   //                       qTarget
 2595 |     |   //
 2596 |     |   // If 'getDirection() == true', then we have:
 2597 |     |   //
 2598 |     |   //  'qTotal1 <= qTarget <= qBegin <= qTotal0'.
 2599 |     |   //
 2600 |     |   // In this case, if 'qTarget == qTotal1' as illustrated below,
 2601 |     |   //
 2602 |     |   //                          +---------+---------+
 2603 |     |   //                          |         |         |
 2604 |     |   //                       qTotal1   qBegin    qTotal0
 2605 |     |   //                          |
 2606 |     |   //                       qTarget
 2607 |     |   //
 2608 |     |   // then 'indexKernelTotal' is incremented and the next piece of 'k(.)' is
 2609 |     |   // loaded and stored in the memory spaces that are pointed to by '_total0_'
 2610 |     |   // and '_total1_':
 2611 |     |   //
 2612 |     |   //      +-------------------+---------+---------+
 2613 |     |   //      |                   |         |
 2614 |     |   //   qTotal1             qTotal0   qBegin
 2615 |     |   //                          |
 2616 |     |   //                       qTarget
 2617 |     |   //
 2618 |     |   // Out of range values for 'indexKernelTotal' are avoided because of an
 2619 |     |   // input requirement for the present function.
 2620 |     |   if (_target_.log() == _total1_.log()) moveBreakpointTotal();
 2621 |     | 
 2622 |     |   // The current direction is loaded from memory.
 2623 |     |   bool direction = getDirection();
 2624 |     | 
 2625 |     |   // According to the above definitions for 'qBegin' and 'qTarget', if
 2626 |     |   // 'getDirection() == false', then we have:
 2627 |     |   //
 2628 |     |   //  'q[indexCurve + 2] <= qBegin <= qTarget <= qEnd'.
 2629 |     |   //
 2630 |     |   // In this case, if 'qTarget == qEnd' as illustrated below,
 2631 |     |   //
 2632 |     |   //         w(q)
 2633 |     |   //          ^
 2634 |     |   //  spacing |                                              /
 2635 |     |   //          |                                             /
 2636 |     |   //          |                                            /
 2637 |     |   //          |                                           /
 2638 |     |   //          |                                          /
 2639 |     |   //          |                                         /
 2640 |     |   //          |                                        /
 2641 |     |   //          |                                       /
 2642 |     |   //          |                                      /
 2643 |     |   //          |                                     /
 2644 |     |   //          |                                    /
 2645 |     |   //          |\
 2646 |     |   //          | \
 2647 |     |   //          |  \
 2648 |     |   //          |   \
 2649 |     |   //          |    \
 2650 |     |   //          |     \
 2651 |     |   //          |      \
 2652 |     |   //          |       \
 2653 |     |   //          |        \
 2654 |     |   //          |         \
 2655 |     |   //          |          \
 2656 |     |   //          |                                  /
 2657 |     |   //          |                                 /
 2658 |     |   //          |                                /
 2659 |     |   //          |                               /
 2660 |     |   //          |                              /
 2661 |     |   //          |                             /
 2662 |     |   //          |                            /
 2663 |     |   //          |                           /
 2664 |     |   //          |                          /
 2665 |     |   //          |                         /
 2666 |     |   //          |                        /
 2667 |     |   //          |            \
 2668 |     |   //          |             \
 2669 |     |   //          |              \
 2670 |     |   //          |               \
 2671 |     |   //          |                \
 2672 |     |   //          |                 \
 2673 |     |   //          |                  \
 2674 |     |   //          |                   \
 2675 |     |   //          |                    \
 2676 |     |   //          |                     \
 2677 |     |   //          |                      \
 2678 |     |   //        0 +-----------+-----------+-----+-----+-----+-----+> q
 2679 |     |   //                      |           |     |     |
 2680 |     |   //                   qOrigin        |  qBegin  qEnd
 2681 |     |   //                                  |           |
 2682 |     |   //                                  |        qTarget
 2683 |     |   //                                  |
 2684 |     |   //                          q[indexCurve + 2]
 2685 |     |   //
 2686 |     |   // then 'indexCurve' is decremented, the direction is flipped and the next
 2687 |     |   // phase of 'w(.)' is loaded by setting:
 2688 |     |   //
 2689 |     |   //  'qEnd := q[indexCurve]'
 2690 |     |   //
 2691 |     |   //  'qOrigin := q[indexCurve + 1]'
 2692 |     |   //
 2693 |     |   //  'qBegin := q[indexCurve + 2]'
 2694 |     |   //
 2695 |     |   // which is illustrated as follows:
 2696 |     |   //
 2697 |     |   //         w(q)
 2698 |     |   //          ^
 2699 |     |   //  spacing |                                              /
 2700 |     |   //          |                                             /
 2701 |     |   //          |                                            /
 2702 |     |   //          |                                           /
 2703 |     |   //          |                                          /
 2704 |     |   //          |                                         /
 2705 |     |   //          |                                        /
 2706 |     |   //          |                                       /
 2707 |     |   //          |                                      /
 2708 |     |   //          |                                     /
 2709 |     |   //          |                                    /
 2710 |     |   //          |\
 2711 |     |   //          | \
 2712 |     |   //          |  \
 2713 |     |   //          |   \
 2714 |     |   //          |    \
 2715 |     |   //          |     \
 2716 |     |   //          |      \
 2717 |     |   //          |       \
 2718 |     |   //          |        \
 2719 |     |   //          |         \
 2720 |     |   //          |          \
 2721 |     |   //          |                                  /
 2722 |     |   //          |                                 /
 2723 |     |   //          |                                /
 2724 |     |   //          |                               /
 2725 |     |   //          |                              /
 2726 |     |   //          |                             /
 2727 |     |   //          |                            /
 2728 |     |   //          |                           /
 2729 |     |   //          |                          /
 2730 |     |   //          |                         /
 2731 |     |   //          |                        /
 2732 |     |   //          |            \
 2733 |     |   //          |             \
 2734 |     |   //          |              \
 2735 |     |   //          |               \
 2736 |     |   //          |                \
 2737 |     |   //          |                 \
 2738 |     |   //          |                  \
 2739 |     |   //          |                   \
 2740 |     |   //          |                    \
 2741 |     |   //          |                     \
 2742 |     |   //          |                      \
 2743 |     |   //        0 +-----------+-----------+-----------+-----------+> q
 2744 |     |   //          |           |                       |
 2745 |     |   //        qEnd       qBegin                  qOrigin
 2746 |     |   //                      |                       |
 2747 |     |   //              q[indexCurve + 2]            qTarget
 2748 |     |   //
 2749 |     |   // If 'getDirection() == true', then we have:
 2750 |     |   //
 2751 |     |   //  'qEnd <= qTarget <= qBegin <= q[indexCurve + 2]'.
 2752 |     |   //
 2753 |     |   // and a similar argument can be made.
 2754 |     |   if (_target_.log() == _end_.log()) {
 2755 |     |     // Once we move the phase, the direction flips and 'qOrigin' will be moved
 2756 |     |     // to 'qEnd'. Hence, the following integral
 2757 |     |     //
 2758 |     |     //                             - 8
 2759 |     |     //    originToOvershoot      e
 2760 |     |     //  '------------------- == ------- * (
 2761 |     |     //        2 ** 216             2
 2762 |     |     //
 2763 |     |     //     getZeroForOne() ? 
 2764 |     |     //
 2765 |     |     //       / qOrigin
 2766 |     |     //      |    + h / 2
 2767 |     |     //      |  e         k(qOrigin - h) dh :
 2768 |     |     //      |
 2769 |     |     //     / qEnd
 2770 |     |     //
 2771 |     |     //       / qEnd
 2772 |     |     //      |    - h / 2
 2773 |     |     //      |  e         k(h - qOrigin) dh
 2774 |     |     //      |
 2775 |     |     //     / qOrigin
 2776 |     |     //
 2777 |     |     //   )'
 2778 |     |     //
 2779 |     |     // should be transformed to
 2780 |     |     //
 2781 |     |     //                             - 8
 2782 |     |     //    originToOvershoot      e
 2783 |     |     //  '------------------- := ------- * (
 2784 |     |     //        2 ** 216             2
 2785 |     |     //
 2786 |     |     //     getZeroForOne() ? 
 2787 |     |     //
 2788 |     |     //       / qOrigin
 2789 |     |     //      |    - h / 2
 2790 |     |     //      |  e         k(h - qEnd) dh :
 2791 |     |     //      |
 2792 |     |     //     / qEnd
 2793 |     |     //
 2794 |     |     //       / qEnd
 2795 |     |     //      |    + h / 2
 2796 |     |     //      |  e         k(qEnd - h) dh
 2797 |     |     //      |
 2798 |     |     //     / qOrigin
 2799 |     |     //
 2800 |     |     //   )'
 2801 |     |     //
 2802 |     |     // Notice that at this stage 'overshoot' and 'target' are equal.
 2803 |     |     //
 2804 |     |     // The loaded integral does not exceed 216-bits and hence, the input
 2805 |     |     // requirement of shift is satisfied.
 2806 |     |     _originToOvershoot_.setIntegral(
 2807 |     |       _originToOvershoot_.integral().shift(_target_, _origin_, direction)
 2808 |     |     );
 2809 |     | 
 2810 |     |     // Underflow of 'indexCurve' is avoided externally via an input requirement
 2811 |     |     // of the present function.
 2812 |     |     direction = movePhase();
 2813 |     |   }
 2814 |     | 
 2815 |     |   // If the phase is moved, then we have:
 2816 |     |   //
 2817 |     |   //  'qBegin == q[indexCurve + 2]'.
 2818 |     |   //
 2819 |     |   // If the phase is not moved, then the kernel piece is moved and we have:
 2820 |     |   //
 2821 |     |   //  'qBegin <= qTarget == qTotal0'.
 2822 |     |   //
 2823 |     |   // In both cases, we need to set:
 2824 |     |   //
 2825 |     |   //  'qBegin := direction ? min(qBegin, qTotal0) : max(qBegin, qTotal0)'
 2826 |     |   //
 2827 |     |   // which is equivalent to setting:
 2828 |     |   //
 2829 |     |   //  'qBegin := qTotal0'
 2830 |     |   //
 2831 |     |   // if and only if 'direction != (qBegin < qTotal0)'.
 2832 |     |   //
 2833 |     |   // Signed comparison is valid because as we argued before in this script,
 2834 |     |   // both 'qBegin' and 'qTotal0' are greater than '0' and less than '32'. This
 2835 |     |   // is due to the custom error 'BlankIntervalsShouldBeAvoided' ensures that
 2836 |     |   // '16 + qLower' is greater than 'qSpacing' and '16 + qUpper' is smaller than
 2837 |     |   // '32 - qSpacing'.
 2838 |     |   if (direction != (_begin_.log() < _total0_.log())) {
 2839 |     |     _begin_.copyPrice(_total0_);
 2840 |     |   }
 2841 |     | 
 2842 |     |   // Next, we need to set:
 2843 |     |   //
 2844 |     |   //  'qTarget := direction ? min(qEnd, qTotal1) : max(qEnd, qTotal1)'
 2845 |     |   //
 2846 |     |   // which is equivalent to setting:
 2847 |     |   //
 2848 |     |   //  'qTarget := qTotal1'
 2849 |     |   //
 2850 |     |   // if and only if 'direction == (qEnd <= qTotal1)' and
 2851 |     |   //
 2852 |     |   //  'qTarget := qEnd'
 2853 |     |   //
 2854 |     |   // otherwise.
 2855 |     |   //
 2856 |     |   // Signed comparison is valid because as we argued before in this script,
 2857 |     |   // both 'qEnd' and 'qTotal1' are greater than '0' and less than '32'. This
 2858 |     |   // is due to the custom error 'BlankIntervalsShouldBeAvoided' ensures that
 2859 |     |   // '16 + qLower' is greater than 'qSpacing' and '16 + qUpper' is smaller than
 2860 |     |   // '32 - qSpacing'.
 2861 |     |   _target_.copyPrice(
 2862 |     |     (direction == (_end_.log() <= _total1_.log())) ? _total1_ : _end_
 2863 |     |   );
 2864 |     | 
 2865 |     |   // Next, if 'direction == getZeroForOne()', we increment the integrals:
 2866 |     |   //
 2867 |     |   //  - 'currentToTarget',
 2868 |     |   //  - 'incomingCurrentToTarget',
 2869 |     |   //
 2870 |     |   // and search for 'qTarget'. Otherwise, we increment the integral:
 2871 |     |   //
 2872 |     |   //  - 'currentToOrigin'
 2873 |     |   //
 2874 |     |   // and in both cases we increment 'originToOvershoot' as well.
 2875 |     |   X216 outgoing;
 2876 |     |   if (direction == getZeroForOne()) {
 2877 |     |     // 'qLimitWithinInterval' is loaded from the memory.
 2878 |     |     X59 logPriceLimitOffsettedWithinInterval = 
 2879 |     |       getLogPriceLimitOffsettedWithinInterval();
 2880 |     | 
 2881 |     |     // If 'qTarget' encounters 'qLimitWithinInterval', then we set 'qTarget' as
 2882 |     |     // 'qLimitWithinInterval'.
 2883 |     |     //
 2884 |     |     // Signed comparison is valid as we argued before.
 2885 |     |     if (direction != (logPriceLimitOffsettedWithinInterval < _target_.log())) {
 2886 |     |       // '_target_' is a constant value which satisfies the input requirement
 2887 |     |       // of 'storePrice'.
 2888 |     |       //
 2889 |     |       // Also we have: 
 2890 |     |       //
 2891 |     |       //  '0 < qLower <= qLimitWithinInterval <= qUpper < 2 ** 64'
 2892 |     |       //
 2893 |     |       // which means that 'logPriceLimitOffsettedWithinInterval' satisfies the
 2894 |     |       // input requirement of 'storePrice'.
 2895 |     |       _target_.storePrice(logPriceLimitOffsettedWithinInterval);
 2896 |     |     }
 2897 |     | 
 2898 |     |     X216 incoming;
 2899 |     |     // Check if 'amountSpecified' is incoming or outgoing.
 2900 |     |     if (getExactInput()) {
 2901 |     |       // In this case, we search for a 'qTarget' which satisfies
 2902 |     |       //
 2903 |     |       //                              - 8     / qTarget
 2904 |     |       //    getIntegralLimit()      e        |    + h / 2
 2905 |     |       //  '-------------------- == ------- * |  e         k(w(h)) dh',
 2906 |     |       //         2 ** 216             2      |
 2907 |     |       //                                    / qCurrent
 2908 |     |       //
 2909 |     |       // if 'zeroForOne == false' and satisfies:
 2910 |     |       //
 2911 |     |       //                              - 8     / qCurrent
 2912 |     |       //    getIntegralLimit()      e        |    - h / 2
 2913 |     |       //  '-------------------- == ------- * |  e         k(w(h)) dh',
 2914 |     |       //         2 ** 216             2      |
 2915 |     |       //                                    / qTarget
 2916 |     |       //
 2917 |     |       // if 'zeroForOne == true'. If no solution exists, then the integral
 2918 |     |       // within the whole range from 'min(qCurrent, qTarget)' to
 2919 |     |       // 'max(qCurrent, qTarget)' is calculated to be used as an increment to
 2920 |     |       // update 'incomingCurrentToTarget'.
 2921 |     |       //
 2922 |     |       // The input requirement 'getDirection() == getZeroForOne()' is checked
 2923 |     |       // by the above 'if'.
 2924 |     |       //
 2925 |     |       // The underflow of
 2926 |     |       //
 2927 |     |       //  'getIntegralLimit() - _incomingCurrentToTarget_.integral()'
 2928 |     |       //
 2929 |     |       // is not possible because of the input requirement of the present
 2930 |     |       // function.
 2931 |     |       (stop, incoming) = searchIncomingTarget();
 2932 |     | 
 2933 |     |       // As argued before, if 'getDirection() == false', then
 2934 |     |       //
 2935 |     |       //  'qTotal0 <= qBegin <= qTarget <= qTotal1'.
 2936 |     |       //
 2937 |     |       // and if 'getDirection() == true', then
 2938 |     |       //
 2939 |     |       //  'qTotal1 <= qTarget <= qBegin <= qTotal0'.
 2940 |     |       //
 2941 |     |       // Additionally, since the vertical coordinates of kernel are monotonic,
 2942 |     |       // we have 'cTotal0 <= cTotal1' and the input requirements of 'outgoing'
 2943 |     |       // are satisfied.
 2944 |     |       outgoing = _total0_.outgoing(_begin_, _target_);
 2945 |     |     } else {
 2946 |     |       // In this case, we search for a 'qTarget' which satisfies
 2947 |     |       //
 2948 |     |       //                              - 8     / qTarget
 2949 |     |       //    getIntegralLimit()      e        |    - h / 2
 2950 |     |       //  '-------------------- == ------- * |  e         k(w(h)) dh',
 2951 |     |       //         2 ** 216             2      |
 2952 |     |       //                                    / qCurrent
 2953 |     |       //
 2954 |     |       // if 'zeroForOne == false' and satisfies:
 2955 |     |       //
 2956 |     |       //                              - 8     / qCurrent
 2957 |     |       //    getIntegralLimit()      e        |    + h / 2
 2958 |     |       //  '-------------------- == ------- * |  e         k(w(h)) dh',
 2959 |     |       //         2 ** 216             2      |
 2960 |     |       //                                    / qTarget
 2961 |     |       //
 2962 |     |       // if 'zeroForOne == true'. If no solution exists, then the integral
 2963 |     |       // within the whole range from 'min(qCurrent, qTarget)' to
 2964 |     |       // 'max(qCurrent, qTarget)' is calculated to be used as an increment to
 2965 |     |       // update 'currentToTarget'.
 2966 |     |       //
 2967 |     |       // The input requirement 'getDirection() == getZeroForOne()' is checked
 2968 |     |       // by the above 'if'.
 2969 |     |       //
 2970 |     |       // The underflow of
 2971 |     |       //
 2972 |     |       //  'getIntegralLimit() - _currentToTarget_.integral()'
 2973 |     |       //
 2974 |     |       // is not possible because of the input requirement of the present
 2975 |     |       // function.
 2976 |     |       (stop, outgoing) = searchOutgoingTarget();
 2977 |     | 
 2978 |     |       // As argued before, if 'getDirection() == false', then
 2979 |     |       //
 2980 |     |       //  'qTotal0 <= qBegin <= qTarget <= qTotal1'.
 2981 |     |       //
 2982 |     |       // and if 'getDirection() == true', then
 2983 |     |       //
 2984 |     |       //  'qTotal1 <= qTarget <= qBegin <= qTotal0'.
 2985 |     |       //
 2986 |     |       // Additionally, since the vertical coordinates of kernel are monotonic,
 2987 |     |       // we have 'cTotal0 <= cTotal1' and the input requirements of 'incoming'
 2988 |     |       // are satisfied.
 2989 |     |       incoming = _total0_.incoming(_begin_, _target_);
 2990 |     |     }
 2991 |     | 
 2992 |     |     // Next, 'currentToTarget' is incremented with 'outgoing'.
 2993 |     |     //
 2994 |     |     //                   - 8     / qTarget
 2995 |     |     //                 e        |    - h / 2
 2996 |     |     //  '(2 ** 216) * ------- * |  e         k(w(h)) dh   <
 2997 |     |     //                   2      |
 2998 |     |     //                         / qCurrent
 2999 |     |     //
 3000 |     |     //                   - 8     / +16
 3001 |     |     //                 e        |    - h / 2
 3002 |     |     //   (2 ** 216) * ------- * |  e         dh   <   2 ** 216 - 1.
 3003 |     |     //                   2      |
 3004 |     |     //                         / -16
 3005 |     |     //
 3006 |     |     // Based on the above inequality, overflow is not possible because
 3007 |     |     // theoretically, no outgoing or incoming integral may exceed 216 bits.
 3008 |     |     _currentToTarget_.incrementIntegral(outgoing);
 3009 |     | 
 3010 |     |     // Next, 'incomingCurrentToTarget' is incremented with 'incoming'.
 3011 |     |     // Based on the above argument, overflow is not possible because
 3012 |     |     // theoretically, no outgoing or incoming integral may exceed 216 bits.
 3013 |     |     _incomingCurrentToTarget_.incrementIntegral(incoming);
 3014 |     |   } else {
 3015 |     |     // As argued before, if 'getDirection() == false', then
 3016 |     |     //
 3017 |     |     //  'qTotal0 <= qBegin <= qTarget <= qTotal1'.
 3018 |     |     //
 3019 |     |     // and if 'getDirection() == true', then
 3020 |     |     //
 3021 |     |     //  'qTotal1 <= qTarget <= qBegin <= qTotal0'.
 3022 |     |     //
 3023 |     |     // Additionally, since the vertical coordinates of kernel are monotonic,
 3024 |     |     // we have 'cTotal0 <= cTotal1' and the input requirements of 'outgoing'
 3025 |     |     // are satisfied.
 3026 |     |     outgoing = _total0_.outgoing(_begin_, _target_);
 3027 |     | 
 3028 |     |     // Next, 'currentToOrigin' is incremented with 'outgoing'.
 3029 |     |     // Based on the above argument, overflow is not possible because
 3030 |     |     // theoretically, no outgoing or incoming integral may exceed 216 bits.
 3031 |     |     _currentToOrigin_.incrementIntegral(outgoing);
 3032 |     |   }
 3033 |     | 
 3034 |     |   // In both cases, (i.e. regardless of 'direction == getZeroForOne()') the
 3035 |     |   // integral 'originToOvershoot' should be incremented with 'outgoing'.
 3036 |     |   // Based on the above argument, overflow is not possible because
 3037 |     |   // theoretically, no outgoing or incoming integral may exceed 216 bits.
 3038 |     |   _originToOvershoot_.incrementIntegral(outgoing);
 3039 |     | }
 3040 |     | 
 3041 |     | /// @notice Calculates 'outgoingMax', 'incomingMax', and
 3042 |     | /// 'outgoingMaxModularInverse', and sets each in the dedicated memory space.
 3043 |     | ///
 3044 |     | /// 'outgoingMax' is calculated based on the formula:
 3045 |     | ///
 3046 |     | ///                       - 8 + qLower / 2     / qUpper
 3047 |     | ///    outgoingMax      e                     |    - h / 2
 3048 |     | ///  '------------- := -------------------- * |  e         k(h - qLower) dh
 3049 |     | ///     2 ** 216                 2            |
 3050 |     | ///                                          / qLower
 3051 |     | ///
 3052 |     | ///                          - 8     / qSpacing + qEpsilon
 3053 |     | ///        qEpsilon / 2    e        |                        - h / 2
 3054 |     | ///   == e              * ------- * |    k(h - qEpsilon) * e         dh'
 3055 |     | ///                          2      |
 3056 |     | ///                                / qEpsilon
 3057 |     | ///
 3058 |     | /// and 'incomingMax' is calculated based on the formula:
 3059 |     | ///
 3060 |     | ///                       - 8 - qUpper / 2     / qUpper
 3061 |     | ///    incomingMax      e                     |    + h / 2
 3062 |     | ///  '------------- := -------------------- * |  e         k(h - qLower) dh
 3063 |     | ///     2 ** 216                 2            |
 3064 |     | ///                                          / qLower
 3065 |     | ///
 3066 |     | ///        - (qSpacing + qEpsilon) / 2
 3067 |     | ///   == e                             *
 3068 |     | ///
 3069 |     | ///         - 8     / qSpacing + qEpsilon
 3070 |     | ///       e        |                        + h / 2
 3071 |     | ///      ------- * |    k(h - qEpsilon) * e         dh'.
 3072 |     | ///         2      |
 3073 |     | ///               / qEpsilon
 3074 |     | ///
 3075 |     | /// where 'qEpsilon := - 16 + 1 / (2 ** 59)'.
 3076 |     | ///
 3077 |     | /// Let '2 ** n' be the largest power of '2' that divides 'outgoingMax' and
 3078 |     | /// define 'outgoingMaxModularInverse' as the modular inverse of 
 3079 |     | /// 
 3080 |     | ///    outgoingMax
 3081 |     | ///  '-------------'
 3082 |     | ///      2 ** n
 3083 |     | ///
 3084 |     | /// modulo '2 ** 256'.
 3085 |     | function calculateMaxIntegrals() pure {
 3086 |     |   // In order to calculate 'outgoingMax' and 'incomingMax' we need to create
 3087 |     |   // the following curve sequence in memory:
 3088 |     |   //
 3089 |     |   //  'q[0] := qSpacing + qEpsilon',
 3090 |     |   //  'q[1] := qEpsilon',
 3091 |     |   //
 3092 |     |   // which we refer to as 'toyCurve'.
 3093 |     | 
 3094 |     |   // To this end, we first cache the memory pointer for the current curve
 3095 |     |   // sequence and the current 'curveLength' from the memory.
 3096 |     |   Curve curve = getCurve();
 3097 |     |   Index curveLength = getCurveLength();
 3098 |     | 
 3099 |     |   // Next, a plain curve is constructed in the first slot of the memory so that
 3100 |     |   // 'outgoingMax' and 'incomingMax' can be calculated.
 3101 |     |   //
 3102 |     |   // The first member of 'toyCurve' is set as:
 3103 |     |   //
 3104 |     |   //  'qLimit := qSpacing + 1 / (2 ** 59)'.
 3105 |     |   //
 3106 |     |   // The addition is safe because as we argued before in this script:
 3107 |     |   //
 3108 |     |   //  'qSpacing < (2 ** 64) / 3'.
 3109 |     |   //
 3110 |     |   X59 qLimit = _spacing_.log() + epsilonX59;
 3111 |     |   {
 3112 |     |     // A new pointer is initialized and set in memory.
 3113 |     |     Curve toyCurve;
 3114 |     |     setCurve(toyCurve);
 3115 |     | 
 3116 |     |     // Both inputs are positive and less than 'thirtyTwoX59'. So, the
 3117 |     |     // requirements of 'newCurve' are satisfied.
 3118 |     |     toyCurve.newCurve(epsilonX59, qLimit);
 3119 |     |   }
 3120 |     | 
 3121 |     |   // As is the case for swaps, we employ the method 'moveTarget()' in order to
 3122 |     |   // calculate both of the integrals:
 3123 |     |   //
 3124 |     |   //      - 8     / qLimit
 3125 |     |   //    e        |                        - h / 2
 3126 |     |   //  '------- * |    k(h - qEpsilon) * e         dh'
 3127 |     |   //      2      |
 3128 |     |   //            / qEpsilon
 3129 |     |   //
 3130 |     |   // and
 3131 |     |   //
 3132 |     |   //      - 8     / qLimit
 3133 |     |   //    e        |                        + h / 2
 3134 |     |   //  '------- * |    k(h - qEpsilon) * e         dh'.
 3135 |     |   //      2      |
 3136 |     |   //            / qEpsilon
 3137 |     |   //
 3138 |     |   // To this end, 'qLimit' is set in memory as the end of the interval.
 3139 |     |   setLogPriceLimitOffsetted(qLimit);
 3140 |     | 
 3141 |     |   // And, '|amountSpecified|' is set to 'infinity'.
 3142 |     |   setIntegralLimit(oneX216 - epsilonX216);
 3143 |     |   
 3144 |     |   // A fresh interval is initiated for us to start the swap that calculates the
 3145 |     |   // two integrals.
 3146 |     |   initiateInterval();
 3147 |     |   
 3148 |     |   // 'currentToTarget' and 'incomingCurrentToTarget' are incremented until 
 3149 |     |   // 'qTarget' reaches 'qLimit'.
 3150 |     |   while (_target_.log() != qLimit) {
 3151 |     |     // The input requirement of 'moveTarget()' are satisfied because
 3152 |     |     // 'integralLimit' is set to 'infinity' and because 'qTarget' reaches
 3153 |     |     // 'qLimit' before 'indexKernelTotal' becomes out of range or 'indexCurve'
 3154 |     |     // underflows.
 3155 |     |     if (moveTarget()) break;
 3156 |     |   }
 3157 |     |   
 3158 |     |   // The 'curve' pointer and 'curveLength' are set to their previous value.
 3159 |     |   setCurve(curve);
 3160 |     |   setCurveLength(curveLength);
 3161 |     | 
 3162 |     |   {
 3163 |     |     // Next, 'outgoingMax' is calculated from 'currentToTarget' as follows:
 3164 |     |     //
 3165 |     |     //    outgoingMax
 3166 |     |     //  '------------- ==
 3167 |     |     //     2 ** 216
 3168 |     |     //
 3169 |     |     //                       - 8     / qLimit
 3170 |     |     //     qEpsilon / 2    e        |                      - h / 2
 3171 |     |     //   e              * ------- * |  k(h - qEpsilon) * e         dh ==
 3172 |     |     //                       2      |
 3173 |     |     //                             / qEpsilon
 3174 |     |     //
 3175 |     |     //     qEpsilon / 2    currentToTarget
 3176 |     |     //   e              * ----------------- ==
 3177 |     |     //                        2 ** 216
 3178 |     |     //
 3179 |     |     //     - 8    currentToTarget      1 / (2 ** 60)
 3180 |     |     //   e     * ----------------- * e              '
 3181 |     |     //               2 ** 216
 3182 |     |     //
 3183 |     |     // The use of 'cheapMul' is safe, because 'expInverse8X216' is positive and
 3184 |     |     // less than 'oneX216'. Moreover, like every outgoing integral,
 3185 |     |     // 'currentToTarget' is nonnegative and less than 'oneX216'.
 3186 |     |     //
 3187 |     |     // Overflow of 'multiplyByExpEpsilon' is impossible because, theoretically,
 3188 |     |     // the output satisfies:
 3189 |     |     //
 3190 |     |     //                       - 8     / qSpacing
 3191 |     |     //    outgoingMax      e        |    - h / 2
 3192 |     |     //  '------------- := ------- * |  e         k(h) dh
 3193 |     |     //     2 ** 216          2      |
 3194 |     |     //                             / 0
 3195 |     |     //
 3196 |     |     //                       - 8     / 32
 3197 |     |     //                     e        |    - h / 2
 3198 |     |     //                  < ------- * |  e         dh < 1
 3199 |     |     //                       2      |
 3200 |     |     //                             / 0
 3201 |     |     //
 3202 |     |     X216 outgoingMax = (
 3203 |     |       _currentToTarget_.integral() & expInverse8X216
 3204 |     |     ).multiplyByExpEpsilon();
 3205 |     | 
 3206 |     |     // Due to the above argument, 'outgoingMax' does not exceed 216 bits and
 3207 |     |     // can be safely stored in the dedicated memory space which is pointed to
 3208 |     |     // by '_outgoingMax_'.
 3209 |     |     setOutgoingMax(outgoingMax);
 3210 |     | 
 3211 |     |     // Next, the modular inverse of the largest odd factor of 'outgoingMax'
 3212 |     |     // is calculated.
 3213 |     |     //
 3214 |     |     // Let 'outgoingMax == (2 ** n) * (2 * r + 1)' where 'n' and 'r' are
 3215 |     |     // nonnegative integers (i.e., '2 ** n' is the largest power of '2' that
 3216 |     |     // divides 'outgoingMax'). Then, the binary representation of 'outgoingMax'
 3217 |     |     // looks like:
 3218 |     |     //
 3219 |     |     //        ___________
 3220 |     |     //        r 1 0 ... 0
 3221 |     |     //
 3222 |     |     // with exactly 'n' zero digits appearing as the least significant. On the
 3223 |     |     // other hand, the binary representation of '(2 ** 256) - outgoingMax'
 3224 |     |     // looks like:
 3225 |     |     //
 3226 |     |     //   ________________
 3227 |     |     //   not(r) 1 0 ... 0
 3228 |     |     //
 3229 |     |     // with exactly 'n' zero digits appearing as the least significant.
 3230 |     |     //
 3231 |     |     // Hence, we have:
 3232 |     |     //
 3233 |     |     //  'outgoingMax & ((2 ** 256) - outgoingMax) == 2 ** n'.
 3234 |     |     //
 3235 |     |     uint256 outgoingMaxLargestOddFactor;
 3236 |     |     assembly {
 3237 |     |       // 'outgoingMax / (2 ** n)'
 3238 |     |       outgoingMaxLargestOddFactor := div(
 3239 |     |         outgoingMax,
 3240 |     |         and(sub(0, outgoingMax), outgoingMax) // '2 ** n'
 3241 |     |       )
 3242 |     |     }
 3243 |     |     setOutgoingMaxModularInverse(
 3244 |     |       FullMathLibrary.modularInverse(outgoingMaxLargestOddFactor)
 3245 |     |     );
 3246 |     |   }
 3247 |     | 
 3248 |     |   // Next, 'incomingMax' is calculated from 'incomingCurrentToTarget' as
 3249 |     |   // follows:
 3250 |     |   //
 3251 |     |   //    incomingMax       - (qSpacing + qEpsilon) / 2
 3252 |     |   //  '------------- == e                             *
 3253 |     |   //     2 ** 216
 3254 |     |   //
 3255 |     |   //      - 8     / qLimit
 3256 |     |   //    e        |                      + h / 2
 3257 |     |   //   ------- * |  k(h - qEpsilon) * e         dh ==
 3258 |     |   //      2      |
 3259 |     |   //            / qEpsilon
 3260 |     |   //
 3261 |     |   //     - (qSpacing + qEpsilon) / 2    incomingCurrentToTarget
 3262 |     |   //   e                             * ------------------------- ==
 3263 |     |   //                                           2 ** 216
 3264 |     |   //
 3265 |     |   //      - qSpacing    incomingCurrentToTarget
 3266 |     |   //    e            * -------------------------
 3267 |     |   //                          2 ** 216                - 1 / (2 ** 60)
 3268 |     |   //   ------------------------------------------ * e                 '.
 3269 |     |   //                       - 8
 3270 |     |   //                     e
 3271 |     |   //
 3272 |     |   // The use of 'mulDivByExpInv8' is safe, because both inputs are positive and
 3273 |     |   // less than 'oneX216'. Moreover, overflow is not possible because the output
 3274 |     |   // of 'mulDivByExpInv8' is smaller than 'incomingMax' which satisfies
 3275 |     |   //
 3276 |     |   //                       - 8 - qSpacing / 2     / qSpacing
 3277 |     |   //    incomingMax      e                       |    + h / 2
 3278 |     |   //  '------------- := ---------------------- * |  e         k(h) dh
 3279 |     |   //     2 ** 216                 2              |
 3280 |     |   //                                            / 0
 3281 |     |   //
 3282 |     |   //                       - 24     / 32
 3283 |     |   //                     e         |    + h / 2
 3284 |     |   //                  < -------- * |  e         dh < 1
 3285 |     |   //                       2       |
 3286 |     |   //                              / 0
 3287 |     |   //
 3288 |     |   setIncomingMax((
 3289 |     |     _incomingCurrentToTarget_.integral() % _spacing_.sqrt(false)
 3290 |     |   ).divideByExpEpsilon());
 3291 |     | 
 3292 |     |   // Clears memory so that it can be used later for the calculation of
 3293 |     |   // 'integral0' and 'integral1'.
 3294 |     |   clearInterval();
 3295 |     | }
 3296 |     | 
 3297 |     | /// @notice Calculates 'integral0' and 'integral1' where:
 3298 |     | ///
 3299 |     | ///                     - 8     / qUpper
 3300 |     | ///    integral0      e        |    - h / 2
 3301 |     | ///  '----------- := ------- * |  e         k(w(h)) dh',
 3302 |     | ///    2 ** 216         2      |
 3303 |     | ///                           / qCurrent
 3304 |     | ///
 3305 |     | /// and
 3306 |     | ///
 3307 |     | ///                     - 8     / qCurrent
 3308 |     | ///    integral1      e        |    + h / 2
 3309 |     | ///  '----------- := ------- * |  e         k(w(h)) dh'.
 3310 |     | ///    2 ** 216         2      |
 3311 |     | ///                           / qLower
 3312 |     | ///
 3313 |     | /// This method is called during initialization.
 3314 |     | function calculateIntegrals() pure {
 3315 |     |   // In order to calculate 'integral0' and 'integral1', we need to employ the
 3316 |     |   // method 'moveTarget()'. To this end, 'qLimit' is set as the very first
 3317 |     |   // member of the curve sequence which is one of the interval boundaries.
 3318 |     |   X59 qLimit = getCurve().member(zeroIndex);
 3319 |     | 
 3320 |     |   // 'qLimit' is set in memory.
 3321 |     |   setLogPriceLimitOffsetted(qLimit);
 3322 |     | 
 3323 |     |   // The direction of our exploration is set with respect to 'qLimit'.
 3324 |     |   setZeroForOne(qLimit <= getLogPriceCurrent());
 3325 |     | 
 3326 |     |   // 'integralLimit' (i.e., '|amountSpecified|') is set to 'infinity'.
 3327 |     |   setIntegralLimit(oneX216 - epsilonX216);
 3328 |     | 
 3329 |     |   // A fresh interval is initiated for us to start the swap that calculates the
 3330 |     |   // two integrals.
 3331 |     |   initiateInterval();
 3332 |     | 
 3333 |     |   // 'currentToTarget' and 'incomingCurrentToTarget' are incremented until 
 3334 |     |   // 'qTarget' reaches 'qLimit'.
 3335 |     |   while (_target_.log() != qLimit) {
 3336 |     |     // The input requirement of 'moveTarget()' are satisfied because
 3337 |     |     // 'integralLimit' is set to 'infinity' and because 'qTarget' reaches
 3338 |     |     // 'qLimit' before 'indexKernelTotal' becomes out of range or 'indexCurve'
 3339 |     |     // underflows.
 3340 |     |     if (moveTarget()) break;
 3341 |     |   }
 3342 |     | 
 3343 |     |   // Depending on the direction, the two integrals are determined and set in
 3344 |     |   // their dedicated memory location.
 3345 |     |   (X216 integral0, X216 integral1) = getZeroForOne() ? (
 3346 |     |     _currentToOrigin_.integral(),
 3347 |     |     _currentToTarget_.integral()
 3348 |     |   ) : (
 3349 |     |     _currentToTarget_.integral(),
 3350 |     |     _currentToOrigin_.integral()
 3351 |     |   );
 3352 |     |   setIntegral0(integral0);
 3353 |     |   setIntegral1(integral1);
 3354 |     | }
 3355 |     | 
 3356 |     | /// @notice Assume that the search for 'qTarget' is concluded and we need to
 3357 |     | /// determine 'qOvershoot'. To this end, the following equation should be
 3358 |     | /// solved:
 3359 |     | ///
 3360 |     | ///   'f(qOvershoot) == 0'
 3361 |     | ///
 3362 |     | /// where
 3363 |     | ///
 3364 |     | ///   'f(qOvershoot) := getZeroForOne() ? 
 3365 |     | ///                     s0(qOvershoot) - s1(qOvershoot) : 
 3366 |     | ///                     s1(qOvershoot) - s0(qOvershoot)',
 3367 |     | ///
 3368 |     | /// and the two functions 's0' and 's1' are defined as:
 3369 |     | ///
 3370 |     | ///                          - 8      / qTarget
 3371 |     | ///                        e         |   + h / 2
 3372 |     | ///                       ------- *  |  e        k(wAmended(h)) dh
 3373 |     | ///                          2       |
 3374 |     | ///                                 / qLower
 3375 |     | ///   's1(qOvershoot) := ------------------------------------------',
 3376 |     | ///                                integral1Incremented
 3377 |     | ///
 3378 |     | ///                          - 8      / qUpper
 3379 |     | ///                        e         |   - h / 2
 3380 |     | ///                       ------- *  |  e        k(wAmended(h)) dh
 3381 |     | ///                          2       |
 3382 |     | ///                                 / qTarget
 3383 |     | ///   's0(qOvershoot) := ------------------------------------------',
 3384 |     | ///                                integral0Incremented
 3385 |     | ///
 3386 |     | /// where, according to the amendment procedure which is described in
 3387 |     | /// 'Curve.sol', if 'getZeroForOne() == false', we have:
 3388 |     | ///
 3389 |     | ///                       / k(w(h))            if  qOvershoot < h < qUpper
 3390 |     | ///   'k(wAmended(h)) == |  k(h - qTarget)     if  qTarget < h < qOvershoot '
 3391 |     | ///                      |  k(qOvershoot - h)  if  qOrigin < h < qTarget
 3392 |     | ///                       \ k(w(h))            if  qLower < h < qOrigin
 3393 |     | ///
 3394 |     | /// and if 'getZeroForOne() == true', we have:
 3395 |     | ///
 3396 |     | ///                       / k(w(h))            if  qLower < h < qOvershoot
 3397 |     | ///   'k(wAmended(h)) == |  k(qTarget - h)     if  qOvershoot < h < qTarget '.
 3398 |     | ///                      |  k(h - qOvershoot)  if  qTarget < h < qOrigin
 3399 |     | ///                       \ k(w(h))            if  qOrigin < h < qUpper
 3400 |     | ///
 3401 |     | /// The present function evaluates the mismatch function 'f(qOvershoot)'. To
 3402 |     | /// this end, we use the following formula which is proven in 'Memory.sol'.
 3403 |     | ///
 3404 |     | ///   'f(qOvershoot) := getZeroForOne() ? (
 3405 |     | ///
 3406 |     | ///      (
 3407 |     | ///
 3408 |     | ///        exp(- (qOrigin + qOvershoot) / 2) * originToOvershoot -
 3409 |     | ///
 3410 |     | ///        exp(- (qTarget + qOvershoot) / 2) * targetToOvershoot - 
 3411 |     | ///
 3412 |     | ///        incomingCurrentToTarget - currentToOrigin
 3413 |     | ///
 3414 |     | ///      ) / integral0Incremented - (
 3415 |     | ///
 3416 |     | ///        targetToOvershoot + currentToTarget - currentToOvershoot
 3417 |     | ///      
 3418 |     | ///      ) / integral1Incremented
 3419 |     | ///
 3420 |     | ///    ) : (
 3421 |     | ///
 3422 |     | ///      (
 3423 |     | ///
 3424 |     | ///        exp(+ (qOrigin + qOvershoot) / 2) * originToOvershoot -
 3425 |     | ///
 3426 |     | ///        exp(+ (qTarget + qOvershoot) / 2) * targetToOvershoot - 
 3427 |     | ///
 3428 |     | ///        incomingCurrentToTarget - currentToOrigin
 3429 |     | ///
 3430 |     | ///      ) / integral1Incremented - (
 3431 |     | ///
 3432 |     | ///        targetToOvershoot + currentToTarget - currentToOvershoot
 3433 |     | ///      
 3434 |     | ///      ) / integral0Incremented
 3435 |     | ///
 3436 |     | ///    )'.
 3437 |     | ///
 3438 |     | /// @param integral0Incremented The integral of the liquidity distribution
 3439 |     | /// function from 'qTarget' to 'qUpper' prior to the amendment of the curve
 3440 |     | /// sequence:
 3441 |     | ///
 3442 |     | ///                                 - 8     / qUpper
 3443 |     | ///     integral0Incremented      e        |    - h / 2
 3444 |     | ///   '---------------------- := ------- * |  e         k(w(h)) dh',
 3445 |     | ///           2 ** 216              2      |
 3446 |     | ///                                       / qTarget
 3447 |     | ///
 3448 |     | /// @param integral1Incremented The integral of the liquidity distribution
 3449 |     | /// function from 'qLower' to 'qTarget' prior to the amendment of the curve
 3450 |     | /// sequence:
 3451 |     | ///
 3452 |     | ///                                 - 8     / qTarget
 3453 |     | ///     integral1Incremented      e        |    + h / 2
 3454 |     | ///   '---------------------- := ------- * |  e         k(w(h)) dh'.
 3455 |     | ///           2 ** 216              2      |
 3456 |     | ///                                       / qLower
 3457 |     | ///
 3458 |     | function getMismatch(
 3459 |     |   X216 integral0Incremented,
 3460 |     |   X216 integral1Incremented
 3461 |     | ) pure returns (
 3462 |     |   X216 mismatch
 3463 |     | ) {
 3464 |     |   // First 'zeroForOne' is loaded from the memory.
 3465 |     |   bool zeroForOne = getZeroForOne();
 3466 |     | 
 3467 |     |   // The following value is calculated next:
 3468 |     |   //
 3469 |     |   //  'zeroForOne ? (
 3470 |     |   //
 3471 |     |   //     exp(- (qOrigin + qOvershoot) / 2) * originToOvershoot -
 3472 |     |   //
 3473 |     |   //     exp(- (qTarget + qOvershoot) / 2) * targetToOvershoot - 
 3474 |     |   //
 3475 |     |   //     incomingCurrentToTarget - currentToOrigin
 3476 |     |   //
 3477 |     |   //   ) : (
 3478 |     |   //
 3479 |     |   //     exp(+ (qOrigin + qOvershoot) / 2) * originToOvershoot -
 3480 |     |   //
 3481 |     |   //     exp(+ (qTarget + qOvershoot) / 2) * targetToOvershoot - 
 3482 |     |   //
 3483 |     |   //     incomingCurrentToTarget - currentToOrigin
 3484 |     |   //
 3485 |     |   //   )'.
 3486 |     |   //
 3487 |     |   // The requirement of 'shift' is satisfied because all of the integrals are
 3488 |     |   // read from 216 bits of memory and do not exceed oneX216.
 3489 |     |   //
 3490 |     |   // The subtractions are unsafe and
 3491 |     |   // 'integral1AmendedMinusIntegral1Incremented' may or may not be negative.
 3492 |     |   X216 integral1AmendedMinusIntegral1Incremented = 
 3493 |     |     _originToOvershoot_.integral().shift(
 3494 |     |       _overshoot_,
 3495 |     |       _origin_,
 3496 |     |       zeroForOne
 3497 |     |     ) - _targetToOvershoot_.integral().shift(
 3498 |     |       _overshoot_,
 3499 |     |       _target_,
 3500 |     |       zeroForOne
 3501 |     |     ) - _currentToOrigin_.integral() - _incomingCurrentToTarget_.integral();
 3502 |     | 
 3503 |     |   // Now, we calculate:
 3504 |     |   //
 3505 |     |   //  'targetToOvershoot + currentToTarget - currentToOvershoot'
 3506 |     |   //  
 3507 |     |   // The subtractions are unsafe and
 3508 |     |   // 'integral0AmendedMinusIntegral0Incremented' may or may not be negative.
 3509 |     |   X216 integral0AmendedMinusIntegral0Incremented = _currentToTarget_.integral()
 3510 |     |     + _targetToOvershoot_.integral()
 3511 |     |     - _currentToOvershoot_.integral();
 3512 |     | 
 3513 |     |   // Neither of 'integral0Incremented' and 'integral1Incremented' do not exceed
 3514 |     |   // 'oneX216'. Additionally, since each of
 3515 |     |   // 'integral0AmendedMinusIntegral0Incremented' and
 3516 |     |   // 'integral1AmendedMinusIntegral1Incremented' are composed of up to four
 3517 |     |   // integrals, their absolute value do not exceed '4 * oneX216'. Hence, both
 3518 |     |   // multiplications are safe.
 3519 |     |   //
 3520 |     |   // The subtractions are unsafe and the output may or may not be negative.
 3521 |     |   return zeroForOne ? (
 3522 |     |     (
 3523 |     |       integral1AmendedMinusIntegral1Incremented * integral1Incremented
 3524 |     |     ) - (
 3525 |     |       integral0AmendedMinusIntegral0Incremented * integral0Incremented
 3526 |     |     )
 3527 |     |   ) : (
 3528 |     |     (
 3529 |     |       integral1AmendedMinusIntegral1Incremented * integral0Incremented
 3530 |     |     ) - (
 3531 |     |       integral0AmendedMinusIntegral0Incremented * integral1Incremented
 3532 |     |     )
 3533 |     |   );
 3534 |     | }
 3535 |     | 
 3536 |     | /// @notice Enumerates the pieces of the liquidity distribution function
 3537 |     | /// 'k(w(.))' in search for the pair of logarithmic prices:
 3538 |     | ///
 3539 |     | ///   'qBegin := (
 3540 |     | ///                direction == getZeroForOne()
 3541 |     | ///              ) ? (
 3542 |     | ///                direction ? 
 3543 |     | ///                max(max(q[indexCurve + 2], qTotal0), qForward0) : 
 3544 |     | ///                min(min(q[indexCurve + 2], qTotal0), qForward0)
 3545 |     | ///              ) : (
 3546 |     | ///                direction ? 
 3547 |     | ///                max(q[indexCurve + 2], qTotal0) : 
 3548 |     | ///                min(q[indexCurve + 2], qTotal0)
 3549 |     | ///              )',
 3550 |     | ///
 3551 |     | /// and
 3552 |     | ///
 3553 |     | ///   'qOvershoot := (
 3554 |     | ///                    direction == getZeroForOne()
 3555 |     | ///                  ) ? (
 3556 |     | ///                    direction ? 
 3557 |     | ///                    max(max(qEnd, qTotal1), qForward1) : 
 3558 |     | ///                    min(min(qEnd, qTotal1), qForward1)
 3559 |     | ///                  ) : (
 3560 |     | ///                    direction ? 
 3561 |     | ///                    max(qEnd, qTotal1) : 
 3562 |     | ///                    min(qEnd, qTotal1)
 3563 |     | ///                  )',
 3564 |     | ///
 3565 |     | /// which satisfy:
 3566 |     | ///
 3567 |     | ///   'f(qBegin) <= 0' and 'f(qOvershoot) >  0'.
 3568 |     | ///
 3569 |     | /// where the mismatch function 'f(.)' is defined in 'Memory.sol' and earlier
 3570 |     | /// in this document.
 3571 |     | ///
 3572 |     | /// The present function transitions to the next piece of 'k(w(.))' by updating 
 3573 |     | /// the appropriate values in memory and by incrementing the following
 3574 |     | /// integrals:
 3575 |     | ///  
 3576 |     | ///  - 'currentToOvershoot',
 3577 |     | ///
 3578 |     | ///  - 'targetToOvershoot',
 3579 |     | ///
 3580 |     | ///  - 'currentToOrigin',
 3581 |     | ///
 3582 |     | ///  - 'originToOvershoot'.
 3583 |     | ///
 3584 |     | /// ---------------------------------------------------------------------------
 3585 |     | ///
 3586 |     | /// The underflow of
 3587 |     | ///
 3588 |     | ///  'getIntegralLimit() - getExactInput() ? 
 3589 |     | ///                        _incomingCurrentToTarget_.integral() : 
 3590 |     | ///                        _currentToTarget_.integral()'
 3591 |     | ///
 3592 |     | /// should be avoided externally.
 3593 |     | ///
 3594 |     | /// Out of range values for 'indexKernelTotal' should be avoided externally.
 3595 |     | ///
 3596 |     | /// Out of range values for 'indexKernelForward' should be avoided externally.
 3597 |     | ///
 3598 |     | /// Underflow of 'indexCurve' should be avoided externally.
 3599 |     | ///
 3600 |     | /// @param integral0Incremented The integral of the liquidity distribution
 3601 |     | /// function from 'qTarget' to 'qUpper' prior to the amendment of the curve
 3602 |     | /// sequence:
 3603 |     | ///
 3604 |     | ///                                 - 8     / qUpper
 3605 |     | ///     integral0Incremented      e        |    - h / 2
 3606 |     | ///   '---------------------- := ------- * |  e         k(w(h)) dh',
 3607 |     | ///           2 ** 216              2      |
 3608 |     | ///                                       / qTarget
 3609 |     | ///
 3610 |     | /// @param integral1Incremented The integral of the liquidity distribution
 3611 |     | /// function from 'qLower' to 'qTarget' prior to the amendment of the curve
 3612 |     | /// sequence:
 3613 |     | ///
 3614 |     | ///                                 - 8     / qTarget
 3615 |     | ///     integral1Incremented      e        |    + h / 2
 3616 |     | ///   '---------------------- := ------- * |  e         k(w(h)) dh'.
 3617 |     | ///           2 ** 216              2      |
 3618 |     | ///                                       / qLower
 3619 |     | ///
 3620 |     | /// @return proceed whether to proceed forward in the search for 'qTarget' and
 3621 |     | /// 'qOvershoot'.
 3622 |     | function moveOvershoot(
 3623 |     |   X216 integral0Incremented,
 3624 |     |   X216 integral1Incremented
 3625 |     | ) pure returns (
 3626 |     |   bool proceed
 3627 |     | ) {
 3628 |     |   // According to the above definitions for 'qBegin' and 'qOvershoot', if
 3629 |     |   // 'direction != getZeroForOne() == false', we have:
 3630 |     |   //
 3631 |     |   //  'qOvershoot < qBegin <= qCurrent <= qForward0 <= qForward1',
 3632 |     |   //
 3633 |     |   // and if 'direction != getZeroForOne() == true', we have:
 3634 |     |   //
 3635 |     |   //  'qForward1 <= qForward0 <= qCurrent <= qBegin < qOvershoot'.
 3636 |     |   //
 3637 |     |   // In both cases, the 'if' condition is bypassed.
 3638 |     |   //
 3639 |     |   // However, if 'getDirection() == getZeroForOne() == false', we have:
 3640 |     |   //
 3641 |     |   //  'qForward0 <= qBegin <= qOvershoot <= qForward1'.
 3642 |     |   //
 3643 |     |   // In this case, if 'qOvershoot == qForward1' as illustrated below,
 3644 |     |   //
 3645 |     |   //      +---------+---------+
 3646 |     |   //      |         |         |
 3647 |     |   //  qForward0  qBegin   qForward1
 3648 |     |   //                          |
 3649 |     |   //                     qOvershoot
 3650 |     |   //
 3651 |     |   // then 'indexKernelForward' is incremented and the next piece of 'k(.)' is
 3652 |     |   // loaded and stored in the memory spaces that are pointed to by '_forward0_'
 3653 |     |   // and '_forward1_':
 3654 |     |   //
 3655 |     |   //      +---------+---------+-------------------+
 3656 |     |   //                |         |                   |
 3657 |     |   //             qBegin   qForward0           qForward1
 3658 |     |   //                          |
 3659 |     |   //                     qOvershoot
 3660 |     |   //
 3661 |     |   // If 'getDirection() == getZeroForOne() == true', then we have:
 3662 |     |   //
 3663 |     |   //  'qForward1 <= qOvershoot <= qBegin <= qForward0'.
 3664 |     |   //
 3665 |     |   // In this case, if 'qOvershoot == qForward1' as illustrated below,
 3666 |     |   //
 3667 |     |   //                          +---------+---------+
 3668 |     |   //                          |         |         |
 3669 |     |   //                      qForward1  qBegin   qForward0
 3670 |     |   //                          |
 3671 |     |   //                     qOvershoot
 3672 |     |   //
 3673 |     |   // then 'indexKernelForward' is incremented and the next piece of 'k(.)' is
 3674 |     |   // loaded and stored in the memory spaces that are pointed to by '_forward0_'
 3675 |     |   // and '_forward1_':
 3676 |     |   //
 3677 |     |   //      +-------------------+---------+---------+
 3678 |     |   //      |                   |         |
 3679 |     |   //  qForward1           qForward0  qBegin
 3680 |     |   //                          |
 3681 |     |   //                     qOvershoot
 3682 |     |   //
 3683 |     |   // Out of range values for 'indexKernelForward' are avoided because of an
 3684 |     |   // input requirement here.
 3685 |     |   if (_overshoot_.log() == _forward1_.log()) moveBreakpointForward();
 3686 |     | 
 3687 |     |   // According to the above definitions for 'qBegin' and 'qOvershoot', if
 3688 |     |   // 'getDirection() == false', then we have:
 3689 |     |   //
 3690 |     |   //  'qTotal0 <= qBegin <= qOvershoot <= qTotal1'.
 3691 |     |   //
 3692 |     |   // In this case, if 'qOvershoot == qTotal1' as illustrated below,
 3693 |     |   //
 3694 |     |   //      +---------+---------+
 3695 |     |   //      |         |         |
 3696 |     |   //   qTotal0   qBegin    qTotal1
 3697 |     |   //                          |
 3698 |     |   //                     qOvershoot
 3699 |     |   //
 3700 |     |   // then 'indexKernelTotal' is incremented and the next piece of 'k(.)' is
 3701 |     |   // loaded and stored in the memory spaces that are pointed to by '_total0_'
 3702 |     |   // and '_total1_':
 3703 |     |   //
 3704 |     |   //      +---------+---------+-------------------+
 3705 |     |   //                |         |                   |
 3706 |     |   //             qBegin    qTotal0             qTotal1
 3707 |     |   //                          |
 3708 |     |   //                     qOvershoot
 3709 |     |   //
 3710 |     |   // If 'getDirection() == true', then we have:
 3711 |     |   //
 3712 |     |   //  'qTotal1 <= qOvershoot <= qBegin <= qTotal0'.
 3713 |     |   //
 3714 |     |   // In this case, if 'qOvershoot == qTotal1' as illustrated below,
 3715 |     |   //
 3716 |     |   //                          +---------+---------+
 3717 |     |   //                          |         |         |
 3718 |     |   //                       qTotal1   qBegin    qTotal0
 3719 |     |   //                          |
 3720 |     |   //                     qOvershoot
 3721 |     |   //
 3722 |     |   // then 'indexKernelTotal' is incremented and the next piece of 'k(.)' is
 3723 |     |   // loaded and stored in the memory spaces that are pointed to by '_total0_'
 3724 |     |   // and '_total1_':
 3725 |     |   //
 3726 |     |   //      +-------------------+---------+---------+
 3727 |     |   //      |                   |         |
 3728 |     |   //   qTotal1             qTotal0   qBegin
 3729 |     |   //                          |
 3730 |     |   //                     qOvershoot
 3731 |     |   //
 3732 |     |   // Out of range values for 'indexKernelTotal' are avoided because of an
 3733 |     |   // input requirement here.
 3734 |     |   if (_overshoot_.log() == _total1_.log()) moveBreakpointTotal();
 3735 |     | 
 3736 |     |   // The current direction is loaded from memory.
 3737 |     |   bool direction = getDirection();
 3738 |     | 
 3739 |     |   // According to the above definitions for 'qBegin' and 'qOvershoot', if
 3740 |     |   // 'getDirection() == false', then we have:
 3741 |     |   //
 3742 |     |   //  'q[indexCurve + 2] <= qBegin <= qOvershoot <= qEnd'.
 3743 |     |   //
 3744 |     |   // In this case, if 'qOvershoot == qEnd' as illustrated below,
 3745 |     |   //
 3746 |     |   //         w(q)
 3747 |     |   //          ^
 3748 |     |   //  spacing |                                              /
 3749 |     |   //          |                                             /
 3750 |     |   //          |                                            /
 3751 |     |   //          |                                           /
 3752 |     |   //          |                                          /
 3753 |     |   //          |                                         /
 3754 |     |   //          |                                        /
 3755 |     |   //          |                                       /
 3756 |     |   //          |                                      /
 3757 |     |   //          |                                     /
 3758 |     |   //          |                                    /
 3759 |     |   //          |\
 3760 |     |   //          | \
 3761 |     |   //          |  \
 3762 |     |   //          |   \
 3763 |     |   //          |    \
 3764 |     |   //          |     \
 3765 |     |   //          |      \
 3766 |     |   //          |       \
 3767 |     |   //          |        \
 3768 |     |   //          |         \
 3769 |     |   //          |          \
 3770 |     |   //          |                                  /
 3771 |     |   //          |                                 /
 3772 |     |   //          |                                /
 3773 |     |   //          |                               /
 3774 |     |   //          |                              /
 3775 |     |   //          |                             /
 3776 |     |   //          |                            /
 3777 |     |   //          |                           /
 3778 |     |   //          |                          /
 3779 |     |   //          |                         /
 3780 |     |   //          |                        /
 3781 |     |   //          |            \
 3782 |     |   //          |             \
 3783 |     |   //          |              \
 3784 |     |   //          |               \
 3785 |     |   //          |                \
 3786 |     |   //          |                 \
 3787 |     |   //          |                  \
 3788 |     |   //          |                   \
 3789 |     |   //          |                    \
 3790 |     |   //          |                     \
 3791 |     |   //          |                      \
 3792 |     |   //        0 +-----------+-----------+-----+-----+-----+-----+> q
 3793 |     |   //                      |           |     |     |
 3794 |     |   //                   qOrigin        |  qBegin  qEnd
 3795 |     |   //                                  |           |
 3796 |     |   //                                  |       qOvershoot
 3797 |     |   //                                  |
 3798 |     |   //                                  |
 3799 |     |   //                                  |
 3800 |     |   //                          q[indexCurve + 2]
 3801 |     |   //
 3802 |     |   // then 'indexCurve' is decremented, the direction is flipped and the next
 3803 |     |   // phase of 'w(.)' is loaded by setting:
 3804 |     |   //
 3805 |     |   //  'qEnd := q[indexCurve]'
 3806 |     |   //
 3807 |     |   //  'qOrigin := q[indexCurve + 1]'
 3808 |     |   //
 3809 |     |   //  'qBegin := q[indexCurve + 2]'
 3810 |     |   //
 3811 |     |   // which is illustrated as follows:
 3812 |     |   //
 3813 |     |   //         w(q)
 3814 |     |   //          ^
 3815 |     |   //  spacing |                                              /
 3816 |     |   //          |                                             /
 3817 |     |   //          |                                            /
 3818 |     |   //          |                                           /
 3819 |     |   //          |                                          /
 3820 |     |   //          |                                         /
 3821 |     |   //          |                                        /
 3822 |     |   //          |                                       /
 3823 |     |   //          |                                      /
 3824 |     |   //          |                                     /
 3825 |     |   //          |                                    /
 3826 |     |   //          |\
 3827 |     |   //          | \
 3828 |     |   //          |  \
 3829 |     |   //          |   \
 3830 |     |   //          |    \
 3831 |     |   //          |     \
 3832 |     |   //          |      \
 3833 |     |   //          |       \
 3834 |     |   //          |        \
 3835 |     |   //          |         \
 3836 |     |   //          |          \
 3837 |     |   //          |                                  /
 3838 |     |   //          |                                 /
 3839 |     |   //          |                                /
 3840 |     |   //          |                               /
 3841 |     |   //          |                              /
 3842 |     |   //          |                             /
 3843 |     |   //          |                            /
 3844 |     |   //          |                           /
 3845 |     |   //          |                          /
 3846 |     |   //          |                         /
 3847 |     |   //          |                        /
 3848 |     |   //          |            \
 3849 |     |   //          |             \
 3850 |     |   //          |              \
 3851 |     |   //          |               \
 3852 |     |   //          |                \
 3853 |     |   //          |                 \
 3854 |     |   //          |                  \
 3855 |     |   //          |                   \
 3856 |     |   //          |                    \
 3857 |     |   //          |                     \
 3858 |     |   //          |                      \
 3859 |     |   //        0 +-----------+-----------+-----------+-----------+> q
 3860 |     |   //          |           |                       |
 3861 |     |   //        qEnd       qBegin                  qOrigin
 3862 |     |   //                      |                       |
 3863 |     |   //              q[indexCurve + 2]          qOvershoot
 3864 |     |   //
 3865 |     |   // If 'getDirection() == true', then we have:
 3866 |     |   //
 3867 |     |   //  'qEnd <= qOvershoot <= qBegin <= q[indexCurve + 2]'.
 3868 |     |   //
 3869 |     |   // and a similar argument can be made.
 3870 |     |   if (_overshoot_.log() == _end_.log()) {
 3871 |     |     // Once we move the phase, the direction flips and 'qOrigin' will be moved
 3872 |     |     // to 'qEnd'. Hence, the following integral
 3873 |     |     //
 3874 |     |     //                             - 8
 3875 |     |     //    originToOvershoot      e
 3876 |     |     //  '------------------- == ------- * (
 3877 |     |     //        2 ** 216             2
 3878 |     |     //
 3879 |     |     //     getZeroForOne() ? 
 3880 |     |     //
 3881 |     |     //       / qOrigin
 3882 |     |     //      |    + h / 2
 3883 |     |     //      |  e         k(qOrigin - h) dh :
 3884 |     |     //      |
 3885 |     |     //     / qEnd
 3886 |     |     //
 3887 |     |     //       / qEnd
 3888 |     |     //      |    - h / 2
 3889 |     |     //      |  e         k(h - qOrigin) dh
 3890 |     |     //      |
 3891 |     |     //     / qOrigin
 3892 |     |     //
 3893 |     |     //   )'
 3894 |     |     //
 3895 |     |     // should be transformed to
 3896 |     |     //
 3897 |     |     //                             - 8
 3898 |     |     //    originToOvershoot      e
 3899 |     |     //  '------------------- := ------- * (
 3900 |     |     //        2 ** 216             2
 3901 |     |     //
 3902 |     |     //     getZeroForOne() ? 
 3903 |     |     //
 3904 |     |     //       / qOrigin
 3905 |     |     //      |    - h / 2
 3906 |     |     //      |  e         k(h - qEnd) dh :
 3907 |     |     //      |
 3908 |     |     //     / qEnd
 3909 |     |     //
 3910 |     |     //       / qEnd
 3911 |     |     //      |    + h / 2
 3912 |     |     //      |  e         k(qEnd - h) dh
 3913 |     |     //      |
 3914 |     |     //     / qOrigin
 3915 |     |     //
 3916 |     |     //   )'
 3917 |     |     //
 3918 |     |     // The loaded integral does not exceed 216-bits and hence, the input
 3919 |     |     // requirement of shift is satisfied.
 3920 |     |     _originToOvershoot_.setIntegral(
 3921 |     |       _originToOvershoot_.integral().shift(_overshoot_, _origin_, direction)
 3922 |     |     );
 3923 |     | 
 3924 |     |     // Underflow of 'indexCurve' is avoided externally via an input requirement
 3925 |     |     // of the present function.
 3926 |     |     direction = movePhase();
 3927 |     |   }
 3928 |     | 
 3929 |     |   // If the phase is moved, then we have:
 3930 |     |   //
 3931 |     |   //  'qBegin == q[indexCurve + 2]'.
 3932 |     |   //
 3933 |     |   // If the phase is not moved, then the kernel piece is moved and we have:
 3934 |     |   //
 3935 |     |   //  'qBegin <= qOvershoot == qTotal0'.
 3936 |     |   //
 3937 |     |   // In both cases, we need to set:
 3938 |     |   //
 3939 |     |   //  'qBegin := direction ? min(qBegin, qTotal0) : max(qBegin, qTotal0)'
 3940 |     |   //
 3941 |     |   // which is equivalent to setting:
 3942 |     |   //
 3943 |     |   //  'qBegin := qTotal0'
 3944 |     |   //
 3945 |     |   // if and only if 'direction != (qBegin < qTotal0)'.
 3946 |     |   //
 3947 |     |   // Signed comparison is valid because as we argued before in this script,
 3948 |     |   // both 'qBegin' and 'qTotal0' are greater than '0' and less than '32'. This
 3949 |     |   // is due to the custom error 'BlankIntervalsShouldBeAvoided' ensures that
 3950 |     |   // '16 + qLower' is greater than 'qSpacing' and '16 + qUpper' is smaller than
 3951 |     |   // '32 - qSpacing'.
 3952 |     |   if (direction != _begin_.log() < _total0_.log()) {
 3953 |     |     _begin_.copyPrice(_total0_);
 3954 |     |   }
 3955 |     | 
 3956 |     |   // Next, we need to set:
 3957 |     |   //
 3958 |     |   //  'qOvershoot := direction ? min(qEnd, qTotal1) : max(qEnd, qTotal1)'
 3959 |     |   //
 3960 |     |   // which is equivalent to setting:
 3961 |     |   //
 3962 |     |   //  'qOvershoot := qTotal1'
 3963 |     |   //
 3964 |     |   // if and only if 'direction == (qEnd < qTotal1)' and
 3965 |     |   //
 3966 |     |   //  'qOvershoot := qEnd'
 3967 |     |   //
 3968 |     |   // otherwise.
 3969 |     |   //
 3970 |     |   // Signed comparison is valid because as we argued before.
 3971 |     |   _overshoot_.copyPrice(
 3972 |     |     (direction == (_end_.log() < _total1_.log())) ? _total1_ : _end_
 3973 |     |   );
 3974 |     | 
 3975 |     |   if (direction == getZeroForOne()) {
 3976 |     |     // In this case, we need to set:
 3977 |     |     //
 3978 |     |     //  'qBegin := direction ? min(qBegin, qForward0) : max(qBegin, qForward0)'
 3979 |     |     //
 3980 |     |     // which is equivalent to setting:
 3981 |     |     //
 3982 |     |     //  'qBegin := qForward0'
 3983 |     |     //
 3984 |     |     // if and only if 'direction != (qBegin < qForward0)'.
 3985 |     |     //
 3986 |     |     // Signed comparison is valid because as we argued before.
 3987 |     |     if (direction != (_begin_.log() < _forward0_.log())) {
 3988 |     |       _begin_.copyPrice(_forward0_);
 3989 |     |     }
 3990 |     | 
 3991 |     |     // Next, we need to set:
 3992 |     |     //
 3993 |     |     //  'qOvershoot := direction ? 
 3994 |     |     //                 min(qOvershoot, qForward1) : 
 3995 |     |     //                 max(qOvershoot, qForward1)'
 3996 |     |     //
 3997 |     |     // which is equivalent to setting:
 3998 |     |     //
 3999 |     |     //  'qOvershoot := qForward1'
 4000 |     |     //
 4001 |     |     // if and only if 'direction == (qOvershoot < qForward1)'.
 4002 |     |     //
 4003 |     |     // Signed comparison is valid because as we argued before.
 4004 |     |     if (direction == (_overshoot_.log() < _forward1_.log())) {
 4005 |     |       _overshoot_.copyPrice(_forward1_);
 4006 |     |     }
 4007 |     |   }
 4008 |     | 
 4009 |     |   // Next, if 'direction == getZeroForOne()', we increment the integrals:
 4010 |     |   //
 4011 |     |   //  - 'currentToOvershoot',
 4012 |     |   //  - 'targetToOvershoot',
 4013 |     |   //  - 'originToOvershoot'.
 4014 |     |   //
 4015 |     |   // Otherwise, we increment the integrals:
 4016 |     |   //
 4017 |     |   //  - 'currentToOrigin'
 4018 |     |   //  - 'originToOvershoot'
 4019 |     |   //
 4020 |     |   // As argued before, if 'direction == false', then
 4021 |     |   //
 4022 |     |   //  'qTotal0 <= qBegin <= qOvershoot <= qTotal1'.
 4023 |     |   //
 4024 |     |   // and if 'direction == true', then
 4025 |     |   //
 4026 |     |   //  'qTotal1 <= qOvershoot <= qBegin <= qTotal0'.
 4027 |     |   //
 4028 |     |   // Additionally, since the vertical coordinates of kernel are monotonic,
 4029 |     |   // we have 'cTotal0 <= cTotal1' and the input requirements of 'outgoing'
 4030 |     |   // are satisfied.
 4031 |     |   X216 outgoingTotal = _total0_.outgoing(_begin_, _overshoot_);
 4032 |     |   if (direction == getZeroForOne()) {
 4033 |     |     // As argued before, if 'direction == false', then
 4034 |     |     //
 4035 |     |     //  'qForward0 <= qBegin <= qOvershoot <= qForward1'.
 4036 |     |     //
 4037 |     |     // and if 'direction == true', then
 4038 |     |     //
 4039 |     |     //  'qForward1 <= qOvershoot <= qBegin <= qForward0'.
 4040 |     |     //
 4041 |     |     // Additionally, since the vertical coordinates of kernel are monotonic,
 4042 |     |     // we have 'cForward0 <= cForward1' and the input requirements of
 4043 |     |     // 'outgoing' are satisfied.
 4044 |     |     X216 outgoingForward = _forward0_.outgoing(_begin_, _overshoot_);
 4045 |     | 
 4046 |     |     // Next, 'currentToOvershoot' is incremented with 'outgoingTotal'. Based on
 4047 |     |     // the earlier argument in this script, overflow is not possible because
 4048 |     |     // theoretically, no outgoing or incoming integral may exceed 216 bits.
 4049 |     |     _currentToOvershoot_.incrementIntegral(outgoingTotal);
 4050 |     | 
 4051 |     |     // Next, 'targetToOvershoot' is incremented with 'outgoingForward'. Based
 4052 |     |     // on the earlier argument in this script, overflow is not possible because
 4053 |     |     // theoretically, no outgoing or incoming integral may exceed 216 bits.
 4054 |     |     _targetToOvershoot_.incrementIntegral(outgoingForward);
 4055 |     | 
 4056 |     |     // Next, 'originToOvershoot' is incremented with 'outgoingTotal'. Based on
 4057 |     |     // the earlier argument in this script, overflow is not possible because
 4058 |     |     // theoretically, no outgoing or incoming integral may exceed 216 bits.
 4059 |     |     _originToOvershoot_.incrementIntegral(outgoingTotal);
 4060 |     | 
 4061 |     |     // If 'f(qOvershoot) > 0', then we project all of the integrals back to
 4062 |     |     // their original values (prior to calling this function) and return
 4063 |     |     // 'false'. The numerical search for overshoot will then start from
 4064 |     |     // 'qBegin'.
 4065 |     |     if (getMismatch(integral0Incremented, integral1Incremented) > zeroX216) {
 4066 |     |       _end_.copyPrice(_overshoot_);
 4067 |     |       _currentToOvershoot_.decrementIntegral(outgoingTotal);
 4068 |     |       _targetToOvershoot_.decrementIntegral(outgoingForward);
 4069 |     |       _originToOvershoot_.decrementIntegral(outgoingTotal);
 4070 |     |       _overshoot_.copyPrice(_begin_);
 4071 |     |       return false;
 4072 |     |     }
 4073 |     |   } else {
 4074 |     |     // Next, 'currentToOrigin' is incremented with 'outgoingTotal'. Based on
 4075 |     |     // the earlier argument in this script, overflow is not possible because
 4076 |     |     // theoretically, no outgoing or incoming integral may exceed 216 bits.
 4077 |     |     _currentToOrigin_.incrementIntegral(outgoingTotal);
 4078 |     | 
 4079 |     |     // Next, 'originToOvershoot' is incremented with 'outgoingTotal'. Based on
 4080 |     |     // the earlier argument in this script, overflow is not possible because
 4081 |     |     // theoretically, no outgoing or incoming integral may exceed 216 bits.
 4082 |     |     _originToOvershoot_.incrementIntegral(outgoingTotal);
 4083 |     |   }
 4084 |     |   return true;
 4085 |     | }
 4086 |     | 
 4087 |     | /// @notice Assume that the search for 'qTarget' is concluded and we need to
 4088 |     | /// determine 'qOvershoot'. To this end, the following equation should be
 4089 |     | /// solved:
 4090 |     | ///
 4091 |     | ///   'f(qOvershoot) == 0'
 4092 |     | ///
 4093 |     | /// where
 4094 |     | ///
 4095 |     | ///   'f(qOvershoot) := getZeroForOne() ? 
 4096 |     | ///                     s0(qOvershoot) - s1(qOvershoot) : 
 4097 |     | ///                     s1(qOvershoot) - s0(qOvershoot)',
 4098 |     | ///
 4099 |     | /// and the two functions 's0' and 's1' are defined as:
 4100 |     | ///
 4101 |     | ///                          - 8      / qTarget
 4102 |     | ///                        e         |   + h / 2
 4103 |     | ///                       ------- *  |  e        k(wAmended(h)) dh
 4104 |     | ///                          2       |
 4105 |     | ///                                 / qLower
 4106 |     | ///   's1(qOvershoot) := ------------------------------------------',
 4107 |     | ///                                integral1Incremented
 4108 |     | ///
 4109 |     | ///                          - 8      / qUpper
 4110 |     | ///                        e         |   - h / 2
 4111 |     | ///                       ------- *  |  e        k(wAmended(h)) dh
 4112 |     | ///                          2       |
 4113 |     | ///                                 / qTarget
 4114 |     | ///   's0(qOvershoot) := ------------------------------------------',
 4115 |     | ///                                integral0Incremented
 4116 |     | ///
 4117 |     | /// where, according to the amendment procedure which is described in
 4118 |     | /// 'Curve.sol', if 'getZeroForOne() == false', we have:
 4119 |     | ///
 4120 |     | ///                       / k(w(h))            if  qOvershoot < h < qUpper
 4121 |     | ///   'k(wAmended(h)) == |  k(h - qTarget)     if  qTarget < h < qOvershoot '
 4122 |     | ///                      |  k(qOvershoot - h)  if  qOrigin < h < qTarget
 4123 |     | ///                       \ k(w(h))            if  qLower < h < qOrigin
 4124 |     | ///
 4125 |     | /// and if 'getZeroForOne() == true', we have:
 4126 |     | ///
 4127 |     | ///                       / k(w(h))            if  qLower < h < qOvershoot
 4128 |     | ///   'k(wAmended(h)) == |  k(qTarget - h)     if  qOvershoot < h < qTarget '.
 4129 |     | ///                      |  k(h - qOvershoot)  if  qTarget < h < qOrigin
 4130 |     | ///                       \ k(w(h))            if  qOrigin < h < qUpper
 4131 |     | ///
 4132 |     | /// The present function evaluates the Newton step:
 4133 |     | ///
 4134 |     | ///                    f(qOvershoot)
 4135 |     | ///   'qStep = ------------------------------'.
 4136 |     | ///                   d
 4137 |     | ///             -------------- f(qOvershoot)
 4138 |     | ///              d qOvershoot
 4139 |     | ///
 4140 |     | /// To this end, we use the following formula for 'f(qOvershoot)' which is
 4141 |     | /// proven in 'Memory.sol':
 4142 |     | ///
 4143 |     | ///   'f(qOvershoot) := getZeroForOne() ? (
 4144 |     | ///
 4145 |     | ///          integral0Amended         integral1Amended
 4146 |     | ///       ---------------------- - ----------------------
 4147 |     | ///        integral0Incremented     integral1Incremented
 4148 |     | ///
 4149 |     | ///    ) : (
 4150 |     | ///
 4151 |     | ///          integral1Amended         integral0Amended
 4152 |     | ///       ---------------------- - ----------------------
 4153 |     | ///        integral1Incremented     integral0Incremented
 4154 |     | ///
 4155 |     | ///    )',
 4156 |     | ///
 4157 |     | /// where
 4158 |     | ///
 4159 |     | ///   'integral0Amended := getZeroForOne() ? (
 4160 |     | ///
 4161 |     | ///       exp(- (qOrigin + qOvershoot) / 2) * originToOvershoot -
 4162 |     | ///
 4163 |     | ///       exp(- (qTarget + qOvershoot) / 2) * targetToOvershoot - 
 4164 |     | ///
 4165 |     | ///       integral0Incremented + incomingCurrentToTarget - currentToOrigin
 4166 |     | ///
 4167 |     | ///    ) : (
 4168 |     | ///
 4169 |     | ///       integral0Incremented + targetToOvershoot + 
 4170 |     | ///
 4171 |     | ///       currentToTarget - currentToOvershoot
 4172 |     | ///
 4173 |     | ///    )',
 4174 |     | ///
 4175 |     | /// and
 4176 |     | ///
 4177 |     | ///   'integral1Amended := getZeroForOne() ? (
 4178 |     | ///
 4179 |     | ///       integral1Incremented + targetToOvershoot + 
 4180 |     | ///
 4181 |     | ///       currentToTarget - currentToOvershoot
 4182 |     | ///
 4183 |     | ///    ) : (
 4184 |     | ///
 4185 |     | ///       exp(+ (qOrigin + qOvershoot) / 2) * originToOvershoot -
 4186 |     | ///
 4187 |     | ///       exp(+ (qTarget + qOvershoot) / 2) * targetToOvershoot - 
 4188 |     | ///
 4189 |     | ///       integral1Incremented + incomingCurrentToTarget - currentToOrigin
 4190 |     | ///
 4191 |     | ///    )'.
 4192 |     | ///
 4193 |     | /// In addition the following formula is used to compute the derivative:
 4194 |     | ///
 4195 |     | ///          d f
 4196 |     | ///   '-------------- == getZeroForOne() ? (
 4197 |     | ///     d qOvershoot
 4198 |     | ///
 4199 |     | ///      (
 4200 |     | ///
 4201 |     | ///           - 8 + qOvershoot / 2
 4202 |     | ///         e
 4203 |     | ///        ------------------------ * k(qTarget - qOvershoot) - 
 4204 |     | ///                    2
 4205 |     | ///
 4206 |     | ///           - 8 + qOvershoot / 2
 4207 |     | ///         e
 4208 |     | ///        ------------------------ * k(qOrigin - qOvershoot) 
 4209 |     | ///                    2
 4210 |     | ///
 4211 |     | ///      ) / integral1Incremented - (
 4212 |     | ///
 4213 |     | ///          - (qOrigin + qOvershoot) / 2    originToOvershoot
 4214 |     | ///        e                              * ------------------- -
 4215 |     | ///                                                  2
 4216 |     | ///
 4217 |     | ///          - (qTarget + qOvershoot) / 2    targetToOvershoot
 4218 |     | ///        e                              * ------------------- +
 4219 |     | ///                                                  2
 4220 |     | ///           - 8 - qOrigin / 2
 4221 |     | ///         e
 4222 |     | ///        --------------------- * k(qOrigin - qOvershoot) - 
 4223 |     | ///                  2
 4224 |     | ///
 4225 |     | ///           - 8 - qTarget / 2
 4226 |     | ///         e
 4227 |     | ///        --------------------- * k(qTarget - qOvershoot)
 4228 |     | ///                  2
 4229 |     | ///
 4230 |     | ///      ) / integral0Incremented
 4231 |     | ///
 4232 |     | ///    ) : (
 4233 |     | ///
 4234 |     | ///      (
 4235 |     | ///
 4236 |     | ///          + (qOrigin + qOvershoot) / 2    originToOvershoot
 4237 |     | ///        e                              * ------------------- -
 4238 |     | ///                                                  2
 4239 |     | ///
 4240 |     | ///          + (qTarget + qOvershoot) / 2    targetToOvershoot
 4241 |     | ///        e                              * ------------------- +
 4242 |     | ///                                                  2
 4243 |     | ///           - 8 + qOrigin / 2
 4244 |     | ///         e
 4245 |     | ///        --------------------- * k(qOvershoot - qOrigin) -
 4246 |     | ///                  2
 4247 |     | ///
 4248 |     | ///           - 8 + qTarget / 2
 4249 |     | ///         e
 4250 |     | ///        --------------------- * k(qOvershoot - qTarget)
 4251 |     | ///                  2
 4252 |     | ///
 4253 |     | ///      ) / integral1Incremented - (
 4254 |     | ///
 4255 |     | ///           - 8 - qOvershoot / 2
 4256 |     | ///         e
 4257 |     | ///        ------------------------ * k(qOvershoot - qTarget) - 
 4258 |     | ///                    2
 4259 |     | ///
 4260 |     | ///           - 8 - qOvershoot / 2
 4261 |     | ///         e
 4262 |     | ///        ------------------------ * k(qOvershoot - qOrigin) 
 4263 |     | ///                    2
 4264 |     | ///
 4265 |     | ///      ) / integral0Incremented
 4266 |     | ///
 4267 |     | ///    )'.
 4268 |     | ///
 4269 |     | /// @param integral0Incremented The integral of the liquidity distribution
 4270 |     | /// function from 'qTarget' to 'qUpper' prior to the amendment of the curve
 4271 |     | /// sequence:
 4272 |     | ///
 4273 |     | ///                                 - 8     / qUpper
 4274 |     | ///     integral0Incremented      e        |    - h / 2
 4275 |     | ///   '---------------------- := ------- * |  e         k(w(h)) dh',
 4276 |     | ///           2 ** 216              2      |
 4277 |     | ///                                       / qTarget
 4278 |     | ///
 4279 |     | /// @param integral1Incremented The integral of the liquidity distribution
 4280 |     | /// function from 'qLower' to 'qTarget' prior to the amendment of the curve
 4281 |     | /// sequence:
 4282 |     | ///
 4283 |     | ///                                 - 8     / qTarget
 4284 |     | ///     integral1Incremented      e        |    + h / 2
 4285 |     | ///   '---------------------- := ------- * |  e         k(w(h)) dh'.
 4286 |     | ///           2 ** 216              2      |
 4287 |     | ///                                       / qLower
 4288 |     | ///
 4289 |     | /// @return sign The sign of Newton step.
 4290 |     | /// @return step Newton step to be added to/subtracted from the current value
 4291 |     | /// of 'qOvershoot'.
 4292 |     | /// @return integral0Amended The integral of the liquidity distribution function
 4293 |     | /// from 'qTarget' to 'qUpper' after the amendment of the curve sequence:
 4294 |     | ///
 4295 |     | ///                             - 8     / qUpper
 4296 |     | ///     integral0Amended      e        |    - h / 2
 4297 |     | ///   '------------------ := ------- * |  e         k(wAmended(h)) dh'.
 4298 |     | ///         2 ** 216            2      |
 4299 |     | ///                                   / qTarget
 4300 |     | ///
 4301 |     | /// @return integral1Amended The integral of the liquidity distribution function
 4302 |     | /// from 'qLower' to 'qTarget' after the amendment of the curve sequence:
 4303 |     | ///
 4304 |     | ///                             - 8     / qTarget
 4305 |     | ///     integral1Amended      e        |    + h / 2
 4306 |     | ///   '------------------ := ------- * |  e         k(wAmended(h)) dh'.
 4307 |     | ///         2 ** 216            2      |
 4308 |     | ///                                   / qLower
 4309 |     | ///
 4310 |     | function newtonStep(
 4311 |     |   X216 integral0Incremented,
 4312 |     |   X216 integral1Incremented
 4313 |     | ) pure returns (
 4314 |     |   bool sign,
 4315 |     |   X59 step,
 4316 |     |   X216 integral0Amended,
 4317 |     |   X216 integral1Amended
 4318 |     | ) {
 4319 |     |   bool zeroForOne = getZeroForOne();
 4320 |     |   (integral0Incremented, integral1Incremented) = zeroForOne ? 
 4321 |     |     (integral1Incremented, integral0Incremented) : 
 4322 |     |     (integral0Incremented, integral1Incremented);
 4323 |     | 
 4324 |     |   X216 originToTarget;
 4325 |     |   {
 4326 |     |     // At this stage, we have:
 4327 |     |     //
 4328 |     |     //  'currentToOvershoot := _currentToOvershoot_.integral() + outgoingTotal'
 4329 |     |     //
 4330 |     |     // and
 4331 |     |     //
 4332 |     |     //  'originToOvershoot := _originToOvershoot_.integral() + outgoingTotal'
 4333 |     |     //
 4334 |     |     // where
 4335 |     |     //
 4336 |     |     //                         - 8
 4337 |     |     //    outgoingTotal      e
 4338 |     |     //  '--------------- := ------- * (
 4339 |     |     //      2 ** 216           2
 4340 |     |     //
 4341 |     |     //     getZeroForOne() ? 
 4342 |     |     //
 4343 |     |     //       / qBegin
 4344 |     |     //      |    + h / 2
 4345 |     |     //      |  e         k(w(h)) dh :
 4346 |     |     //      |
 4347 |     |     //     / qOvershoot
 4348 |     |     //
 4349 |     |     //       / qOvershoot
 4350 |     |     //      |    - h / 2
 4351 |     |     //      |  e         k(w(h)) dh
 4352 |     |     //      |
 4353 |     |     //     / qBegin
 4354 |     |     //
 4355 |     |     //   )'.
 4356 |     |     //
 4357 |     |     // As argued before, if 'direction == false', then
 4358 |     |     //
 4359 |     |     //  'qTotal0 <= qBegin <= qOvershoot <= qTotal1'.
 4360 |     |     //
 4361 |     |     // and if 'direction == true', then
 4362 |     |     //
 4363 |     |     //  'qTotal1 <= qOvershoot <= qBegin <= qTotal0'.
 4364 |     |     //
 4365 |     |     // Additionally, since the vertical coordinates of kernel are monotonic,
 4366 |     |     // we have 'cTotal0 <= cTotal1' and the input requirements of 'outgoing'
 4367 |     |     // are satisfied.
 4368 |     |     X216 outgoingTotal = _total0_.outgoing(_begin_, _overshoot_);
 4369 |     | 
 4370 |     |     // At this stage, we have:
 4371 |     |     //
 4372 |     |     //  'targetToOvershoot := _targetToOvershoot_.integral() + outgoingForward'
 4373 |     |     //
 4374 |     |     // where
 4375 |     |     //                           - 8
 4376 |     |     //    outgoingForward      e
 4377 |     |     //  '----------------- := ------- * (
 4378 |     |     //       2 ** 216            2
 4379 |     |     //
 4380 |     |     //     getZeroForOne() ? 
 4381 |     |     //
 4382 |     |     //       / qBegin
 4383 |     |     //      |    + h / 2
 4384 |     |     //      |  e         k(qTarget - h) dh :
 4385 |     |     //      |
 4386 |     |     //     / qOvershoot
 4387 |     |     //
 4388 |     |     //       / qOvershoot
 4389 |     |     //      |    - h / 2
 4390 |     |     //      |  e         k(h - qTarget) dh
 4391 |     |     //      |
 4392 |     |     //     / qBegin
 4393 |     |     //
 4394 |     |     //   )'.
 4395 |     |     //
 4396 |     |     // As argued before, if 'direction == false', then
 4397 |     |     //
 4398 |     |     //  'qForward0 <= qBegin <= qOvershoot <= qForward1'.
 4399 |     |     //
 4400 |     |     // and if 'direction == true', then
 4401 |     |     //
 4402 |     |     //  'qForward1 <= qOvershoot <= qBegin <= qForward0'.
 4403 |     |     //
 4404 |     |     // Additionally, since the vertical coordinates of kernel are monotonic,
 4405 |     |     // we have 'cForward0 <= cForward1' and the input requirements of
 4406 |     |     // 'outgoing' are satisfied.
 4407 |     |     X216 outgoingForward = _forward0_.outgoing(_begin_, _overshoot_);
 4408 |     | 
 4409 |     |     // Next, we calculate:
 4410 |     |     //
 4411 |     |     //  'getZeroForOne() ? integral1Amended : integral0Amended'.
 4412 |     |     //
 4413 |     |     // The operations are theoretically safe. However, the output may be negative
 4414 |     |     // due to rounding error.
 4415 |     |     integral0Amended = integral0Incremented
 4416 |     |       + _currentToTarget_.integral()
 4417 |     |       - (_currentToOvershoot_.integral() + outgoingTotal)
 4418 |     |       + (_targetToOvershoot_.integral() + outgoingForward);
 4419 |     | 
 4420 |     |     // The output is capped to prevent negative values due to rounding error.
 4421 |     |     integral0Amended = max(integral0Amended, zeroX216);
 4422 |     | 
 4423 |     |     // Define, 'originToTarget' as:
 4424 |     |     //
 4425 |     |     //   'getZeroForOne() ? (
 4426 |     |     //
 4427 |     |     //       exp(- (qOrigin + qOvershoot) / 2) * originToOvershoot -
 4428 |     |     //
 4429 |     |     //       exp(- (qTarget + qOvershoot) / 2) * targetToOvershoot
 4430 |     |     //
 4431 |     |     //    ) : (
 4432 |     |     //
 4433 |     |     //       exp(+ (qOrigin + qOvershoot) / 2) * originToOvershoot -
 4434 |     |     //
 4435 |     |     //       exp(+ (qTarget + qOvershoot) / 2) * targetToOvershoot
 4436 |     |     //
 4437 |     |     //    )'
 4438 |     |     //
 4439 |     |     originToTarget = (
 4440 |     |       _originToOvershoot_.integral() + outgoingTotal
 4441 |     |     ).shift(
 4442 |     |       _overshoot_,
 4443 |     |       _origin_,
 4444 |     |       zeroForOne
 4445 |     |     ) - (
 4446 |     |       _targetToOvershoot_.integral() + outgoingForward
 4447 |     |     ).shift(
 4448 |     |       _overshoot_,
 4449 |     |       _target_,
 4450 |     |       zeroForOne
 4451 |     |     );
 4452 |     |   }
 4453 |     | 
 4454 |     |   // Next, we calculate:
 4455 |     |   //
 4456 |     |   //   'integral1Amended := getZeroForOne() ? (
 4457 |     |   //
 4458 |     |   //       exp(- (qOrigin + qOvershoot) / 2) * originToOvershoot -
 4459 |     |   //
 4460 |     |   //       exp(- (qTarget + qOvershoot) / 2) * targetToOvershoot - 
 4461 |     |   //
 4462 |     |   //       integral0Incremented + incomingCurrentToTarget - currentToOrigin
 4463 |     |   //
 4464 |     |   //    ) : (
 4465 |     |   //
 4466 |     |   //       exp(+ (qOrigin + qOvershoot) / 2) * originToOvershoot -
 4467 |     |   //
 4468 |     |   //       exp(+ (qTarget + qOvershoot) / 2) * targetToOvershoot - 
 4469 |     |   //
 4470 |     |   //       integral1Incremented + incomingCurrentToTarget - currentToOrigin
 4471 |     |   //
 4472 |     |   //    )',
 4473 |     |   //
 4474 |     |   // The operations are theoretically safe. However, the output may be negative
 4475 |     |   // due to rounding error.
 4476 |     |   integral1Amended = integral1Incremented
 4477 |     |     + originToTarget
 4478 |     |     - _currentToOrigin_.integral()
 4479 |     |     - _incomingCurrentToTarget_.integral();
 4480 |     | 
 4481 |     |   // The output is capped to prevent negative values due to rounding error.
 4482 |     |   integral1Amended = max(integral1Amended, zeroX216);
 4483 |     | 
 4484 |     |   // Next, we calculate:
 4485 |     |   //
 4486 |     |   //      - 8
 4487 |     |   //    e
 4488 |     |   //  '------- * k(|qOrigin - qOvershoot|)'.
 4489 |     |   //      2
 4490 |     |   //
 4491 |     |   // As argued before, if 'direction == false', then
 4492 |     |   //
 4493 |     |   //  'qTotal0 <= qOvershoot <= qTotal1'.
 4494 |     |   //
 4495 |     |   // and if 'direction == true', then
 4496 |     |   //
 4497 |     |   //  'qTotal1 <= qOvershoot <= qTotal0'.
 4498 |     |   //
 4499 |     |   // Additionally, since the vertical coordinates of kernel are monotonic,
 4500 |     |   // we have 'cTotal0 <= cTotal1' and the input requirements of 'outgoing'
 4501 |     |   // are satisfied.
 4502 |     |   X216 overshootMinusOrigin = _total0_.evaluate(_overshoot_);
 4503 |     | 
 4504 |     |   // Then:
 4505 |     |   //
 4506 |     |   //      - 8
 4507 |     |   //    e
 4508 |     |   //  '------- * k(|qTarget - qOvershoot|)'.
 4509 |     |   //      2
 4510 |     |   //
 4511 |     |   // As argued before, if 'direction == false', then
 4512 |     |   //
 4513 |     |   //  'qForward0 <= qOvershoot <= qForward1'.
 4514 |     |   //
 4515 |     |   // and if 'direction == true', then
 4516 |     |   //
 4517 |     |   //  'qForward1 <= qOvershoot <= qForward0'.
 4518 |     |   //
 4519 |     |   // Additionally, since the vertical coordinates of kernel are monotonic,
 4520 |     |   // we have 'cForward0 <= cForward1' and the input requirements of
 4521 |     |   // 'outgoing' are satisfied.
 4522 |     |   X216 overshootMinusTarget = _forward0_.evaluate(_overshoot_);
 4523 |     | 
 4524 |     |   //  'getZeroForOne() ? (
 4525 |     |   //
 4526 |     |   //         - 8 - qOrigin / 2
 4527 |     |   //       e
 4528 |     |   //      --------------------- * k(qOrigin - qOvershoot) - 
 4529 |     |   //                2
 4530 |     |   //
 4531 |     |   //         - 8 - qTarget / 2
 4532 |     |   //       e
 4533 |     |   //      --------------------- * k(qTarget - qOvershoot)
 4534 |     |   //                2
 4535 |     |   //
 4536 |     |   //   ) : (
 4537 |     |   //
 4538 |     |   //         - 8 + qOrigin / 2
 4539 |     |   //       e
 4540 |     |   //      --------------------- * k(qOvershoot - qOrigin) -
 4541 |     |   //                2
 4542 |     |   //
 4543 |     |   //         - 8 + qTarget / 2
 4544 |     |   //       e
 4545 |     |   //      --------------------- * k(qOvershoot - qTarget)
 4546 |     |   //                2
 4547 |     |   //
 4548 |     |   //   )'.
 4549 |     |   //
 4550 |     |   // The requirements 'mulDivByExpInv8' are satisfied because:
 4551 |     |   //
 4552 |     |   //  'zeroX216 <= _origin_.sqrt(!zeroForOne) < oneX216',
 4553 |     |   //  'zeroX216 <= _target_.sqrt(!zeroForOne) < oneX216'.
 4554 |     |   //
 4555 |     |   X216 integral1AmendedPrime = 
 4556 |     |     _origin_.sqrt(!zeroForOne) % overshootMinusOrigin  - 
 4557 |     |     _target_.sqrt(!zeroForOne) % overshootMinusTarget;
 4558 |     | 
 4559 |     |   //  'getZeroForOne() ? (
 4560 |     |   //
 4561 |     |   //      exp(- (qOrigin + qOvershoot) / 2) * originToOvershoot -
 4562 |     |   //
 4563 |     |   //      exp(- (qTarget + qOvershoot) / 2) * targetToOvershoot +
 4564 |     |   //
 4565 |     |   //        - 8 - qOrigin / 2
 4566 |     |   //      e                   * k(qOrigin - qOvershoot) - 
 4567 |     |   //
 4568 |     |   //        - 8 - qTarget / 2
 4569 |     |   //      e                   * k(qTarget - qOvershoot)
 4570 |     |   //
 4571 |     |   //   ) : (
 4572 |     |   //
 4573 |     |   //      exp(+ (qOrigin + qOvershoot) / 2) * originToOvershoot -
 4574 |     |   //
 4575 |     |   //      exp(+ (qTarget + qOvershoot) / 2) * targetToOvershoot +
 4576 |     |   //
 4577 |     |   //        - 8 + qOrigin / 2
 4578 |     |   //      e                   * k(qOvershoot - qOrigin) -
 4579 |     |   //
 4580 |     |   //        - 8 + qTarget / 2
 4581 |     |   //      e                   * k(qOvershoot - qTarget)
 4582 |     |   //
 4583 |     |   //   )'.
 4584 |     |   integral1AmendedPrime = 
 4585 |     |     originToTarget + integral1AmendedPrime + integral1AmendedPrime;
 4586 |     | 
 4587 |     |   //   'getZeroForOne() ? (
 4588 |     |   //
 4589 |     |   //           - 8 + qOvershoot / 2
 4590 |     |   //         e                      * k(qTarget - qOvershoot) - 
 4591 |     |   //
 4592 |     |   //           - 8 + qOvershoot / 2
 4593 |     |   //         e                      * k(qOrigin - qOvershoot) 
 4594 |     |   //
 4595 |     |   //    ) : (
 4596 |     |   //
 4597 |     |   //           - 8 - qOvershoot / 2
 4598 |     |   //         e                      * k(qOvershoot - qTarget) - 
 4599 |     |   //
 4600 |     |   //           - 8 - qOvershoot / 2
 4601 |     |   //         e                      * k(qOvershoot - qOrigin) 
 4602 |     |   //
 4603 |     |   //    )'.
 4604 |     |   X216 integral0AmendedPrime = _overshoot_.sqrt(zeroForOne) % (
 4605 |     |     overshootMinusOrigin - overshootMinusTarget
 4606 |     |   );
 4607 |     |   integral0AmendedPrime = integral0AmendedPrime + integral0AmendedPrime;
 4608 |     | 
 4609 |     |   // 'f(qOvershoot)' is calculated next. The result may or may not be negative.
 4610 |     |   // The requirements of cheapMul are satisfied because all four integrals are
 4611 |     |   // non-negative and less than 'oneX216'.
 4612 |     |   X216 mismatch;
 4613 |     |   (mismatch, integral0Amended, integral1Amended) = zeroForOne ? (
 4614 |     |     (
 4615 |     |       integral0Incremented & integral1Amended
 4616 |     |     ) - (
 4617 |     |       integral1Incremented & integral0Amended
 4618 |     |     ),
 4619 |     |     integral1Amended,
 4620 |     |     integral0Amended
 4621 |     |   ) : (
 4622 |     |     (
 4623 |     |       integral1Incremented & integral0Amended
 4624 |     |     ) - (
 4625 |     |       integral0Incremented & integral1Amended
 4626 |     |     ),
 4627 |     |     integral0Amended,
 4628 |     |     integral1Amended
 4629 |     |   );
 4630 |     | 
 4631 |     |   // Next, the derivative of 'f' with respect to 'qOvershoot' is calculated.
 4632 |     |   // Multiplications do not overflow because both integrals are non-negative
 4633 |     |   // and less than 'oneX216'. Additionally, 'integral0AmendedPrime' and
 4634 |     |   // 'integral1AmendedPrime' are composed of up to 4 integrals and their
 4635 |     |   // absolute value does not exceed '2 ** 218'.
 4636 |     |   X216 mismatchPrime = (
 4637 |     |     integral0Incremented * integral1AmendedPrime
 4638 |     |   ) + (
 4639 |     |     integral1Incremented * integral0AmendedPrime
 4640 |     |   );
 4641 |     | 
 4642 |     |   // Sign of the Newton step is determined.
 4643 |     |   sign = (mismatch > zeroX216) != (mismatchPrime > zeroX216);
 4644 |     | 
 4645 |     |   // The Newton step is calculated next.
 4646 |     |   // Multiplication does not overflow because '-oneX216 <= mismatch <= oneX216'
 4647 |     |   // Division by zero results on 'step == zeroX59'.
 4648 |     |   assembly {
 4649 |     |     step := sdiv(mul(shl(38, 1), mismatch), sar(22, mismatchPrime))
 4650 |     |   }
 4651 |     | 
 4652 |     |   if (step == zeroX59) {
 4653 |     |     assembly {
 4654 |     |       mismatchPrime := sar(22, mismatchPrime)
 4655 |     |     }
 4656 |     |     if (mismatch != zeroX216) {
 4657 |     |       require(mismatchPrime != zeroX216, SearchingForOvershootFailed());
 4658 |     |     }
 4659 |     |   }
 4660 |     | }
 4661 |     | 
 4662 |     | /// @notice Calculates 'integral0Amended' and 'integral1Amended' efficiently.
 4663 |     | ///
 4664 |     | /// @param integral0Incremented The integral of the liquidity distribution
 4665 |     | /// function from 'qTarget' to 'qUpper' prior to the amendment of the curve
 4666 |     | /// sequence:
 4667 |     | ///
 4668 |     | ///                                 - 8     / qUpper
 4669 |     | ///     integral0Incremented      e        |    - h / 2
 4670 |     | ///   '---------------------- := ------- * |  e         k(w(h)) dh',
 4671 |     | ///           2 ** 216              2      |
 4672 |     | ///                                       / qTarget
 4673 |     | ///
 4674 |     | /// @param integral1Incremented The integral of the liquidity distribution
 4675 |     | /// function from 'qLower' to 'qTarget' prior to the amendment of the curve
 4676 |     | /// sequence:
 4677 |     | ///
 4678 |     | ///                                 - 8     / qTarget
 4679 |     | ///     integral1Incremented      e        |    + h / 2
 4680 |     | ///   '---------------------- := ------- * |  e         k(w(h)) dh'.
 4681 |     | ///           2 ** 216              2      |
 4682 |     | ///                                       / qLower
 4683 |     | ///
 4684 |     | /// @return integral0Amended The integral of the liquidity distribution function
 4685 |     | /// from 'qTarget' to 'qUpper' after the amendment of the curve sequence:
 4686 |     | ///
 4687 |     | ///                             - 8     / qUpper
 4688 |     | ///     integral0Amended      e        |    - h / 2
 4689 |     | ///   '------------------ := ------- * |  e         k(wAmended(h)) dh'.
 4690 |     | ///         2 ** 216            2      |
 4691 |     | ///                                   / qTarget
 4692 |     | ///
 4693 |     | /// @return integral1Amended The integral of the liquidity distribution function
 4694 |     | /// from 'qLower' to 'qTarget' after the amendment of the curve sequence:
 4695 |     | ///
 4696 |     | ///                             - 8     / qTarget
 4697 |     | ///     integral1Amended      e        |    + h / 2
 4698 |     | ///   '------------------ := ------- * |  e         k(wAmended(h)) dh'.
 4699 |     | ///         2 ** 216            2      |
 4700 |     | ///                                   / qLower
 4701 |     | ///
 4702 |     | function newIntegrals(
 4703 |     |   X216 integral0Incremented,
 4704 |     |   X216 integral1Incremented
 4705 |     | ) pure returns (
 4706 |     |   X216 integral0Amended,
 4707 |     |   X216 integral1Amended
 4708 |     | ) {
 4709 |     |   bool zeroForOne = getZeroForOne();
 4710 |     |   (integral0Incremented, integral1Incremented) = zeroForOne ? 
 4711 |     |     (integral1Incremented, integral0Incremented) : 
 4712 |     |     (integral0Incremented, integral1Incremented);
 4713 |     | 
 4714 |     |   // At this stage, we have:
 4715 |     |   //
 4716 |     |   //  'currentToOvershoot := _currentToOvershoot_.integral() + outgoingTotal'
 4717 |     |   //
 4718 |     |   // and
 4719 |     |   //
 4720 |     |   //  'originToOvershoot := _originToOvershoot_.integral() + outgoingTotal'
 4721 |     |   //
 4722 |     |   // where
 4723 |     |   //
 4724 |     |   //                         - 8
 4725 |     |   //    outgoingTotal      e
 4726 |     |   //  '--------------- := ------- * (
 4727 |     |   //      2 ** 216           2
 4728 |     |   //
 4729 |     |   //     getZeroForOne() ? 
 4730 |     |   //
 4731 |     |   //       / qBegin
 4732 |     |   //      |    + h / 2
 4733 |     |   //      |  e         k(w(h)) dh :
 4734 |     |   //      |
 4735 |     |   //     / qOvershoot
 4736 |     |   //
 4737 |     |   //       / qOvershoot
 4738 |     |   //      |    - h / 2
 4739 |     |   //      |  e         k(w(h)) dh
 4740 |     |   //      |
 4741 |     |   //     / qBegin
 4742 |     |   //
 4743 |     |   //   )'.
 4744 |     |   //
 4745 |     |   // As argued before, if 'direction == false', then
 4746 |     |   //
 4747 |     |   //  'qTotal0 <= qBegin <= qOvershoot <= qTotal1'.
 4748 |     |   //
 4749 |     |   // and if 'direction == true', then
 4750 |     |   //
 4751 |     |   //  'qTotal1 <= qOvershoot <= qBegin <= qTotal0'.
 4752 |     |   //
 4753 |     |   // Additionally, since the vertical coordinates of kernel are monotonic,
 4754 |     |   // we have 'cTotal0 <= cTotal1' and the input requirements of 'outgoing'
 4755 |     |   // are satisfied.
 4756 |     |   X216 outgoingTotal = _total0_.outgoing(_begin_, _overshoot_);
 4757 |     | 
 4758 |     |   // At this stage, we have:
 4759 |     |   //
 4760 |     |   //  'targetToOvershoot := _targetToOvershoot_.integral() + outgoingForward'
 4761 |     |   //
 4762 |     |   // where
 4763 |     |   //                           - 8
 4764 |     |   //    outgoingForward      e
 4765 |     |   //  '----------------- := ------- * (
 4766 |     |   //       2 ** 216            2
 4767 |     |   //
 4768 |     |   //     getZeroForOne() ? 
 4769 |     |   //
 4770 |     |   //       / qBegin
 4771 |     |   //      |    + h / 2
 4772 |     |   //      |  e         k(qTarget - h) dh :
 4773 |     |   //      |
 4774 |     |   //     / qOvershoot
 4775 |     |   //
 4776 |     |   //       / qOvershoot
 4777 |     |   //      |    - h / 2
 4778 |     |   //      |  e         k(h - qTarget) dh
 4779 |     |   //      |
 4780 |     |   //     / qBegin
 4781 |     |   //
 4782 |     |   //   )'.
 4783 |     |   //
 4784 |     |   // As argued before, if 'direction == false', then
 4785 |     |   //
 4786 |     |   //  'qForward0 <= qBegin <= qOvershoot <= qForward1'.
 4787 |     |   //
 4788 |     |   // and if 'direction == true', then
 4789 |     |   //
 4790 |     |   //  'qForward1 <= qOvershoot <= qBegin <= qForward0'.
 4791 |     |   //
 4792 |     |   // Additionally, since the vertical coordinates of kernel are monotonic,
 4793 |     |   // we have 'cForward0 <= cForward1' and the input requirements of
 4794 |     |   // 'outgoing' are satisfied.
 4795 |     |   X216 outgoingForward = _forward0_.outgoing(_begin_, _overshoot_);
 4796 |     | 
 4797 |     |   // Define, 'originToTarget' as:
 4798 |     |   //
 4799 |     |   //   'getZeroForOne() ? (
 4800 |     |   //
 4801 |     |   //       exp(- (qOrigin + qOvershoot) / 2) * originToOvershoot -
 4802 |     |   //
 4803 |     |   //       exp(- (qTarget + qOvershoot) / 2) * targetToOvershoot
 4804 |     |   //
 4805 |     |   //    ) : (
 4806 |     |   //
 4807 |     |   //       exp(+ (qOrigin + qOvershoot) / 2) * originToOvershoot -
 4808 |     |   //
 4809 |     |   //       exp(+ (qTarget + qOvershoot) / 2) * targetToOvershoot
 4810 |     |   //
 4811 |     |   //    )'
 4812 |     |   //
 4813 |     |   X216 originToTarget = (_originToOvershoot_.integral() + outgoingTotal).shift(
 4814 |     |     _overshoot_,
 4815 |     |     _origin_,
 4816 |     |     zeroForOne
 4817 |     |   ) - (_targetToOvershoot_.integral() + outgoingForward).shift(
 4818 |     |     _overshoot_,
 4819 |     |     _target_,
 4820 |     |     zeroForOne
 4821 |     |   );
 4822 |     | 
 4823 |     |   // Next, we calculate:
 4824 |     |   //
 4825 |     |   //  'getZeroForOne() ? integral1Amended : integral0Amended'.
 4826 |     |   //
 4827 |     |   // The operations are theoretically safe. However, the output may be negative
 4828 |     |   // due to rounding error.
 4829 |     |   integral0Amended = integral0Incremented
 4830 |     |     + _currentToTarget_.integral()
 4831 |     |     - (_currentToOvershoot_.integral() + outgoingTotal)
 4832 |     |     + (_targetToOvershoot_.integral() + outgoingForward);
 4833 |     | 
 4834 |     |   // The output is capped to prevent negative values due to rounding error.
 4835 |     |   integral0Amended = max(integral0Amended, zeroX216);
 4836 |     | 
 4837 |     |   // Next, we calculate:
 4838 |     |   //
 4839 |     |   //   'integral1Amended := getZeroForOne() ? (
 4840 |     |   //
 4841 |     |   //       exp(- (qOrigin + qOvershoot) / 2) * originToOvershoot -
 4842 |     |   //
 4843 |     |   //       exp(- (qTarget + qOvershoot) / 2) * targetToOvershoot - 
 4844 |     |   //
 4845 |     |   //       integral0Incremented + incomingCurrentToTarget - currentToOrigin
 4846 |     |   //
 4847 |     |   //    ) : (
 4848 |     |   //
 4849 |     |   //       exp(+ (qOrigin + qOvershoot) / 2) * originToOvershoot -
 4850 |     |   //
 4851 |     |   //       exp(+ (qTarget + qOvershoot) / 2) * targetToOvershoot - 
 4852 |     |   //
 4853 |     |   //       integral1Incremented + incomingCurrentToTarget - currentToOrigin
 4854 |     |   //
 4855 |     |   //    )',
 4856 |     |   //
 4857 |     |   // The operations are theoretically safe. However, the output may be negative
 4858 |     |   // due to rounding error.
 4859 |     |   integral1Amended = integral1Incremented
 4860 |     |     + originToTarget
 4861 |     |     - _currentToOrigin_.integral()
 4862 |     |     - _incomingCurrentToTarget_.integral();
 4863 |     | 
 4864 |     |   // The output is capped to prevent negative values due to rounding error.
 4865 |     |   integral1Amended = max(integral1Amended, zeroX216);
 4866 |     | 
 4867 |     |   // The amended integrals are set depending on the direction.
 4868 |     |   (integral0Amended, integral1Amended) = zeroForOne ? 
 4869 |     |     (integral1Amended, integral0Amended) : 
 4870 |     |     (integral0Amended, integral1Amended);
 4871 |     | }
 4872 |     | 
 4873 |     | /// @notice Performs Newton search to find the optimal mismatch value.
 4874 |     | /// For each swap, the protocol moves the current price to an 'overshoot' price
 4875 |     | /// and then projects it back to the 'target' price. The 'overshoot' value
 4876 |     | /// is determined using newton search in such a way that the total liquidity
 4877 |     | /// growth is maximized. Notice that the incoming and outgoing values are
 4878 |     | /// already determined and this process is only concerned with curve update.
 4879 |     | ///
 4880 |     | /// @param integral0Incremented The integral of the liquidity distribution
 4881 |     | /// function from 'qTarget' to 'qUpper' prior to the amendment of the curve
 4882 |     | /// sequence:
 4883 |     | ///
 4884 |     | ///                                 - 8     / qUpper
 4885 |     | ///     integral0Incremented      e        |    - h / 2
 4886 |     | ///   '---------------------- := ------- * |  e         k(w(h)) dh',
 4887 |     | ///           2 ** 216              2      |
 4888 |     | ///                                       / qTarget
 4889 |     | ///
 4890 |     | /// @param integral1Incremented The integral of the liquidity distribution
 4891 |     | /// function from 'qLower' to 'qTarget' prior to the amendment of the curve
 4892 |     | /// sequence:
 4893 |     | ///
 4894 |     | ///                                 - 8     / qTarget
 4895 |     | ///     integral1Incremented      e        |    + h / 2
 4896 |     | ///   '---------------------- := ------- * |  e         k(w(h)) dh'.
 4897 |     | ///           2 ** 216              2      |
 4898 |     | ///                                       / qLower
 4899 |     | ///
 4900 |     | /// @return integral0Amended The integral of the liquidity distribution function
 4901 |     | /// from 'qTarget' to 'qUpper' after the amendment of the curve sequence:
 4902 |     | ///
 4903 |     | ///                             - 8     / qUpper
 4904 |     | ///     integral0Amended      e        |    - h / 2
 4905 |     | ///   '------------------ := ------- * |  e         k(wAmended(h)) dh'.
 4906 |     | ///         2 ** 216            2      |
 4907 |     | ///                                   / qTarget
 4908 |     | ///
 4909 |     | /// @return integral1Amended The integral of the liquidity distribution function
 4910 |     | /// from 'qLower' to 'qTarget' after the amendment of the curve sequence:
 4911 |     | ///
 4912 |     | ///                             - 8     / qTarget
 4913 |     | ///     integral1Amended      e        |    + h / 2
 4914 |     | ///   '------------------ := ------- * |  e         k(wAmended(h)) dh'.
 4915 |     | ///         2 ** 216            2      |
 4916 |     | ///                                   / qLower
 4917 |     | ///
 4918 |     | function searchOvershoot(
 4919 |     |   X216 integral0Incremented,
 4920 |     |   X216 integral1Incremented
 4921 |     | ) pure returns (
 4922 |     |   X216 integral0Amended,
 4923 |     |   X216 integral1Amended
 4924 |     | ) {
 4925 |     |   bool zeroForOne = getZeroForOne();
 4926 |     | 
 4927 |     |   // Newton search is performed here:
 4928 |     |   X59 step;
 4929 |     |   bool sign;
 4930 |     |   while (true) {
 4931 |     |     (sign, step, integral0Amended, integral1Amended) = newtonStep(
 4932 |     |       integral0Incremented,
 4933 |     |       integral1Incremented
 4934 |     |     );
 4935 |     |     if (step == zeroX59) break;
 4936 |     |     // The addition is safe because overshoot remains within the interval.
 4937 |     |     _overshoot_.storePrice(
 4938 |     |       zeroForOne ? 
 4939 |     |       min(max(_end_.log(), _overshoot_.log() + step), _begin_.log()) :
 4940 |     |       min(max(_begin_.log(), _overshoot_.log() + step), _end_.log())
 4941 |     |     );
 4942 |     |   }
 4943 |     | 
 4944 |     |   // We intend to maximize marginal growth which is equal to:
 4945 |     |   //
 4946 |     |   //        integral0Incremented     integral1Incremented
 4947 |     |   //  'min(---------------------- , ----------------------)'
 4948 |     |   //          integral0Amended         integral1Amended
 4949 |     |   //
 4950 |     |   // Given that 'integral0Incremented' and 'integral1Incremented' are constant,
 4951 |     |   // this is equivalent to minimizing the following.
 4952 |     |   //
 4953 |     |   // Both multiplications are safe because all four integrals do not exceed
 4954 |     |   // 'oneX216'.
 4955 |     |   X216 growthInverse = max(
 4956 |     |     integral0Incremented & integral1Amended,
 4957 |     |     integral1Incremented & integral0Amended
 4958 |     |   );
 4959 |     | 
 4960 |     |   // Next, we move overshoot one step forward or backward to make sure that it
 4961 |     |   // is perfectly optimized.
 4962 |     | 
 4963 |     |   // If we are not at the end of the search interval and sign is aligned with
 4964 |     |   // zeroForOne, then overshoot is moved one step forward.
 4965 |     |   bool forward = (_overshoot_.log() != _end_.log()) && (sign == zeroForOne);
 4966 |     | 
 4967 |     |   // If we are not at the beginning of the search interval and sign is not 
 4968 |     |   // aligned with zeroForOne, then overshoot is moved one step backward.
 4969 |     |   bool backward = (_overshoot_.log() != _begin_.log()) && (sign != zeroForOne);
 4970 |     | 
 4971 |     |   // If either forward or backward are true we move the overshoot.
 4972 |     |   if (forward || backward) {
 4973 |     |     // Backing up 'integral0Amended' and 'integral1Amended'.
 4974 |     |     X216 _integral0Amended = integral0Amended;
 4975 |     |     X216 _integral1Amended = integral1Amended;
 4976 |     |     _end_.copyPrice(_overshoot_); // Backing up 'overshoot'.
 4977 |     | 
 4978 |     |     // Moving one step forward or backward.
 4979 |     |     // This is safe due to the prior 'if'.
 4980 |     |     // Notice that 'forward' and 'backward' are mutually exclusive.
 4981 |     |     moveOvershootByEpsilon(forward == zeroForOne);
 4982 |     |     (integral0Amended, integral1Amended) = newIntegrals(
 4983 |     |       integral0Incremented,
 4984 |     |       integral1Incremented
 4985 |     |     );
 4986 |     | 
 4987 |     |     // Both multiplications are safe because all four integrals do not exceed
 4988 |     |     // 'oneX216'.
 4989 |     |     X216 _growthInverse = max(
 4990 |     |       integral0Incremented & integral1Amended,
 4991 |     |       integral1Incremented & integral0Amended
 4992 |     |     );
 4993 |     | 
 4994 |     |     if (_growthInverse >= growthInverse) {
 4995 |     |       _overshoot_.copyPrice(_end_); // Moving forward.
 4996 |     |       integral0Amended = _integral0Amended; // Moving forward.
 4997 |     |       integral1Amended = _integral1Amended; // Moving forward.
 4998 |     |     }
 4999 |     |   }
 5000 |     | 
 5001 |     |   // Amended integrals should never be greater than the original ones.
 5002 |     |   integral0Amended = min(integral0Incremented, integral0Amended);
 5003 |     |   integral1Amended = min(integral1Incremented, integral1Amended);
 5004 |     | }
 5005 |     | 
 5006 |     | /// @notice Clears this interval from memory so that a second 'swapWithin' can
 5007 |     | /// be called.
 5008 |     | function clearInterval() pure {
 5009 |     |   assembly {
 5010 |     |     //
 5011 |     |     //  _interval_                               _endOfInterval_
 5012 |     |     //      |                                           |
 5013 |     |     //      +-------------------------------------------+
 5014 |     |     //      |                     0                     |
 5015 |     |     //      +-------------------------------------------+
 5016 |     |     //
 5017 |     |     codecopy(
 5018 |     |       _interval_,
 5019 |     |       sub(0, sub(_endOfInterval_, _interval_)),
 5020 |     |       sub(_endOfInterval_, _interval_)
 5021 |     |     )
 5022 |     |   }
 5023 |     | }

/home/training/contracts/utilities/Kernel.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {Index, zeroIndex} from "./Index.sol";
   5 |     | import {X15} from "./X15.sol";
   6 |     | import {X59} from "./X59.sol";
   7 |     | import {X216, oneX216} from "./X216.sol";
   8 |     | import {PriceLibrary} from "./Price.sol";
   9 |     | 
  10 |     | using PriceLibrary for uint16;
  11 |     | using PriceLibrary for uint256;
  12 |     | 
  13 |     | // For every pool, the kernel function 'k : [0, qSpacing] -> [0, 1]' represents
  14 |     | // a monotonically non-decreasing piece-wise linear function whose breakpoints
  15 |     | // are listed in the storage smart contract. Let 'm + 1' denote the number
  16 |     | // of these breakpoints. For every integer '0 <= i <= m' the i-th breakpoint of
  17 |     | // the kernel represents the pair '(b[i], c[i])' where
  18 |     | //
  19 |     | //  '0 == b[0] <  b[1] <= b[2] <= ... <= b[m - 1] <  b[m] == qSpacing',
  20 |     | //  '0 == c[0] <= c[1] <= c[2] <= ... <= c[m - 1] <= c[m] == 1'.
  21 |     | // 
  22 |     | // Each breakpoint occupies 64 bytes, in which:
  23 |     | //
  24 |     | //  - the 'X15' representation of '(2 ** 15) * c[i]' occupies 2 bytes,
  25 |     | //
  26 |     | //  - the 'X59' representation of '(2 ** 59) * b[i]' occupies 8 bytes,
  27 |     | //
  28 |     | //  - the 'X216' representation of '(2 ** 216) * exp(- b[i] / 2)' occupies 27
  29 |     | //    bytes,
  30 |     | //
  31 |     | //  - the 'X216' representation of '(2 ** 216) * exp(- 16 + b[i] / 2)' occupies
  32 |     | //    27 bytes.
  33 |     | //
  34 |     | // The above-mentioned layout is illustrated as follows:
  35 |     | //
  36 |     | //                      A 512 bit kernel breakpoint
  37 |     | //  +--+--------+---------------------------+---------------------------+
  38 |     | //  |  | 8 byte |          27 byte          |          27 byte          |
  39 |     | //  +--+--------+---------------------------+---------------------------+
  40 |     | //  |  |        |                           |
  41 |     | //  |  |        |                            \
  42 |     | //  |  |        |                             (2 ** 216) * exp(- 16 + b[i] / 2)
  43 |     | //  |  |         \
  44 |     | //  |  |          (2 ** 216) * exp(- b[i] / 2)
  45 |     | //  |   \
  46 |     | //  |    (2 ** 59) * b[i]
  47 |     | //   \
  48 |     | //    (2 ** 15) * c[i]
  49 |     | //
  50 |     | // Consider the following list of kernel breakpoints:
  51 |     | //
  52 |     | //  '(b[0], c[0]), (b[1], c[1]), (b[2], c[2]), ..., (b[m], c[m])'
  53 |     | //
  54 |     | // and for every integer '0 < i <= m', define
  55 |     | //
  56 |     | //  'k_i : [0, qSpacing] -> [0, 1]'
  57 |     | //
  58 |     | // as
  59 |     | //
  60 |     | //  'k_i(q) :=
  61 |     | //
  62 |     | //    /            c[i] - c[i - 1]
  63 |     | //   | c[i - 1] + ----------------- * (q - b[i - 1])  if  b[i - 1] < q < b[i]
  64 |     | //   |             b[i] - b[i - 1]                                           ',
  65 |     | //   | 0                                              otherwise
  66 |     | //    \
  67 |     | //
  68 |     | // which means that if 'b[i - 1] == b[i]', then 'k_i(q) := 0'. Now, the kernel
  69 |     | // function
  70 |     | // 
  71 |     | //  'k : [0, qSpacing] -> [0, 1]'
  72 |     | //
  73 |     | // is defined as
  74 |     | //
  75 |     | //             m
  76 |     | //           -----
  77 |     | //           \
  78 |     | //  'k(q) := /     k_i(q)'.
  79 |     | //           -----
  80 |     | //           i = 1
  81 |     | //
  82 |     | type Kernel is uint256;
  83 |     | 
  84 |     | using KernelLibrary for Kernel global;
  85 |     | 
  86 |     | library KernelLibrary {
  87 |     |   /// @notice Returns the components of the kernel breakpoint which corresponds
  88 |     |   /// to the given index.
  89 |     |   ///
  90 |     |   /// Index out of range should be avoided externally.
  91 |     |   function member(
  92 |     |     Kernel kernel,
  93 |     |     Index index
  94 |     |   ) internal pure returns (
  95 |     |     X15 height,
  96 |     |     X59 logShift,
  97 |     |     X216 sqrtShift,
  98 |     |     X216 sqrtInverseShift
  99 |     |   ) {
 100 |     |     // If 'index' is equal to 0, then this function should return 
 101 |     |     // '(zeroX15, zeroX59, oneX216, floor((2 ** 216) * exp(-16)))'. Because the
 102 |     |     // first member of kernelCompact is always '(zeroX15, zeroX59)'.
 103 |     |     if (index > zeroIndex) {
 104 |     |       uint256 pointer;
 105 |     |       assembly {
 106 |     |         // Each member of Kernel is '64 == 2 ** 6' bytes. Hence we shift
 107 |     |         // 'index' by '6' digits which is equivalent to multiplying by '64'.
 108 |     |         // The origin is omitted and handled separately. We subtract by
 109 |     |         // '62 = 8 + 27 + 27' so that the pointer corresponding to 
 110 |     |         // 'index == oneIndex' follows this layout:
 111 |     |         //
 112 |     |         //        pointer
 113 |     |         //      /
 114 |     |         //     |        A 512 bit kernel breakpoint
 115 |     |         //  +--+--------+-----------------+-----------------+
 116 |     |         //  |  | 8 byte |     27 byte     |     27 byte     |
 117 |     |         //  +--+--------+-----------------+-----------------+
 118 |     |         //  |  |        |                 |
 119 |     |         //  |  |        |                  \
 120 |     |         //  |  |        |                   (2 ** 216) * exp(- 16 + b[i] / 2)
 121 |     |         //  |  |         \
 122 |     |         //  |  |          (2 ** 216) * exp(- b[i] / 2)
 123 |     |         //  |   \
 124 |     |         //  |    (2 ** 59) * b[i]
 125 |     |         //   \
 126 |     |         //    (2 ** 15) * c[i]
 127 |     |         //
 128 |     |         pointer := add(kernel, sub(shl(6, index), 62))
 129 |     |       }
 130 |     |       // Now that 'pointer' points to a price with height according to the
 131 |     |       // above layout, all four values are loaded from memory using
 132 |     |       // 'PriceLibrary'.
 133 |     |       height = pointer.height();
 134 |     |       logShift = pointer.log();
 135 |     |       sqrtShift = pointer.sqrt(false);
 136 |     |       sqrtInverseShift = pointer.sqrt(true);
 137 |     |     } else {
 138 |     |       // 'height' and 'logShift' are zero by default.
 139 |     |       sqrtShift = oneX216;
 140 |     |       sqrtInverseShift = X216.wrap(
 141 |     |         0x0000000000000001E355BBAEE85CADA65F73F32E88FB3CC629B709109F57564D
 142 |     |       ); // floor((2 ** 216) * exp(-16))
 143 |     |     }
 144 |     |   }
 145 |     | 
 146 |     |   /// @notice This function calculates the resultant of the logarithmic price
 147 |     |   /// 'q' which is stored in 'basePrice' and the 'index' breakpoint of
 148 |     |   /// 'kernel'. The resultant is then stored in memory.
 149 |     |   ///
 150 |     |   /// If 'left == false', the resulting log price is equal to 
 151 |     |   ///
 152 |     |   ///  'qResultant := q + b[index]'.
 153 |     |   ///
 154 |     |   /// In this case we should have: '0 < q + b[index] < 2 ** 64'.
 155 |     |   ///
 156 |     |   /// If 'left == true', the resulting log price is equal to 
 157 |     |   ///
 158 |     |   ///  'qResultant := q - b[index]'.
 159 |     |   ///
 160 |     |   /// In this case we should have: '0 < q - b[index] < 2 ** 64'.
 161 |     |   ///
 162 |     |   /// Index out of range should be avoided externally.
 163 |     |   /// 'resultant' should not be less than '34'.
 164 |     |   function impose(
 165 |     |     Kernel kernel,
 166 |     |     uint256 resultant,
 167 |     |     uint256 basePrice,
 168 |     |     Index index,
 169 |     |     bool left
 170 |     |   ) internal pure {
 171 |     |     // These four values correspond to the kernel's member.
 172 |     |     (X15 height, X59 logShift, X216 sqrtShift, X216 sqrtInverseShift) = 
 173 |     |       kernel.member(index);
 174 |     |     
 175 |     |     // Addition or subtraction is safe due to the above requirements.
 176 |     |     // The multiplication does not overflow because both values are loaded from
 177 |     |     // 216 bits of memory. Hence, they are non-negative and are less than
 178 |     |     // oneX216.
 179 |     |     // The requirements of 'mulDivByExpInv16' are met because both values are 
 180 |     |     // loaded from 216 bits of memory. Hence, they are non-negative and are 
 181 |     |     // less than oneX216. Additionally, 'mulDivByExpInv16' does not overflow
 182 |     |     // and fits within 216 bits, because if 'left == false':
 183 |     |     //
 184 |     |     // '(basePrice.sqrt(true) ^ sqrtInverseShift) / (2 ** 216) == 
 185 |     |     //  exp(- 16 - 16 + (basePrice.log() + logShift) / (2 ** 60)) / exp(-16)
 186 |     |     //  == exp(- 16 + (basePrice.log() + logShift) / (2 ** 60)) <
 187 |     |     //  == exp(- 16 + (2 ** 64) / (2 ** 60)) <= 1'
 188 |     |     //
 189 |     |     // and if 'left == true':
 190 |     |     //
 191 |     |     // '(basePrice.sqrt(false) ^ sqrtInverseShift) / (2 ** 216) == 
 192 |     |     //  exp(-16 - (basePrice.log() - logShift) / (2 ** 60)) / exp(-16) == 
 193 |     |     //  exp(- (basePrice.log() - logShift) / (2 ** 60)) < exp(0) <= 1'
 194 |     |     //
 195 |     |     // Hence, the outcome of the multiplication and 'mulDivByExpInv16' do not
 196 |     |     // exceed 216 bits.
 197 |     |     (X59 logPrice, X216 sqrtPrice, X216 sqrtInversePrice) = left ? (
 198 |     |       basePrice.log() - logShift,
 199 |     |       basePrice.sqrt(false) ^ sqrtInverseShift,
 200 |     |       basePrice.sqrt(true) * sqrtShift
 201 |     |     ) : (
 202 |     |       basePrice.log() + logShift,
 203 |     |       basePrice.sqrt(false) * sqrtShift,
 204 |     |       basePrice.sqrt(true) ^ sqrtInverseShift
 205 |     |     );
 206 |     | 
 207 |     |     // The requirements of 'storePrice' are satisfied due to the above
 208 |     |     // arguments and the input requirements.
 209 |     |     resultant.storePrice(height, logPrice, sqrtPrice, sqrtInversePrice);
 210 |     |   }
 211 |     | }

/home/training/contracts/utilities/Memory.sol
    1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
    2 |     | pragma solidity ^0.8.28;
    3 |     | 
    4 |     | /// @dev Nofeeswap's memory layout.
    5 |     | /// @notice Each 'uint16' value is a memory pointer referring to the
    6 |     | /// corresponding value in memory. This file is generated using 'Memory.py'.
    7 |     | 
    8 |     | import {Tag} from "./Tag.sol";
    9 |     | import {Index} from "./Index.sol";
   10 |     | import {X15} from "./X15.sol";
   11 |     | import {X23} from "./X23.sol";
   12 |     | import {X47} from "./X47.sol";
   13 |     | import {X59} from "./X59.sol";
   14 |     | import {X111} from "./X111.sol";
   15 |     | import {X127} from "./X127.sol";
   16 |     | import {X208} from "./X208.sol";
   17 |     | import {X216} from "./X216.sol";
   18 |     | import {Curve} from "./Curve.sol";
   19 |     | import {Kernel} from "./Kernel.sol";
   20 |     | 
   21 |     | // Refers to the third slot of the memory which contains the free memory
   22 |     | // pointer.
   23 |     | uint16 constant _freeMemoryPointer_ = 64;
   24 |     | 
   25 |     | // Refers to the fourth slot of the memory which remains blank.
   26 |     | uint16 constant _blank_ = 96;
   27 |     | 
   28 |     | // When the protocol calls a hook or the sentinel contract, a snapshot of the
   29 |     | // memory (with '_hookSelector_' as the starting point) is sent to the target
   30 |     | // contract as calldata. Before calling the target contract, this 4 byte space
   31 |     | // is populated with the intended function selector of the target contract.
   32 |     | uint16 constant _hookSelector_ = 128;
   33 |     | 
   34 |     | // This space is populated with the abi offset '0x20' so that the hook or the
   35 |     | // sentinel contract can decode the given calldata. This offset value points to
   36 |     | // the slot that contains the byte count of the snapshot given to the hook or
   37 |     | // the sentinel contract
   38 |     | uint16 constant _hookInputHeader_ = 132;
   39 |     | 
   40 |     | // This space is populated with the byte count of 'bytes calldata hookInput'
   41 |     | // which is passed as input to the hook or the sentinel contract.
   42 |     | uint16 constant _hookInputByteCount_ = 164;
   43 |     | 
   44 |     | // 'msg.sender' in the current execution context is placed in this space to be
   45 |     | // passed to the hook or the sentinel contract. This way, the hook or the
   46 |     | // sentinel contract have access to 'msg.sender' in the prior execution
   47 |     | // context (i.e., in the context where the protocol is called).
   48 |     | uint16 constant _msgSender_ = 196;
   49 |     | 
   50 |     | // This space is dedicated to the identifier of the intended pool. The least
   51 |     | // significant 160 bits of this memory space refer to the hook address. The
   52 |     | // next 20 bits are referred to as flags that are used by the protocol to know
   53 |     | // which methods from 'IHook.sol' should be invoked and what permissions are
   54 |     | // activated. Flags are further explained in 'IHook.sol'. The next 8 bits
   55 |     | // represent the natural logarithm of 'pOffset' which must be greater than or
   56 |     | // equal to '-89' and less than or equal to '89' in 'int8' representation
   57 |     | // (two's complement). Hence, 'pOffset' is greater than or equal to 'exp(-89)'
   58 |     | // and less than or equal to 'exp(+89)'. As will be discussed later, the price
   59 |     | // of the pool is always greater than or equal to
   60 |     | //
   61 |     | //  'pOffset * exp(- 16 + 1 / (2 ** 59))'
   62 |     | //
   63 |     | // and less than or equal to
   64 |     | //
   65 |     | //  'pOffset * exp(+ 16 - 1 / (2 ** 59))'.
   66 |     | uint16 constant _poolId_ = 216;
   67 |     | 
   68 |     | // How does a swap work?
   69 |     | // ----------------------------------------------------------------------------
   70 |     | // A swap in a pool can be interpreted as a change in that pool's price. There
   71 |     | // are two types of swaps:
   72 |     | //
   73 |     | //  - If 'tag0' is outgoing from the pool and 'tag1' is incoming to the pool as
   74 |     | //    a result of a swap, then the swap is price increasing, i.e., the price
   75 |     | //    prior to the execution of the swap is lower than the price after the
   76 |     | //    execution of the swap.
   77 |     | //
   78 |     | //  - If 'tag0' is incoming to the pool and 'tag1' is outgoing from the pool as
   79 |     | //    a result of a swap, then the swap is price decreasing, i.e., the price
   80 |     | //    prior to the execution of the swap is higher than the price after the
   81 |     | //    execution of the swap.
   82 |     | //
   83 |     | // Let 'pOffset' represent the offset price whose natural logarithm is encoded
   84 |     | // in 'poolId' as described above (in the definition of 'poolId'). The protocol
   85 |     | // offers liquidity providers (LPs) the flexibility to deposit their liquidity
   86 |     | // in a range of their choosing. To this end, the price horizon is partitioned
   87 |     | // into a number of liquidity intervals with equal length in the natural
   88 |     | // logarithmic scale. An LP may choose any consecutive range of liquidity
   89 |     | // intervals to deposit their liquidity. By doing so, the LP acquires a number
   90 |     | // of shares in every liquidity interval that belongs to the given range. The
   91 |     | // shares can be used later to withdraw liquidity along with any accumulated
   92 |     | // growth which is accrued as a result of swap and donate actions.
   93 |     | //
   94 |     | // At each moment, a single one of the above-mentioned intervals is active to
   95 |     | // which the current price of the pool belongs. Let 'pLower' and 'pUpper',
   96 |     | // respectively, denote the minimum and maximum price in the current active
   97 |     | // liquidity interval and define
   98 |     | //
   99 |     | //  'qLower := log(pLower / pOffset)'
  100 |     | //  'qUpper := log(pUpper / pOffset)'
  101 |     | //  'qSpacing := log(pUpper / pLower)'.
  102 |     | //
  103 |     | // Then, for every integer 'j', the interval
  104 |     | //
  105 |     | //  '[qLower + j * qSpacing, qUpper + j * qSpacing]'
  106 |     | //
  107 |     | // is a valid liquidity interval if and only if:
  108 |     | //
  109 |     | //  '- 16 + 1 / (2 ** 59) + qSpacing < qLower + j * qSpacing'
  110 |     | //
  111 |     | // and
  112 |     | //
  113 |     | //  'qUpper + j * qSpacing <= + 16 - 1 / (2 ** 59) - qSpacing'.
  114 |     | //
  115 |     | // This includes the current active liquidity interval '[qLower, qUpper]'
  116 |     | // which corresponds to 'j == 0'.
  117 |     | //
  118 |     | // Every swap has the following input parameters:
  119 |     | //
  120 |     | //  - 'logPriceLimit': This value is the natural logarithm of a price limit in
  121 |     | //    'X59' representation. It imposes a constraint on the price of the pool
  122 |     | //    post execution of the swap. For price increasing swaps, 'logPriceLimit'
  123 |     | //    serves as an upper bound, in which case the price of the pool must not
  124 |     | //    exceed 'exp(logPriceLimit / (2 ** 59))'. For price decreasing swaps,
  125 |     | //    'logPriceLimit' serves as a lower bound, in which case the price of the
  126 |     | //    pool must not subceed 'exp(logPriceLimit / (2 ** 59))'. In both cases,
  127 |     | //    once the price of the pool reaches 'exp(logPriceLimit / (2 ** 59))', the
  128 |     | //    execution of the swap is halted. Put simply, no amount of tags are traded
  129 |     | //    with any price worst than 'exp(logPriceLimit / (2 ** 59))' for the
  130 |     | //    swapper.
  131 |     | //
  132 |     | //  - 'zeroForOne': If 'zeroForOne == 0', then the swap is price increasing in
  133 |     | //    which case 'tag0' is outgoing from the pool and 'tag1' is incoming to the
  134 |     | //    pool. If 'zeroForOne == 1', then the swap is price decreasing in which
  135 |     | //    case 'tag0' is incoming to the pool and 'tag1' is outgoing from the pool.
  136 |     | //    Given any other value, the movement of the price is towards
  137 |     | //    'logPriceLimit', i.e., the swap is price increasing if
  138 |     | //
  139 |     | //      'pCurrent < exp(logPriceLimit / (2 ** 59))'
  140 |     | //
  141 |     | //    and the swap is price decreasing if
  142 |     | //
  143 |     | //      'exp(logPriceLimit / (2 ** 59)) < pCurrent'
  144 |     | //
  145 |     | //    where 'pCurrent' represents the current price of the pool.
  146 |     | //
  147 |     | //  - 'amountSpecified': If 'amountSpecified > 0' then 'amountSpecified'
  148 |     | //    represents the amount of 'tag0' (if the swap is price decreasing) or the
  149 |     | //    amount of 'tag1' (if the swap is price increasing) to be given to the
  150 |     | //    pool subject to the constraint imposed by 'logPriceLimit'. If
  151 |     | //    'amountSpecified < 0' then '0 - amountSpecified' represents the amount of
  152 |     | //    'tag0' (if the swap is price increasing) or the amount of 'tag1' (if the
  153 |     | //    swap is price decreasing) to be taken from the pool. Define
  154 |     | //
  155 |     | //      'exactInput := amountSpecified > 0'
  156 |     | //
  157 |     | //    which determines whether 'amountSpecified' is incoming to the pool or
  158 |     | //    outgoing from the pool. Additionally, if 'zeroForOne == exactInput', then
  159 |     | //    'amountSpecified' is with respect to 'tag0' and if
  160 |     | //    'zeroForOne != exactInput' then 'amountSpecified' is with respect to
  161 |     | //    'tag1'.
  162 |     | //
  163 |     | //  - 'crossThreshold': If large enough, a swap may involve transitioning from
  164 |     | //    the active liquidity interval to other intervals. 'crossThreshold'
  165 |     | //    imposes a lower bound on the total number of shares that should be
  166 |     | //    available in any interval for the swapper to transact in that interval.
  167 |     | //    For example, if 'crossThreshold == 0', which is the default, no minimum
  168 |     | //    number of shares is imposed. If 'crossThreshold == 100', there has to be
  169 |     | //    at least 100 shares in the interval for the swap function to either swap
  170 |     | //    within or enter that interval.
  171 |     | //
  172 |     | // Consider a hypothetical pool that satisfies
  173 |     | //
  174 |     | //  'qLower < qCurrent < qUpper',
  175 |     | //
  176 |     | // where
  177 |     | //
  178 |     | //  'qCurrent := log(pCurrent / pOffset)'
  179 |     | //
  180 |     | // and 'pCurrent' is the current price of the pool.
  181 |     | //
  182 |     | // Consider a swap in this pool with the following parameters:
  183 |     | //
  184 |     | //  'logPriceLimit := (2 ** 59) * log(pLimit)'
  185 |     | //  'zeroForOne := 1'
  186 |     | //  'amountSpecified := +oo'
  187 |     | //  'crossThreshold := 0'
  188 |     | //
  189 |     | // where
  190 |     | //
  191 |     | //  'pLimit := exp(- 3 * qSpacing) * pCurrent'
  192 |     | //
  193 |     | // and
  194 |     | //
  195 |     | //  'qLimit := log(pLimit / pOffset)'.
  196 |     | //
  197 |     | // As explained later in this script, each of the above input parameters are
  198 |     | // loaded from calldata, transformed to appropriate formats and then stored in
  199 |     | // dedicated spaces in memory that are pointed to by the constant values
  200 |     | // '_logPriceLimit_', '_zeroForOne_', '_amountSpecified_', and
  201 |     | // '_crossThreshold_', respectively. Additionally, prior to the execution
  202 |     | // of the swap, 'qLimit' is calculated and stored in the memory space which
  203 |     | // is pointed to by '_logPriceLimitOffsetted_'.
  204 |     | //
  205 |     | // In this example, we have:
  206 |     | //
  207 |     | //  'qLower - 3 * qSpacing < qLimit < qUpper - 3 * qSpacing',
  208 |     | //
  209 |     | // which is illustrated as follows:
  210 |     | //
  211 |     | //             qLimit                                  qCurrent
  212 |     | //               |                                         |
  213 |     | //  ... <--+-------------+-------------+-------------+-------------+--> ...
  214 |     | //
  215 |     | // In the presence of liquidity, the further away 'qLimit' is from 'qCurrent'
  216 |     | // the larger the outgoing amount from the pool and the incoming amount to the
  217 |     | // pool are.
  218 |     | //
  219 |     | // In the above example, the swap is price decreasing which means that 'tag0'
  220 |     | // is incoming to the pool and 'tag1' is outgoing from the pool as a result of
  221 |     | // the swap.
  222 |     | //
  223 |     | // Observe that 'qLimit' is three intervals away from 'qCurrent'. Hence, in
  224 |     | // order to go from 'qCurrent' to 'qLimit' we need to transact in the following
  225 |     | // four intervals:
  226 |     | //
  227 |     | //  '[qLower - 0 * qSpacing, qUpper - 0 * qSpacing]',
  228 |     | //  '[qLower - 1 * qSpacing, qUpper - 1 * qSpacing]',
  229 |     | //  '[qLower - 2 * qSpacing, qUpper - 2 * qSpacing]',
  230 |     | //  '[qLower - 3 * qSpacing, qUpper - 3 * qSpacing]'.
  231 |     | //
  232 |     | // At each point throughout the execution of the swap, as we transition from
  233 |     | // each interval to the next one, the memory pointers '_back_' and '_next_' are
  234 |     | // used in order to keep track of the boundaries for the current active
  235 |     | // interval. Each of these pointers refer to a memory space in which the
  236 |     | // following two values are enclosed:
  237 |     | //
  238 |     | //  'qBack := log(pBack / pOffset)'
  239 |     | //  'qNext := log(pNext / pOffset)'
  240 |     | //
  241 |     | // (among other values) where 'pBack' is the boundary of the current active
  242 |     | // liquidity interval in the opposite direction of the swap and 'pNext' is the
  243 |     | // other boundary in the direction of the swap.
  244 |     | //
  245 |     | // For price increasing swaps, the initial values for 'qBack' and 'qNext' are
  246 |     | // as follows
  247 |     | //
  248 |     | //  'qBack := qLower'
  249 |     | //  'qNext := qUpper'.
  250 |     | //
  251 |     | // However, in the present example, since the swap is price decreasing, these
  252 |     | // initial values are:
  253 |     | //
  254 |     | //  'qBack := qUpper'
  255 |     | //  'qNext := qLower'.
  256 |     | //
  257 |     | // as illustrated here:
  258 |     | //
  259 |     | //             qLimit                                   qCurrent
  260 |     | //               |                                         |
  261 |     | //  ... <--+-------------+-------------+-------------+-------------+--> ...
  262 |     | //                                                   |             |
  263 |     | //                                                 qNext         qBack
  264 |     | //
  265 |     | // As the price transitions to a new liquidity interval, the content of the
  266 |     | // memory spaces that are pointed to by '_back_' and '_next_' are updated
  267 |     | // accordingly.
  268 |     | //
  269 |     | // Now, in order to perform this swap, we need to proceed as follows:
  270 |     | //
  271 |     | //  - The dynamic parameters of the pool are read from the protocol's storage
  272 |     | //    which include the followings:
  273 |     | //
  274 |     | //    - 'sharesTotal': This is the total number of shares that are deposited in
  275 |     | //      the current active liquidity interval '[qLower, qUpper]' across all
  276 |     | //      LPs. Consider an example where we have only two LP positions such that
  277 |     | //      
  278 |     | //      - The first position has 2 shares in every interval from 'qLower' to
  279 |     | //        'qUpper + 2 * qSpacing', i.e., 2 shares in each of the intervals
  280 |     | //        '[qLower, qUpper]', '[qLower + qSpacing, qUpper + qSpacing]', and
  281 |     | //        '[qSpacing + 2 * qSpacing, qUpper + 2 * qSpacing]'.
  282 |     | //      
  283 |     | //      - The second position has 5 shares in every interval from
  284 |     | //        'qLower - qSpacing' to 'qUpper + qSpacing', i.e., 5 shares in each of
  285 |     | //        the intervals '[qLower - qSpacing, qUpper - qSpacing]',
  286 |     | //        '[qLower, qUpper]', and '[qLower + qSpacing, qUpper + qSpacing]'.
  287 |     | //
  288 |     | //      In this case, both LP positions include the active liquidity interval
  289 |     | //      '[qLower, qUpper]' which means that 'sharesTotal == 2 + 5 == 7'.
  290 |     | //
  291 |     | //    - 'growth': The amount of liquidity which is allocated to a single LP
  292 |     | //      share in the active interval increases as a result of a swap or a
  293 |     | //      donation. We use this parameter to keep track of the amount of
  294 |     | //      liquidity for each share. 'growth' is stored in 'X111' format and we
  295 |     | //      always have 'growth >= oneX111'.
  296 |     | //
  297 |     | //    - 'qCurrent': This is equal to 'log(pCurrent / pOffset)' where 'pCurrent'
  298 |     | //      is the current price of the pool prior to the execution of the swap.
  299 |     | //
  300 |     | //    - 'staticParamsStoragePointer': Certain information about the pool that
  301 |     | //      never change (e.g., 'tag0' and 'tag1') or do not change frequently are
  302 |     | //      encoded in an external smart contract's bytecode. We refer to this
  303 |     | //      external smart contract as the storage smart contract of the pool. This
  304 |     | //      way, the encoded parameters can be accessed by reading the storage
  305 |     | //      smart contract's bytecode which is more gas efficient than accessing
  306 |     | //      protocol's storage via 'sload'. However, if we ever need to make any
  307 |     | //      modification, a new storage smart contract should be deployed with an
  308 |     | //      updated bytecode. Hence, the protocol needs to keep track of the
  309 |     | //      address for the storage smart contract associated with each pool.
  310 |     | //      Instead of storing a 20-byte address for each pool, we calculate it
  311 |     | //      from 'staticParamsStoragePointer' as further explained in
  312 |     | //      'Storage.sol'. Hence, 'staticParamsStoragePointer' is a 16-bit pointer
  313 |     | //      which is used to derive the address of the storage smart contract from
  314 |     | //      which additional information about the pool is read.
  315 |     | //
  316 |     | //  - The curve sequence is read from the protocol's storage. The 'curve' is a
  317 |     | //    sequence containing historical prices in 'X59' representation. It should
  318 |     | //    have at least two members. In other words, every  member of the curve
  319 |     | //    sequence represents a historical price 'pHistorical' which is stored in
  320 |     | //    the form:
  321 |     | //
  322 |     | //      '(2 ** 59) * (16 + qHistorical)'
  323 |     | //
  324 |     | //    where
  325 |     | //
  326 |     | //      'qHistorical := log(pHistorical / pOffset)'.
  327 |     | //
  328 |     | //    Hence, each member of the curve occupies exactly '64' bits as explained
  329 |     | //    in 'Curve.sol'. This is because 'pHistorical' satisfies
  330 |     | //
  331 |     | //      'pOffset * exp(- 16 + 1 / (2 ** 59)) <= pHistorical'
  332 |     | //
  333 |     | //    and
  334 |     | //
  335 |     | //      'pHistorical <= pOffset * exp(+ 16 - 1 / (2 ** 59))'.
  336 |     | //
  337 |     | //    which conclude that
  338 |     | //
  339 |     | //      '1 <= (2 ** 59) * (16 + qHistorical) <= 2 ** 64 - 1'.
  340 |     | //
  341 |     | //    The first and the second members of the curve sequence correspond to the
  342 |     | //    boundaries of the current active liquidity interval (i.e., 'qLower' and
  343 |     | //    'qUpper') with the order depending on the pool's history. The last member
  344 |     | //    of the curve represents the current price of the pool, i.e., 'qCurrent'.
  345 |     | //    
  346 |     | //    Let 'l' denote the number of members in the curve sequence. Since, we
  347 |     | //    already know 'qCurrent' from dynamic parameters, we can determine 'l'
  348 |     | //    without having to load an entire length slot! In other words, we keep
  349 |     | //    reading members of the curve sequence from protocol's storage (four
  350 |     | //    members per slot) until we encounter 'qCurrent' which is already known
  351 |     | //    from dynamic parameters. Then, 'l' can be determined based on the
  352 |     | //    position of 'qCurrent' in the curve sequence.
  353 |     | //
  354 |     | //    For every integer '0 <= i < l', denote the (i + 1)-th historical price
  355 |     | //    recorded by the curve sequence as 'p[i]'. Additionally, to simplify the
  356 |     | //    notations, the out-of-range price 'p[l]' is assigned the same value as
  357 |     | //    'p[l - 1]'. Now, for every integer '0 <= i <= l', define also 
  358 |     | //    
  359 |     | //      'q[i] := log(p[i] / pOffset)'.
  360 |     | //
  361 |     | //    The curve sequence is constructed in such a way that for every
  362 |     | //    '2 <= i < l', we have:
  363 |     | //
  364 |     | //      'min(q[i - 1], q[i - 2]) < q[i] < max(q[i - 1], q[i - 2])'.
  365 |     | //
  366 |     | //    This ordering rule is verified upon initialization of any pool and it is
  367 |     | //    preserved by every amendment to the curve sequence.
  368 |     | //    
  369 |     | //    In order to use the curve sequence, we need to define a number of
  370 |     | //    functions. For every '0 <= i <= l - 2', if 'q[i + 2] < q[i]' define
  371 |     | //
  372 |     | //      'w_i : [qLower, qUpper] -> [0, qSpacing]'
  373 |     | //
  374 |     | //    as
  375 |     | //
  376 |     | //                  /
  377 |     | //                 |  q - q[i + 1]  if q[i + 2] < q < q[i]
  378 |     | //      'w_i(q) := |                                       '
  379 |     | //                 |  0             otherwise
  380 |     | //                  \
  381 |     | //
  382 |     | //    and if 'q[i] < q[i + 2]' define
  383 |     | //
  384 |     | //      'w_i : [qLower, qUpper] -> [0, qSpacing]'
  385 |     | //
  386 |     | //    as
  387 |     | //
  388 |     | //                  /
  389 |     | //                 |  q[i + 1] - q  if q[i] < q < q[i + 2]
  390 |     | //      'w_i(q) := |                                        '
  391 |     | //                 |  0             otherwise
  392 |     | //                  \
  393 |     | //
  394 |     | //    Each of the above functions is regarded as a phase. Observe that the
  395 |     | //    diagram for each of the phase is a compactly supported (i.e., equal to
  396 |     | //    zero outside of a bounded interval) segment with either '45' or '135'
  397 |     | //    degrees angle. Define
  398 |     | //
  399 |     | //      'w : [qLower, qUpper] -> [0, qSpacing]'
  400 |     | //
  401 |     | //    as
  402 |     | //
  403 |     | //               l - 2
  404 |     | //               -----
  405 |     | //               \
  406 |     | //      'w(q) := /     w_i(q).
  407 |     | //               -----
  408 |     | //               i = 0
  409 |     | //
  410 |     | //    This function will be used to determine the distribution of liquidity
  411 |     | //    within the active interval '[qLower, qUpper]'. As we will discuss later
  412 |     | //    in this script, the distribution of liquidity is modified with every swap
  413 |     | //    via amendments to the curve sequence and this process ensures liquidity
  414 |     | //    growth for the LPs without the need to charge fees.
  415 |     | //
  416 |     | //    For example, let
  417 |     | //
  418 |     | //      'q[0] := qUpper'
  419 |     | //      'q[1] := qLower'
  420 |     | //      'q[2]'
  421 |     | //      'q[3] := qCurrent'
  422 |     | //
  423 |     | //    represent the curve sequence. Then,
  424 |     | //
  425 |     | //      'w(q) := w_0(q) + w_1(q) + w_2(q)'
  426 |     | //
  427 |     | //    can be plotted as follows:
  428 |     | //
  429 |     | //            w(q)
  430 |     | //              ^
  431 |     | //      spacing |                /
  432 |     | //              |               /
  433 |     | //              |              /
  434 |     | //              |             /
  435 |     | //              |            /
  436 |     | //              |           /
  437 |     | //              |          /
  438 |     | //              |\
  439 |     | //              | \
  440 |     | //              |  \
  441 |     | //              |   \
  442 |     | //              |        /
  443 |     | //              |       /
  444 |     | //              |      /
  445 |     | //              |     /
  446 |     | //            0 +----+----+-------+-> q
  447 |     | //           qLower  |    |       |
  448 |     | //                   |   q[2]   qUpper
  449 |     | //                   |
  450 |     | //               qCurrent
  451 |     | //    
  452 |     | //    To summarize, reading the curve sequence from the protocol's storage
  453 |     | //    gives us access to 'qLower', 'qUpper' and the function 'w'.
  454 |     | //
  455 |     | //    The curve sequence is defined for every inactive liquidity interval as
  456 |     | //    well, although we do not need to keep track of them. For every integer
  457 |     | //    'j > 0', the curve sequence associated with the interval:
  458 |     | //
  459 |     | //      '[qLower + j * qSpacing, qUpper + j * qSpacing]'
  460 |     | //
  461 |     | //    is composed of only two members:
  462 |     | //
  463 |     | //      'q[0] := qUpper + j * qSpacing' 
  464 |     | //      'q[1] := qLower + j * qSpacing'. 
  465 |     | //
  466 |     | //    Hence, the function
  467 |     | //
  468 |     | //      'w : [qLower + j * qSpacing, qUpper + j * qSpacing] -> [0, qSpacing]'
  469 |     | //
  470 |     | //    corresponding to that interval is defined as:
  471 |     | //
  472 |     | //      'w(q) := q - qLower - j * qSpacing'
  473 |     | //
  474 |     | //    which is consistent with the prior definition of 'w' for the active
  475 |     | //    interval. Additionally, for every integer 'j < 0', the curve sequence
  476 |     | //    associated with the interval:
  477 |     | //
  478 |     | //      '[qLower + j * qSpacing, qUpper + j * qSpacing]'
  479 |     | //
  480 |     | //    is composed of only two members:
  481 |     | //
  482 |     | //      'q[0] := qLower + j * qSpacing' 
  483 |     | //      'q[1] := qUpper + j * qSpacing'. 
  484 |     | //
  485 |     | //    Hence, the function
  486 |     | //
  487 |     | //      'w : [qLower + j * qSpacing, qUpper + j * qSpacing] -> [0, qSpacing]'
  488 |     | //
  489 |     | //    corresponding to that interval is defined as:
  490 |     | //
  491 |     | //      'w(q) := qUpper + j * qSpacing - q'
  492 |     | //    
  493 |     | //    which is also consistent with our prior definition.
  494 |     | //
  495 |     | //    After reading the curve sequence for the active interval, we store
  496 |     | //    'qBack' and 'qNext' in their dedicated memory spaces in order to keep
  497 |     | //    track of the boundaries of the active liquidity interval. In the present
  498 |     | //    example, since the swap is price decreasing, the initial values for
  499 |     | //    'qBack' and 'qNext' are as follows:
  500 |     | //
  501 |     | //      'qBack := qUpper',
  502 |     | //      'qNext := qLower'.
  503 |     | //
  504 |     | //    For price increasing swaps, these initial values are
  505 |     | //
  506 |     | //      'qBack := qLower',
  507 |     | //      'qNext := qUpper'.
  508 |     | //
  509 |     | //    As discussed before, 'qBack' and 'qNext' are continuously updated
  510 |     | //    throughout the execution of a swap as we transition to new liquidity
  511 |     | //    intervals.
  512 |     | //
  513 |     | //  - Next, the kernel function is read from the storage smart contract's
  514 |     | //    bytecode. To this end, the dynamic parameter 'staticParamsStoragePointer'
  515 |     | //    is used to calculate the address to the storage smart contract associated
  516 |     | //    with the pool whose bytecode contains the kernel function. The kernel,
  517 |     | //    denoted by
  518 |     | //
  519 |     | //      'k : [0, qSpacing] -> [0, 1]',
  520 |     | //
  521 |     | //    is a monotonically non-decreasing piecewise linear function which is
  522 |     | //    characterized via a list of breakpoints. Each breakpoint has a horizontal
  523 |     | //    coordinate as well as a vertical coordinate. Consider the following
  524 |     | //    examples:
  525 |     | //
  526 |     | //      - The sequence of breakpoints
  527 |     | //
  528 |     | //          '(0, 0), (qSpacing, 1)'
  529 |     | //
  530 |     | //        implies that the diagram of 'k' is a single segment connecting the
  531 |     | //        point '(0, 0)' to the point '(qSpacing, 1)'. This leads to the kernel
  532 |     | //        function:
  533 |     | //
  534 |     | //          'k(h) := h / qSpacing'.
  535 |     | //
  536 |     | //      - The sequence of breakpoints
  537 |     | //
  538 |     | //          '(0, 0), (qSpacing / 2, 1), (qSpacing, 1)'
  539 |     | //
  540 |     | //        implies that the diagram of 'k' is composed of two segments:
  541 |     | //
  542 |     | //          - The first segment connects the point '(0, 0)' to the point
  543 |     | //            '(qSpacing / 2, 1)'.
  544 |     | //
  545 |     | //          - The second segment connects the point '(qSpacing / 2, 1)' to the
  546 |     | //            point '(qSpacing, 1)'.
  547 |     | //
  548 |     | //        The combination of the two segments leads to the kernel function:
  549 |     | //
  550 |     | //                    /
  551 |     | //                   |  2 * h / qSpacing    if 0 < q < qSpacing / 2
  552 |     | //          'k(h) := |                                                      '.
  553 |     | //                   |  1                   if qSpacing / 2 < q < qSpacing
  554 |     | //                    \
  555 |     | //
  556 |     | //      - The sequence of breakpoints
  557 |     | //
  558 |     | //          '(0, 0), (qSpacing / 2, 0), (qSpacing / 2, 1 / 2), (qSpacing, 1)'
  559 |     | //
  560 |     | //        implies that the diagram of 'k' is composed of three segments:
  561 |     | //
  562 |     | //          - The first segment belongs to the horizontal axis connecting the
  563 |     | //            point '(0, 0)' to the point '(qSpacing / 2, 0)'.
  564 |     | //
  565 |     | //          - The second segment is vertical, connecting the point
  566 |     | //            '(qSpacing / 2, 0)' to the point '(qSpacing / 2, 1 / 2)'. A
  567 |     | //            vertical segment (i.e., two consecutive breakpoints with equal
  568 |     | //            horizontal coordinates) indicates that the kernel function is
  569 |     | //            discontinuous which is permitted by the protocol. In this case,
  570 |     | //            we have a discontinuity at point 'qSpacing / 2' because:
  571 |     | //            
  572 |     | //              '0 == k(qSpacing / 2 - epsilon) != 
  573 |     | //                    k(qSpacing / 2 + epsilon) == 1 / 2 + epsilon / qSpacing'
  574 |     | //            
  575 |     | //            where 'epsilon > 0' is an arbitrarily small value approaching 0.
  576 |     | //
  577 |     | //          - The third segment connects the point '(qSpacing / 2, 1 / 2)' to
  578 |     | //            the point '(qSpacing, 1)'.
  579 |     | //
  580 |     | //        The combination of the three segments leads to the kernel function:
  581 |     | //
  582 |     | //                    /
  583 |     | //                   |  0               if 0 < q < qSpacing / 2
  584 |     | //          'k(h) := |                                                  '.
  585 |     | //                   |  h / qSpacing    if qSpacing / 2 < q < qSpacing
  586 |     | //                    \
  587 |     | //    
  588 |     | //    Hence, reading the kernel breakpoints from the storage smart contract
  589 |     | //    gives us access to the function 'k'.
  590 |     | //    
  591 |     | //    Define
  592 |     | //
  593 |     | //      'k(w(.)) : [qLower, qUpper] -> [0, 1]'
  594 |     | //
  595 |     | //    as the liquidity distribution function. As we will demonstrate next, one
  596 |     | //    can determine the outgoing amount from the pool and the incoming amount
  597 |     | //    to the pool by integrating the liquidity distribution function. More
  598 |     | //    precisely, consider a swap that involves a movement of price from
  599 |     | //    'qCurrent' to
  600 |     | //
  601 |     | //      'qTarget := log(pTarget / pOffset)'
  602 |     | //
  603 |     | //    within the same active liquidity interval, i.e.,
  604 |     | //
  605 |     | //      'qLower <= qTarget <= qUpper'.
  606 |     | //
  607 |     | //    If 'qCurrent < qTarget, then the outgoing amount of 'tag0' as a result of
  608 |     | //    this movement is proportional to the following integration of the
  609 |     | //    liquidity distribution function:
  610 |     | //
  611 |     | //                               - 8     / qTarget
  612 |     | //        currentToTarget      e        |    - h / 2
  613 |     | //      '----------------- := ------- * |  e         k(w(h)) dh'.
  614 |     | //           2 ** 216            2      |
  615 |     | //                                     / qCurrent
  616 |     | //
  617 |     | //    In this case, the incoming amount of 'tag1' as a result of this movement
  618 |     | //    is proportional to the following integration of the liquidity
  619 |     | //    distribution function:
  620 |     | //
  621 |     | //                                       - 8     / qTarget
  622 |     | //        incomingCurrentToTarget      e        |    + h / 2
  623 |     | //      '------------------------- := ------- * |  e         k(w(h)) dh'.
  624 |     | //               2 ** 216                2      |
  625 |     | //                                             / qCurrent
  626 |     | //
  627 |     | //    On the other hand, if 'qTarget < qCurrent', then the outgoing amount of
  628 |     | //    'tag1' and the incoming amount of 'tag0', respectively, are proportional
  629 |     | //    to the following integrations of the liquidity distribution function:
  630 |     | //
  631 |     | //                               - 8     / qCurrent
  632 |     | //        currentToTarget      e        |    + h / 2
  633 |     | //      '----------------- := ------- * |  e         k(w(h)) dh',
  634 |     | //           2 ** 216            2      |
  635 |     | //                                     / qTarget
  636 |     | //
  637 |     | //                                       - 8     / qCurrent
  638 |     | //        incomingCurrentToTarget      e        |    - h / 2
  639 |     | //      '------------------------- := ------- * |  e         k(w(h)) dh'.
  640 |     | //                2 ** 216               2      |
  641 |     | //                                             / qTarget
  642 |     | //
  643 |     | //    Now, imagine a scenario where we want to move all the way from 'qCurrent'
  644 |     | //    to 'qUpper' which is a price increasing swap. Hence, in this case, the
  645 |     | //    outgoing amount of 'tag0' is proportional to:
  646 |     | //
  647 |     | //                         - 8     / qUpper
  648 |     | //        integral0      e        |    - h / 2
  649 |     | //      '----------- := ------- * |  e         k(w(h)) dh'.
  650 |     | //        2 ** 216         2      |
  651 |     | //                               / qCurrent
  652 |     | //
  653 |     | //    Observe that moving from 'qCurrent' to 'qUpper' depletes the entire
  654 |     | //    reserve of 'tag0', within the interval '[qLower, qUpper]' (because we
  655 |     | //    cannot go further than that without transitioning to a new interval).
  656 |     | //    Hence, the total reserve of 'tag0' within the interval '[qLower, qUpper]'
  657 |     | //    is proportional to 'integral0' which is given by the above formula.
  658 |     | //
  659 |     | //    Similarly, imagine a scenario where we want to move all the way from
  660 |     | //    'qCurrent' to 'qLower' which is a price decreasing swap. Hence, in this
  661 |     | //    case, the outgoing amount of 'tag1' is proportional to:
  662 |     | //
  663 |     | //                         - 8     / qCurrent
  664 |     | //        integral1      e        |    + h / 2
  665 |     | //      '----------- := ------- * |  e         k(w(h)) dh',
  666 |     | //        2 ** 216         2      |
  667 |     | //                               / qLower
  668 |     | //
  669 |     | //    Observe that moving from 'qCurrent' to 'qLower' depletes the entire
  670 |     | //    reserve of 'tag1', within the interval '[qLower, qUpper]' (because we
  671 |     | //    cannot go further than that without transitioning to a new interval).
  672 |     | //    Hence, the total reserve of 'tag1' within the interval '[qLower, qUpper]'
  673 |     | //    is proportional to 'integral1' which is given by the above formula.
  674 |     | //
  675 |     | //    The values 'integral0' and 'integral1' are stored among the dynamic
  676 |     | //    parameters. This is because storing and updating them with every swap is
  677 |     | //    more gas efficient than recalculating them.
  678 |     | //
  679 |     | //    To summarize, in order to execute a swap,
  680 |     | //
  681 |     | //      - the function 'w' is formed by reading the members of the curve
  682 |     | //        sequence from the protocol's storage,
  683 |     | //   
  684 |     | //      - the kernel function 'k' is formed by reading its breakpoints from the
  685 |     | //        pool's storage smart contract, and
  686 |     | //
  687 |     | //      - the outgoing amount from the pool and the incoming amount to the pool
  688 |     | //        are determined by integrating the liquidity distribution function
  689 |     | //        'k(w(.))'.
  690 |     | //
  691 |     | //    An alternative way to look at the notion of liquidity distribution is to
  692 |     | //    imagine a traditional automated market making (AMM) diagram as
  693 |     | //    illustrated below:
  694 |     | //
  695 |     | //                tag1   pUpper
  696 |     | //                  ^   /
  697 |     | //                  |  /
  698 |     | //                  | /
  699 |     | //                  *
  700 |     | //                  |.
  701 |     | //                  | .
  702 |     | //                  |  .    
  703 |     | //                  |   .           pCurrent
  704 |     | //                  |     .        /
  705 |     | //                  |       .     /
  706 |     | //                  |         .  /           pTarget
  707 |     | //        integral1 + - - - - - *           /
  708 |     | //                  |           |  .       /         pLower
  709 |     | //                  |           |     .   /         /
  710 |     | //                  |           |        *         /
  711 |     | //                  |           |            .    /
  712 |     | //                  +-----------+----------------*----> tag0
  713 |     | //                              |
  714 |     | //                          integral0 
  715 |     | //
  716 |     | //    where the horizontal and vertical coordinates, respectively, correspond
  717 |     | //    to the reserves of 'tag0' and 'tag1', in the active liquidity interval.
  718 |     | //
  719 |     | //    Remember that the current reserve of 'tag0' in '[qLower, qUpper]' is
  720 |     | //    proportional to 'integral0' and the current reserve of 'tag1' in the same
  721 |     | //    interval is proportional to 'integral1'. Because of this, the point
  722 |     | //    '(integral0, integral1)' in the above diagram is indicated as 'pCurrent'
  723 |     | //    which is the current price of the pool. As a result, '0 - pCurrent' is
  724 |     | //    equal to the slope of the diagram at the point '(integral0, integral1)'.
  725 |     | //    
  726 |     | //    A swapper is permitted to move to any point that belongs to the above
  727 |     | //    diagram by giving or taking appropriate amounts of 'tag0' and 'tag1'.
  728 |     | //    When a swapper moves on the above diagram we calculate the outgoing and
  729 |     | //    incoming amounts of 'tag0' and 'tag1' by computing the two integrals
  730 |     | //    'currentToTarget' and 'incomingCurrentToTarget'. In short, the shape of
  731 |     | //    the above diagram is determined by the liquidity distribution function
  732 |     | //    'k(w(.))'.
  733 |     | //
  734 |     | //    As we will discuss later in this script, after a movement to 'pTarget',
  735 |     | //    the curve sequence is amended in preparation for the next swap which
  736 |     | //    renders a different liquidity distribution function. Such amendment also
  737 |     | //    leads to a new AMM diagram with the following properties:
  738 |     | //
  739 |     | //    - The new diagram intersects with the old one at the point 'pTarget'.
  740 |     | //      This is due to the conservation of interval reserves.
  741 |     | //
  742 |     | //    - The new diagram is tangent to the old one at point 'pTarget'. This is
  743 |     | //      because our transition to a new AMM diagram should not change the price
  744 |     | //      of the pool, i.e., the slopes of the new diagrams should be the same as
  745 |     | //      the old diagrams at the intersection point which means that the two are
  746 |     | //      tangent.
  747 |     | //
  748 |     | //    The proposed structure for the kernel function enables the pool creators
  749 |     | //    to build custom AMM diagrams. Additionally, the proposed structure for
  750 |     | //    the curve sequence allows the protocol to keep track of AMM diagrams,
  751 |     | //    efficiently. In other words, the curve sequence and the kernel function
  752 |     | //    provide us with an efficient method to store the geometry of AMM diagrams
  753 |     | //    and to transform them into new ones.
  754 |     | //
  755 |     | //    Now, in order to derive the outgoing and incoming amounts from the
  756 |     | //    integral values 'currentToTarget' and 'incomingCurrentToTarget' we need
  757 |     | //    to access the static parameters that are explained next.
  758 |     | //
  759 |     | //  - The static parameters of the pool are read from the same storage smart 
  760 |     | //    contract whose address is calculated using the dynamic parameter
  761 |     | //    'staticParamsStoragePointer'. This includes the following parameters:
  762 |     | //
  763 |     | //    - 'sqrtOffset': This is the square root of 'pOffset' in 'X127'
  764 |     | //      representation, i.e.,
  765 |     | //
  766 |     | //        'sqrtOffset := (2 ** 127) * sqrt(pOffset)'.
  767 |     | //
  768 |     | //      This value is used frequently for calculating any amount of 'tag1'.
  769 |     | //      Because of this, we calculate it at the time of initialization and
  770 |     | //      store it among the static parameters.
  771 |     | //
  772 |     | //    - 'sqrtInverseOffset': This is the square root of '1 / pOffset' in 'X127'
  773 |     | //      representation, i.e.,
  774 |     | //
  775 |     | //        'sqrtInverseOffset := (2 ** 127) / sqrt(pOffset)'
  776 |     | //
  777 |     | //      This value is used frequently for calculating any amount of 'tag0'.
  778 |     | //      Because of this, we calculate it at the time of initialization and
  779 |     | //      store it among the static parameters.
  780 |     | //
  781 |     | //    - 'outgoingMax': This value is a kernel parameter in 'X216'
  782 |     | //      representation which is defined as follows:
  783 |     | //
  784 |     | //                             - 8     / qSpacing
  785 |     | //          outgoingMax      e        |    - h / 2
  786 |     | //        '------------- := ------- * |  e         k(h) dh'.
  787 |     | //           2 ** 216          2      |
  788 |     | //                                   / 0
  789 |     | //
  790 |     | //      'outgoingMax' is used frequently for calculating any amount of 'tag0'
  791 |     | //      and 'tag1'. Because of this, we calculate 'outgoingMax' and its modular
  792 |     | //      inverse at the time of initialization or anytime that the kernel
  793 |     | //      function is modified and then we store the resulting values among the
  794 |     | //      static parameters.
  795 |     | //
  796 |     | //      Now, we have all of the parameters that are needed to calculate the
  797 |     | //      outgoing amount from the pool and the incoming amount to the pool as
  798 |     | //      long as we remain within the current active liquidity interval.
  799 |     | //
  800 |     | //      For a price increasing swap we have:
  801 |     | //                                                               growth
  802 |     | //        'amount0Partial := sqrtInverseOffset * sharesTotal * ---------- * 
  803 |     | //                                                              2 ** 111
  804 |     | //                            currentToTarget
  805 |     | //                           -----------------',
  806 |     | //                              outgoingMax
  807 |     | //                                                        growth
  808 |     | //        'amount1Partial := sqrtOffset * sharesTotal * ---------- * 
  809 |     | //                                                       2 ** 111
  810 |     | //                            incomingCurrentToTarget
  811 |     | //                           -------------------------',
  812 |     | //                                  outgoingMax
  813 |     | //
  814 |     | //      where 'amount0Partial' denotes the amount of outgoing 'tag0' from the
  815 |     | //      pool and 'amount1Partial' denotes the amount of incoming 'tag1' to the
  816 |     | //      pool, as a result of swapping within the active liquidity interval,
  817 |     | //      where both of the amounts are in 'X127' representation.
  818 |     | //
  819 |     | //      Similarly, for a price decreasing swap we have:
  820 |     | //                                                               growth
  821 |     | //        'amount0Partial := sqrtInverseOffset * sharesTotal * ---------- * 
  822 |     | //                                                              2 ** 111
  823 |     | //                            incomingCurrentToTarget
  824 |     | //                           -------------------------',
  825 |     | //                                  outgoingMax
  826 |     | //                                                        growth
  827 |     | //        'amount1Partial := sqrtOffset * sharesTotal * ---------- * 
  828 |     | //                                                       2 ** 111
  829 |     | //                            currentToTarget
  830 |     | //                           -----------------',
  831 |     | //                              outgoingMax
  832 |     | //
  833 |     | //      where 'amount0Partial' denotes the amount of incoming 'tag0' to the
  834 |     | //      pool and 'amount1Partial' denotes the amount of outgoing 'tag1' from
  835 |     | //      the pool, as a result of swapping within the active liquidity interval,
  836 |     | //      where both of the amounts are in 'X127' representation.
  837 |     | //
  838 |     | //    - 'incomingMax': This value is a kernel parameter in 'X216'
  839 |     | //      representation which is defined as follows:
  840 |     | //
  841 |     | //                             - 8 - qSpacing / 2     / qSpacing
  842 |     | //          incomingMax      e                       |    + h / 2
  843 |     | //        '------------- := ---------------------- * |  e         k(h) dh'.
  844 |     | //           2 ** 216                  2             |
  845 |     | //                                                  / 0
  846 |     | //
  847 |     | //      Consider a scenario where the price of the pool is moved all the way
  848 |     | //      from the left interval boundary 'qLower', to the right interval
  849 |     | //      boundary 'qUpper', as part of a swap. In this case, let 
  850 |     | //      'amount0Partial' denote the amount of outgoing 'tag0' from the pool and
  851 |     | //      let 'amount1Partial' denote the amount of incoming 'tag1' to the pool,
  852 |     | //      as a result of swapping within the entire interval, '[qLower, qUpper]'
  853 |     | //      where both of the amounts are in 'X127' representation. Then, we have:
  854 |     | //
  855 |     | //        'amount0Partial ==
  856 |     | //                                             growth
  857 |     | //         sqrtInverseOffset * sharesTotal * ---------- *
  858 |     | //                                            2 ** 111
  859 |     | //
  860 |     | //                            - 8     / qUpper
  861 |     | //           2 ** 216       e        |                     - h / 2
  862 |     | //         ------------- * ------- * |   k(h - qLower) * e         dh ==
  863 |     | //          outgoingMax       2      |
  864 |     | //                                  / qLower
  865 |     | //
  866 |     | //                                             growth
  867 |     | //         sqrtInverseOffset * sharesTotal * ---------- *
  868 |     | //                                            2 ** 111
  869 |     | //
  870 |     | //                            - 8 - qLower / 2     / qSpacing
  871 |     | //           2 ** 216       e                     |            - h / 2
  872 |     | //         ------------- * -------------------- * |   k(h) * e         dh ==
  873 |     | //          outgoingMax              2            |
  874 |     | //                                               / 0
  875 |     | //
  876 |     | //                                             growth       - qLower / 2
  877 |     | //         sqrtInverseOffset * sharesTotal * ---------- * e              '
  878 |     | //                                            2 ** 111
  879 |     | //
  880 |     | //      and
  881 |     | //
  882 |     | //        'amount1Partial ==
  883 |     | //                                      growth
  884 |     | //         sqrtOffset * sharesTotal * ---------- *
  885 |     | //                                     2 ** 111
  886 |     | //
  887 |     | //                            - 8     / qUpper
  888 |     | //           2 ** 216       e        |                     + h / 2
  889 |     | //         ------------- * ------- * |   k(h - qLower) * e         dh ==
  890 |     | //          outgoingMax       2      |
  891 |     | //                                  / qLower
  892 |     | //
  893 |     | //                                      growth       2 ** 216
  894 |     | //         sqrtOffset * sharesTotal * ---------- * ------------- * 
  895 |     | //                                     2 ** 111     outgoingMax
  896 |     | //
  897 |     | //            - 8 + (qUpper - qSpacing) / 2     / qSpacing
  898 |     | //          e                                  |            + h / 2
  899 |     | //         --------------------------------- * |   k(h) * e         dh ==
  900 |     | //                         2                   |
  901 |     | //                                            / 0
  902 |     | //
  903 |     | //                                      growth
  904 |     | //         sqrtOffset * sharesTotal * ---------- * 
  905 |     | //                                     2 ** 111
  906 |     | //
  907 |     | //          incomingMax      + qUpper / 2
  908 |     | //         ------------- * e              '.
  909 |     | //          outgoingMax
  910 |     | //
  911 |     | //      Consider another scenario where the price of the pool is moved all the
  912 |     | //      way from the right interval boundary 'qUpper', to the left interval
  913 |     | //      boundary 'qLower', as part of a swap. In this case, let
  914 |     | //      'amount1Partial' denote the amount of outgoing 'tag1' from the pool and
  915 |     | //      let 'amount0Partial' denote the amount of incoming 'tag0' to the
  916 |     | //      pool, as a result of swapping within the the entire interval,
  917 |     | //      '[qLower, qUpper]' where both of the amounts are in 'X127'
  918 |     | //      representation. Then, we have:
  919 |     | //
  920 |     | //        'amount1Partial ==
  921 |     | //                                      growth
  922 |     | //         sqrtOffset * sharesTotal * ---------- *
  923 |     | //                                     2 ** 111
  924 |     | //
  925 |     | //                            - 8     / qUpper
  926 |     | //           2 ** 216       e        |                     + h / 2
  927 |     | //         ------------- * ------- * |   k(qUpper - h) * e         dh ==
  928 |     | //          outgoingMax       2      |
  929 |     | //                                  / qLower
  930 |     | //
  931 |     | //                                      growth
  932 |     | //         sqrtOffset * sharesTotal * ---------- *
  933 |     | //                                     2 ** 111
  934 |     | //
  935 |     | //                            - 8 + qUpper / 2     / qSpacing
  936 |     | //           2 ** 216       e                     |            - h / 2
  937 |     | //         ------------- * -------------------- * |   k(h) * e         dh ==
  938 |     | //          outgoingMax              2            |
  939 |     | //                                               / 0
  940 |     | //
  941 |     | //                                      growth       + qUpper / 2
  942 |     | //         sqrtOffset * sharesTotal * ---------- * e              '.
  943 |     | //                                     2 ** 111
  944 |     | //
  945 |     | //      and
  946 |     | //
  947 |     | //        'amount0Partial ==
  948 |     | //                                             growth
  949 |     | //         sqrtInverseOffset * sharesTotal * ---------- *
  950 |     | //                                            2 ** 111
  951 |     | //
  952 |     | //                            - 8     / qUpper
  953 |     | //           2 ** 216       e        |                     - h / 2
  954 |     | //         ------------- * ------- * |   k(qUpper - h) * e         dh ==
  955 |     | //          outgoingMax       2      |
  956 |     | //                                  / qLower
  957 |     | //
  958 |     | //                                             growth       2 ** 216
  959 |     | //         sqrtInverseOffset * sharesTotal * ---------- * ------------- * 
  960 |     | //                                            2 ** 111     outgoingMax
  961 |     | //
  962 |     | //            - 8 - (qLower + qSpacing) / 2     / qSpacing
  963 |     | //          e                                  |            + h / 2
  964 |     | //         --------------------------------- * |   k(h) * e         dh ==
  965 |     | //                          2                  |
  966 |     | //                                            / 0
  967 |     | //
  968 |     | //                                             growth
  969 |     | //         sqrtInverseOffset * sharesTotal * ---------- * 
  970 |     | //                                            2 ** 111
  971 |     | //
  972 |     | //          incomingMax      - qLower / 2
  973 |     | //         ------------- * e              '.
  974 |     | //          outgoingMax
  975 |     | //
  976 |     | //      Hence, in order to facilitate the calculation of 'amount0Partial' and
  977 |     | //      'amount1Partial' in such scenarios, we calculate 'incomingMax' at the
  978 |     | //      time of initialization or anytime that the kernel function is modified
  979 |     | //      and then we store the resulting value among the static parameters.
  980 |     | //
  981 |     | //      Lastly, we are going to prove the inequality
  982 |     | //
  983 |     | //        'incomingMax >= outgoingMax'
  984 |     | //
  985 |     | //      which will be used later in this script. According to the definitions
  986 |     | //      for 'outgoingMax' and 'incomingMax', we have:
  987 |     | //
  988 |     | //                             - 8 - qSpacing / 2     / qSpacing
  989 |     | //          incomingMax      e                       |    + h / 2
  990 |     | //        '------------- := ---------------------- * |  e         k(h) dh
  991 |     | //           2 ** 216                  2             |
  992 |     | //                                                  / 0
  993 |     | //
  994 |     | //                             - 8     / qSpacing
  995 |     | //                           e        |             - (qSpacing - h) / 2
  996 |     | //                       == ------- * |    k(h) * e                      dh
  997 |     | //                             2      |
  998 |     | //                                   / 0
  999 |     | //
 1000 |     | //                             - 8     / qSpacing
 1001 |     | //                           e        |           - h / 2        outgoingMax
 1002 |     | //                       >= ------- * |  k(h) * e         dh == -------------'.
 1003 |     | //                             2      |                           2 ** 216
 1004 |     | //                                   / 0
 1005 |     | //
 1006 |     | //      which is concluded from HardyLittlewood inequality and the fact that
 1007 |     | //      'exp(- (qSpacing - h) / 2)' is an increasing rearrangement of
 1008 |     | //      'exp(- h / 2)'.
 1009 |     | //  
 1010 |     | //  - In the previous steps we read the dynamic parameters, the curve sequence,
 1011 |     | //    the kernel function, and the static parameters. The next step is to move
 1012 |     | //    the price towards 'qNext' until any of the following conditions are met:
 1013 |     | //
 1014 |     | //    (a) 'amountSpecified' is fulfilled, after which the swap is halted.
 1015 |     | //
 1016 |     | //    (b) 'qLimit' is reached, after which the swap is halted.
 1017 |     | //
 1018 |     | //    (c) 'qNext' is reached, after which we transition to a new interval.
 1019 |     | //
 1020 |     | //    Before doing so, we need to verify the condition,
 1021 |     | //
 1022 |     | //      'sharesTotal >= crossThreshold'.
 1023 |     | //
 1024 |     | //    If true, we move the price within the current interval, if not we halt
 1025 |     | //    the swap.
 1026 |     | //
 1027 |     | //    As we move the price from 'qCurrent' towards 'qNext', the integrals
 1028 |     | //    'currentToTarget' and 'incomingCurrentToTarget' are continuously
 1029 |     | //    incremented as they are cumulatively calculated piece by piece. This
 1030 |     | //    process involves exploring the liquidity distribution function 'k(w(h))'
 1031 |     | //    within the active liquidity interval. Since 'k(w(.))' is a piecewise
 1032 |     | //    linear function, we proceed piece by piece and we increment both
 1033 |     | //    'currentToTarget' and 'incomingCurrentToTarget' as we move forward. The
 1034 |     | //    process of exploring 'k(w(.))' is explained later in this script and in
 1035 |     | //    'Interval.sol'.
 1036 |     | //
 1037 |     | //    In the present example, since 'zeroForOne == True' and
 1038 |     | //    'amountSpecified == +oo > 0', we have:
 1039 |     | //
 1040 |     | //      'zeroForOne == exactInput'
 1041 |     | //
 1042 |     | //    which indicates that 'amountSpecified' is with respect to 'tag0'.
 1043 |     | //
 1044 |     | //    Remember that for price decreasing swaps (as is the case in this
 1045 |     | //    example), as long as we remain within the current active liquidity
 1046 |     | //    interval, the amount of incoming 'tag0' is calculated as:
 1047 |     | //
 1048 |     | //                                                             growth
 1049 |     | //      'amount0Partial == sqrtInverseOffset * sharesTotal * ---------- * 
 1050 |     | //                                                            2 ** 111
 1051 |     | //                          incomingCurrentToTarget
 1052 |     | //                         -------------------------',
 1053 |     | //                                outgoingMax
 1054 |     | //
 1055 |     | //    which means that in order for us to meet the stopping criteria (a), we
 1056 |     | //    should have:
 1057 |     | //                                                                growth
 1058 |     | //      '|amountSpecified| == sqrtInverseOffset * sharesTotal * ---------- * 
 1059 |     | //                                                               2 ** 111
 1060 |     | //                             incomingCurrentToTarget
 1061 |     | //                            -------------------------',
 1062 |     | //                                   outgoingMax
 1063 |     | //    or equivalently,
 1064 |     | //
 1065 |     | //      'incomingCurrentToTarget == 
 1066 |     | //
 1067 |     | //                      |amountSpecified|          1          2 ** 111
 1068 |     | //       outgoingMax * ------------------- * ------------- * ----------'.
 1069 |     | //                      sqrtInverseOffset     sharesTotal      growth
 1070 |     | //
 1071 |     | //    As we increment 'currentToTarget' and 'incomingCurrentToTarget' by
 1072 |     | //    moving towards 'qNext', at every step (i.e., with each piece of the
 1073 |     | //    liquidity distribution function 'k(w(.))') we need to determine whether
 1074 |     | //    'amountSpecified' is fulfilled or not. To that end, before starting the
 1075 |     | //    exploration, the protocol calculates the right hand side of the above
 1076 |     | //    equation, i.e.,
 1077 |     | //
 1078 |     | //                      |amountSpecified|          1          2 ** 111
 1079 |     | //       outgoingMax * ------------------- * ------------- * ----------'.
 1080 |     | //                      sqrtInverseOffset     sharesTotal      growth
 1081 |     | //
 1082 |     | //    which is regarded as 'integralLimit', and stores its 'X216'
 1083 |     | //    representation in the memory space which is pointed to by
 1084 |     | //    '_integralLimit_'.
 1085 |     | //
 1086 |     | //    Consider a hypothetical swap for which 'exactInput == false'. Then, every
 1087 |     | //    time that we increment 'currentToTarget', we check whether it has
 1088 |     | //    exceeded 'integralLimit'. Once it has, we use the method
 1089 |     | //    'searchOutgoingTarget' in 'Interval.sol' to find the precise value
 1090 |     | //
 1091 |     | //      'qTarget := log(pTarget / pOffset)'
 1092 |     | //
 1093 |     | //    in order to have
 1094 |     | //
 1095 |     | //      'currentToTarget == integralLimit'
 1096 |     | //
 1097 |     | //    which guarantees that 'amountSpecified' is fulfilled.
 1098 |     | //
 1099 |     | //    If 'exactInput == true', as is the case in our current example, every
 1100 |     | //    time that we increment 'incomingCurrentToTarget', we check whether it has
 1101 |     | //    exceeded 'integralLimit'. Once it has, we use the method
 1102 |     | //    'searchIncomingTarget' in 'Interval.sol' to find the precise value
 1103 |     | //
 1104 |     | //      'qTarget := log(pTarget / pOffset)'
 1105 |     | //
 1106 |     | //    in order to have
 1107 |     | //
 1108 |     | //      'incomingCurrentToTarget == integralLimit'
 1109 |     | //
 1110 |     | //    which guarantees that 'amountSpecified' is fulfilled.
 1111 |     | //
 1112 |     | //    After either of the above searches, the price of the pool is moved to
 1113 |     | //    'qTarget' and the corresponding outgoing and incoming amounts are
 1114 |     | //    calculated.
 1115 |     | //
 1116 |     | //    Throughout the execution of the swap, whenever we enter a new liquidity
 1117 |     | //    interval, both 'amountSpecified' and 'integralLimit' are updated. This is
 1118 |     | //    further explained in the next step.
 1119 |     | //
 1120 |     | //    However, remember that in the present example, we have
 1121 |     | //    'amountSpecified == +oo' which means that:
 1122 |     | //
 1123 |     | //      'integralLimit := outgoingMax * 
 1124 |     | //
 1125 |     | //        |amountSpecified|          1          2 ** 111
 1126 |     | //       ------------------- * ------------- * ---------- == +oo'.
 1127 |     | //        sqrtInverseOffset     sharesTotal      growth
 1128 |     | //
 1129 |     | //    Hence, 'incomingCurrentToTarget' may never exceed 'integralLimit' and the
 1130 |     | //    stopping criteria (a) is not reachable. Put simply, since
 1131 |     | //    'amountSpecified' is equal to infinity, we may never reach it and we only
 1132 |     | //    need to worry about 'qLimit' and 'qNext'.
 1133 |     | //
 1134 |     | //    In order to keep track of (b) and (c) concurrently, the protocol
 1135 |     | //    calculates
 1136 |     | //
 1137 |     | //      'qLimitWithinInterval := min(max(qLower, qLimit), qUpper)'
 1138 |     | //
 1139 |     | //    and stores it in the memory space which is referred to by
 1140 |     | //    '_logPriceLimitOffsettedWithinInterval_'. As we move forward with pieces
 1141 |     | //    of the liquidity distribution function, we continuously check whether
 1142 |     | //    'qLimitWithinInterval' is reached. If so, we either need to halt the swap
 1143 |     | //    (stopping criteria (b)) or transition to a new interval (stopping
 1144 |     | //    criteria (c)).
 1145 |     | //
 1146 |     | //    In our example, it can be easily observed that
 1147 |     | //
 1148 |     | //      'qLimitWithinInterval == qNext'
 1149 |     | //
 1150 |     | //    as illustrated below:
 1151 |     | //
 1152 |     | //                                             qLimitWithinInterval
 1153 |     | //                                                      |
 1154 |     | //                  qLimit                              |  qCurrent
 1155 |     | //                     |                                |     |
 1156 |     | //     ... <--+-------------+-------------+-------------+-------------+--> ...
 1157 |     | //                                                      |             |
 1158 |     | //                                                    qNext         qBack
 1159 |     | //
 1160 |     | //    Hence, in the present active liquidity interval, we do not need to worry
 1161 |     | //    about 'qLimit' either and we can move forward until we reach 'qNext'.
 1162 |     | //    After that, we need to update a number of parameters, including:
 1163 |     | //
 1164 |     | //    - 'amount0': This is the total amount of 'tag0' which is traded as a
 1165 |     | //      result of this swap. In this example, since our swap is price
 1166 |     | //      decreasing, we should have 'amount0 > 0' which indicates that 'amount0'
 1167 |     | //      is incoming to the pool. Hence, according to the above formulas, with
 1168 |     | //      each interval that we transact in, 'amount0' should be incremented by:
 1169 |     | //
 1170 |     | //                                                               growth
 1171 |     | //        'amount0Partial := sqrtInverseOffset * sharesTotal * ---------- *
 1172 |     | //                                                              2 ** 111
 1173 |     | //                            incomingCurrentToTarget
 1174 |     | //                           -------------------------'
 1175 |     | //                                  outgoingMax
 1176 |     | //
 1177 |     | //    - 'amount1': This is the total amount of 'tag1' which is traded as a
 1178 |     | //      result of this swap. In this example, since our swap is price
 1179 |     | //      decreasing, we should have 'amount1 < 0' which indicates that 'amount1'
 1180 |     | //      is outgoing from the pool. Hence, according to the above formulas, with
 1181 |     | //      each interval that we transact in, 'amount1' should be decremented by:
 1182 |     | //
 1183 |     | //                                                        growth
 1184 |     | //        'amount1Partial := sqrtOffset * sharesTotal * ---------- *
 1185 |     | //                                                       2 ** 111
 1186 |     | //                            currentToTarget
 1187 |     | //                           -----------------'
 1188 |     | //                              outgoingMax
 1189 |     | //
 1190 |     | //    - 'amountSpecified': Since the swap is partially fulfilled, we should
 1191 |     | //      decrement 'amountSpecified' by 'amount0Partial' to reflect this:
 1192 |     | //
 1193 |     | //        'amountSpecified -= amount0Partial'.
 1194 |     | //
 1195 |     | //    - 'curve': As explained before, when we transact in a liquidity interval,
 1196 |     | //      as part of a swap, we then need to amend the curve sequence for that
 1197 |     | //      interval in preparation for the next swap. In this example, the
 1198 |     | //      amendment is straightforward. Since we are about to transition out of
 1199 |     | //      the interval '[qLower, qUpper]', it should turn into an inactive
 1200 |     | //      interval. Hence, the corresponding curve sequence for this interval
 1201 |     | //      should transform into a sequence of length two as is the case for every
 1202 |     | //      inactive liquidity interval. Following the pattern that was introduced
 1203 |     | //      earlier for inactive liquidity intervals, the amended curve sequence
 1204 |     | //      for '[qLower, qUpper]' should be:
 1205 |     | //
 1206 |     | //        'q[0] := qUpper',
 1207 |     | //        'q[1] := qLower'.
 1208 |     | //
 1209 |     | //      This amendment, transforms the function 'w' associated with
 1210 |     | //      '[qLower, qUpper]' from the following:
 1211 |     | //
 1212 |     | //            w(q)
 1213 |     | //              ^
 1214 |     | //      spacing |                /
 1215 |     | //              |               /
 1216 |     | //              |              /
 1217 |     | //              |             /
 1218 |     | //              |            /
 1219 |     | //              |           /
 1220 |     | //              |          /
 1221 |     | //              |\
 1222 |     | //              | \
 1223 |     | //              |  \
 1224 |     | //              |   \
 1225 |     | //              |        /
 1226 |     | //              |       /
 1227 |     | //              |      /
 1228 |     | //              |     /
 1229 |     | //            0 +----+----+-------+-> q
 1230 |     | //           qLower  |    |       |
 1231 |     | //                   |   q[2]  qUpper
 1232 |     | //                   |
 1233 |     | //               qCurrent
 1234 |     | //
 1235 |     | //      to a new function:
 1236 |     | //
 1237 |     | //        'wAmended(q) := q - qLower'
 1238 |     | //
 1239 |     | //      which can be plotted as follows:
 1240 |     | //
 1241 |     | //          wAmended(q)
 1242 |     | //              ^
 1243 |     | //      spacing |                /
 1244 |     | //              |               /
 1245 |     | //              |              /
 1246 |     | //              |             /
 1247 |     | //              |            /
 1248 |     | //              |           /
 1249 |     | //              |          /
 1250 |     | //              |         /
 1251 |     | //              |        /
 1252 |     | //              |       /
 1253 |     | //              |      /
 1254 |     | //              |     /
 1255 |     | //              |    /
 1256 |     | //              |   /
 1257 |     | //              |  /
 1258 |     | //              | /
 1259 |     | //              |/
 1260 |     | //            0 +-----------------+-> q
 1261 |     | //           qLower               |
 1262 |     | //                             qUpper
 1263 |     | //
 1264 |     | //      As we will demonstrate next, this procedure results in positive growth
 1265 |     | //      for liquidity providers.
 1266 |     | //
 1267 |     | //    - 'growth': As discussed earlier, before transitioning out of the
 1268 |     | //      interval '[qLower, qUpper]', the curve sequence for this interval is
 1269 |     | //      amended. This action, changes the function 'w' to 'wAmended' which in
 1270 |     | //      turn changes the liquidity distribution function from 'k(w(.))' to
 1271 |     | //      'k(wAmended(.))'. However, the amount of reserve for 'tag0' within
 1272 |     | //      '[qLower, qUpper]' should stay the same before and after the amendment
 1273 |     | //      of the curve sequence. This is because modifying the curve sequence is
 1274 |     | //      a change in our trading policy and it does not introduce or remove any
 1275 |     | //      amount of liquidity. Hence, in order to conserve the amount of 'tag0'
 1276 |     | //      within '[qLower, qUpper]' despite the transformation of 'w' to
 1277 |     | //      'wAmended', we need to make an adjustment to the 'growth' value and
 1278 |     | //      turn it into 'growthAmended'. In order to determine 'growthAmended',
 1279 |     | //      the following equation is solved:
 1280 |     | //
 1281 |     | //        'totalReserveOfTag0Before == totalReserveOfTag0After'
 1282 |     | //
 1283 |     | //      where 'totalReserveOfTag0Before' is the total amount of 'tag0' within
 1284 |     | //      '[qLower, qUpper]' which is calculated based on 'k(w(.))', whereas
 1285 |     | //      'totalReserveOfTag0After' is the same value calculated based on
 1286 |     | //      'k(wAmended(.))'. The two sides of the equation can be derived as:
 1287 |     | //
 1288 |     | //        'totalReserveOfTag0Before = sqrtInverseOffset * sharesTotal * 
 1289 |     | //
 1290 |     | //                                         - 8     / qUpper
 1291 |     | //           growth       2 ** 216       e        |    - h / 2
 1292 |     | //         ---------- * ------------- * ------- * |  e         k(w(h)) dh',
 1293 |     | //          2 ** 111     outgoingMax       2      |
 1294 |     | //                                               / qLower
 1295 |     | //
 1296 |     | //        'totalReserveOfTag0After = sqrtInverseOffset * sharesTotal * 
 1297 |     | //
 1298 |     | //          growthAmended       2 ** 216
 1299 |     | //         --------------- * ------------- *
 1300 |     | //             2 ** 111       outgoingMax
 1301 |     | //
 1302 |     | //            - 8     / qUpper
 1303 |     | //          e        |    - h / 2
 1304 |     | //         ------- * |  e         k(wAmended(h)) dh',
 1305 |     | //            2      |
 1306 |     | //                  / qLower
 1307 |     | //
 1308 |     | //      Hence, 'growthAmended' can be derived as:
 1309 |     | //
 1310 |     | //                                           / qUpper
 1311 |     | //                                          |    - h / 2
 1312 |     | //                                          |  e         k(w(h)) dh
 1313 |     | //                                          |
 1314 |     | //                                         / qLower
 1315 |     | //        'growthAmended == growth * ---------------------------------'.
 1316 |     | //                                       / qUpper
 1317 |     | //                                      |    - h / 2
 1318 |     | //                                      |  e         k(wAmended(h)) dh
 1319 |     | //                                      |
 1320 |     | //                                     / qLower
 1321 |     | //
 1322 |     | //      Observe that 'wAmended' is a monotonically non-decreasing rearrangement
 1323 |     | //      of 'w'. This is because pieces of 'wAmended' can be flipped and
 1324 |     | //      rearranged in order to transform its diagram to the diagram of 'w'. On
 1325 |     | //      the other hand, since 'k' is a monotonically non-decreasing function,
 1326 |     | //      we can conclude that 'k(wAmended(.))' is a monotonically non-decreasing
 1327 |     | //      rearrangement of 'k(w(.))'. Hence, according to the HardyLittlewood
 1328 |     | //      inequality, we have:
 1329 |     | //
 1330 |     | //            / qUpper                             / qUpper
 1331 |     | //           |    - h / 2                         |    - h / 2
 1332 |     | //        '  |  e         k(wAmended(h)) dh  <=   |  e         k(w(h)) dh '
 1333 |     | //           |                                    |
 1334 |     | //          / qLower                             / qLower
 1335 |     | //      
 1336 |     | //      which concludes that:
 1337 |     | //
 1338 |     | //        'growthAmended >= growth'.
 1339 |     | //
 1340 |     | //      This is exactly what we want!
 1341 |     | //
 1342 |     | //      To summarize, when we transact in a liquidity interval as part of a
 1343 |     | //      swap, we then need to amend the curve sequence for that interval. After
 1344 |     | //      that, in order to make up for the transformation of 'w' to 'wAmended',
 1345 |     | //      the 'growth' value should be incremented according to the above formula
 1346 |     | //      for 'growthAmended'.
 1347 |     | //
 1348 |     | //    - 'qCurrent': Lastly, as we move the price of the pool to 'qNext', the
 1349 |     | //      value for 'qCurrent' should be updated to reflect this change. which is
 1350 |     | //      illustrated as follows:
 1351 |     | //
 1352 |     | //                qLimit                              qCurrent
 1353 |     | //                   |                                   |
 1354 |     | //      ... <--+-------------+-------------+-------------+-------------+--> ...
 1355 |     | //                                                       |             |
 1356 |     | //                                                     qNext         qBack
 1357 |     | //    
 1358 |     | //    Now, we are ready to transition out of the interval '[qLower, qUpper]'
 1359 |     | //    which is explained next.
 1360 |     | //
 1361 |     | //  - In the previous step we moved the price of the pool to 'qNext' to
 1362 |     | //    partially fulfill the requested swap. In this step, we transition from
 1363 |     | //    the original liquidity interval '[qLower, qUpper]' to its adjacent
 1364 |     | //    interval '[qLower - qSpacing, qUpper - qSpacing]'. This transition
 1365 |     | //    involves updating the following parameters:
 1366 |     | //
 1367 |     | //    - 'sharesTotal': The current value of 'sharesTotal' reflects the total
 1368 |     | //      number of shares within '[qLower, qUpper]'. As we are transitioning to
 1369 |     | //      '[qLower - qSpacing, qUpper - qSpacing]', this value should be modified
 1370 |     | //      in order to reflect the total number of shares in the new active
 1371 |     | //      interval.
 1372 |     | //
 1373 |     | //      We keep track of the total share values in all of the liquidity
 1374 |     | //      intervals via the mapping 'sharesDelta' within protocol's storage. Let
 1375 |     | //      'qBoundary' denote an arbitrary boundary for a liquidity interval,
 1376 |     | //      i.e.,
 1377 |     | //
 1378 |     | //        'qBoundary == qLower + j * qSpacing'
 1379 |     | //
 1380 |     | //      for some integer 'j'. Let 'sharesTotalLeft' and 'sharesTotalRight'
 1381 |     | //      denote the total number of shares within the intervals
 1382 |     | //
 1383 |     | //        '[qBoundary - qSpacing, qBoundary]' and
 1384 |     | //        '[qBoundary, qBoundary + qSpacing]',
 1385 |     | //
 1386 |     | //      respectively. Define:
 1387 |     | //
 1388 |     | //        'sharesDelta[qBoundary] := sharesTotalRight - sharesTotalLeft'.
 1389 |     | //
 1390 |     | //      In other words, 'sharesDelta[qBoundary]' is defined as the difference
 1391 |     | //      between the total number of shares within the two liquidity intervals
 1392 |     | //      that contain 'qBoundary'.
 1393 |     | //
 1394 |     | //      Hence, for price increasing swaps, as we transition to a new interval,
 1395 |     | //      'sharesTotal' should be modified as follows:
 1396 |     | //
 1397 |     | //        'sharesTotal += sharesDelta[qNext]',
 1398 |     | //
 1399 |     | //      and for price decreasing swaps, as we transition to a new interval,
 1400 |     | //      'sharesTotal' should be modified as follows:
 1401 |     | //
 1402 |     | //        'sharesTotal -= sharesDelta[qNext]'.
 1403 |     | //
 1404 |     | //      This way of accounting for the total shares makes liquidity deposit or
 1405 |     | //      withdrawal by LPs more efficient. Imagine an example where an LP
 1406 |     | //      intends to deposit '100' shares in every interval within the range
 1407 |     | //      'qLower - i * qSpacing' to 'qUpper + j * qSpacing', where 'i' and 'j'
 1408 |     | //      are arbitrary non-negative integers. In this case, we need to add '100'
 1409 |     | //      shares to every one of the following intervals:
 1410 |     | //
 1411 |     | //        '[qLower - i * qSpacing, qUpper - i * qSpacing]',
 1412 |     | //          .
 1413 |     | //          .
 1414 |     | //          .
 1415 |     | //        '[qLower - 1 * qSpacing, qUpper - 1 * qSpacing]',
 1416 |     | //        '[qLower               , qUpper               ]',
 1417 |     | //        '[qLower + 1 * qSpacing, qUpper + 1 * qSpacing]',
 1418 |     | //          .
 1419 |     | //          .
 1420 |     | //          .
 1421 |     | //        '[qLower + j * qSpacing, qUpper + j * qSpacing]'.
 1422 |     | //
 1423 |     | //      However, it may not be efficient or even possible to enumerated every
 1424 |     | //      single one of the 'i + j + 1' intervals and thanks to 'sharesDelta', we
 1425 |     | //      do not need to do that! Alternatively, in order to account for the
 1426 |     | //      additional '100' shares, the protocol:
 1427 |     | //
 1428 |     | //      - increments 'sharesDelta[qLower - i * qSpacing]' by '100',
 1429 |     | //
 1430 |     | //      - increments 'sharesTotal' by '100',
 1431 |     | //
 1432 |     | //      - decrements 'sharesDelta[qUpper + j * qSpacing]' by '100',
 1433 |     | //
 1434 |     | //      which is sufficient to updated the total number of shares in every
 1435 |     | //      liquidity interval within the intended range.
 1436 |     | //
 1437 |     | //    - 'growth': In the prior step, we updated the content of the memory space
 1438 |     | //      which is pointed to by '_growth_', according to the following formula:
 1439 |     | //
 1440 |     | //                                          / qUpper
 1441 |     | //                                         |    - h / 2
 1442 |     | //                                         |  e         k(w(h)) dh
 1443 |     | //                                         |
 1444 |     | //                                        / qLower
 1445 |     | //        'growthAmended == growth * ----------------------------------'.
 1446 |     | //                                       / qUpper
 1447 |     | //                                      |    - h / 2
 1448 |     | //                                      |  e         k(wAmended(h)) dh
 1449 |     | //                                      |
 1450 |     | //                                     / qLower
 1451 |     | //
 1452 |     | //      Hence, the current value stored in this memory space reflects the
 1453 |     | //      updated liquidity growth within '[qLower, qUpper]' (as a result of the
 1454 |     | //      partial swap that moved the price to 'qNext').
 1455 |     | //
 1456 |     | //      Now, as we are transitioning out of '[qLower, qUpper]', 'growthAmended'
 1457 |     | //      which currently resides in the memory has to be written somewhere in
 1458 |     | //      the protocol's storage, and then the amount of liquidity growth within
 1459 |     | //
 1460 |     | //        '[qLower - qSpacing, qUpper - qSpacing]'
 1461 |     | //
 1462 |     | //      should be loaded in the memory so that we can transact within this new
 1463 |     | //      interval.
 1464 |     | //
 1465 |     | //      We keep track of these 'growth' values for all of the liquidity
 1466 |     | //      intervals, via the mapping 'growthMultiplier'. For every integer 'm',
 1467 |     | //      let 'growth(m)' denote the 'growth' value for the interval
 1468 |     | //
 1469 |     | //        '[qLower + m * qSpacing, qUpper + m * qSpacing]'.
 1470 |     | //
 1471 |     | //      Hence, 'growth(0)' corresponds to '[qLower, qUpper]' which is the
 1472 |     | //      current value stored in memory. 
 1473 |     | //
 1474 |     | //      Now, for every integer 'm >= 1' define:
 1475 |     | //
 1476 |     | //          growthMultiplier[qLower + m * qSpacing]
 1477 |     | //        '----------------------------------------- := 
 1478 |     | //                         2 ** 208
 1479 |     | //         ---- +oo
 1480 |     | //         \            growth(+j)      (- qLower - j * qSpacing) / 2
 1481 |     | //         /           ------------ * e                               '.
 1482 |     | //         ---- j = m    2 ** 111
 1483 |     | //
 1484 |     | //      According to the above definition, for every integer 'm >= 1',
 1485 |     | //
 1486 |     | //          sqrtInverseOffset     growthMultiplier[qLower + m * qSpacing]
 1487 |     | //        '------------------- * -----------------------------------------'
 1488 |     | //              2 ** 127                         2 ** 208
 1489 |     | //
 1490 |     | //      is equal to the total amount of 'tag0' corresponding to a single
 1491 |     | //      liquidity provider's share in every interval spanning from
 1492 |     | //      'qLower + m * qSpacing' to '+oo'.
 1493 |     | //
 1494 |     | //      Similarly, for every integer 'm >= 1' define:
 1495 |     | //
 1496 |     | //          growthMultiplier[qUpper - m * qSpacing]
 1497 |     | //        '----------------------------------------- := 
 1498 |     | //                         2 ** 208
 1499 |     | //         ---- +oo
 1500 |     | //         \            growth(-j)      (+ qUpper - j * qSpacing) / 2
 1501 |     | //         /           ------------ * e                               '.
 1502 |     | //         ---- j = m    2 ** 111
 1503 |     | //
 1504 |     | //      According to the above definition, for every integer 'm >= 1',
 1505 |     | //
 1506 |     | //          sqrtOffset     growthMultiplier[qUpper - m * qSpacing]
 1507 |     | //        '------------ * -----------------------------------------'
 1508 |     | //           2 ** 127                     2 ** 208
 1509 |     | //
 1510 |     | //      is equal to the total amount of 'tag1' corresponding to a single
 1511 |     | //      liquidity provider's share in every interval spanning from '-oo' to
 1512 |     | //      'qUpper - m * qSpacing'.
 1513 |     | //
 1514 |     | //      The following illustration further elaborates the notion of 
 1515 |     | //      'growthMultiplier':
 1516 |     | //
 1517 |     | //                                         growthMultiplier[qUpper + qSpacing]
 1518 |     | //                                                                    |-->
 1519 |     | //       growthMultiplier[qLower - qSpacing]                          |
 1520 |     | //           <--|                                                     |
 1521 |     | //              |                        growthMultiplier[qUpper]     |
 1522 |     | //              |                                   |-->              |
 1523 |     | //              |      growthMultiplier[qLower]     |                 |
 1524 |     | //              |              <--|                 |                 |
 1525 |     | //              |                 |     growth      |                 |
 1526 |     | //              |                 |       ==        |                 |
 1527 |     | //              |    growth(-1)   |    growth(0)    |    growth(+1)   |
 1528 |     | //       ... <--+-----------------+-----------------+-----------------+--> ...
 1529 |     | //                                |                 |
 1530 |     | //                              qLower           qUpper
 1531 |     | //
 1532 |     | //      In the above figure, 'growthMultiplier[qUpper]' and
 1533 |     | //      'growthMultiplier[qUpper + qSpacing]' point towards '+oo'. This is
 1534 |     | //      because these two values are proportional to the the amount of 'tag0'
 1535 |     | //      for a single share in every interval within '[qUpper, +oo]' and
 1536 |     | //      '[qUpper + qSpacing, +oo]', respectively. This is also the case for
 1537 |     | //      every 'growthMultiplier[qBoundary]' where 'qBoundary' is on the right
 1538 |     | //      side of the active liquidity interval as it is proportional to the
 1539 |     | //      amount of 'tag0' for a single share in every interval within
 1540 |     | //      '[qBoundary, +oo]'.
 1541 |     | //
 1542 |     | //      On the contrary, 'growthMultiplier[qLower]' and
 1543 |     | //      'growthMultiplier[qLower - qSpacing]' point towards '-oo'. This is
 1544 |     | //      because these two values are proportional to the the amount of 'tag1'
 1545 |     | //      for a single share in every interval within '[-oo, qLower]' and
 1546 |     | //      '[-oo, qLower - qSpacing]', respectively. This is also the case for
 1547 |     | //      every 'growthMultiplier[qBoundary]' where 'qBoundary' is on the left
 1548 |     | //      side of the active liquidity interval as it is proportional to the
 1549 |     | //      amount of 'tag1' for a single share in every interval whithin
 1550 |     | //      '[-oo, qBoundary]'.
 1551 |     | //
 1552 |     | //      Instead of storing the growth value for each inactive interval, the
 1553 |     | //      protocol stores the mapping 'growthMultiplier'.
 1554 |     | //
 1555 |     | //      This way of accounting for the growth values makes liquidity deposit or
 1556 |     | //      withdrawal by LPs more efficient. Imagine an example where an LP
 1557 |     | //      intends to deposit '100' shares in every interval within the range
 1558 |     | //      'qLower + i * qSpacing' to 'qUpper + j * qSpacing', where 'i' and 'j'
 1559 |     | //      are arbitrary positive integers. In this case, we need to calculate the
 1560 |     | //      amount of 'tag0' corresponding to '100' shares in every one of the
 1561 |     | //      following intervals:
 1562 |     | //
 1563 |     | //        '[qLower + i       * qSpacing, qUpper + i       * qSpacing]',
 1564 |     | //        '[qLower + (i + 1) * qSpacing, qUpper + (i + 1) * qSpacing]',
 1565 |     | //          .
 1566 |     | //          .
 1567 |     | //          .
 1568 |     | //        '[qLower + (j - 1) * qSpacing, qUpper + (j - 1) * qSpacing]',
 1569 |     | //        '[qLower + j       * qSpacing, qUpper + j       * qSpacing]'.
 1570 |     | //
 1571 |     | //      However, it may not be efficient or even possible to enumerated every
 1572 |     | //      single one of the 'j - i + 1' intervals and thanks to
 1573 |     | //      'growthMultiplier', we do not need to do that! Alternatively, the
 1574 |     | //      protocol calculates the amount of 'tag0' that needs to be deposited
 1575 |     | //      using the following formula:
 1576 |     | //
 1577 |     | //                sqrtInverseOffset
 1578 |     | //        '100 * ------------------- * (
 1579 |     | //                    2 ** 127
 1580 |     | //
 1581 |     | //                          growthMultiplier[qLower + i * qSpacing]
 1582 |     | //                         ----------------------------------------- - 
 1583 |     | //                                          2 ** 208
 1584 |     | //
 1585 |     | //                          growthMultiplier[qUpper + j * qSpacing]
 1586 |     | //                         -----------------------------------------
 1587 |     | //                                          2 ** 208
 1588 |     | //         )'.
 1589 |     | //
 1590 |     | //      The following figure visualizes the direction of the growth multipliers
 1591 |     | //      prior to the transition from '[qLower, qUpper]' to the new interval
 1592 |     | //      '[qLower - qSpacing, qUpper - qSpacing]':
 1593 |     | //
 1594 |     | //                           growthMultiplier[qCurrent - qSpacing]
 1595 |     | //                                      <--|
 1596 |     | //                                         |            growthMultiplier[qBack]
 1597 |     | //                                         |                           |-->
 1598 |     | //                                         | growthMultiplier[qCurrent]|
 1599 |     | //                                         |          <--|             |
 1600 |     | //                qLimit                   |             |             |
 1601 |     | //                   |                     |  growth(-1) |  growth(0)  |
 1602 |     | //      ... <--+-------------+-------------+-------------+-------------+--> ...
 1603 |     | //                                                       |             |
 1604 |     | //                                                     qNext         qBack
 1605 |     | //                                                       |
 1606 |     | //                                                    qCurrent
 1607 |     | //
 1608 |     | //      where 'growth(0) := growthAmended'. As shown in the above figure,
 1609 |     | //      'growthMultiplier[qBack]' points towards '+oo' because it is on the
 1610 |     | //      right side of the active liquidity interval whereas
 1611 |     | //      'growthMultiplier[qCurrent]' and 'growthMultiplier[qCurrent - qSpacing]'
 1612 |     | //      point towards '-oo' because they are on the left side of the active
 1613 |     | //      liquidity interval.
 1614 |     | //
 1615 |     | //      As part of this interval transition, we need to take the following
 1616 |     | //      steps:
 1617 |     | //      
 1618 |     | //      - 'growth(-1)' is the value which is supposed to replace
 1619 |     | //        'growthAmended' in the memory space which is pointed to by
 1620 |     | //        '_growth_'. However, since the protocol does not store growth values
 1621 |     | //        for inactive intervals, we do not have direct access to 'growth(-1)'.
 1622 |     | //        Because of this, we calculate it via the following formula:
 1623 |     | //
 1624 |     | //            growth(-1)       - qCurrent / 2
 1625 |     | //          '------------ == e                * ( 
 1626 |     | //             2 ** 111
 1627 |     | //
 1628 |     | //             growthMultiplier[qCurrent]
 1629 |     | //            ---------------------------- - 
 1630 |     | //                      2 ** 208
 1631 |     | //
 1632 |     | //             growthMultiplier[qCurrent - qSpacing]
 1633 |     | //            ---------------------------------------
 1634 |     | //                           2 ** 208
 1635 |     | //           )'
 1636 |     | //
 1637 |     | //      - Next, we need to recalculate 'growthMultiplier[qCurrent]' because it
 1638 |     | //        is currently pointing to '-oo' since 'qCurrent' is on the left side
 1639 |     | //        of '[qLower, qUpper]'. However, once we transition, 'qCurrent' would
 1640 |     | //        be on the right side of the active liquidity interval
 1641 |     | //
 1642 |     | //          '[qLower - qSpacing, qUpper - qSpacing]'
 1643 |     | //
 1644 |     | //        which means that it should point to '+oo'. Hence,
 1645 |     | //        'growthMultiplier[qCurrent]' is recalculated via the following
 1646 |     | //        formula:
 1647 |     | //
 1648 |     | //            growthMultiplier[qCurrent]      growthMultiplier[qBack]
 1649 |     | //          '---------------------------- := ------------------------- +
 1650 |     | //                    2 ** 208                       2 ** 208
 1651 |     | //
 1652 |     | //            growthAmended      - qCurrent / 2
 1653 |     | //           --------------- * e                '.
 1654 |     | //              2 ** 111
 1655 |     | //
 1656 |     | //        Observe that according to the above formula, 'growthAmended' is
 1657 |     | //        incorporated into 'growthMultiplier[qCurrent]' which is where it is
 1658 |     | //        kept track of.
 1659 |     | //
 1660 |     | //      The following figure illustrates the above modification of the
 1661 |     | //      'growthMultiplier' mapping:
 1662 |     | //
 1663 |     | //                           growthMultiplier[qCurrent - qSpacing]
 1664 |     | //                                      <--|
 1665 |     | //                                         |            growthMultiplier[qBack]
 1666 |     | //                                         |                           |-->
 1667 |     | //                                         | growthMultiplier[qCurrent]|
 1668 |     | //                                         |             |-->          |
 1669 |     | //                qLimit                   |             |             |
 1670 |     | //                   |                     |             |             |
 1671 |     | //      ... <--+-------------+-------------+-------------+-------------+--> ...
 1672 |     | //                                                       |             |
 1673 |     | //                                                     qNext         qBack
 1674 |     | //                                                       |
 1675 |     | //                                                    qCurrent
 1676 |     | //
 1677 |     | //    - 'qBack' and 'qNext': Since we are dealing with a price decreasing swap,
 1678 |     | //      the values 'qBack' and 'qNext' should be modified as follows in order
 1679 |     | //      to represent the new liquidity interval that we are transitioning to:
 1680 |     | //
 1681 |     | //        'qBack -= qSpacing',
 1682 |     | //        'qNext -= qSpacing'.
 1683 |     | //
 1684 |     | //      which is illustrated below:
 1685 |     | //
 1686 |     | //                qLimit                              qCurrent
 1687 |     | //                   |                                   |
 1688 |     | //      ... <--+-------------+-------------+-------------+-------------+--> ...
 1689 |     | //                                         |             |
 1690 |     | //                                       qNext         qBack
 1691 |     | //    
 1692 |     | //    - 'curve': As we discussed before, since
 1693 |     | //
 1694 |     | //          '[qLower - qSpacing, qUpper - qSpacing]'
 1695 |     | //
 1696 |     | //      is currently inactive, its corresponding curve sequence is composed of
 1697 |     | //      only two members:
 1698 |     | //
 1699 |     | //      'q[0] := qUpper - qSpacing',
 1700 |     | //      'q[1] := qLower - qSpacing'.
 1701 |     | //
 1702 |     | //      As part of the transition, we discard the previous curve sequence and
 1703 |     | //      initiate this above curve sequence in memory.
 1704 |     | //
 1705 |     | //    Now, the transition to '[qLower - qSpacing, qUpper - qSpacing]' is
 1706 |     | //    complete and throughout the remainder of this example, we refer to this
 1707 |     | //    interval as the active liquidity interval. Additionally, we redefine:
 1708 |     | //
 1709 |     | //      'qUpper := qUpper - qSpacing', 
 1710 |     | //      'qLower := qLower - qSpacing'
 1711 |     | //
 1712 |     | //    which allows us to continue using the notation '[qLower, qUpper]' in
 1713 |     | //    order to refer to the active liquidity interval.
 1714 |     | //
 1715 |     | //  - In this step, we need to determine whether we should explore the active
 1716 |     | //    interval '[qLower, qUpper]' or to cross it entirely, i.e., all the way
 1717 |     | //    from 'qBack' to 'qNext'. In the former case, we need to integrate the
 1718 |     | //    liquidity distribution function 'k(w(.))' piece by piece through which
 1719 |     | //    the 'incomingCurrentToTarget' and 'currentToTarget' are calculated. As we
 1720 |     | //    discussed before, the calculation of these integrals leads to
 1721 |     | //    'amount0Partial' and 'amount1Partial', respectively. However, the latter
 1722 |     | //    case is more efficient because if the active interval is crossed 
 1723 |     | //    entirely, then the precalculated integrals 'incomingMax' and
 1724 |     | //    'outgoingMax' can be used to determine 'amount0Partial' and
 1725 |     | //    'amount1Partial'. In order for the protocol to be able to cross the
 1726 |     | //    active interval entirely the following two criteria should be met:
 1727 |     | //
 1728 |     | //    (a) The cross must not violate 'qLimit'. In other words, for price
 1729 |     | //        increasing swaps we should have
 1730 |     | //
 1731 |     | //          'qNext <= qLimit'
 1732 |     | //
 1733 |     | //        and for price decreasing swaps, we should have
 1734 |     | //
 1735 |     | //          'qLimit <= qNext'.
 1736 |     | //
 1737 |     | //        which is the case in the present example.
 1738 |     | //
 1739 |     | //    (b) The cross must not violate 'amountSpecified'. In order words, if
 1740 |     | //        'exactInput == false', then the outgoing amount from the pool as a
 1741 |     | //        result of crossing all the way from 'qBack' to 'qNext' must not
 1742 |     | //        exceed the remaining absolute value '0 - amountSpecified'. Similarly,
 1743 |     | //        if 'exactInput == true', then the incoming amount to the pool as a
 1744 |     | //        result of crossing all the way from 'qBack' to 'qNext' must not
 1745 |     | //        exceed the remaining value 'amountSpecified'.
 1746 |     | //
 1747 |     | //        In order to verify this, we first need to recalculate 'integralLimit'
 1748 |     | //        based on the decremented value for '|amountSpecified|':
 1749 |     | //        
 1750 |     | //          'integralLimit :=
 1751 |     | //
 1752 |     | //                          |amountSpecified|          1          2 ** 111
 1753 |     | //           outgoingMax * ------------------- * ------------- * ----------
 1754 |     | //                          sqrtInverseOffset     sharesTotal      growth
 1755 |     | //
 1756 |     | //           == +oo'.
 1757 |     | //
 1758 |     | //        which remains equal to '+oo' for this example.
 1759 |     | //
 1760 |     | //        Next, we need to define the notion of 'integralLimitInterval' which
 1761 |     | //        is compared with 'integralLimit' in order to determine if
 1762 |     | //        'amountSpecified' is violated or not. Consider the following four
 1763 |     | //        scenarios:
 1764 |     | //
 1765 |     | //        - If the swap is price increasing and 'exactInput == false', define:
 1766 |     | //
 1767 |     | //                                         - 8     / qUpper
 1768 |     | //            integralLimitInterval      e        |    - h / 2
 1769 |     | //          '----------------------- := ------- * |  e         k(h - qLower) dh
 1770 |     | //                   2 ** 216              2      |
 1771 |     | //                                               / qLower
 1772 |     | //
 1773 |     | //                - qLower / 2    outgoingMax
 1774 |     | //           == e              * -------------'
 1775 |     | //                                 2 ** 216
 1776 |     | //
 1777 |     | //        - If the swap is price increasing and 'exactInput == true', define:
 1778 |     | //
 1779 |     | //                                         - 8     / qUpper
 1780 |     | //            integralLimitInterval      e        |    + h / 2
 1781 |     | //          '----------------------- := ------- * |  e         k(h - qLower) dh
 1782 |     | //                   2 ** 216              2      |
 1783 |     | //                                               / qLower
 1784 |     | //
 1785 |     | //                + qUpper / 2    incomingMax
 1786 |     | //           == e              * -------------'
 1787 |     | //                                 2 ** 216
 1788 |     | //
 1789 |     | //        - If the swap is price decreasing and 'exactInput == false', define:
 1790 |     | //
 1791 |     | //                                         - 8     / qUpper
 1792 |     | //            integralLimitInterval      e        |    + h / 2
 1793 |     | //          '----------------------- := ------- * |  e         k(qUpper - h) dh
 1794 |     | //                   2 ** 216              2      |
 1795 |     | //                                               / qLower
 1796 |     | //
 1797 |     | //                + qUpper / 2    outgoingMax
 1798 |     | //           == e              * -------------'
 1799 |     | //                                 2 ** 216
 1800 |     | //
 1801 |     | //        - If the swap is price decreasing and 'exactInput == true', define:
 1802 |     | //
 1803 |     | //                                         - 8     / qUpper
 1804 |     | //            integralLimitInterval      e        |    - h / 2
 1805 |     | //          '----------------------- := ------- * |  e         k(qUpper - h) dh
 1806 |     | //                   2 ** 216              2      |
 1807 |     | //                                               / qLower
 1808 |     | //
 1809 |     | //                - qLower / 2    incomingMax
 1810 |     | //           == e              * -------------'
 1811 |     | //                                 2 ** 216
 1812 |     | // 
 1813 |     | //        In the first and the fourth cases above, 'amountSpecified' is in
 1814 |     | //        'tag0'. By crossing the active interval entirely, the absolute value
 1815 |     | //        '|amountSpecified|' is decremented by:
 1816 |     | //
 1817 |     | //                                               growth
 1818 |     | //          'sqrtInverseOffset * sharesTotal * ---------- * 
 1819 |     | //                                              2 ** 111
 1820 |     | //            integralLimitInterval
 1821 |     | //           -----------------------',
 1822 |     | //                 outgoingMax
 1823 |     | // 
 1824 |     | //        In the second and the third cases above, 'amountSpecified' is in
 1825 |     | //        'tag1'. By crossing the active interval entirely, the absolute value
 1826 |     | //        '|amountSpecified|' is decremented by:
 1827 |     | //
 1828 |     | //                                        growth      integralLimitInterval
 1829 |     | //          'sqrtOffset * sharesTotal * ---------- * -----------------------',
 1830 |     | //                                       2 ** 111          outgoingMax
 1831 |     | //
 1832 |     | //        Hence, in both cases, by crossing the active interval, the limit
 1833 |     | //        imposed by 'amountSpecified' is not violated if and only if:
 1834 |     | //        
 1835 |     | //          'integralLimitInterval <= integralLimit'.
 1836 |     | //
 1837 |     | //    In the present example, since 'integralLimit == +oo' and
 1838 |     | //    'qLimit <= qNext' both (a) and (b) are satisfied which means that we can
 1839 |     | //    cross the active interval and move the price to 'qNext' directly, while
 1840 |     | //    determining the outgoing and incoming amounts based on the precalculated
 1841 |     | //    parameters of the pool.
 1842 |     | //
 1843 |     | //    Once again, before the execution of this cross, we need to verify the
 1844 |     | //    condition, 'sharesTotal >= crossThreshold'. If not met, the swap call is
 1845 |     | //    halted and the current values accumulated as 'amount0' and 'amount1' are
 1846 |     | //    exchanged.
 1847 |     | //
 1848 |     | //  - In order to move the price from 'qBack' to 'qNext', we need to update a
 1849 |     | //    number of parameters, including:
 1850 |     | //
 1851 |     | //    - 'amount0': According to the above formulas, as we move the price all
 1852 |     | //      the way from 'qBack' to 'qNext', 'amount0' should be incremented by:
 1853 |     | //
 1854 |     | //                                                               growth
 1855 |     | //        'amount0Partial == sqrtInverseOffset * sharesTotal * ---------- *
 1856 |     | //                                                              2 ** 111
 1857 |     | //          incomingMax      - qLower / 2
 1858 |     | //         ------------- * e              '.
 1859 |     | //          outgoingMax
 1860 |     | //
 1861 |     | //    - 'amount1': According to the above formulas, as we move the price all
 1862 |     | //      the way from 'qBack' to 'qNext', 'amount1' should be decremented by:
 1863 |     | //
 1864 |     | //                                                        growth
 1865 |     | //        'amount1Partial == sqrtOffset * sharesTotal * ---------- * 
 1866 |     | //                                                       2 ** 111
 1867 |     | //                             + qUpper / 2
 1868 |     | //                           e              '.
 1869 |     | //
 1870 |     | //    - 'amountSpecified': Since the swap is partially fulfilled, we should
 1871 |     | //      decrement 'amountSpecified' by 'amount0Partial' to reflect this:
 1872 |     | //
 1873 |     | //        'amountSpecified -= amount0Partial'.
 1874 |     | //
 1875 |     | //    - 'curve': Following the pattern that was introduced earlier, for
 1876 |     | //      inactive liquidity intervals, the amended curve sequence for
 1877 |     | //      '[qLower, qUpper]' should be:
 1878 |     | //
 1879 |     | //        'q[0] := qUpper',
 1880 |     | //        'q[1] := qLower'.
 1881 |     | //
 1882 |     | //      This amendment, transforms the function 'w' associated with
 1883 |     | //      '[qLower, qUpper]' from the following:
 1884 |     | //
 1885 |     | //            w(q)
 1886 |     | //              ^
 1887 |     | //      spacing |\
 1888 |     | //              | \
 1889 |     | //              |  \
 1890 |     | //              |   \
 1891 |     | //              |    \
 1892 |     | //              |     \
 1893 |     | //              |      \
 1894 |     | //              |       \
 1895 |     | //              |        \
 1896 |     | //              |         \
 1897 |     | //              |          \
 1898 |     | //              |           \
 1899 |     | //              |            \
 1900 |     | //              |             \
 1901 |     | //              |              \
 1902 |     | //              |               \
 1903 |     | //              |                \
 1904 |     | //            0 +-----------------+-> q
 1905 |     | //           qLower               |
 1906 |     | //                              qUpper
 1907 |     | //                                |
 1908 |     | //                            qCurrent
 1909 |     | //
 1910 |     | //      to a new function:
 1911 |     | //
 1912 |     | //        'wAmended(q) := q - qLower'
 1913 |     | //
 1914 |     | //      which can be plotted as follows:
 1915 |     | //
 1916 |     | //          wAmended(q)
 1917 |     | //              ^
 1918 |     | //      spacing |                /
 1919 |     | //              |               /
 1920 |     | //              |              /
 1921 |     | //              |             /
 1922 |     | //              |            /
 1923 |     | //              |           /
 1924 |     | //              |          /
 1925 |     | //              |         /
 1926 |     | //              |        /
 1927 |     | //              |       /
 1928 |     | //              |      /
 1929 |     | //              |     /
 1930 |     | //              |    /
 1931 |     | //              |   /
 1932 |     | //              |  /
 1933 |     | //              | /
 1934 |     | //              |/
 1935 |     | //            0 +-----------------+-> q
 1936 |     | //           qLower               |
 1937 |     | //                              qUpper
 1938 |     | //
 1939 |     | //      As we will demonstrate next, this procedure results in growth for
 1940 |     | //      liquidity providers.
 1941 |     | //
 1942 |     | //    - 'growth': As discussed earlier, since the liquidity distribution
 1943 |     | //      function 'k(w(.))' is modified to 'k(wAmended(.))', we need to make an
 1944 |     | //      adjustment to the 'growth' value and turn it into 'growthAmended'.
 1945 |     | //      In order to determine 'growthAmended', the following equation is
 1946 |     | //      solved:
 1947 |     | //
 1948 |     | //        'totalReserveOfTag0Before == totalReserveOfTag0After'
 1949 |     | //
 1950 |     | //      where 'totalReserveOfTag0Before' is the total amount of 'tag0' within
 1951 |     | //      '[qLower, qUpper]' which is calculated based on 'k(w(.))', whereas
 1952 |     | //      'totalReserveOfTag0After' is the same value calculated based on
 1953 |     | //      'k(wAmended(.))'. The two sides of the equation can be derived as:
 1954 |     | //
 1955 |     | //        'totalReserveOfTag0Before == sqrtInverseOffset * sharesTotal * 
 1956 |     | //
 1957 |     | //                                         - 8     / qUpper
 1958 |     | //           growth       2 ** 216       e        |    - h / 2
 1959 |     | //         ---------- * ------------- * ------- * |  e         k(w(h)) dh ==
 1960 |     | //          2 ** 111     outgoingMax       2      |
 1961 |     | //                                               / qLower
 1962 |     | //
 1963 |     | //                                             growth       2 ** 216
 1964 |     | //         sqrtInverseOffset * sharesTotal * ---------- * ------------- *
 1965 |     | //                                            2 ** 111     outgoingMax
 1966 |     | //
 1967 |     | //            - 8     / qUpper
 1968 |     | //          e        |    - h / 2
 1969 |     | //         ------- * |  e         k(qUpper - h) dh ==
 1970 |     | //            2      |
 1971 |     | //                  / qLower
 1972 |     | //
 1973 |     | //                                             growth
 1974 |     | //         sqrtInverseOffset * sharesTotal * ---------- * 
 1975 |     | //                                            2 ** 111
 1976 |     | //
 1977 |     | //          incomingMax      - qLower / 2
 1978 |     | //         ------------- * e              '.
 1979 |     | //          outgoingMax
 1980 |     | //
 1981 |     | //      and
 1982 |     | //
 1983 |     | //        'totalReserveOfTag0After ==
 1984 |     | //
 1985 |     | //                                            growthAmended
 1986 |     | //         sqrtInverseOffset * sharesTotal * --------------- * 
 1987 |     | //                                              2 ** 111
 1988 |     | //
 1989 |     | //                            - 8     / qUpper
 1990 |     | //            2 ** 216      e        |    - h / 2
 1991 |     | //         ------------- * ------- * |  e         k(h - qLower) dh' == 
 1992 |     | //          outgoingMax       2      |
 1993 |     | //                                  / qLower
 1994 |     | //
 1995 |     | //                                            growthAmended
 1996 |     | //         sqrtInverseOffset * sharesTotal * --------------- *
 1997 |     | //                                              2 ** 111
 1998 |     | //
 1999 |     | //           - qLower / 2
 2000 |     | //         e              '.
 2001 |     | //
 2002 |     | //
 2003 |     | //      Hence, 'growthAmended' is given by the following formula:
 2004 |     | //
 2005 |     | //                                    incomingMax
 2006 |     | //        'growthAmended == growth * -------------'.
 2007 |     | //                                    outgoingMax
 2008 |     | //
 2009 |     | //      As proven earlier, 'incomingMax' is always greater than or equal to
 2010 |     | //      'outgoingMax'. Hence, crossing the active interval results in growth.
 2011 |     | //
 2012 |     | //    - 'qCurrent': Lastly, as we move the price of the pool to 'qNext', the
 2013 |     | //      value for 'qCurrent' should be updated to reflect this change., which
 2014 |     | //      is illustrated as follows:
 2015 |     | //
 2016 |     | //                qLimit                qCurrent
 2017 |     | //                   |                     |
 2018 |     | //      ... <--+-------------+-------------+-------------+-------------+--> ...
 2019 |     | //                                         |             |
 2020 |     | //                                       qNext         qBack
 2021 |     | //
 2022 |     | //  - Similar to the prior steps, as we reach 'qNext', we transition from the
 2023 |     | //    original liquidity interval '[qLower, qUpper]' to its adjacent interval
 2024 |     | //    '[qLower - qSpacing, qUpper - qSpacing]'. This transition involves the
 2025 |     | //    adjustment of growth multipliers. In addition we need to update 'growth'
 2026 |     | //    'sharesTotal', 'qBack', 'qNext', as well as the curve sequence. The new
 2027 |     | //    status of the pool following this transition is illustrated as follows:
 2028 |     | //
 2029 |     | //                qLimit                qCurrent
 2030 |     | //                   |                     |
 2031 |     | //      ... <--+-------------+-------------+-------------+-------------+--> ...
 2032 |     | //                           |             |
 2033 |     | //                         qNext         qBack
 2034 |     | //
 2035 |     | //  - Similar to the prior steps, as we transition to a new liquidity interval,
 2036 |     | //    we determine whether we should cross this new active interval entirely or
 2037 |     | //    not. In the present example, since 'qLimit <= qNext' and 
 2038 |     | //    'amountSpecified == +oo', we need to cross one more time. This action
 2039 |     | //    will modify 'amount0', 'amount1', 'growth', as well as the curve
 2040 |     | //    sequence. Additionally, crossing the active interval moves 'qCurrent' to
 2041 |     | //    'qNext' which is illustrated below:
 2042 |     | //
 2043 |     | //                        qCurrent
 2044 |     | //                qLimit     |
 2045 |     | //                   |       |
 2046 |     | //      ... <--+-------------+-------------+-------------+-------------+--> ...
 2047 |     | //                           |             |
 2048 |     | //                         qNext         qBack
 2049 |     | //
 2050 |     | //  - Next, we need to perform another transition in order to enter the
 2051 |     | //    liquidity interval that contains 'qLimit'. The new status of the pool
 2052 |     | //    following this transition is illustrated as follows:
 2053 |     | //
 2054 |     | //                        qCurrent
 2055 |     | //                qLimit     |
 2056 |     | //                   |       |
 2057 |     | //      ... <--+-------------+-------------+-------------+-------------+--> ...
 2058 |     | //             |             |
 2059 |     | //           qNext         qBack
 2060 |     | //  
 2061 |     | //  - Once again, as we transition to a new liquidity interval, we determine
 2062 |     | //    whether we should cross this new active interval entirely or not. This,
 2063 |     | //    time, since 'qNext < qLimit', we should transact within the active
 2064 |     | //    interval as opposed to crossing it. To this end, we move the price
 2065 |     | //    towards 'qNext' until either of the following conditions are met:
 2066 |     | //
 2067 |     | //    (a) 'amountSpecified' is fulfilled.
 2068 |     | //
 2069 |     | //    (b) 'qLimit' is reached.
 2070 |     | //
 2071 |     | //    We move the price from 'qCurrent' towards 'qNext' by enumerating pieces
 2072 |     | //    of the present liquidity distribution function 'k(w(.))'. To this end,
 2073 |     | //    the memory pointers '_begin_' and '_target_' are used in order to keep
 2074 |     | //    track of the two endpoints for the current piece under exploration. Here,
 2075 |     | //    we refer to these endpoints as 'qBegin' and 'qTarget'.
 2076 |     | //
 2077 |     | //    We start with 'qBegin == qCurrent' and move forward by continuously
 2078 |     | //    updating 'qBegin' and 'qTarget'. In each step, the integrals
 2079 |     | //    'currentToTarget' and 'incomingCurrentToTarget' are incremented to
 2080 |     | //    account for the outgoing amount from the pool and the incoming amount to
 2081 |     | //    the pool.
 2082 |     | //
 2083 |     | //    While incrementing the two integrals, we need to continuously monitor
 2084 |     | //    condition (a). To that end, we once again calculate 'integralLimit'
 2085 |     | //
 2086 |     | //      'integralLimit := outgoingMax * 
 2087 |     | //
 2088 |     | //        |amountSpecified|          1          2 ** 111
 2089 |     | //       ------------------- * ------------- * ---------- == +oo'.
 2090 |     | //        sqrtInverseOffset     sharesTotal      growth
 2091 |     | //
 2092 |     | //    With each increment of 'incomingCurrentToTarget' we check whether it has
 2093 |     | //    exceeded 'integralLimit' in which case the swap is halted (alternatively,
 2094 |     | //    in the case where 'exactInput == false', we need to continuously check
 2095 |     | //    whether 'currentToTarget' has exceeded 'integralLimit' or not). However,
 2096 |     | //    this stopping criteria does not apply to this example because
 2097 |     | //    'integralLimit == +oo'.
 2098 |     | //
 2099 |     | //    Hence, we can move forward until the stopping criteria (b) is met, i.e.,
 2100 |     | //    until
 2101 |     | //
 2102 |     | //      'qTarget == qLimit'.
 2103 |     | //
 2104 |     | //    Once the above condition is met, we need to update a number of
 2105 |     | //    parameters, including:
 2106 |     | //
 2107 |     | //    - 'amount0': As discussed in the prior steps, the following increment
 2108 |     | //      should be applied to 'amount0':
 2109 |     | //                                                               growth
 2110 |     | //        'amount0Partial := sqrtInverseOffset * sharesTotal * ---------- *
 2111 |     | //                                                              2 ** 111
 2112 |     | //                            incomingCurrentToTarget
 2113 |     | //                           -------------------------'
 2114 |     | //                                  outgoingMax
 2115 |     | //
 2116 |     | //    - 'amount1': As discussed in the prior steps, the following decrement
 2117 |     | //      should be applied to 'amount1':
 2118 |     | //                                                        growth
 2119 |     | //        'amount1Partial := sqrtOffset * sharesTotal * ---------- *
 2120 |     | //                                                       2 ** 111
 2121 |     | //                            currentToTarget
 2122 |     | //                           -----------------'
 2123 |     | //                              outgoingMax
 2124 |     | //
 2125 |     | //    - 'amountSpecified': Since the swap is partially fulfilled, we should
 2126 |     | //      decrement 'amountSpecified' by 'amount0Partial' to reflect this:
 2127 |     | //
 2128 |     | //        'amountSpecified -= amount0Partial'.
 2129 |     | //
 2130 |     | //    - 'qCurrent': Since we moved the price of the pool to 'qLimit', the value
 2131 |     | //      for 'qCurrent' in memory (i.e., the content of the memory space which
 2132 |     | //      is pointed to by '_logPriceCurrent_') should be updated to
 2133 |     | //
 2134 |     | //        'qCurrent := qTarget'.
 2135 |     | //
 2136 |     | //      This is illustrated as follows:
 2137 |     | //
 2138 |     | //                qTarget
 2139 |     | //                   |
 2140 |     | //                qLimit
 2141 |     | //                   |
 2142 |     | //      ... <--+-------------+-------------+-------------+-------------+--> ...
 2143 |     | //             |     |       |
 2144 |     | //           qNext   |     qBack
 2145 |     | //                   |
 2146 |     | //               qCurrent
 2147 |     | //
 2148 |     | //    - 'curve' and 'growth': Now that the target price is determined as well
 2149 |     | //      as the outgoing and incoming amounts, we need to update the AMM curve 
 2150 |     | //      in preparation for the next swap. To this end, the curve sequence
 2151 |     | //      should be amended. In doing so, we need to respect certain
 2152 |     | //      requirements:
 2153 |     | //
 2154 |     | //      Firstly, remember that the last member of the curve sequence should
 2155 |     | //      always correspond to the current price of the pool, i.e., 'qCurrent'.
 2156 |     | //      Now that we have set 'qCurrent' to 'qTarget' the curve sequence should
 2157 |     | //      be amended with this new value in preparation for the next swap.
 2158 |     | //
 2159 |     | //      Secondly, we should be mindful of the fact that amending the curve
 2160 |     | //      sequence changes the liquidity distribution function from 'k(w(.))' to
 2161 |     | //      'k(wAmended(.))' and we need to make sure that this change does not
 2162 |     | //      affect our accounting of the total interval reserves with respect to
 2163 |     | //      both tags. More precisely, the curve sequence must be amended subject
 2164 |     | //      to the following constraints:
 2165 |     | //
 2166 |     | //        'totalReserveOfTag0Before == totalReserveOfTag0After'
 2167 |     | //
 2168 |     | //        'totalReserveOfTag1Before == totalReserveOfTag1After'
 2169 |     | //
 2170 |     | //      where 'totalReserveOfTag0Before' and 'totalReserveOfTag1Before',
 2171 |     | //      respectively, are the total reserves of 'tag0' and 'tag1' within
 2172 |     | //      '[qLower, qUpper]' that are calculated based on 'k(w(.))', whereas
 2173 |     | //      'totalReserveOfTag0After' and 'totalReserveOfTag1After' are the same
 2174 |     | //      amounts that are calculated based on 'k(wAmended(.))'.
 2175 |     | //
 2176 |     | //      The two sides of the first equation can be derived as:
 2177 |     | //
 2178 |     | //        'totalReserveOfTag0Before := sqrtInverseOffset * sharesTotal * 
 2179 |     | //
 2180 |     | //                                         - 8     / qUpper
 2181 |     | //           growth       2 ** 216       e        |    - h / 2
 2182 |     | //         ---------- * ------------- * ------- * |  e         k(w(h)) dh',
 2183 |     | //          2 ** 111     outgoingMax       2      |
 2184 |     | //                                               / qTarget
 2185 |     | //      and
 2186 |     | //
 2187 |     | //        'totalReserveOfTag0After := 
 2188 |     | //
 2189 |     | //                                            growthAmended
 2190 |     | //         sqrtInverseOffset * sharesTotal * --------------- *
 2191 |     | //                                               2 ** 111
 2192 |     | //
 2193 |     | //                            - 8     / qUpper
 2194 |     | //           2 ** 216       e        |    - h / 2
 2195 |     | //         ------------- * ------- * |  e         k(wAmended(h)) dh',
 2196 |     | //          outgoingMax       2      |
 2197 |     | //                                  / qTarget
 2198 |     | //
 2199 |     | //      which simplify the first equation to:
 2200 |     | //
 2201 |     | //                               / qUpper
 2202 |     | //                              |    - h / 2
 2203 |     | //                              |  e         k(wAmended(h)) dh
 2204 |     | //                              |
 2205 |     | //              growth         / qTarget
 2206 |     | //        '--------------- == ---------------------------------'.
 2207 |     | //          growthAmended           / qUpper
 2208 |     | //                                 |    - h / 2
 2209 |     | //                                 |  e         k(w(h)) dh
 2210 |     | //                                 |
 2211 |     | //                                / qTarget
 2212 |     | //
 2213 |     | //      The two sides of the second equation can be derived as:
 2214 |     | //
 2215 |     | //        'totalReserveOfTag1Before := sqrtOffset * sharesTotal * 
 2216 |     | //
 2217 |     | //                                         - 8     / qTarget
 2218 |     | //           growth       2 ** 216       e        |    + h / 2
 2219 |     | //         ---------- * ------------- * ------- * |  e         k(w(h)) dh',
 2220 |     | //          2 ** 111     outgoingMax       2      |
 2221 |     | //                                               / qLower
 2222 |     | //      and
 2223 |     | //
 2224 |     | //        'totalReserveOfTag1After := 
 2225 |     | //
 2226 |     | //                                     growthAmended      2 ** 216
 2227 |     | //         sqrtOffset * sharesTotal * --------------- * ------------- *
 2228 |     | //                                        2 ** 111       outgoingMax
 2229 |     | //
 2230 |     | //            - 8     / qTarget
 2231 |     | //          e        |    + h / 2
 2232 |     | //         ------- * |  e         k(wAmended(h)) dh',
 2233 |     | //            2      |
 2234 |     | //                  / qLower
 2235 |     | //
 2236 |     | //      which simplifies the second equation to:
 2237 |     | //
 2238 |     | //                               / qTarget
 2239 |     | //                              |    + h / 2
 2240 |     | //                              |  e         k(wAmended(h)) dh
 2241 |     | //                              |
 2242 |     | //            growth           / qLower
 2243 |     | //        '--------------- == ---------------------------------'.
 2244 |     | //          growthAmended           / qTarget
 2245 |     | //                                 |    + h / 2
 2246 |     | //                                 |  e         k(w(h)) dh
 2247 |     | //                                 |
 2248 |     | //                                / qLower
 2249 |     | //
 2250 |     | //      Based on the above equations, finding 'growthAmended' with respect to
 2251 |     | //      'k(w(.))' and 'k(wAmended(.))' is straightforward.
 2252 |     | //
 2253 |     | //      However, in order to satisfy both of the equations, we should have:
 2254 |     | //
 2255 |     | //            / qTarget                         / qUpper
 2256 |     | //           |   + h/2                         |   - h/2
 2257 |     | //           |  e      k(wAmended(h)) dh       |  e      k(wAmended(h)) dh
 2258 |     | //           |                                 |
 2259 |     | //          / qLower                          / qTarget
 2260 |     | //        '------------------------------ == ------------------------------'.
 2261 |     | //               / qTarget                         / qUpper
 2262 |     | //              |    + h/2                        |    - h/2
 2263 |     | //              |  e       k(w(h)) dh             |  e       k(w(h)) dh
 2264 |     | //              |                                 |
 2265 |     | //             / qLower                          / qTarget
 2266 |     | //
 2267 |     | //      Because of the above constraint, we need to take an additional step
 2268 |     | //      prior to amending the curve sequence with 'qTarget'.
 2269 |     | //
 2270 |     | //      Observe that the current curve sequence is last updated when we
 2271 |     | //      transitioned into '[qLower, qUpper]' and it is composed of the
 2272 |     | //      following two points:
 2273 |     | //
 2274 |     | //        'q[0] := qLower',
 2275 |     | //        'q[1] := qUpper'.
 2276 |     | //
 2277 |     | //      The corresponding diagram for the current curve sequence is illustrated
 2278 |     | //      as follows:
 2279 |     | //
 2280 |     | //            w(q)
 2281 |     | //              ^
 2282 |     | //      spacing |                /
 2283 |     | //              |               /
 2284 |     | //              |              /
 2285 |     | //              |             /
 2286 |     | //              |            /
 2287 |     | //              |           /
 2288 |     | //              |          /
 2289 |     | //              |\
 2290 |     | //              | \
 2291 |     | //              |  \
 2292 |     | //              |   \
 2293 |     | //              |        /
 2294 |     | //              |       /
 2295 |     | //              |      /
 2296 |     | //              |     /
 2297 |     | //            0 +----+----+-------+-> q
 2298 |     | //           qLower  |    |       |
 2299 |     | //                   |   q[2]  qUpper
 2300 |     | //                   |
 2301 |     | //               qCurrent
 2302 |     | //
 2303 |     | //            w(q)
 2304 |     | //              ^
 2305 |     | //      spacing |\
 2306 |     | //              | \
 2307 |     | //              |  \
 2308 |     | //              |   \
 2309 |     | //              |    \
 2310 |     | //              |     \
 2311 |     | //              |      \
 2312 |     | //              |       \
 2313 |     | //              |        \
 2314 |     | //              |         \
 2315 |     | //              |          \
 2316 |     | //              |           \
 2317 |     | //              |            \
 2318 |     | //              |             \
 2319 |     | //              |              \
 2320 |     | //            0 +-------+------+-> q
 2321 |     | //           qLower     |      |
 2322 |     | //                      |    qUpper
 2323 |     | //                      |
 2324 |     | //                   qTarget
 2325 |     | //
 2326 |     | //      Before amending the curve sequence with 'qTarget', we first determine a
 2327 |     | //      point between 'qTarget' and 'qNext == qLower' which is regarded as
 2328 |     | //      'qOvershoot':
 2329 |     | //
 2330 |     | //            w(q)
 2331 |     | //              ^
 2332 |     | //      spacing |\
 2333 |     | //              | \
 2334 |     | //              |  \
 2335 |     | //              |   \
 2336 |     | //              |    \
 2337 |     | //              |     \
 2338 |     | //              |      \
 2339 |     | //              |       \
 2340 |     | //              |        \
 2341 |     | //              |         \
 2342 |     | //              |          \
 2343 |     | //              |           \
 2344 |     | //              |            \
 2345 |     | //              |             \
 2346 |     | //              |              \
 2347 |     | //              |               \
 2348 |     | //              |                \
 2349 |     | //            0 +----+----+-------+-> q
 2350 |     | //           qLower  |    |       |
 2351 |     | //                   |    |     qUpper
 2352 |     | //                   |    |
 2353 |     | //                   | qTarget
 2354 |     | //                   |
 2355 |     | //               qOvershoot
 2356 |     | //
 2357 |     | //      Then, the curve sequence is amended with 'qOvershoot' which leads to
 2358 |     | //      the following sequence:
 2359 |     | //
 2360 |     | //        'q[0] := qUpper',
 2361 |     | //        'q[1] := qLower',
 2362 |     | //        'q[2] := qOvershoot'.
 2363 |     | //
 2364 |     | //      and the following diagram:
 2365 |     | //
 2366 |     | //              ^
 2367 |     | //      spacing |\
 2368 |     | //              | \
 2369 |     | //              |  \
 2370 |     | //              |                /
 2371 |     | //              |               /
 2372 |     | //              |              /
 2373 |     | //              |             /
 2374 |     | //              |            /
 2375 |     | //              |           /
 2376 |     | //              |          /
 2377 |     | //              |         /
 2378 |     | //              |        /
 2379 |     | //              |       /
 2380 |     | //              |      /
 2381 |     | //              |     /
 2382 |     | //            0 +----+----+-------+-> q
 2383 |     | //           qLower  |    |       |
 2384 |     | //                   |    |     qUpper
 2385 |     | //                   |    |
 2386 |     | //                   |  qTarget
 2387 |     | //                   |
 2388 |     | //               qOvershoot
 2389 |     | //
 2390 |     | //      In this case, amending the curve sequence has increased its length.
 2391 |     | //      However, this is not always the case. As explained in 'Curve.sol', this
 2392 |     | //      process may involve clearing a number of members from the end of the
 2393 |     | //      curve sequence and then inserting the new member.
 2394 |     | //
 2395 |     | //      After the amendment with 'qOvershoot', the resulting curve sequence is
 2396 |     | //      then amended with 'qTarget' which leads to the following sequence:
 2397 |     | //
 2398 |     | //        'q[0] := qUpper',
 2399 |     | //        'q[1] := qLower',
 2400 |     | //        'q[2] := qOvershoot',
 2401 |     | //        'q[3] := qTarget'.
 2402 |     | //
 2403 |     | //      and the following diagram:
 2404 |     | //
 2405 |     | //          wAmended(q)
 2406 |     | //              ^
 2407 |     | //      spacing |\
 2408 |     | //              | \
 2409 |     | //              |  \
 2410 |     | //              |   \
 2411 |     | //              |                /
 2412 |     | //              |               /
 2413 |     | //              |              /
 2414 |     | //              |             /
 2415 |     | //              |            /
 2416 |     | //              |           /
 2417 |     | //              |          /
 2418 |     | //              |     \
 2419 |     | //              |      \
 2420 |     | //              |       \
 2421 |     | //              |        \
 2422 |     | //            0 +----+----+-------+-> q
 2423 |     | //           qLower  |    |       |
 2424 |     | //                   |    |     qUpper
 2425 |     | //                   |    |
 2426 |     | //                   | qTarget
 2427 |     | //                   |
 2428 |     | //               qOvershoot
 2429 |     | //
 2430 |     | //      The purpose of first amending with 'qOvershoot' is to have an
 2431 |     | //      additional degree of freedom in order to satisfy the equation:
 2432 |     | //
 2433 |     | //        'f(qOvershoot) == 0'
 2434 |     | //
 2435 |     | //      where
 2436 |     | //
 2437 |     | //        'f(qOvershoot) :=
 2438 |     | //
 2439 |     | //            / qUpper                         / qTarget
 2440 |     | //           |   - h/2                        |   + h/2
 2441 |     | //           |  e      k(wAmended(h)) dh      |  e      k(wAmended(h)) dh
 2442 |     | //           |                                |
 2443 |     | //          / qTarget                        / qLower
 2444 |     | //         ------------------------------ - ------------------------------'.
 2445 |     | //               / qUpper                         / qTarget
 2446 |     | //              |    - h/2                       |    + h/2
 2447 |     | //              |  e       k(w(h)) dh            |  e       k(w(h)) dh
 2448 |     | //              |                                |
 2449 |     | //             / qTarget                        / qLower
 2450 |     | //
 2451 |     | //      By investigating the above equation, we can observe that:
 2452 |     | //
 2453 |     | //        - Both of the denominators are fixed. This is because at this stage,
 2454 |     | //          'qTarget' is fully determined either through 'qLimit' or
 2455 |     | //          'amountSpecified'. Additionally, the current curve sequence is
 2456 |     | //          fixed which dictates the shape of 'w(.)'.
 2457 |     | //
 2458 |     | //        - Both of the numerators are functions of 'qOvershoot'. This is
 2459 |     | //          because 'wAmended(.)' can be fully characterized by
 2460 |     | //
 2461 |     | //            - the current curve sequence which is fixed,
 2462 |     | //
 2463 |     | //            - 'qTarget' which is also fixed,
 2464 |     | //
 2465 |     | //            - and 'qOvershoot' which is the only unknown value that we are
 2466 |     | //              trying to determine.
 2467 |     | //
 2468 |     | //      Hence, in order to update the liquidity distribution function from
 2469 |     | //      'k(w(.))' to 'k(wAmended(.))', which updates the AMM diagram of the
 2470 |     | //      active interval, we need to solve the above equation with respect to
 2471 |     | //      'qOvershoot'. As proven in nofeeswap's yellowpaper, there always exist
 2472 |     | //      a root between 'qTarget' and 'qNext' that satisfies:
 2473 |     | //
 2474 |     | //        'growthAmended >= growth'.
 2475 |     | //
 2476 |     | //      This root is found via numerical search by running the methods
 2477 |     | //      'moveOvershoot' and 'searchOvershoot' from 'Interval.sol'.
 2478 |     | //
 2479 |     | //      Remember that 'k(w(.))' and 'k(wAmended(.))' are piecewise linear
 2480 |     | //      functions whose domains cover the entire active interval. The method
 2481 |     | //      'moveOvershoot' from 'Interval.sol' identifies a range within
 2482 |     | //      '[qLower, qUpper]':
 2483 |     | //
 2484 |     | //        - in which 'k(w(.))' is linear,
 2485 |     | //
 2486 |     | //        - in which 'k(wAmended(.))' is linear, and
 2487 |     | //
 2488 |     | //        - to which 'qOvershoot' belongs.
 2489 |     | //
 2490 |     | //      Since 'f(.)' is a continuous function, the membership of a root (i.e.,
 2491 |     | //      'qOvershoot') to a particular range can be verified by evaluating the
 2492 |     | //      sign of 'f(.)' at the two ends of the range. Hence, in light of the
 2493 |     | //      intermediate value theorem, if the signs at the two ends of the range
 2494 |     | //      are different, then there has to be a root somewhere within this
 2495 |     | //      range.
 2496 |     | //
 2497 |     | //      Next, the method 'searchOvershoot' from 'Interval.sol' performs a
 2498 |     | //      Newton search in order to pinpoint the precise value of 'qOvershoot'
 2499 |     | //      within the range that is identified by 'moveOvershoot'.
 2500 |     | //
 2501 |     | //      Once 'qOvershoot' is calculated, we proceed with the two amendments to
 2502 |     | //      the curve sequence via 'qOvershoot' and 'qTarget'.
 2503 |     | //
 2504 |     | //      After that, we derive 'growthAmended' based on the following formula:
 2505 |     | //
 2506 |     | //                                          / qTarget
 2507 |     | //                                         |    + h / 2
 2508 |     | //                                         |  e         k(w(h)) dh
 2509 |     | //                                         |
 2510 |     | //                                        / qLower
 2511 |     | //        'growthAmended == growth * ---------------------------------'.
 2512 |     | //                                      / qTarget
 2513 |     | //                                     |    + h / 2
 2514 |     | //                                     |  e         k(wAmended(h)) dh
 2515 |     | //                                     |
 2516 |     | //                                    / qLower
 2517 |     | //
 2518 |     | //      This concludes the update of our liquidity distribution function (or
 2519 |     | //      equivalently, the update of our AMM diagram) for the next swap.
 2520 |     | //
 2521 |     | //  - The last step involves writing the dynamic parameters of the pool as well
 2522 |     | //    as the amended curve sequence in the protocol's storage which concludes
 2523 |     | //    this example.
 2524 |     | 
 2525 |     | // Swap Inputs
 2526 |     | // ----------------------------------------------------------------------------
 2527 |     | // The following memory pointers correspond to the inputs of the method 'swap'
 2528 |     | // from 'Nofeeswap.sol'. Each parameter is read from calldata via the method
 2529 |     | // 'readSwapInput' from 'Calldata.sol'. Then, the parameters are transformed to
 2530 |     | // appropriate formats and stored in their dedicated memory locations as listed
 2531 |     | // below. Throughout the execution of the swap, the following memory pointers
 2532 |     | // as well as the corresponding getter functions can be used to access each
 2533 |     | // parameter. Moreover, when invoking an applicable hook these input parameters
 2534 |     | // are passed to the hook as calldata and they can be accessed via the
 2535 |     | // corresponding calldata pointers and getter functions that are listed in
 2536 |     | // 'HookCalldata.sol'.
 2537 |     | uint16 constant _swapInput_ = 248;
 2538 |     | 
 2539 |     | // 'crossThreshold' refers to a minimum limit on the total number of shares
 2540 |     | // that should be available in any interval for the 'swap' method to transact
 2541 |     | // in that interval.
 2542 |     | //
 2543 |     | // For example, if 'crossThreshold == 50', then there has to be a minimum of
 2544 |     | // 50 shares present in an interval so that the algorithm either enters that
 2545 |     | // interval or crosses it entirely. Once we encounter an interval with the
 2546 |     | // total number of shares less than 50, the 'swap' call is halted and the price
 2547 |     | // of the pool does not go beyond that point.
 2548 |     | //
 2549 |     | // However, if 'crossThreshold == 0', which is the default, no minimum number
 2550 |     | // of shares is imposed.
 2551 |     | //
 2552 |     | // The calldata layout of the method 'swap' in 'Nofeeswap.sol' does not have a
 2553 |     | // slot dedicated to 'crossThreshold'. Instead, the two inputs 'crossThreshold'
 2554 |     | // and 'zeroForOne' share the same slot in calldata as illustrated below:
 2555 |     | //
 2556 |     | //     +---------------------------+---------------------------+
 2557 |     | //     | crossThreshold (128 bits) |   zeroForOne (128 bits)   |
 2558 |     | //     +---------------------------+---------------------------+
 2559 |     | //
 2560 |     | // 'crossThreshold' occupies the most significant 128 bits and 'zeroForOne'
 2561 |     | // occupies the least significant 128 bits. Hence, 16 bytes are reserved for
 2562 |     | // 'crossThreshold' in memory.
 2563 |     | uint16 constant _crossThreshold_ = 248;
 2564 |     | 
 2565 |     | // The input 'amountSpecified' of the 'swap' method in 'Nofeeswap.sol' is a
 2566 |     | // signed integer. If positive ('exactInput == true'), this value represents
 2567 |     | // the requested incoming amount to be given to the pool as a result of the
 2568 |     | // swap call. If negative ('exactInput == false'), this value represents the
 2569 |     | // requested outgoing amount to be taken from the pool as a result of the swap
 2570 |     | // call. As an initial step of the swap algorithm, the method 'readSwapInput'
 2571 |     | // from 'Calldata.sol' performs the following actions:
 2572 |     | //
 2573 |     | //  - Reads the integer representation of 'amountSpecified' from the dedicated
 2574 |     | //    calldata slot.
 2575 |     | //
 2576 |     | //  - Caps it by '2 ** 127 - 1' from above and by '1 - 2 ** 127' from below.
 2577 |     | //
 2578 |     | //  - Transforms it to the 'X127' format.
 2579 |     | //
 2580 |     | //  - Stores the resulting value in the 32 byte memory space which is referred
 2581 |     | //    to by '_amountSpecified_'.
 2582 |     | //
 2583 |     | // Throughout the execution of the swap, 'amountSpecified' is partially
 2584 |     | // fulfilled with each interval that we visit and because of this, the content
 2585 |     | // of this memory space is continuously updated.
 2586 |     | //
 2587 |     | // Due to limited granularity of logarithmic price in 'X59' representation, a
 2588 |     | // requested amount may not be fulfilled. However,
 2589 |     | //
 2590 |     | //  - if 'amountSpecified > 0', the incoming amount to be given to the pool as
 2591 |     | //    a result of the swap call must not exceed 'amountSpecified'.
 2592 |     | //
 2593 |     | //  - if 'amountSpecified < 0', the outgoing amount to be taken from the pool
 2594 |     | //    as a result of the swap call must be greater than or equal to
 2595 |     | //    '0 - amountSpecified'.
 2596 |     | //
 2597 |     | // 32 bytes are reserved for the 'X127' representation of 'amountSpecified' in
 2598 |     | // memory.
 2599 |     | uint16 constant _amountSpecified_ = 264;
 2600 |     | 
 2601 |     | // The input 'logPriceLimit' of the 'swap' method in 'Nofeeswap.sol' is a
 2602 |     | // signed value in 'X59' format. Define
 2603 |     | //
 2604 |     | //  'pLimit := exp(logPriceLimit / (2 ** 59))'.
 2605 |     | //
 2606 |     | // The input 'logPriceLimit' imposes a limit on the price of the pool post
 2607 |     | // execution of the swap call.
 2608 |     | //
 2609 |     | //  - For price increasing swaps, 'logPriceLimit' serves as an upper bound, in
 2610 |     | //    which case the price of the pool must not exceed 'pLimit'.
 2611 |     | //
 2612 |     | //  - For price decreasing swaps, 'logPriceLimit' serves as a lower bound, in
 2613 |     | //    which case the price of the pool must not subceed 'pLimit'.
 2614 |     | //
 2615 |     | // In both cases, once the price of the pool reaches 'pLimit', the execution of
 2616 |     | // the swap is halted. Put simply, no amount of tags are traded with any price
 2617 |     | // worst than 'pLimit' for the swapper.
 2618 |     | //
 2619 |     | // 32 bytes are reserved for 'logPriceLimit' in memory.
 2620 |     | uint16 constant _logPriceLimit_ = 296;
 2621 |     | 
 2622 |     | // Let 'pLower' and 'pUpper', respectively, denote the minimum and maximum
 2623 |     | // price in the current active liquidity interval and define
 2624 |     | //
 2625 |     | //  'qLower := log(pLower / pOffset)'
 2626 |     | //  'qUpper := log(pUpper / pOffset)'
 2627 |     | //  'qSpacing := log(pUpper / pLower)',
 2628 |     | //  'qMost  := + 16 - 1 / (2 ** 59) - qSpacing'.
 2629 |     | //  'qLeast := - 16 + 1 / (2 ** 59) + qSpacing'.
 2630 |     | //
 2631 |     | // As previously argued, for every integer 'j', the interval
 2632 |     | //
 2633 |     | //  '[qLower + j * qSpacing, qUpper + j * qSpacing]'
 2634 |     | //
 2635 |     | // is a valid liquidity interval if and only if:
 2636 |     | //
 2637 |     | //  '- qMost <= qLower + j * qSpacing'
 2638 |     | //
 2639 |     | // and
 2640 |     | //
 2641 |     | //  'qUpper + j * qSpacing <= + qMost.
 2642 |     | //
 2643 |     | // This includes the current active liquidity interval '[qLower, qUpper]'
 2644 |     | // which corresponds to 'j == 0'.
 2645 |     | //
 2646 |     | // Because of this,
 2647 |     | //
 2648 |     | //  'qCurrent := log(pCurrent / pOffset)'
 2649 |     | //
 2650 |     | // always satisfies
 2651 |     | //
 2652 |     | //  'qCurrent >= qLeast + ((qLower - qLeast) % qSpacing)'
 2653 |     | //
 2654 |     | // and
 2655 |     | //
 2656 |     | //  'qCurrent <= qMost - ((qMost - qLower) % qSpacing)'
 2657 |     | //
 2658 |     | // where 'pCurrent' is the current price of the pool.
 2659 |     | //
 2660 |     | // In order to enforce the above inequalities, the following value is
 2661 |     | // calculated in the method 'setSwapParams' of 'swap.sol':
 2662 |     | //
 2663 |     | //  'qLimit := min(
 2664 |     | //     max(
 2665 |     | //       qLeast + ((qLower - qLeast) % qSpacing),
 2666 |     | //       log(pLimit / pOffset)
 2667 |     | //     ),
 2668 |     | //     qMost - ((qMost - qLower) % qSpacing)
 2669 |     | //   )'
 2670 |     | //
 2671 |     | // based on 'qLower', 'qUpper', and 'logPriceLimit'. Then, the offset binary
 2672 |     | // 'X59' representation of 'qLimit', i.e.,
 2673 |     | //
 2674 |     | //  'logPriceLimitOffsetted := (2 ** 59) * (16 + qLimit)'
 2675 |     | //
 2676 |     | // is stored in the memory space which is pointed to by
 2677 |     | // '_logPriceLimitOffsetted_'.
 2678 |     | //
 2679 |     | // Because
 2680 |     | // 
 2681 |     | //  '- 16 + 1 / (2 ** 59) <= qLimit <= + 16 - 1 / (2 ** 59)',
 2682 |     | //
 2683 |     | // we have
 2684 |     | //
 2685 |     | //  '1 <= logPriceLimitOffsetted <= (2 ** 64) - 1',
 2686 |     | //
 2687 |     | // which is why 8 bytes are reserved for 'logPriceLimitOffsetted' in memory.
 2688 |     | uint16 constant _logPriceLimitOffsetted_ = 328;
 2689 |     | 
 2690 |     | // Swap Parameters
 2691 |     | // ----------------------------------------------------------------------------
 2692 |     | // The following memory pointers correspond to a number of secondary parameters
 2693 |     | // that are derived and stored in memory in order to facilitate the execution
 2694 |     | // of each 'swap' call. The following memory pointers as well as the
 2695 |     | // corresponding getter functions can be used to access each parameter.
 2696 |     | // Moreover, when invoking either of the 'midSwap' and 'postSwap' hooks, if
 2697 |     | // applicable, these parameters are included in memory snapshot that is passed
 2698 |     | // to the hook as calldata. Hence they can be accessed via the corresponding
 2699 |     | // calldata pointers and getter functions that are listed in
 2700 |     | // 'HookCalldata.sol'.
 2701 |     | uint16 constant _swapParams_ = 336;
 2702 |     | 
 2703 |     | // As discussed before, the calldata layout of the method 'swap' in
 2704 |     | // 'Nofeeswap.sol' does not have a slot dedicated to 'crossThreshold' or
 2705 |     | // 'zeroForOne'. Instead, the two inputs 'crossThreshold' and 'zeroForOne'
 2706 |     | // share the same slot in calldata as illustrated below:
 2707 |     | //
 2708 |     | //     +---------------------------+---------------------------+
 2709 |     | //     | crossThreshold (128 bits) |   zeroForOne (128 bits)   |
 2710 |     | //     +---------------------------+---------------------------+
 2711 |     | //
 2712 |     | // 'crossThreshold' occupies the most significant 128 bits and 'zeroForOne'
 2713 |     | // occupies the least significant 128 bits.
 2714 |     | //
 2715 |     | //  - If the given 'zeroForOne' input is equal to '0', then the swap is price
 2716 |     | //    increasing in which case 'tag0' is outgoing from the pool and 'tag1' is
 2717 |     | //    incoming to the pool.
 2718 |     | //
 2719 |     | //  - If the given 'zeroForOne' input is equal to '1', then the swap is price
 2720 |     | //    decreasing in which case 'tag0' is incoming to the pool and 'tag1' is
 2721 |     | //    outgoing from the pool.
 2722 |     | //
 2723 |     | //  - If the given 'zeroForOne' input is equal to any other value, then the
 2724 |     | //    movement of the price is towards 'logPriceLimit', i.e., the swap is price
 2725 |     | //    increasing if
 2726 |     | //
 2727 |     | //      'pCurrent < pLimit'
 2728 |     | //
 2729 |     | //    and the swap is price decreasing if
 2730 |     | //
 2731 |     | //      'pLimit < pCurrent'
 2732 |     | //
 2733 |     | //    where
 2734 |     | //
 2735 |     | //      'pLimit := exp(logPriceLimit / (2 ** 59))'.
 2736 |     | //
 2737 |     | //    and 'pCurrent' represents the current price of the pool.
 2738 |     | //
 2739 |     | // A single byte is reserved for this memory space. After the investigation of
 2740 |     | // calldata and comparing 'pCurrent' with 'pLimit',
 2741 |     | //
 2742 |     | //   - If the swap is deemed to be price increasing, then the byte which is
 2743 |     | //     pointed to by '_zeroForOne_' is left as '0x00'.
 2744 |     | //
 2745 |     | //   - If the swap is price decreasing, then this byte is populated with
 2746 |     | //     '0xFF'.
 2747 |     | //
 2748 |     | // The getter function 'getZeroForOne' in this script and the getter function
 2749 |     | // 'getZeroForOneFromCalldata' in 'HookCalldata.sol' give access to the content
 2750 |     | // of this memory space (or calldata in the context of the hook contract) as a
 2751 |     | // boolean with 'false' and 'true' representing price increasing and price
 2752 |     | // decreasing swaps, respectively.
 2753 |     | uint16 constant _zeroForOne_ = 336;
 2754 |     | 
 2755 |     | // The input 'amountSpecified' of the 'swap' method in 'Nofeeswap.sol' is a
 2756 |     | // signed integer. The following memory spaces contains the sign of
 2757 |     | // 'amountSpecified' which can be accessed as a boolean. To this end, a single
 2758 |     | // byte is reserved in memory which is pointed to by '_exactInput_'.
 2759 |     | //
 2760 |     | //   - If 'amountSpecified > 0', then 'amountSpecified' represents the
 2761 |     | //     requested incoming amount to be given to the pool as a result of the
 2762 |     | //     swap call. In this case the byte which is pointed to by '_exactInput_'
 2763 |     | //     is left as '0x00'.
 2764 |     | //
 2765 |     | //   - If 'amountSpecified < 0', then '0 - amountSpecified' represents the
 2766 |     | //     requested outgoing amount to be taken from the pool as a result of the
 2767 |     | //     swap call. In this case the byte which is pointed to by '_exactInput_'
 2768 |     | //     is populated with '0xFF'.
 2769 |     | //
 2770 |     | // The getter function 'getExactInput' in this script and the getter function
 2771 |     | // 'getExactInputFromCalldata' in 'HookCalldata.sol' give access to the content
 2772 |     | // of this memory space (or calldata in the context of the hook contract) as a
 2773 |     | // boolean with 'false' and 'true' representing exact output and exact input 
 2774 |     | // swaps, respectively.
 2775 |     | uint16 constant _exactInput_ = 337;
 2776 |     | 
 2777 |     | // The execution of a swap call may involve transacting in a single liquidity
 2778 |     | // interval, or it may require visits to multiple intervals.
 2779 |     | //
 2780 |     | // If 'crossThreshold' and 'logPriceLimitOffsetted' are not binding, and in the
 2781 |     | // presence of sufficient liquidity, the protocol should be able to fulfill
 2782 |     | // 'amountSpecified' in the current active interval. This process involves a
 2783 |     | // movement of price from
 2784 |     | //
 2785 |     | //  'qCurrent := log(pCurrent / pOffset)'
 2786 |     | //
 2787 |     | // to
 2788 |     | //
 2789 |     | //  'qTarget := log(pTarget / pOffset)'
 2790 |     | //
 2791 |     | // within the same active liquidity interval, i.e.,
 2792 |     | //
 2793 |     | //   'qLower <= qTarget <= qUpper'.
 2794 |     | //
 2795 |     | // In order to accomplish this, we need to solve the equation:
 2796 |     | //
 2797 |     | //  '|amountSpecified| == 
 2798 |     | //
 2799 |     | //      (getZeroForOne() != getExactInput() ? sqrtOffset : sqrtInverseOffset) * 
 2800 |     | //
 2801 |     | //                      growth
 2802 |     | //      sharesTotal * ---------- * 
 2803 |     | //                     2 ** 111
 2804 |     | //
 2805 |     | //       getExactInput() ? incomingCurrentToTarget : currentToTarget
 2806 |     | //      -------------------------------------------------------------',
 2807 |     | //                                outgoingMax
 2808 |     | //
 2809 |     | // where '|amountSpecified|', 'sqrtOffset', 'sqrtInverseOffset', 'outgoingMax',
 2810 |     | // 'sharesTotal', and 'growth' remain fixed as long as we are in the same
 2811 |     | // interval.
 2812 |     | //
 2813 |     | // Hence, as an initial step of a swap call's execution and with each visit to
 2814 |     | // a new interval, the following value is calculated in 'X216' format:
 2815 |     | //
 2816 |     | //  'integralLimit := min(
 2817 |     | //
 2818 |     | //      oneX216 - epsilonX216,
 2819 |     | //
 2820 |     | //                           1          2 ** 111
 2821 |     | //      outgoingMax *  ------------- * ---------- *
 2822 |     | //                      sharesTotal      growth
 2823 |     | //
 2824 |     | //                                |amountSpecified|
 2825 |     | //      -----------------------------------------------------------------------
 2826 |     | //       (getZeroForOne() != getExactInput()) ? sqrtOffset : sqrtInverseOffset
 2827 |     | //
 2828 |     | //   )'.
 2829 |     | //
 2830 |     | // Based on the above equations, it is straightforward to verify that
 2831 |     | // 'amountSpecified' is fulfilled if and only if:
 2832 |     | //
 2833 |     | //   'getExactInput() ? incomingCurrentToTarget : currentToTarget
 2834 |     | //     == 
 2835 |     | //    integralLimit'.
 2836 |     | //
 2837 |     | // Since the left-hand side is a function of 'qTarget', the above equation is
 2838 |     | // solved by methods 'searchOutgoingTarget' and 'searchIncomingTarget' in
 2839 |     | // 'Interval.sol' in order to calculate the precise value of 'qTarget' that
 2840 |     | // fulfills 'amountSpecified'. These two methods work with 'integralLimit'.
 2841 |     | //
 2842 |     | // 'integralLimit' is less than 'oneX216' and does not exceed 216 bits. Hence,
 2843 |     | // 27 bytes are reserved for the memory space that stores 'integralLimit'.
 2844 |     | uint16 constant _integralLimit_ = 338;
 2845 |     | 
 2846 |     | // Let 'pLower' and 'pUpper', respectively, denote the minimum and maximum
 2847 |     | // price in the current active liquidity interval and define
 2848 |     | //
 2849 |     | //  'qLower := log(pLower / pOffset)',
 2850 |     | //  'qUpper := log(pUpper / pOffset)'.
 2851 |     | //
 2852 |     | // By crossing the active interval entirely from one end to the other end, the
 2853 |     | // absolute value '|amountSpecified|' is decremented by
 2854 |     | //
 2855 |     | //  '(getZeroForOne() != getExactInput() ? sqrtOffset : sqrtInverseOffset) * 
 2856 |     | //
 2857 |     | //                   growth      integralLimitInterval
 2858 |     | //   sharesTotal * ---------- * -----------------------',
 2859 |     | //                  2 ** 111          outgoingMax
 2860 |     | //
 2861 |     | // where 'integralLimitInterval' for the present interval is defined as
 2862 |     | //
 2863 |     | //  'integralLimitInterval := (getExactInput() ? incomingMax : outgoingMax)
 2864 |     | //
 2865 |     | //           (getZeroForOne() != getExactInput() ? - qLower : + qUpper) / 2
 2866 |     | //       * e                                                               '.
 2867 |     | //
 2868 |     | // By crossing the active interval, the limit imposed by 'amountSpecified' is
 2869 |     | // not violated if and only if:
 2870 |     | //        
 2871 |     | //  'integralLimitInterval <= integralLimit'.
 2872 |     | //
 2873 |     | // Hence, 'integralLimitInterval' can be used to determined whether we should
 2874 |     | // cross a new active interval entirely or not.
 2875 |     | //
 2876 |     | // 'integralLimitInterval' is calculated with each visit to a new interval and
 2877 |     | // stored in the 27 bytes memory space which is pointed to by
 2878 |     | // '_integralLimitInterval_'.
 2879 |     | uint16 constant _integralLimitInterval_ = 365;
 2880 |     | 
 2881 |     | // Throughout the execution of a swap, this 32 bytes memory space hosts the
 2882 |     | // 'X127' representation of 'amount0' which is the total amount of 'tag0' that
 2883 |     | // is traded so far. Concluding the visit to each interval involves
 2884 |     | // incrementing the absolute value '|amount0|' with
 2885 |     | //                                                         growth
 2886 |     | //  'amount0Partial := sqrtInverseOffset * sharesTotal * ---------- *
 2887 |     | //                                                        2 ** 111
 2888 |     | //
 2889 |     | //   (getZeroForOne() ? incomingCurrentToTarget : currentToTarget)'.
 2890 |     | //
 2891 |     | // If positive, 'amount0' is incoming to the pool and if negative it is
 2892 |     | // outgoing from the pool.
 2893 |     | uint16 constant _amount0_ = 392;
 2894 |     | 
 2895 |     | // Throughout the execution of a swap, this 32 bytes memory space hosts the
 2896 |     | // 'X127' representation of 'amount1' which is the total amount of 'tag1' that
 2897 |     | // is traded so far. Concluding the visit to each interval involves
 2898 |     | // incrementing the absolute value '|amount1|' with
 2899 |     | //                                                  growth
 2900 |     | //  'amount1Partial := sqrtOffset * sharesTotal * ---------- *
 2901 |     | //                                                 2 ** 111
 2902 |     | //
 2903 |     | //   (getZeroForOne() ? currentToTarget : incomingCurrentToTarget)'.
 2904 |     | //
 2905 |     | // If positive, 'amount1' is incoming to the pool and if negative it is
 2906 |     | // outgoing from the pool.
 2907 |     | uint16 constant _amount1_ = 424;
 2908 |     | 
 2909 |     | // At each point throughout the execution of a swap, as we transition from
 2910 |     | // each interval to the next one, the memory pointer '_back_' is used in order
 2911 |     | // to keep track of the active interval boundary in the opposite direction of
 2912 |     | // the swap.
 2913 |     | //
 2914 |     | // Let 'pLower' and 'pUpper', respectively, denote the minimum and maximum
 2915 |     | // price in the current active liquidity interval and define
 2916 |     | //
 2917 |     | //  'qBack := log((getZeroForOne() ? pUpper : pLower) / pOffset)'.
 2918 |     | //
 2919 |     | // The 62 bytes memory space which is pointed to by '_back_' hosts the
 2920 |     | // following values:
 2921 |     | //
 2922 |     | //  '_back_.log() := (2 ** 59) * (16 + qBack)',
 2923 |     | //  '_back_.sqrt(false) := (2 ** 216) * exp(- 8 - qBack / 2)',
 2924 |     | //  '_back_.sqrt(true) := (2 ** 216) * exp(- 8 + qBack / 2)'.
 2925 |     | //
 2926 |     | // which can be accessed via 'PriceLibrary'. The logarithmic price
 2927 |     | // '_back_.log()' occupies 64 bits, whereas '_back_.sqrt(false)' and
 2928 |     | // '_back_.sqrt(true)' occupy 216 bits each.
 2929 |     | uint16 constant _back_ = 456;
 2930 |     | 
 2931 |     | // At each point throughout the execution of a swap, as we transition from
 2932 |     | // each interval to the next one, the memory pointer '_next_' is used in order
 2933 |     | // to keep track of the active interval boundary in the direction of the swap.
 2934 |     | //
 2935 |     | // Let 'pLower' and 'pUpper', respectively, denote the minimum and maximum
 2936 |     | // price in the current active liquidity interval and define
 2937 |     | //
 2938 |     | //  'qNext := log((getZeroForOne() ? pLower : pUpper) / pOffset)'.
 2939 |     | //
 2940 |     | // The 62 bytes memory space which is pointed to by '_next_' hosts the
 2941 |     | // following values:
 2942 |     | //
 2943 |     | //  '_next_.log() := (2 ** 59) * (16 + qNext)',
 2944 |     | //  '_next_.sqrt(false) := (2 ** 216) * exp(- 8 - qNext / 2)',
 2945 |     | //  '_next_.sqrt(true) := (2 ** 216) * exp(- 8 + qNext / 2)'.
 2946 |     | //
 2947 |     | // which can be accessed via 'PriceLibrary'. The logarithmic price
 2948 |     | // '_next_.log()' occupies 64 bits, whereas '_next_.sqrt(false)' and
 2949 |     | // '_next_.sqrt(true)' occupy 216 bits each.
 2950 |     | uint16 constant _next_ = 518;
 2951 |     | 
 2952 |     | // An LP may choose any consecutive range of liquidity intervals to deposit
 2953 |     | // their liquidity. By doing so, the LP acquires a number of shares in every
 2954 |     | // liquidity interval that belongs to the given range.
 2955 |     | //
 2956 |     | // Let 'pLower' and 'pUpper', respectively, denote the minimum and maximum
 2957 |     | // price in the current active liquidity interval and define
 2958 |     | //
 2959 |     | //  'qLower := log(pLower / pOffset)',
 2960 |     | //  'qUpper := log(pUpper / pOffset)'.
 2961 |     | //
 2962 |     | // Additionally, let
 2963 |     | // 
 2964 |     | //    sqrtInverseOffset     growthMultiplier[qUpper]
 2965 |     | //  '------------------- * --------------------------'
 2966 |     | //         2 ** 127                 2 ** 208
 2967 |     | //
 2968 |     | // represent the total amount of 'tag0' corresponding to a single liquidity
 2969 |     | // provider's share from 'qUpper' to '+oo' and
 2970 |     | //
 2971 |     | //    sqrtOffset     growthMultiplier[qLower]
 2972 |     | //  '------------ * --------------------------'
 2973 |     | //     2 ** 127             2 ** 208
 2974 |     | //
 2975 |     | // represent the total amount of 'tag1' corresponding to a single liquidity
 2976 |     | // provider's share from '-oo' to 'qLower'.
 2977 |     | //
 2978 |     | // The 32 bytes memory space which is pointed to by '_backGrowthMultiplier_'
 2979 |     | // hosts the 'X208' representation of
 2980 |     | // 'growthMultiplier[getZeroForOne() ? qUpper : qLower]'.
 2981 |     | //
 2982 |     | // The 32 bytes memory space which is pointed to by '_nextGrowthMultiplier_'
 2983 |     | // hosts the 'X208' representation of
 2984 |     | // 'growthMultiplier[getZeroForOne() ? qLower : qUpper]'.
 2985 |     | uint16 constant _backGrowthMultiplier_ = 580;
 2986 |     | uint16 constant _nextGrowthMultiplier_ = 612;
 2987 |     | 
 2988 |     | // Interval Parameters
 2989 |     | // ----------------------------------------------------------------------------
 2990 |     | // The following memory pointers correspond to the main variables that are used
 2991 |     | // to calculate swaps within the active liquidity interval.
 2992 |     | //
 2993 |     | // Let 'pCurrent' denote the current price of the pool and let 'pLower' and
 2994 |     | // 'pUpper', respectively, denote the minimum and maximum price in the current
 2995 |     | // active liquidity interval. Define:
 2996 |     | //
 2997 |     | //  'qLower := log(pLower / pOffset)',
 2998 |     | //  'qUpper := log(pUpper / pOffset)',
 2999 |     | //  'qSpacing := log(pUpper / pLower)',
 3000 |     | //  'qCurrent := log(pCurrent / pOffset)'.
 3001 |     | //
 3002 |     | // Then we have:
 3003 |     | //
 3004 |     | //  'qLower <= qCurrent <= qUpper',
 3005 |     | //
 3006 |     | // Consider a swap that involves a movement of price from 'qCurrent' to
 3007 |     | //
 3008 |     | //  'qTarget := log(pTarget / pOffset)'
 3009 |     | //
 3010 |     | // within the same active liquidity interval, i.e.,
 3011 |     | //
 3012 |     | //  'qLower <= qTarget <= qUpper'.
 3013 |     | //
 3014 |     | // Notice that 'qTarget' is an unknown value which will be determined based on
 3015 |     | // one of the followings:
 3016 |     | //
 3017 |     | //  - 'qLimitWithinInterval', which is calculated based on the input
 3018 |     | //    'logPriceLimit' as well as 'qLower' and 'qUpper'. It is stored in the
 3019 |     | //    memory space which is pointed to by
 3020 |     | //    '_logPriceLimitOffsettedWithinInterval_'.
 3021 |     | //
 3022 |     | //  - 'integralLimit', which is calculated based on the input 'amountSpecified'
 3023 |     | //    and is stored in the memory space which is pointed to by
 3024 |     | //    '_integralLimit_'.
 3025 |     | //
 3026 |     | // After determination of 'qTarget', the amounts of 'tag0' and 'tag1' to be
 3027 |     | // exchanged as a result of the movement within '[qLower, qUpper]' are equal
 3028 |     | // to:
 3029 |     | //
 3030 |     | //                                                         growth
 3031 |     | //  'amount0Partial := sqrtInverseOffset * sharesTotal * ---------- *
 3032 |     | //                                                        2 ** 111
 3033 |     | //
 3034 |     | //    getZeroForOne() ? incomingCurrentToTarget : currentToTarget
 3035 |     | //   -------------------------------------------------------------',
 3036 |     | //                            outgoingMax
 3037 |     | // and
 3038 |     | //                                                  growth
 3039 |     | //  'amount1Partial := sqrtOffset * sharesTotal * ---------- *
 3040 |     | //                                                 2 ** 111
 3041 |     | //
 3042 |     | //    getZeroForOne() ? currentToTarget : incomingCurrentToTarget
 3043 |     | //   -------------------------------------------------------------',
 3044 |     | //                            outgoingMax
 3045 |     | //
 3046 |     | // where the parameters 'sqrtInverseOffset', 'sqrtOffset', 'sharesTotal',
 3047 |     | // 'growth', and 'outgoingMax' remain fixed throughout the movement from
 3048 |     | // 'qCurrent' to 'qTarget'.
 3049 |     | //
 3050 |     | // While searching for 'qTarget', the two integrals 'currentToTarget' and
 3051 |     | // 'incomingCurrentToTarget' are calculated. These two integrals are defined as
 3052 |     | // follows:
 3053 |     | //
 3054 |     | //                           - 8
 3055 |     | //    currentToTarget      e
 3056 |     | //  '----------------- := ------- * (
 3057 |     | //       2 ** 216            2
 3058 |     | //
 3059 |     | //                         / qCurrent                 / qTarget
 3060 |     | //                        |    + h / 2               |    - h / 2
 3061 |     | //     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh
 3062 |     | //                        |                          |
 3063 |     | //                       / qTarget                  / qCurrent
 3064 |     | //
 3065 |     | //   )'
 3066 |     | //
 3067 |     | // and
 3068 |     | //                                   - 8
 3069 |     | //    incomingCurrentToTarget      e
 3070 |     | //  '------------------------- := ------- * (
 3071 |     | //           2 ** 216                2
 3072 |     | //
 3073 |     | //                         / qCurrent                 / qTarget
 3074 |     | //                        |    - h / 2               |    + h / 2
 3075 |     | //     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh
 3076 |     | //                        |                          |
 3077 |     | //                       / qTarget                  / qCurrent
 3078 |     | //
 3079 |     | //   )'.
 3080 |     | //
 3081 |     | // To further clarify the above definitions, we first need to define the
 3082 |     | // function 'w(.)' which is constructed based on the curve sequence.
 3083 |     | //
 3084 |     | // The curve sequence comprises 64 bit logarithmic prices in the form of
 3085 |     | //
 3086 |     | //  '(2 ** 59) * (16 + qHistorical)'
 3087 |     | //
 3088 |     | // where every 'qHistorical' satisfies:
 3089 |     | //
 3090 |     | //  'qLower <= qHistorical <= qUpper'.
 3091 |     | //
 3092 |     | // Hence, each slot of the curve sequence consists of up to four members. The
 3093 |     | // curve sequence should have at least two members. The first and the second
 3094 |     | // members are 'qLower' and 'qUpper' with the order depending on the pool's
 3095 |     | // history. The last member is always 'qCurrent'. Consider the following curve
 3096 |     | // sequence:
 3097 |     | // 
 3098 |     | //  'q[0], q[1], q[2], ..., q[l - 1]'
 3099 |     | //
 3100 |     | // where 'l' is the number of members. Additionally, to simplify the notations,
 3101 |     | // the out-of-range member 'q[l]' is assigned the same value as 'q[l - 1]'. In
 3102 |     | // order for the above sequence to be considered valid, we should have:
 3103 |     | //
 3104 |     | //  'min(q[i - 1], q[i - 2]) < q[i] < max(q[i - 1], q[i - 2])'.
 3105 |     | //
 3106 |     | // for every '2 <= i < l'. Define
 3107 |     | // 
 3108 |     | //  'w : [qLower, qUpper] -> [0, qSpacing]'
 3109 |     | //
 3110 |     | // as
 3111 |     | //           l - 2
 3112 |     | //           -----
 3113 |     | //           \
 3114 |     | //  'w(q) := /     w_i(q)'.
 3115 |     | //           -----
 3116 |     | //           i = 0
 3117 |     | //
 3118 |     | // where for every '0 <= i <= l - 2', the function
 3119 |     | //
 3120 |     | //  'w_i : [qLower, qUpper] -> [0, qSpacing]'
 3121 |     | //
 3122 |     | // is regarded as a phase which is defined as
 3123 |     | //
 3124 |     | //  'w_i(q) :=
 3125 |     | //
 3126 |     | //    /
 3127 |     | //   |  |q - q[i + 1]|  if  min(q[i], q[i + 2]) < q < max(q[i], q[i + 2])
 3128 |     | //   |                                                                    '.
 3129 |     | //   |  0               otherwise
 3130 |     | //    \
 3131 |     | //
 3132 |     | // Observe that for each '0 <= i <= l - 2', the phase 'w_i' can be
 3133 |     | // characterized via the following three consecutive members of the curve
 3134 |     | // sequence:
 3135 |     | //
 3136 |     | //  'q[i], q[i + 1], q[i + 2]'
 3137 |     | //
 3138 |     | // Next, we need to define the function 'k(.)' which is constructed from the
 3139 |     | // kernel. The kernel is composed of breakpoints. Let 'm + 1' denote the number
 3140 |     | // of these breakpoints. For every integer '0 <= i <= m' the i-th breakpoint of
 3141 |     | // the kernel represents the pair '(b[i], c[i])' where
 3142 |     | //
 3143 |     | //  '0 == b[0] <  b[1] <= b[2] <= ... <= b[m - 1] <  b[m] == qSpacing',
 3144 |     | //  '0 == c[0] <= c[1] <= c[2] <= ... <= c[m - 1] <= c[m] == 1'.
 3145 |     | // 
 3146 |     | // Each breakpoint occupies 64 bytes, in which:
 3147 |     | //
 3148 |     | //  - the 'X15' representation of '(2 ** 15) * c[i]' occupies 2 bytes,
 3149 |     | //
 3150 |     | //  - the 'X59' representation of '(2 ** 59) * b[i]' occupies 8 bytes,
 3151 |     | //
 3152 |     | //  - the 'X216' representation of '(2 ** 216) * exp(- b[i] / 2)' occupies 27
 3153 |     | //    bytes,
 3154 |     | //
 3155 |     | //  - the 'X216' representation of '(2 ** 216) * exp(- 16 + b[i] / 2)' occupies
 3156 |     | //    27 bytes.
 3157 |     | //
 3158 |     | // The above-mentioned layout is illustrated as follows:
 3159 |     | //
 3160 |     | //                      A 512 bit kernel breakpoint
 3161 |     | //  +--+--------+---------------------------+---------------------------+
 3162 |     | //  |  | 8 byte |          27 byte          |          27 byte          |
 3163 |     | //  +--+--------+---------------------------+---------------------------+
 3164 |     | //  |  |        |                           |
 3165 |     | //  |  |        |                            \
 3166 |     | //  |  |        |                             (2 ** 216) * exp(- 16 + b[i] / 2)
 3167 |     | //  |  |         \
 3168 |     | //  |  |          (2 ** 216) * exp(- b[i] / 2)
 3169 |     | //  |   \
 3170 |     | //  |    (2 ** 59) * b[i]
 3171 |     | //   \
 3172 |     | //    (2 ** 15) * c[i]
 3173 |     | //
 3174 |     | // Consider the following list of kernel breakpoints:
 3175 |     | //
 3176 |     | //  '(b[0], c[0]), (b[1], c[1]), (b[2], c[2]), ..., (b[m], c[m])'
 3177 |     | //
 3178 |     | // and for every integer '0 < i <= m', define
 3179 |     | //
 3180 |     | //  'k_i : [0, qSpacing] -> [0, 1]'
 3181 |     | //
 3182 |     | // as
 3183 |     | //
 3184 |     | //  'k_i(q) :=
 3185 |     | //
 3186 |     | //    /            c[i] - c[i - 1]
 3187 |     | //   | c[i - 1] + ----------------- * (q - b[i - 1])  if  b[i - 1] < q < b[i]
 3188 |     | //   |             b[i] - b[i - 1]                                           ',
 3189 |     | //   | 0                                              otherwise
 3190 |     | //    \
 3191 |     | //
 3192 |     | // which means that if 'b[i - 1] == b[i]', then 'k_i(q) := 0'. Now, the kernel
 3193 |     | // function
 3194 |     | // 
 3195 |     | //  'k : [0, qSpacing] -> [0, 1]'
 3196 |     | //
 3197 |     | // is defined as
 3198 |     | //
 3199 |     | //             m
 3200 |     | //           -----
 3201 |     | //           \
 3202 |     | //  'k(q) := /     k_i(q)'.
 3203 |     | //           -----
 3204 |     | //           i = 1
 3205 |     | //
 3206 |     | // Define the liquidity distribution function
 3207 |     | //
 3208 |     | //  'k(w(.)) : [qLower, qUpper] -> [0, 1]'
 3209 |     | //
 3210 |     | // for the active interval as the composition of 'k(.)' with 'w(.)'.
 3211 |     | //
 3212 |     | // As argued above, while searching for 'qTarget', the integrals
 3213 |     | // 'currentToTarget' and 'incomingCurrentToTarget' are calculated based on
 3214 |     | // 'k(w(.))' which enables the protocol to determine 'amount0Partial' and
 3215 |     | // 'amount1Partial' when moving the price from 'qCurrent' to 'qTarget'. In
 3216 |     | // addition, we need to calculate two other integrals that are referred to as
 3217 |     | // 'currentToOrigin' and 'originToOvershoot' which will be defined later in
 3218 |     | // this script. Next, we explain how this search is conducted.
 3219 |     | //
 3220 |     | // Remember that both 'w(.)' and 'k(.)' are piecewise linear functions. As a
 3221 |     | // result, 'k(w(.))' is also piecewise linear. In search for 'qTarget', we
 3222 |     | // enumerate the pieces of 'k(w(.))', one by one, until we discover the piece
 3223 |     | // to which 'qTarget' belongs. To this end, the two indices 'indexCurve' and
 3224 |     | // 'indexKernelTotal' are employed:
 3225 |     | //
 3226 |     | //  - 'indexCurve' keeps track of the current phase under exploration (i.e.,
 3227 |     | //    the piece of 'w(.)'). Remember, that 'w_indexCurve' can be characterized
 3228 |     | //    via the following three consecutive members of the curve sequence:
 3229 |     | //
 3230 |     | //      'q[indexCurve], q[indexCurve + 1], q[indexCurve + 2]'.
 3231 |     | //
 3232 |     | //    Here, we refer to 'q[indexCurve + 1]' and 'q[indexCurve]' as 'qOrigin'
 3233 |     | //    and 'qEnd', respectively. Throughout the search, 'qOrigin' and 'qEnd'
 3234 |     | //    are stored, respectively, in the memory spaces which are pointed to by
 3235 |     | //    '_origin_' and '_end_', and they are updated with each transition to a
 3236 |     | //    new phase.
 3237 |     | //
 3238 |     | //    Additionally, the memory space which is pointed to by '_direction_' keeps
 3239 |     | //    track of the boolean:
 3240 |     | //
 3241 |     | //      'qEnd < q[indexCurve + 2]'.
 3242 |     | //
 3243 |     | //    Hence, 'getDirection() == false' means that we are currently searching
 3244 |     | //    within the range
 3245 |     | //    
 3246 |     | //      'q[indexCurve + 2] < q < qEnd'
 3247 |     | //
 3248 |     | //    in which
 3249 |     | //
 3250 |     | //      'w(q) == w_indexCurve(q) == q - qOrigin'.
 3251 |     | //
 3252 |     | //    Whereas, 'getDirection() == true' means that we are currently searching
 3253 |     | //    within the range
 3254 |     | //    
 3255 |     | //      'qEnd < q < q[indexCurve + 2]'
 3256 |     | //
 3257 |     | //    in which
 3258 |     | //
 3259 |     | //      'w(q) == w_indexCurve(q) == qOrigin - q'.
 3260 |     | //
 3261 |     | //    In order to determine whether 'qTarget' belongs to the current range
 3262 |     | //    under exploration, i.e., the range between
 3263 |     | //
 3264 |     | //      'min(qEnd, q[indexCurve + 2])'
 3265 |     | //
 3266 |     | //    and
 3267 |     | //
 3268 |     | //      'max(qEnd, q[indexCurve + 2])'
 3269 |     | //
 3270 |     | //    we start from the price 'q[indexCurve + 2]' and proceed towards the price
 3271 |     | //    'qEnd' by enumerating the pieces of
 3272 |     | //
 3273 |     | //      'k(w(q)) == getDirection() ? k(qOrigin - q) : k(q - qOrigin)'
 3274 |     | //
 3275 |     | //    one by one. The fact that 'w(.)' is a linear function throughout the
 3276 |     | //    above range, means that we only need to worry about the pieces of either
 3277 |     | //    'k(qOrigin - q)' or 'k(q - qOrigin)', depending on the direction.
 3278 |     | //
 3279 |     | //    The process of enumerating phases starts with the following initial
 3280 |     | //    state:
 3281 |     | //
 3282 |     | //      - 'indexCurve := l - 2',
 3283 |     | //
 3284 |     | //      - 'qOrigin := q[indexCurve + 1] == q[l - 1] == qCurrent',
 3285 |     | //
 3286 |     | //      - 'qEnd := q[indexCurve] == q[l - 2]'.
 3287 |     | //
 3288 |     | //    Once we reach 'qEnd', we transition to a new phase by
 3289 |     | //
 3290 |     | //      - decrementing 'indexCurve' by one,
 3291 |     | //
 3292 |     | //      - updating 'qOrigin' and 'qEnd',
 3293 |     | //
 3294 |     | //      - updating the direction flag,
 3295 |     | //
 3296 |     | //    and the cycle continues until we reach the phase to which 'qTarget'
 3297 |     | //    belongs.
 3298 |     | //
 3299 |     | //  - 'indexKernelTotal' keeps track of the pieces of the kernel function that
 3300 |     | //    we enumerate as we explore the current phase. As defined earlier, let:
 3301 |     | //
 3302 |     | //      - 'qOrigin := q[indexCurve + 1]'
 3303 |     | //
 3304 |     | //      - 'qEnd := q[indexCurve]'
 3305 |     | //
 3306 |     | //      - 'getDirection() := qEnd < q[indexCurve + 2]'
 3307 |     | //
 3308 |     | //    correspond to the current phase under exploration which leads to the
 3309 |     | //    following simplification of the liquidity distribution function:
 3310 |     | //
 3311 |     | //      'k(w(q)) == getDirection() ? k(qOrigin - q) : k(q - qOrigin)'
 3312 |     | //
 3313 |     | //    within the range
 3314 |     | //
 3315 |     | //      'min(q[indexCurve + 2], qEnd) < q < max(q[indexCurve + 2], qEnd)'.
 3316 |     | //
 3317 |     | //    Hence, as we move from 'q[indexCurve + 2]' to 'qEnd', each piece of
 3318 |     | //    'k(w(.))' can be characterized via the following four vertical and
 3319 |     | //    horizontal coordinates:
 3320 |     | //
 3321 |     | //      'cTotal0 := c[indexKernelTotal - 1]',
 3322 |     | //
 3323 |     | //      'qTotal0 := getDirection() ? 
 3324 |     | //                  qOrigin - b[indexKernelTotal - 1] : 
 3325 |     | //                  qOrigin + b[indexKernelTotal - 1]',
 3326 |     | //
 3327 |     | //      'cTotal1 := c[indexKernelTotal]',
 3328 |     | //
 3329 |     | //      'qTotal1 := getDirection() ? 
 3330 |     | //                  qOrigin - b[indexKernelTotal] : 
 3331 |     | //                  qOrigin + b[indexKernelTotal]'.
 3332 |     | //
 3333 |     | //    The pair '(cTotal0, qTotal0)' is stored in the memory space which is
 3334 |     | //    pointed to by '_total0_' and similarly, the pair '(cTotal1, qTotal1)' is
 3335 |     | //    stored in the memory space which is pointed to by '_total1_'.
 3336 |     | //
 3337 |     | //    Hence, the function 'k(w(.))' is linear within the intersection of the
 3338 |     | //    two ranges:
 3339 |     | //
 3340 |     | //      'min(q[indexCurve + 2], qEnd) < q < max(q[indexCurve + 2], qEnd)',
 3341 |     | //
 3342 |     | //    and
 3343 |     | //
 3344 |     | //      'min(qTotal0, qTotal1) < q < max(qTotal0, qTotal1)'.
 3345 |     | //
 3346 |     | //    As long as 'k(w(.))' is linear, we have closed-forms for all of the
 3347 |     | //    integrals that we intend to calculate. Hence, it is important to keep
 3348 |     | //    track of the domain in which 'k(w(.))' is linear and to update it as we
 3349 |     | //    move forward in our search. Moreover, we need to make sure that 'qTarget'
 3350 |     | //    does not go beyond 'qLimitWithinInterval'. Hence, with each transition to
 3351 |     | //    a new phase or a new piece of the kernel function, we make the following
 3352 |     | //    two updates:
 3353 |     | //
 3354 |     | //      'qBegin := getDirection() ? 
 3355 |     | //                 min(q[indexCurve + 2], qTotal0) : 
 3356 |     | //                 max(q[indexCurve + 2], qTotal0)',
 3357 |     | //
 3358 |     | //      'qTarget := (
 3359 |     | //                    getDirection() == getZeroForOne()
 3360 |     | //                  ) ? (
 3361 |     | //                    getDirection() ? 
 3362 |     | //                    max(max(qEnd, qTotal1), qLimitWithinInterval) : 
 3363 |     | //                    min(min(qEnd, qTotal1), qLimitWithinInterval)
 3364 |     | //                  ) : (
 3365 |     | //                    getDirection() ? 
 3366 |     | //                    max(qEnd, qTotal1) : 
 3367 |     | //                    min(qEnd, qTotal1)
 3368 |     | //                  )',
 3369 |     | //
 3370 |     | //    where 'qBegin' and 'qTarget' are stored, respectively, in the memory
 3371 |     | //    spaces that are pointed to by '_begin_' and '_target_'. Both values are
 3372 |     | //    updated with each transition to a new phase or a new piece of 'k(w(.))'.
 3373 |     | //
 3374 |     | //    The process of enumerating the pieces of the kernel function starts with
 3375 |     | //    the initial state 'indexKernelTotal := 1'.
 3376 |     | //
 3377 |     | // While searching for 'qTarget', we need to calculate the following two
 3378 |     | // integrals, in addition to 'currentToTarget' and 'incomingCurrentToTarget':
 3379 |     | //
 3380 |     | //                           - 8
 3381 |     | //    currentToOrigin      e
 3382 |     | //  '----------------- := ------- * (
 3383 |     | //       2 ** 216            2
 3384 |     | //
 3385 |     | //                         / qOrigin                  / qCurrent
 3386 |     | //                        |    - h / 2               |    + h / 2
 3387 |     | //     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh
 3388 |     | //                        |                          |
 3389 |     | //                       / qCurrent                 / qOrigin
 3390 |     | //
 3391 |     | //   )'
 3392 |     | //
 3393 |     | // and
 3394 |     | //                             - 8
 3395 |     | //    originToOvershoot      e
 3396 |     | //  '------------------- := ------- * (
 3397 |     | //        2 ** 216             2
 3398 |     | //
 3399 |     | //     getZeroForOne() ? 
 3400 |     | //
 3401 |     | //       / qOrigin
 3402 |     | //      |    + h / 2
 3403 |     | //      |  e         k(qOrigin - h) dh :
 3404 |     | //      |
 3405 |     | //     / qTarget
 3406 |     | //
 3407 |     | //       / qTarget
 3408 |     | //      |    - h / 2
 3409 |     | //      |  e         k(h - qOrigin) dh
 3410 |     | //      |
 3411 |     | //     / qOrigin
 3412 |     | //
 3413 |     | //   )'.
 3414 |     | //
 3415 |     | // To summarize, the four integrals:
 3416 |     | //
 3417 |     | //  - 'currentToTarget',
 3418 |     | //
 3419 |     | //  - 'incomingCurrentToTarget',
 3420 |     | //
 3421 |     | //  - 'currentToOrigin', and
 3422 |     | //
 3423 |     | //  - 'originToOvershoot',
 3424 |     | //
 3425 |     | // are incremented with each decrement of 'indexCurve' or increment of
 3426 |     | // 'indexKernelTotal'.
 3427 |     | //
 3428 |     | // The following figure illustrates the ranges covered by the above integrals
 3429 |     | // in the case of 'getZeroForOne() == false', i.e., 'qCurrent < qTarget':
 3430 |     | //
 3431 |     | //                                                currentToTarget
 3432 |     | //                                                exp(- h / 2) * k(w(h))
 3433 |     | //           currentToOrigin                    / 
 3434 |     | //    exp(+ h / 2) * k(w(h))                   /\ 
 3435 |     | //                          \                 /   incomingCurrentToTarget
 3436 |     | //                           \               /    exp(+ h / 2) * k(w(h))
 3437 |     | //                            \             /
 3438 |     | //                     |<------------>|<-------->|
 3439 |     | //                     |              |          |
 3440 |     | //      +--------------+--------------+----------+------------------+
 3441 |     | //      |              |              |          |                  |
 3442 |     | //    qLower           |          qCurrent       |                qUpper
 3443 |     | //                     |                         |
 3444 |     | //                     |<----------------------->|
 3445 |     | //                     |            \            |
 3446 |     | //                  qOrigin          \        qTarget == qOvershoot
 3447 |     | //                                    \
 3448 |     | //                             originToOvershoot
 3449 |     | //                             exp(- h / 2) * k(h - qOrigin)
 3450 |     | //
 3451 |     | // The search for 'qTarget' is conducted by calling the method 'moveTarget()'
 3452 |     | // from 'Interval.sol' in a loop until either of the following condition are
 3453 |     | // met:
 3454 |     | //
 3455 |     | //  - 'qLimitWithinInterval == qTarget', or
 3456 |     | //
 3457 |     | //  - 'integralLimit == (
 3458 |     | //       getExactInput() ? incomingCurrentToTarget : currentToTarget
 3459 |     | //     )'.
 3460 |     | //
 3461 |     | // Define:
 3462 |     | //
 3463 |     | //                                - 8     / qUpper
 3464 |     | //    integral0Incremented      e        |    - h / 2
 3465 |     | //  '---------------------- := ------- * |  e         k(w(h)) dh',
 3466 |     | //          2 ** 216              2      |
 3467 |     | //                                      / qTarget
 3468 |     | //
 3469 |     | //                                - 8     / qTarget
 3470 |     | //    integral1Incremented      e        |    + h / 2
 3471 |     | //  '---------------------- := ------- * |  e         k(w(h)) dh'.
 3472 |     | //          2 ** 216              2      |
 3473 |     | //                                      / qLower
 3474 |     | //
 3475 |     | // Now, the total reserves of 'tag0' and 'tag1' within '[qLower, qUpper]' after
 3476 |     | // the movement of price from 'qCurrent' to 'qTarget' (i.e., after the exchange
 3477 |     | // of 'amount0Partial' and 'amount1Partial') are equal to 
 3478 |     | //
 3479 |     | //                                       growth      integral0Incremented
 3480 |     | //  'sqrtInverseOffset * sharesTotal * ---------- * ----------------------'
 3481 |     | //                                      2 ** 111         outgoingMax
 3482 |     | //
 3483 |     | // and
 3484 |     | //
 3485 |     | //                                growth      integral1Incremented
 3486 |     | //  'sqrtOffset * sharesTotal * ---------- * ----------------------',
 3487 |     | //                               2 ** 111         outgoingMax
 3488 |     | //
 3489 |     | // respectively. The ranges covered by 'integral0Incremented' and
 3490 |     | // 'integral1Incremented' are illustrated as follows:
 3491 |     | //
 3492 |     | //                                                    integral0Incremented
 3493 |     | //                                                    exp(- h / 2) * k(w(h))
 3494 |     | //                integral1Incremented               /
 3495 |     | //                exp(+ h / 2) * k(w(h))            /
 3496 |     | //      |<-------------------------------------->|<---------------->|
 3497 |     | //      |                                        |                  |
 3498 |     | //      +----------------------------------------+------------------+
 3499 |     | //      |                                        |                  |
 3500 |     | //    qLower                                  qTarget             qUpper
 3501 |     | //
 3502 |     | // After the search for 'qTarget' is concluded, and 'amount0Partial' and
 3503 |     | // 'amount1Partial' are calculated, we need to determine 'qOvershoot'. If
 3504 |     | // 'getZeroForOne() == false', we have
 3505 |     | //
 3506 |     | //  'qTarget <= qOvershoot <= qUpper'
 3507 |     | //
 3508 |     | // and if 'getZeroForOne() == true', we have
 3509 |     | //
 3510 |     | //  'qLower <= qOvershoot <= qTarget'.
 3511 |     | //
 3512 |     | // The curve sequence is first amended with 'qOvershoot' and then 'qTarget', in
 3513 |     | // preparation for the next swap.
 3514 |     | //
 3515 |     | // To this end, define:
 3516 |     | //                              - 8
 3517 |     | //    currentToOvershoot      e
 3518 |     | //  '-------------------- := ------- * (
 3519 |     | //         2 ** 216             2
 3520 |     | //
 3521 |     | //                         / qCurrent                 / qOvershoot
 3522 |     | //                        |    + h / 2               |    - h / 2
 3523 |     | //     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh
 3524 |     | //                        |                          |
 3525 |     | //                       / qOvershoot               / qCurrent
 3526 |     | //
 3527 |     | //   )'
 3528 |     | //
 3529 |     | // and
 3530 |     | //                             - 8
 3531 |     | //    targetToOvershoot      e
 3532 |     | //  '------------------- := ------- * (
 3533 |     | //         2 ** 216            2
 3534 |     | //
 3535 |     | //     getZeroForOne()
 3536 |     | //
 3537 |     | //         / qTarget
 3538 |     | //        |    + h / 2
 3539 |     | //     ?  |  e         k(qTarget - h) dh
 3540 |     | //        |
 3541 |     | //       / qOvershoot
 3542 |     | //
 3543 |     | //         / qOvershoot
 3544 |     | //        |    - h / 2
 3545 |     | //     :  |  e         k(h - qTarget) dh
 3546 |     | //        |
 3547 |     | //       / qTarget
 3548 |     | //
 3549 |     | //   )'
 3550 |     | //
 3551 |     | // While searching for 'qOvershoot', the four integrals:
 3552 |     | //
 3553 |     | //  - 'currentToOvershoot',
 3554 |     | //
 3555 |     | //  - 'targetToOvershoot',
 3556 |     | //
 3557 |     | //  - 'originToOvershoot', and
 3558 |     | //
 3559 |     | //  - 'currentToOrigin',
 3560 |     | //
 3561 |     | // are kept track of. The following figure illustrates the ranges covered by
 3562 |     | // the above integrals in the case of 'getZeroForOne() == false', i.e.,
 3563 |     | // 'qCurrent < qTarget':
 3564 |     | //
 3565 |     | //           currentToOrigin                      currentToOvershoot
 3566 |     | //    exp(+ h / 2) * k(w(h))                      exp(- h / 2) * k(w(h))
 3567 |     | //                          \                    /
 3568 |     | //                           \                  /
 3569 |     | //                            \                /
 3570 |     | //              |<------------------->|<--------------->|
 3571 |     | //              |                     |                 |
 3572 |     | //              |                     |    qTarget      |
 3573 |     | //              |                     |       |         |
 3574 |     | //      +-------+---------------------+-------+---------+-----------+
 3575 |     | //      |       |                     |       |         |           |
 3576 |     | //    qLower    |                 qCurrent    |<------->|         qUpper
 3577 |     | //              |                                  /    |
 3578 |     | //              |                                 /     |
 3579 |     | //              |                targetToOvershoot      |
 3580 |     | //              |    exp(- h / 2) * k(h - qTarget)      |
 3581 |     | //              |                                       |
 3582 |     | //              |                                       |
 3583 |     | //              |<------------------------------------->|
 3584 |     | //              |                     /                 |
 3585 |     | //           qOrigin                 /              qOvershoot
 3586 |     | //                                  /
 3587 |     | //                                 /
 3588 |     | //                originToOvershoot
 3589 |     | //    exp(- h / 2) * k(h - qOrigin)
 3590 |     | //
 3591 |     | // Now, in order to find 'qOvershoot', we need to solve the equation:
 3592 |     | //
 3593 |     | //   'f(qOvershoot) == 0'
 3594 |     | //
 3595 |     | // where
 3596 |     | //
 3597 |     | //   'f(qOvershoot) := getZeroForOne() ? 
 3598 |     | //                     s0(qOvershoot) - s1(qOvershoot) : 
 3599 |     | //                     s1(qOvershoot) - s0(qOvershoot)',
 3600 |     | //
 3601 |     | // and the two functions 's0' and 's1' are defined as:
 3602 |     | //
 3603 |     | //                          - 8      / qTarget
 3604 |     | //                        e         |   + h / 2
 3605 |     | //                       ------- *  |  e        k(wAmended(h)) dh
 3606 |     | //                          2       |
 3607 |     | //                                 / qLower
 3608 |     | //   's1(qOvershoot) := ------------------------------------------',
 3609 |     | //                                integral1Incremented
 3610 |     | //
 3611 |     | //                          - 8      / qUpper
 3612 |     | //                        e         |   - h / 2
 3613 |     | //                       ------- *  |  e        k(wAmended(h)) dh
 3614 |     | //                          2       |
 3615 |     | //                                 / qTarget
 3616 |     | //   's0(qOvershoot) := ------------------------------------------'.
 3617 |     | //                                integral0Incremented
 3618 |     | //
 3619 |     | // Now, according to the amendement procedure which is described in
 3620 |     | // 'Curve.sol', if 'getZeroForOne() == false', we have:
 3621 |     | //
 3622 |     | //                       / k(w(h))            if  qOvershoot < h < qUpper
 3623 |     | //   'k(wAmended(h)) == |  k(h - qTarget)     if  qTarget < h < qOvershoot '
 3624 |     | //                      |  k(qOvershoot - h)  if  qOrigin < h < qTarget
 3625 |     | //                       \ k(w(h))            if  qLower < h < qOrigin
 3626 |     | //
 3627 |     | // and if 'getZeroForOne() == true', we have:
 3628 |     | //
 3629 |     | //                       / k(w(h))            if  qLower < h < qOvershoot
 3630 |     | //   'k(wAmended(h)) == |  k(qTarget - h)     if  qOvershoot < h < qTarget '.
 3631 |     | //                      |  k(h - qOvershoot)  if  qTarget < h < qOrigin
 3632 |     | //                       \ k(w(h))            if  qOrigin < h < qUpper
 3633 |     | //
 3634 |     | // For the case 'getZeroForOne() == false', the above formulas conclude that:
 3635 |     | //
 3636 |     | //  - the numerator of 's1' is equal to:
 3637 |     | //
 3638 |     | //        - 8     / qTarget
 3639 |     | //      e        |    + h / 2
 3640 |     | //    '------- * |  e         k(wAmended(h)) dh == 
 3641 |     | //        2      |
 3642 |     | //              / qLower
 3643 |     | //
 3644 |     | //        - 8     / qOrigin
 3645 |     | //      e        |    + h / 2
 3646 |     | //     ------- * |  e         k(wAmended(h)) dh +
 3647 |     | //        2      |
 3648 |     | //              / qLower
 3649 |     | //
 3650 |     | //                                - 8     / qTarget
 3651 |     | //                              e        |    + h / 2
 3652 |     | //                             ------- * |  e         k(wAmended(h)) dh ==
 3653 |     | //                                2      |
 3654 |     | //                                      / qOrigin
 3655 |     | //
 3656 |     | //        - 8     / qOrigin
 3657 |     | //      e        |    + h / 2
 3658 |     | //     ------- * |  e         k(w(h)) dh +
 3659 |     | //        2      |
 3660 |     | //              / qLower
 3661 |     | //
 3662 |     | //                                - 8     / qTarget
 3663 |     | //                              e        |    + h / 2
 3664 |     | //                             ------- * |  e         k(qOvershoot - h) dh ==
 3665 |     | //                                2      |
 3666 |     | //                                      / qOrigin
 3667 |     | //
 3668 |     | //        - 8     / qOrigin
 3669 |     | //      e        |    + h / 2
 3670 |     | //     ------- * |  e         k(w(h)) dh +
 3671 |     | //        2      |
 3672 |     | //              / qLower
 3673 |     | //
 3674 |     | //                                - 8     / qOvershoot
 3675 |     | //                              e        |    + h / 2
 3676 |     | //                             ------- * |  e         k(qOvershoot - h) dh -
 3677 |     | //                                2      |
 3678 |     | //                                      / qOrigin
 3679 |     | //
 3680 |     | //                                - 8     / qOvershoot
 3681 |     | //                              e        |    + h / 2
 3682 |     | //                             ------- * |  e         k(qOvershoot - h) dh ==
 3683 |     | //                                2      |
 3684 |     | //                                      / qTarget
 3685 |     | //
 3686 |     | //        - 8     / qTarget
 3687 |     | //      e        |    + h / 2
 3688 |     | //     ------- * |  e         k(w(h)) dh - 
 3689 |     | //        2      |
 3690 |     | //              / qLower
 3691 |     | //
 3692 |     | //        - 8     / qTarget                   - 8     / qCurrent
 3693 |     | //      e        |    + h / 2               e        |    + h / 2
 3694 |     | //     ------- * |  e         k(w(h)) dh - ------- * |  e         k(w(h)) dh +
 3695 |     | //        2      |                            2      |
 3696 |     | //              / qCurrent                          / qOrigin
 3697 |     | //
 3698 |     | //        - 8 + (qOrigin + qOvershoot) / 2     / qOvershoot
 3699 |     | //      e                                     |    - h / 2
 3700 |     | //     ------------------------------------ * |  e         k(h - qOrigin) dh -
 3701 |     | //                        2                   |
 3702 |     | //                                           / qOrigin
 3703 |     | //
 3704 |     | //        - 8 + (qTarget + qOvershoot) / 2     / qOvershoot
 3705 |     | //      e                                     |    - h / 2
 3706 |     | //     ------------------------------------ * |  e         k(h - qTarget) dh ==
 3707 |     | //                        2                   |
 3708 |     | //                                           / qTarget
 3709 |     | //
 3710 |     | //      integral1Incremented - incomingCurrentToTarget - currentToOrigin
 3711 |     | //     ------------------------------------------------------------------ + 
 3712 |     | //                                  2 ** 216
 3713 |     | //
 3714 |     | //      exp((qOrigin + qOvershoot) / 2) * originToOvershoot
 3715 |     | //     ----------------------------------------------------- - 
 3716 |     | //                            2 ** 216
 3717 |     | //
 3718 |     | //      exp((qTarget + qOvershoot) / 2) * targetToOvershoot
 3719 |     | //     -----------------------------------------------------'.
 3720 |     | //                            2 ** 216
 3721 |     | //
 3722 |     | //  - the numerator of 's0' is equal to:
 3723 |     | //
 3724 |     | //        - 8     / qUpper
 3725 |     | //      e        |    - h / 2
 3726 |     | //    '------- * |  e         k(wAmended(h)) dh == 
 3727 |     | //        2      |
 3728 |     | //              / qTarget
 3729 |     | //
 3730 |     | //        - 8     / qOvershoot
 3731 |     | //      e        |    - h / 2
 3732 |     | //     ------- * |  e         k(wAmended(h)) dh +
 3733 |     | //        2      |
 3734 |     | //              / qTarget
 3735 |     | //
 3736 |     | //                                - 8     / qUpper
 3737 |     | //                              e        |    - h / 2
 3738 |     | //                             ------- * |  e         k(wAmended(h)) dh == 
 3739 |     | //                                2      |
 3740 |     | //                                      / qOvershoot
 3741 |     | //
 3742 |     | //        - 8     / qOvershoot
 3743 |     | //      e        |    - h / 2
 3744 |     | //     ------- * |  e         k(h - qTarget) dh +
 3745 |     | //        2      |
 3746 |     | //              / qTarget
 3747 |     | //
 3748 |     | //                                - 8     / qUpper
 3749 |     | //                              e        |    - h / 2
 3750 |     | //                             ------- * |  e         k(w(h)) dh == 
 3751 |     | //                                2      |
 3752 |     | //                                      / qOvershoot
 3753 |     | //
 3754 |     | //        - 8     / qOvershoot
 3755 |     | //      e        |    - h / 2
 3756 |     | //     ------- * |  e         k(h - qTarget) dh +
 3757 |     | //        2      |
 3758 |     | //              / qTarget
 3759 |     | //
 3760 |     | //        - 8     / qTarget                   - 8     / qUpper
 3761 |     | //      e        |    - h / 2               e        |    - h / 2
 3762 |     | //     ------- * |  e         k(w(h)) dh + ------- * |  e         k(w(h)) dh -
 3763 |     | //        2      |                            2      |
 3764 |     | //              / qCurrent                          / qTarget
 3765 |     | //
 3766 |     | //        - 8     / qOvershoot
 3767 |     | //      e        |
 3768 |     | //     ------- * |  e         k(w(h)) dh == 
 3769 |     | //        2      |
 3770 |     | //              / qCurrent
 3771 |     | //
 3772 |     | //      targetToOvershoot + currentToTarget
 3773 |     | //     ------------------------------------- + 
 3774 |     | //                    2 ** 216
 3775 |     | //
 3776 |     | //      integral0Incremented - currentToOvershoot
 3777 |     | //     -------------------------------------------'.
 3778 |     | //                       2 ** 216
 3779 |     | //
 3780 |     | // Similar arguments can be made for the case 'getZeroForOne() == true' and for
 3781 |     | // both cases, we have:
 3782 |     | //
 3783 |     | //   'f(qOvershoot) := getZeroForOne() ? (
 3784 |     | //
 3785 |     | //      (
 3786 |     | //
 3787 |     | //        exp(- (qOrigin + qOvershoot) / 2) * originToOvershoot -
 3788 |     | //
 3789 |     | //        exp(- (qTarget + qOvershoot) / 2) * targetToOvershoot - 
 3790 |     | //
 3791 |     | //        incomingCurrentToTarget - currentToOrigin
 3792 |     | //
 3793 |     | //      ) / integral0Incremented - (
 3794 |     | //
 3795 |     | //        targetToOvershoot + currentToTarget - currentToOvershoot
 3796 |     | //      
 3797 |     | //      ) / integral1Incremented
 3798 |     | //
 3799 |     | //    ) : (
 3800 |     | //
 3801 |     | //      (
 3802 |     | //
 3803 |     | //        exp(+ (qOrigin + qOvershoot) / 2) * originToOvershoot -
 3804 |     | //
 3805 |     | //        exp(+ (qTarget + qOvershoot) / 2) * targetToOvershoot - 
 3806 |     | //
 3807 |     | //        incomingCurrentToTarget - currentToOrigin
 3808 |     | //
 3809 |     | //      ) / integral1Incremented - (
 3810 |     | //
 3811 |     | //        targetToOvershoot + currentToTarget - currentToOvershoot
 3812 |     | //      
 3813 |     | //      ) / integral0Incremented
 3814 |     | //
 3815 |     | //    )'.
 3816 |     | //
 3817 |     | // We use Newton's method in order to pinpoint the precise value for
 3818 |     | // 'qOvershoot' which satisfies:
 3819 |     | //
 3820 |     | //   'f(qOvershoot) == 0'.
 3821 |     | //
 3822 |     | // To this end, we need access to a simple and closed-form expression for all
 3823 |     | // of the above integrals. Hence, we first need to restrict our search to a
 3824 |     | // domain in which both 'k(w(.))' and 'k(|h - qTarget|)' are linear.
 3825 |     | //
 3826 |     | // Hence, prior to the above-mentioned numerical search, we first need to move
 3827 |     | // 'qOvershoot' from 'qTarget' towards 'qNext' until we determine the
 3828 |     | // followings:
 3829 |     | //
 3830 |     | //   - The piece of 'k(w(.))' to which 'qOvershoot' belongs.
 3831 |     | //
 3832 |     | //   - The piece of 'k(|h - qTarget|)' to which 'qOvershoot' belongs.
 3833 |     | //
 3834 |     | // The former is accomplished via a similar procedure as we delineated before
 3835 |     | // in search for 'qTarget'. Put simply, we start with
 3836 |     | //
 3837 |     | //   'qOvershoot := qTarget'
 3838 |     | //
 3839 |     | // because
 3840 |     | //
 3841 |     | //   'f(qTarget) < 0',
 3842 |     | //
 3843 |     | // and we keep moving 'qOvershoot' forward until we encounter a point that
 3844 |     | // satisfies:
 3845 |     | //
 3846 |     | //   'f(qOvershoot) > 0'.
 3847 |     | //
 3848 |     | // Throughout the movement from 'qTarget' towards 'qNext', we keep track of the
 3849 |     | // current phase under exploration using the variables:
 3850 |     | //
 3851 |     | //   - 'indexCurve', 'qOrigin', 'qEnd', 'direction',
 3852 |     | //
 3853 |     | // and we keep track of the current piece of the kernel function using the
 3854 |     | // variables:
 3855 |     | //
 3856 |     | //   - 'indexKernelTotal', 'cTotal0', 'cTotal1', 'qTotal0', 'qTotal1'
 3857 |     | //
 3858 |     | // Throughout the search for 'qOvershoot', the piece of 'k(|h - qTarget|)' to
 3859 |     | // which 'qOvershoot' belongs is determined using an additional index:
 3860 |     | //
 3861 |     | //  - 'indexKernelForward' keeps track of the pieces of the function
 3862 |     | //    'k(|h - qTarget|)' that we enumerate as we move from 'qTarget' to
 3863 |     | //    'qOvershoot'. Each piece of 'k(|h - qTarget|)' can be characterized via
 3864 |     | //    the following four vertical and horizontal coordinates:
 3865 |     | //
 3866 |     | //      'cForward0 := c[indexKernelForward - 1]',
 3867 |     | //
 3868 |     | //      'qForward0 := getZeroForOne() ? 
 3869 |     | //                    qTarget - b[indexKernelForward - 1] : 
 3870 |     | //                    qTarget + b[indexKernelForward - 1]',
 3871 |     | //
 3872 |     | //      'cForward1 := c[indexKernelForward]',
 3873 |     | //
 3874 |     | //      'qForward1 := getZeroForOne() ? 
 3875 |     | //                    qTarget - b[indexKernelForward] : 
 3876 |     | //                    qTarget + b[indexKernelForward]'.
 3877 |     | //
 3878 |     | //    The pair '(cForward0, qForward0)' is stored in the memory space which is
 3879 |     | //    pointed to by '_forward0_' and similarly, the pair
 3880 |     | //    '(cForward1, qForward1)' is stored in the memory space which is pointed
 3881 |     | //    to by '_forward1_'.
 3882 |     | //
 3883 |     | //    Hence, the function 'k(|. - qTarget|)' is linear within the range:
 3884 |     | //
 3885 |     | //      'min(qForward0, qForward1) < q < max(qForward0, qForward1)'.
 3886 |     | //
 3887 |     | //    and the function 'k(w(.))' is linear within the intersection of the two
 3888 |     | //    ranges:
 3889 |     | //
 3890 |     | //      'min(q[indexCurve + 2], qEnd) < q < max(q[indexCurve + 2], qEnd)',
 3891 |     | //
 3892 |     | //    and
 3893 |     | //
 3894 |     | //      'min(qTotal0, qTotal1) < q < max(qTotal0, qTotal1)'.
 3895 |     | //
 3896 |     | //    Now, in order to have closed-forms for all of the integrals that the
 3897 |     | //    formula for 'f(qOvershoot)' comprises, at each step, we keep track of the
 3898 |     | //    domain in which both 'k(w(.))' and 'k(|. - qTarget|)' are linear and we
 3899 |     | //    update this domain as we move forward in our search. Hence, with every
 3900 |     | //    update of 'indexCurve', 'indexKernelTotal', and 'indexKernelForward', we
 3901 |     | //    make the following two updates:
 3902 |     | //
 3903 |     | //      'qBegin := (
 3904 |     | //                   direction == getZeroForOne()
 3905 |     | //                 ) ? (
 3906 |     | //                   direction ? 
 3907 |     | //                   max(max(q[indexCurve + 2], qTotal0), qForward0) : 
 3908 |     | //                   min(min(q[indexCurve + 2], qTotal0), qForward0)
 3909 |     | //                 ) : (
 3910 |     | //                   direction ? 
 3911 |     | //                   max(q[indexCurve + 2], qTotal0) : 
 3912 |     | //                   min(q[indexCurve + 2], qTotal0)
 3913 |     | //                 )',
 3914 |     | //
 3915 |     | //      'qOvershoot := (
 3916 |     | //                       direction == getZeroForOne()
 3917 |     | //                     ) ? (
 3918 |     | //                       direction ? 
 3919 |     | //                       max(max(qEnd, qTotal1), qForward1) : 
 3920 |     | //                       min(min(qEnd, qTotal1), qForward1)
 3921 |     | //                     ) : (
 3922 |     | //                       direction ? 
 3923 |     | //                       max(qEnd, qTotal1) : 
 3924 |     | //                       min(qEnd, qTotal1)
 3925 |     | //                     )',
 3926 |     | //
 3927 |     | //    where 'qBegin' and 'qOvershoot' are stored, respectively, in the memory
 3928 |     | //    spaces that are pointed to by '_begin_' and '_overshoot_'. Both values
 3929 |     | //    are updated with each transition to a new phase, a new piece of
 3930 |     | //    'k(w(.))', or a new piece of 'k(|. - qTarget|)'.
 3931 |     | //
 3932 |     | //    The process of enumerating the pieces of 'k(|. - qTarget|)' starts with
 3933 |     | //    the initial state 'indexKernelForward := 1'.
 3934 |     | //
 3935 |     | // Determining the search domain to which 'qOvershoot' belongs and in which
 3936 |     | // both 'k(w(.))' and 'k(|. - qTarget|)' are linear, is conducted by calling
 3937 |     | // the method 'moveOvershoot' from 'Interval.sol' in a loop until the following
 3938 |     | // condition is met:
 3939 |     | //
 3940 |     | //   'f(qBegin) <= 0' and 'f(qOvershoot) >  0'.
 3941 |     | //
 3942 |     | // Then, according to the intermediate value theorem, there exists a solution
 3943 |     | // in this search domain which satisfies:
 3944 |     | //
 3945 |     | //   'f(qOvershoot) == 0'.
 3946 |     | //
 3947 |     | // Then, this solution is found by calling the method 'searchOvershoot' from
 3948 |     | // 'Interval.sol'.
 3949 |     | //
 3950 |     | // In order to calculate the Newton step at each stage, we need to find the
 3951 |     | // derivative of 'f(.)'. If 'getZeroForOne() == false', then we have:
 3952 |     | //
 3953 |     | //          d f
 3954 |     | //   '-------------- ==
 3955 |     | //     d qOvershoot
 3956 |     | //
 3957 |     | //    (
 3958 |     | //
 3959 |     | //        + (qOrigin + qOvershoot) / 2    originToOvershoot
 3960 |     | //      e                              * ------------------- -
 3961 |     | //                                              2
 3962 |     | //
 3963 |     | //        + (qTarget + qOvershoot) / 2    targetToOvershoot
 3964 |     | //      e                              * ------------------- +
 3965 |     | //                                              2
 3966 |     | //         - 8 + qOrigin / 2
 3967 |     | //       e
 3968 |     | //      --------------------- * k(qOvershoot - qOrigin) -
 3969 |     | //                2
 3970 |     | //
 3971 |     | //         - 8 + qTarget / 2
 3972 |     | //       e
 3973 |     | //      --------------------- * k(qOvershoot - qTarget)
 3974 |     | //                2
 3975 |     | //
 3976 |     | //    ) / integral1Incremented - (
 3977 |     | //
 3978 |     | //         - 8 - qOvershoot / 2
 3979 |     | //       e
 3980 |     | //      ------------------------ * k(qOvershoot - qTarget) - 
 3981 |     | //                  2
 3982 |     | //
 3983 |     | //         - 8 - qOvershoot / 2
 3984 |     | //       e
 3985 |     | //      ------------------------ * k(qOvershoot - qOrigin) 
 3986 |     | //                  2
 3987 |     | //
 3988 |     | //    ) / integral0Incremented'.
 3989 |     | //
 3990 |     | // If 'getZeroForOne() == true', then we have:
 3991 |     | //
 3992 |     | //          d f
 3993 |     | //   '-------------- ==
 3994 |     | //     d qOvershoot
 3995 |     | //
 3996 |     | //    (
 3997 |     | //
 3998 |     | //         - 8 + qOvershoot / 2
 3999 |     | //       e
 4000 |     | //      ------------------------ * k(qTarget - qOvershoot) - 
 4001 |     | //                  2
 4002 |     | //
 4003 |     | //         - 8 + qOvershoot / 2
 4004 |     | //       e
 4005 |     | //      ------------------------ * k(qOrigin - qOvershoot) 
 4006 |     | //                  2
 4007 |     | //
 4008 |     | //    ) / integral1Incremented - (
 4009 |     | //
 4010 |     | //        - (qOrigin + qOvershoot) / 2    originToOvershoot
 4011 |     | //      e                              * ------------------- -
 4012 |     | //                                              2
 4013 |     | //
 4014 |     | //        - (qTarget + qOvershoot) / 2    targetToOvershoot
 4015 |     | //      e                              * ------------------- +
 4016 |     | //                                              2
 4017 |     | //         - 8 - qOrigin / 2
 4018 |     | //       e
 4019 |     | //      --------------------- * k(qOrigin - qOvershoot) - 
 4020 |     | //                2
 4021 |     | //
 4022 |     | //         - 8 - qTarget / 2
 4023 |     | //       e
 4024 |     | //      --------------------- * k(qTarget - qOvershoot)
 4025 |     | //                2
 4026 |     | //
 4027 |     | //    ) / integral0Incremented'.
 4028 |     | //
 4029 |     | // After the calulation of 'qOvershoot', the amended values 'growthAmended', 
 4030 |     | // 'integral0Amended' and 'integral1Amended' are determined as follows:
 4031 |     | //
 4032 |     | //                         growth              growth
 4033 |     | //  'growthAmended == ---------------- == ----------------',
 4034 |     | //                     s0(qOvershoot)      s1(qOvershoot)
 4035 |     | //
 4036 |     | //                            - 8     / qUpper
 4037 |     | //    integral0Amended      e        |    - h / 2
 4038 |     | //  '------------------ := ------- * |  e         k(wAmended(h)) dh == 
 4039 |     | //        2 ** 216            2      |
 4040 |     | //                                  / qTarget
 4041 |     | //
 4042 |     | //                              growth        integral0Incremented
 4043 |     | //                         --------------- * ----------------------',
 4044 |     | //                          growthAmended           2 ** 216
 4045 |     | //
 4046 |     | //                            - 8     / qTarget
 4047 |     | //    integral1Amended      e        |    + h / 2
 4048 |     | //  '------------------ := ------- * |  e         k(wAmended(h)) dh == 
 4049 |     | //        2 ** 216            2      |
 4050 |     | //                                  / qLower
 4051 |     | //
 4052 |     | //                              growth        integral0Incremented
 4053 |     | //                         --------------- * ----------------------',
 4054 |     | //                          growthAmended           2 ** 216
 4055 |     | //
 4056 |     | // where the ranges covered by 'integral0Amended' and 'integral1Amended' are
 4057 |     | // illustrated as follows:
 4058 |     | //
 4059 |     | //                         integral0Amended
 4060 |     | //                         exp(- h / 2) * k(wAmended(h))
 4061 |     | //                                                      \
 4062 |     | //             integral1Amended                          \
 4063 |     | //             exp(+ h / 2) * k(wAmended(h))              \
 4064 |     | //      |<-------------------------------------->|<---------------->|
 4065 |     | //      |                                        |                  |
 4066 |     | //      +----------------------------------------+------------------+
 4067 |     | //      |                                        |                  |
 4068 |     | //    qLower                                  qTarget             qUpper
 4069 |     | //
 4070 |     | // In the following section, the memory pointers that are used for the purpose
 4071 |     | // of the above calculations are introduced.
 4072 |     | uint16 constant _interval_ = 644;
 4073 |     | 
 4074 |     | // The direction of the current 'phase' under exploration. Everytime that we
 4075 |     | // move from one 'phase' to the next, by decrementing 'indexCurve' this binary
 4076 |     | // value is flipped. 'direction' should not be confused with 'zeroForOne' which
 4077 |     | // does not change throughout a swap. Define:
 4078 |     | //
 4079 |     | //  'qEnd := q[indexCurve]'.
 4080 |     | //
 4081 |     | // 'direction = 0x00' if 'q[indexCurve + 2] < qEnd', i.e., when we are moving
 4082 |     | // towards '+oo', in search for 'qTarget' or 'qOvershoot'. In this case, for
 4083 |     | // every 'q[indexCurve + 2] < h < qEnd', we have:
 4084 |     | //
 4085 |     | //  'w(h) := h - qOrigin'.
 4086 |     | //
 4087 |     | // 'direction = 0xFF' if 'qEnd < q[indexCurve + 2]', i.e., when we are moving
 4088 |     | // towards '-oo', in search for 'qTarget' or 'qOvershoot'. In this case, for
 4089 |     | // every 'qEnd < h < q[indexCurve + 2]', we have:
 4090 |     | //
 4091 |     | //  'w(h) := qOrigin - h'.
 4092 |     | //
 4093 |     | uint16 constant _direction_ = 644;
 4094 |     | 
 4095 |     | // The index of 'qEnd' among the members of the 'curve', i.e.,
 4096 |     | //
 4097 |     | //  'qEnd == q[indexCurve]'.
 4098 |     | //
 4099 |     | // While searching for 'qTarget' and 'qOvershoot', the value of 'indexCurve'
 4100 |     | // starts from 'curveLength - twoIndex' and is decremented by 'oneIndex' with
 4101 |     | // each run of the function 'movePhase()' in 'Interval.sol'.
 4102 |     | uint16 constant _indexCurve_ = 645;
 4103 |     | 
 4104 |     | // The index of 'qTotal1' and 'cTotal1' among the breakpoints of the 'kernel',
 4105 |     | // i.e.,
 4106 |     | //
 4107 |     | //  'cTotal0 := c[indexKernelTotal - 1]',
 4108 |     | //
 4109 |     | //  'qTotal0 := direction ? 
 4110 |     | //              qOrigin - b[indexKernelTotal - 1] : 
 4111 |     | //              qOrigin + b[indexKernelTotal - 1]',
 4112 |     | //
 4113 |     | //  'cTotal1 == c[indexKernelTotal]',
 4114 |     | //
 4115 |     | //  'qTotal1 == direction ? 
 4116 |     | //              qOrigin - b[indexKernelTotal] : 
 4117 |     | //              qOrigin + b[indexKernelTotal]'.
 4118 |     | //
 4119 |     | // While searching for 'qTarget' and 'qOvershoot', the value of
 4120 |     | // 'indexKernelTotal' starts from 'oneIndex' and is incremented by 'oneIndex'
 4121 |     | // with each transition to a new piece of kernel as we explore 'k(w(h))'.
 4122 |     | //
 4123 |     | // If 'getDirection() == false', then we have:
 4124 |     | //
 4125 |     | //  'k(w(h)) == k(h - qOrigin) == k_indexKernelTotal(h - qOrigin) :=
 4126 |     | //
 4127 |     | //                         cTotal1 - cTotal0
 4128 |     | //              cTotal0 + ------------------- * (h - qTotal0)'.
 4129 |     | //                         qTotal1 - qTotal0
 4130 |     | //
 4131 |     | // for every 'qBegin < h < qTarget'.
 4132 |     | //
 4133 |     | // If 'getDirection() == true', then we have:
 4134 |     | //
 4135 |     | //  'k(w(h)) == k(qOrigin - h) == k_indexKernelTotal(qOrigin - h) :=
 4136 |     | //
 4137 |     | //                         cTotal1 - cTotal0
 4138 |     | //              cTotal0 + ------------------- * (qTotal0 - h)'.
 4139 |     | //                         qTotal0 - qTotal1
 4140 |     | //
 4141 |     | // for every 'qTarget < h < qBegin'.
 4142 |     | uint16 constant _indexKernelTotal_ = 647;
 4143 |     | 
 4144 |     | // The index of 'qForward1' and 'cForward1' among the breakpoints of the
 4145 |     | // 'kernel', i.e.,
 4146 |     | //
 4147 |     | //  'cForward0 := c[indexKernelForward - 1]',
 4148 |     | //
 4149 |     | //  'qForward0 := getZeroForOne() ? 
 4150 |     | //                qTarget - b[indexKernelForward - 1] : 
 4151 |     | //                qTarget + b[indexKernelForward - 1]',
 4152 |     | //
 4153 |     | //  'cForward1 := c[indexKernelForward]',
 4154 |     | //
 4155 |     | //  'qForward1 := getZeroForOne() ? 
 4156 |     | //                qTarget - b[indexKernelForward] : 
 4157 |     | //                qTarget + b[indexKernelForward]'.
 4158 |     | //
 4159 |     | // While searching for 'qOvershoot', the value of 'indexKernelForward' starts
 4160 |     | // from 'oneIndex' and is incremented by 'oneIndex' with each transition to a
 4161 |     | // new piece of kernel.
 4162 |     | //
 4163 |     | // If 'getZeroForOne() == false', then we have:
 4164 |     | //
 4165 |     | //  'k(h - qTarget) == k_indexKernelForward(h - qTarget) :=
 4166 |     | //
 4167 |     | //                                  cForward1 - cForward0
 4168 |     | //                     cForward0 + ----------------------- * (h - qForward0)'.
 4169 |     | //                                  qForward1 - qForward0
 4170 |     | //
 4171 |     | // for every 'qBegin < h < qOvershoot'.
 4172 |     | //
 4173 |     | // If 'getZeroForOne() == true', then we have:
 4174 |     | //
 4175 |     | //  'k(qTarget - h) == k_indexKernelForward(qTarget - h) :=
 4176 |     | //
 4177 |     | //                                  cForward1 - cForward0
 4178 |     | //                     cForward0 + ----------------------- * (qForward0 - h)'.
 4179 |     | //                                  qForward0 - qForward1
 4180 |     | //
 4181 |     | // for every 'qOvershoot < h < qBegin'.
 4182 |     | uint16 constant _indexKernelForward_ = 649;
 4183 |     | 
 4184 |     | // Let 'pLower' and 'pUpper' be the minimum and maximum price in the active
 4185 |     | // liquidity interval and define
 4186 |     | //
 4187 |     | //  'qLower := log(pLower / pOffset)',
 4188 |     | //  'qUpper := log(pUpper / pOffset)'.
 4189 |     | //  'qLimitWithinInterval := min(max(qLower, qLimit), qUpper)'
 4190 |     | //
 4191 |     | // The value set as 'logPriceLimitOffsetted' may be outside of the current
 4192 |     | // active liquidity interval. In such cases, we first need to perform a swap
 4193 |     | // towards the current interval boundary and then we transition to a new
 4194 |     | // interval. In order to perform the former step, 'qLimitWithinInterval' is
 4195 |     | // calculated and its offset binary 'X59' representation, i.e.,
 4196 |     | //
 4197 |     | //  '_origin_.log() := (2 ** 59) * (16 + qOrigin)'
 4198 |     | //
 4199 |     | // is stored in the memory space which pointed to by
 4200 |     | // '_logPriceLimitOffsettedWithinInterval_'.
 4201 |     | uint16 constant _logPriceLimitOffsettedWithinInterval_ = 651;
 4202 |     | 
 4203 |     | // Let 'pCurrent' represent the current price within the active liquidity
 4204 |     | // interval (prior to the movement to 'qTarget' or 'qNext'). This value
 4205 |     | // corresponds to the last member of the curve. Define:
 4206 |     | //
 4207 |     | //  'qCurrent := log(pCurrent / pOffset)',
 4208 |     | //
 4209 |     | // The 62 bytes memory space which is pointed to by '_current_' hosts the
 4210 |     | // following values:
 4211 |     | //
 4212 |     | //  '_current_.log() := (2 ** 59) * (16 + qCurrent)',
 4213 |     | //  '_current_.sqrt(false) := (2 ** 216) * exp(- 8 - qCurrent / 2)',
 4214 |     | //  '_current_.sqrt(true) := (2 ** 216) * exp(- 8 + qCurrent / 2)'.
 4215 |     | //
 4216 |     | // which can be accessed via 'PriceLibrary'. The logarithmic price
 4217 |     | // '_current_.log()' occupies 64 bits, whereas '_current_.sqrt(false)' and
 4218 |     | // '_current_.sqrt(true)' occupy 216 bits each.
 4219 |     | uint16 constant _current_ = 659;
 4220 |     | 
 4221 |     | // Let 'indexCurve' represent the index of the current phase under exploration.
 4222 |     | // Define:
 4223 |     | //
 4224 |     | //  'qOrigin := q[indexCurve + 1]',
 4225 |     | //
 4226 |     | //  'qEnd := q[indexCurve]'.
 4227 |     | //
 4228 |     | // If 'getDirection() == false', for every 'q[indexCurve + 2] < h < qEnd', we
 4229 |     | // have:
 4230 |     | //
 4231 |     | //  'w(h) := h - qOrigin'.
 4232 |     | //
 4233 |     | // If 'getDirection() == true', for every 'qEnd < h < q[indexCurve + 2]', we
 4234 |     | // have:
 4235 |     | //
 4236 |     | //  'w(h) := qOrigin - h'.
 4237 |     | //
 4238 |     | // The 62 bytes memory space which is pointed to by '_origin_' hosts the
 4239 |     | // following values:
 4240 |     | //
 4241 |     | //  '_origin_.log() := (2 ** 59) * (16 + qOrigin)',
 4242 |     | //  '_origin_.sqrt(false) := (2 ** 216) * exp(- 8 - qOrigin / 2)',
 4243 |     | //  '_origin_.sqrt(true) := (2 ** 216) * exp(- 8 + qOrigin / 2)'.
 4244 |     | //
 4245 |     | // which can be accessed via 'PriceLibrary'. The logarithmic price
 4246 |     | // '_origin_.log()' occupies 64 bits, whereas '_origin_.sqrt(false)' and
 4247 |     | // '_origin_.sqrt(true)' occupy 216 bits each.
 4248 |     | uint16 constant _origin_ = 721;
 4249 |     | 
 4250 |     | // At every step of searching for 'qTarget', the range
 4251 |     | //
 4252 |     | //  'min(qBegin, qTarget) < h < max(qBegin, qTarget)'
 4253 |     | //
 4254 |     | // represents a piece of the liquidity distribution function 'k(w(.))' in which
 4255 |     | // 'k(w(.))' is linear. More precisely, if 'getDirection() == false', we have:
 4256 |     | //
 4257 |     | //  'k(w(h)) == k(h - qOrigin) == k_indexKernelTotal(h - qOrigin) :=
 4258 |     | //
 4259 |     | //                         cTotal1 - cTotal0
 4260 |     | //              cTotal0 + ------------------- * (h - qTotal0)'.
 4261 |     | //                         qTotal1 - qTotal0
 4262 |     | //
 4263 |     | // for every 'qBegin < h < qTarget' and if 'getDirection() == true', we have:
 4264 |     | //
 4265 |     | //  'k(w(h)) == k(qOrigin - h) == k_indexKernelTotal(qOrigin - h) :=
 4266 |     | //
 4267 |     | //                         cTotal1 - cTotal0
 4268 |     | //              cTotal0 + ------------------- * (qTotal0 - h)'.
 4269 |     | //                         qTotal0 - qTotal1
 4270 |     | //
 4271 |     | // for every 'qTarget < h < qBegin'.
 4272 |     | //
 4273 |     | // At the stage where we search for 'qTarget', we have
 4274 |     | //
 4275 |     | //  'qBegin := direction ? 
 4276 |     | //             min(q[indexCurve + 2], qTotal0) : 
 4277 |     | //             max(q[indexCurve + 2], qTotal0)'.
 4278 |     | //
 4279 |     | // At every step of searching for 'qOvershoot', the following inequality
 4280 |     | //
 4281 |     | //  'min(qBegin, qOvershoot) < h < max(qBegin, qOvershoot)'
 4282 |     | //
 4283 |     | // represents a range in which both 'k(w(.))' and 'k(|. - qTarget|)' are
 4284 |     | // linear. More precisely, if 'getZeroForOne() == false', we have:
 4285 |     | //
 4286 |     | //  'k(h - qTarget) == k_indexKernelForward(h - qTarget) :=
 4287 |     | //
 4288 |     | //                                  cForward1 - cForward0
 4289 |     | //                     cForward0 + ----------------------- * (h - qForward0)'.
 4290 |     | //                                  qForward1 - qForward0
 4291 |     | //
 4292 |     | // for every 'qBegin < h < qOvershoot' and if 'getZeroForOne() == true', we
 4293 |     | // have:
 4294 |     | //
 4295 |     | //  'k(qTarget - h) == k_indexKernelForward(qTarget - h) :=
 4296 |     | //
 4297 |     | //                                  cForward1 - cForward0
 4298 |     | //                     cForward0 + ----------------------- * (qForward0 - h)'.
 4299 |     | //                                  qForward0 - qForward1
 4300 |     | //
 4301 |     | // for every 'qOvershoot < h < qBegin'.
 4302 |     | //
 4303 |     | // At the stage where we search for 'qOvershoot', we have
 4304 |     | //
 4305 |     | //  'qBegin := (
 4306 |     | //               direction == getZeroForOne()
 4307 |     | //             ) ? (
 4308 |     | //               direction ? 
 4309 |     | //               max(max(q[indexCurve + 2], qTotal0), qForward0) : 
 4310 |     | //               min(min(q[indexCurve + 2], qTotal0), qForward0)
 4311 |     | //             ) : (
 4312 |     | //               direction ? 
 4313 |     | //               max(q[indexCurve + 2], qTotal0) : 
 4314 |     | //               min(q[indexCurve + 2], qTotal0)
 4315 |     | //             )',
 4316 |     | //
 4317 |     | // The 62 bytes memory space which is pointed to by '_begin_' hosts the
 4318 |     | // following values:
 4319 |     | //
 4320 |     | //  '_begin_.log() := (2 ** 59) * (16 + qBegin)',
 4321 |     | //  '_begin_.sqrt(false) := (2 ** 216) * exp(- 8 - qBegin / 2)',
 4322 |     | //  '_begin_.sqrt(true) := (2 ** 216) * exp(- 8 + qBegin / 2)'.
 4323 |     | //
 4324 |     | // which can be accessed via 'PriceLibrary'. The logarithmic price
 4325 |     | // '_begin_.log()' occupies 64 bits, whereas '_begin_.sqrt(false)' and
 4326 |     | // '_begin_.sqrt(true)' occupy 216 bits each.
 4327 |     | uint16 constant _begin_ = 783;
 4328 |     | 
 4329 |     | // Let 'indexCurve' represent the index of the current phase under exploration.
 4330 |     | // Define:
 4331 |     | //
 4332 |     | //  'qOrigin := q[indexCurve + 1]',
 4333 |     | //
 4334 |     | //  'qEnd := q[indexCurve]'.
 4335 |     | //
 4336 |     | // If 'getDirection() == false', for every 'q[indexCurve + 2] < h < qEnd', we
 4337 |     | // have:
 4338 |     | //
 4339 |     | //  'w(h) := h - qOrigin'.
 4340 |     | //
 4341 |     | // If 'getDirection() == true', for every 'qEnd < h < q[indexCurve + 2]', we
 4342 |     | // have:
 4343 |     | //
 4344 |     | //  'w(h) := qOrigin - h'.
 4345 |     | //
 4346 |     | // The 62 bytes memory space which is pointed to by '_end_' hosts the following
 4347 |     | // values:
 4348 |     | //
 4349 |     | //  '_end_.log() := (2 ** 59) * (16 + qEnd)',
 4350 |     | //  '_end_.sqrt(false) := (2 ** 216) * exp(- 8 - qEnd / 2)',
 4351 |     | //  '_end_.sqrt(true) := (2 ** 216) * exp(- 8 + qEnd / 2)'.
 4352 |     | //
 4353 |     | // which can be accessed via 'PriceLibrary'. The logarithmic price
 4354 |     | // '_end_.log()' occupies 64 bits, whereas '_end_.sqrt(false)' and
 4355 |     | // '_end_.sqrt(true)' occupy 216 bits each.
 4356 |     | uint16 constant _end_ = 845;
 4357 |     | 
 4358 |     | // Every visit to a liquidity interval as part of a swap involves the movement
 4359 |     | // of price from 'pCurrent' to 'pTarget'. Define:
 4360 |     | //
 4361 |     | //  'qCurrent := log(pCurrent / pOffset)',
 4362 |     | //  'qTarget := log(pTarget / pOffset)',
 4363 |     | //
 4364 |     | // and assume that
 4365 |     | //
 4366 |     | //  'qLower <= qCurrent <= qUpper',
 4367 |     | //  'qLower <= qTarget <= qUpper',
 4368 |     | //
 4369 |     | // where '[qLower, qUpper]' represents the current active liquidity interval.
 4370 |     | //
 4371 |     | // At first 'qTarget' is an unknown value which will be determined based on one
 4372 |     | // of the followings:
 4373 |     | //
 4374 |     | //  - 'qLimitWithinInterval', which is calculated based on the input
 4375 |     | //    'logPriceLimit' as well as 'qLower' and 'qUpper'. It is stored in the
 4376 |     | //    memory space which is pointed to by
 4377 |     | //    '_logPriceLimitOffsettedWithinInterval_'.
 4378 |     | //
 4379 |     | //  - 'integralLimit', which is calculated based on the input 'amountSpecified'
 4380 |     | //    and is stored in the memory space which is pointed to by
 4381 |     | //    '_integralLimit_'.
 4382 |     | //
 4383 |     | // After determination of 'qTarget', the amounts of 'tag0' and 'tag1' to be
 4384 |     | // exchanged as a result of the movement within '[qLower, qUpper]' are equal
 4385 |     | // to:
 4386 |     | //
 4387 |     | //                                                         growth
 4388 |     | //  'amount0Partial := sqrtInverseOffset * sharesTotal * ---------- *
 4389 |     | //                                                        2 ** 111
 4390 |     | //
 4391 |     | //                      - 8     / max(qCurrent, qTarget)
 4392 |     | //         1          e        |                         - h / 2
 4393 |     | //   ------------- * ------- * |                       e         k(w(h)) dh',
 4394 |     | //    outgoingMax       2      |
 4395 |     | //                            / min(qCurrent, qTarget)
 4396 |     | //
 4397 |     | // and
 4398 |     | //                                                  growth
 4399 |     | //  'amount1Partial := sqrtOffset * sharesTotal * ---------- *
 4400 |     | //                                                 2 ** 111
 4401 |     | //
 4402 |     | //                      - 8     / max(qCurrent, qTarget)
 4403 |     | //         1          e        |                         + h / 2
 4404 |     | //   ------------- * ------- * |                       e         k(w(h)) dh',
 4405 |     | //    outgoingMax       2      |
 4406 |     | //                            / min(qCurrent, qTarget)
 4407 |     | //
 4408 |     | // where the parameters 'sqrtInverseOffset', 'sqrtOffset', 'sharesTotal',
 4409 |     | // 'growth', and 'outgoingMax' remain fixed throughout the movement from
 4410 |     | // 'qCurrent' to 'qTarget'.
 4411 |     | //
 4412 |     | // In search for 'qTarget', we first need to enumerate the pieces of 'k(w(.))',
 4413 |     | // one by one, until we discover the piece to which 'qTarget' belongs. While 
 4414 |     | // enumerating the pieces of 'k(w(.))', one end of the current piece under
 4415 |     | // exploration is 'qBegin' and the other end is temporarily referred to as:
 4416 |     | //
 4417 |     | //  'qTarget := (
 4418 |     | //                direction == getZeroForOne()
 4419 |     | //              ) ? (
 4420 |     | //                direction ? 
 4421 |     | //                max(max(qEnd, qTotal1), qLimitWithinInterval) : 
 4422 |     | //                min(min(qEnd, qTotal1), qLimitWithinInterval)
 4423 |     | //              ) : (
 4424 |     | //                direction ? 
 4425 |     | //                max(qEnd, qTotal1) : 
 4426 |     | //                min(qEnd, qTotal1)
 4427 |     | //              )'.
 4428 |     | //
 4429 |     | // After the correct piece is determined, we perform a numerical search via
 4430 |     | // either of the methods 'searchOutgoingTarget' or 'searchIncomingTarget' in
 4431 |     | // 'Interval.sol' in order to pinpoint the precise value of 'qTarget'.
 4432 |     | //
 4433 |     | // At every step of searching for the piece to which 'qTarget' belongs, if 
 4434 |     | // 'getDirection() == false', we have:
 4435 |     | //
 4436 |     | //  'k(w(h)) == k(h - qOrigin) == k_indexKernelTotal(h - qOrigin) :=
 4437 |     | //
 4438 |     | //                         cTotal1 - cTotal0
 4439 |     | //              cTotal0 + ------------------- * (h - qTotal0)'.
 4440 |     | //                         qTotal1 - qTotal0
 4441 |     | //
 4442 |     | // for every 'qBegin < h < qTarget' and if 'getDirection() == true', we have:
 4443 |     | //
 4444 |     | //  'k(w(h)) == k(qOrigin - h) == k_indexKernelTotal(qOrigin - h) :=
 4445 |     | //
 4446 |     | //                         cTotal1 - cTotal0
 4447 |     | //              cTotal0 + ------------------- * (qTotal0 - h)'.
 4448 |     | //                         qTotal0 - qTotal1
 4449 |     | //
 4450 |     | // for every 'qTarget < h < qBegin'.
 4451 |     | //
 4452 |     | // The 62 bytes memory space which is pointed to by '_target_' hosts the
 4453 |     | // following values:
 4454 |     | //
 4455 |     | //  '_target_.log() := (2 ** 59) * (16 + qTarget)',
 4456 |     | //  '_target_.sqrt(false) := (2 ** 216) * exp(- 8 - qTarget / 2)',
 4457 |     | //  '_target_.sqrt(true) := (2 ** 216) * exp(- 8 + qTarget / 2)'.
 4458 |     | //
 4459 |     | // which can be accessed via 'PriceLibrary'. The logarithmic price
 4460 |     | // '_target_.log()' occupies 64 bits, whereas '_target_.sqrt(false)' and
 4461 |     | // '_target_.sqrt(true)' occupy 216 bits each.
 4462 |     | uint16 constant _target_ = 907;
 4463 |     | 
 4464 |     | // Assume that we are in the process of doing a swap within an interval for
 4465 |     | // which 'qTarget' as well as both 'amount0Partial' and 'amount1Partial' are
 4466 |     | // determined. Let '[qLower, pUpper]' represent the active liquidity interval
 4467 |     | // and define:
 4468 |     | //
 4469 |     | // Now we need to update the curve in preparation for the next swap. Before
 4470 |     | // doing so, define:
 4471 |     | //
 4472 |     | //                                - 8     / qUpper
 4473 |     | //    integral0Incremented      e        |    - h / 2
 4474 |     | //  '---------------------- := ------- * |  e         k(w(h)) dh',
 4475 |     | //          2 ** 216              2      |
 4476 |     | //                                      / qTarget
 4477 |     | //
 4478 |     | //                                - 8     / qTarget
 4479 |     | //    integral1Incremented      e        |    + h / 2
 4480 |     | //  '---------------------- := ------- * |  e         k(w(h)) dh'.
 4481 |     | //          2 ** 216              2      |
 4482 |     | //                                      / qLower
 4483 |     | //
 4484 |     | // Then we have:
 4485 |     | //
 4486 |     | //                                                                   growth
 4487 |     | //  'totalReserveOfTag0Before := sqrtInverseOffset * sharesTotal * ---------- * 
 4488 |     | //                                                                  2 ** 111
 4489 |     | //    integral0Incremented
 4490 |     | //   ----------------------'
 4491 |     | //        outgoingMax
 4492 |     | //
 4493 |     | //                                                            growth
 4494 |     | //  'totalReserveOfTag1Before := sqrtOffset * sharesTotal * ---------- * 
 4495 |     | //                                                           2 ** 111
 4496 |     | //    integral1Incremented
 4497 |     | //   ----------------------'
 4498 |     | //        outgoingMax
 4499 |     | //
 4500 |     | // Now, assume that the curve sequence is updated and the function 'w' is
 4501 |     | // transformed into a new function 'wAmended' which is constructed based on the
 4502 |     | // updated curve sequence. Then, we can similarly define:
 4503 |     | //
 4504 |     | //                            - 8     / qUpper
 4505 |     | //    integral0Amended      e        |    - h / 2
 4506 |     | //  '------------------ := ------- * |  e         k(wAmended(h)) dh',
 4507 |     | //        2 ** 216            2      |
 4508 |     | //                                  / qTarget
 4509 |     | //
 4510 |     | //                            - 8     / qTarget
 4511 |     | //    integral1Amended      e        |    + h / 2
 4512 |     | //  '------------------ := ------- * |  e         k(wAmended(h)) dh'.
 4513 |     | //        2 ** 216            2      |
 4514 |     | //                                  / qLower
 4515 |     | //
 4516 |     | // Then we have:
 4517 |     | //
 4518 |     | //  'totalReserveOfTag0After := sqrtInverseOffset * sharesTotal *
 4519 |     | //
 4520 |     | //    growthAmended     integral0Amended
 4521 |     | //   --------------- * ------------------'
 4522 |     | //      2 ** 111          outgoingMax
 4523 |     | //
 4524 |     | //  'totalReserveOfTag1After := sqrtOffset * sharesTotal * 
 4525 |     | //
 4526 |     | //    growthAmended     integral1Amended
 4527 |     | //   --------------- * ------------------'
 4528 |     | //      2 ** 111          outgoingMax
 4529 |     | //
 4530 |     | // Now, we need to make sure that the reserve amounts before and after the
 4531 |     | // curve update are the same, which means that:
 4532 |     | //
 4533 |     | //  'totalReserveOfTag0Before == totalReserveOfTag0After'
 4534 |     | //  'totalReserveOfTag1Before == totalReserveOfTag1After'
 4535 |     | //
 4536 |     | // This leads to the following two equations:
 4537 |     | // 
 4538 |     | //       growth            integral0Amended
 4539 |     | //  '--------------- == ----------------------'
 4540 |     | //    growthAmended      integral0Incremented
 4541 |     | // 
 4542 |     | //       growth            integral1Amended
 4543 |     | //  '--------------- == ----------------------'
 4544 |     | //    growthAmended      integral1Incremented
 4545 |     | //
 4546 |     | // Hence, we must have:
 4547 |     | //
 4548 |     | //      integral0Amended          integral1Amended
 4549 |     | //  '---------------------- == ----------------------'
 4550 |     | //    integral0Incremented      integral1Incremented
 4551 |     | //
 4552 |     | // which means that:
 4553 |     | //
 4554 |     | //      / qUpper                          / qTarget
 4555 |     | //     |   - h/2                         |   + h/2
 4556 |     | //     |  e      k(wAmended(h)) dh       |  e      k(wAmended(h)) dh
 4557 |     | //     |                                 |
 4558 |     | //    / qTarget                         / qLower
 4559 |     | //  '------------------------------ == ------------------------------'.
 4560 |     | //         / qUpper                          / qTarget
 4561 |     | //        |    - h/2                        |    + h/2
 4562 |     | //        |  e       k(w(h)) dh             |  e       k(w(h)) dh
 4563 |     | //        |                                 |
 4564 |     | //       / qTarget                         / qLower
 4565 |     | //
 4566 |     | // As a result, we should update the curve in such a way that the above
 4567 |     | // equality is satisfied.
 4568 |     | //
 4569 |     | // To that end, once 'qOvershoot' and both 'amount0Partial' and
 4570 |     | // 'amount1Partial' are determined, the curve sequence is amended with
 4571 |     | // 'qOvershoot' and then 'qTarget'.
 4572 |     | //
 4573 |     | // If 'getZeroForOne() == false' then 'qTarget <= qOvershoot' and if
 4574 |     | // 'getZeroForOne() == true' then 'qOvershoot <= qTarget'. Assume that
 4575 |     | // 'wAmended' is constructed from the amended curve sequence. 'qOvershoot' is
 4576 |     | // calculated in such a way that the above equality holds for the amended
 4577 |     | // curve. The process of searching for 'qOvershoot' is further explained at
 4578 |     | // the beginning of this section.
 4579 |     | //
 4580 |     | // The 62 bytes memory space which is pointed to by '_overshoot_' hosts the
 4581 |     | // following values:
 4582 |     | //
 4583 |     | //  '_overshoot_.log() := (2 ** 59) * (16 + qOvershoot)',
 4584 |     | //  '_overshoot_.sqrt(false) := (2 ** 216) * exp(- 8 - qOvershoot / 2)',
 4585 |     | //  '_overshoot_.sqrt(true) := (2 ** 216) * exp(- 8 + qOvershoot / 2)'.
 4586 |     | //
 4587 |     | // which can be accessed via 'PriceLibrary'. The logarithmic price
 4588 |     | // '_overshoot_.log()' occupies 64 bits, whereas '_overshoot_.sqrt(false)' and
 4589 |     | // '_overshoot_.sqrt(true)' occupy 216 bits each.
 4590 |     | uint16 constant _overshoot_ = 969;
 4591 |     | 
 4592 |     | // At every step of searching for 'qTarget', the range
 4593 |     | //
 4594 |     | //  'min(qBegin, qTarget) < h < max(qBegin, qTarget)'
 4595 |     | //
 4596 |     | // represents a piece of the liquidity distribution function 'k(w(.))' in which
 4597 |     | // 'k(w(.))' is linear. More precisely, if 'getDirection() == false', we have:
 4598 |     | //
 4599 |     | //  'k(w(h)) == k(h - qOrigin) == k_indexKernelTotal(h - qOrigin) :=
 4600 |     | //
 4601 |     | //                         cTotal1 - cTotal0
 4602 |     | //              cTotal0 + ------------------- * (h - qTotal0)'.
 4603 |     | //                         qTotal1 - qTotal0
 4604 |     | //
 4605 |     | // for every 'qBegin < h < qTarget' and if 'getDirection() == true', we have:
 4606 |     | //
 4607 |     | //  'k(w(h)) == k(qOrigin - h) == k_indexKernelTotal(qOrigin - h) :=
 4608 |     | //
 4609 |     | //                         cTotal1 - cTotal0
 4610 |     | //              cTotal0 + ------------------- * (qTotal0 - h)'.
 4611 |     | //                         qTotal0 - qTotal1
 4612 |     | //
 4613 |     | // for every 'qTarget < h < qBegin', where:
 4614 |     | //
 4615 |     | //  'cTotal0 := c[indexKernelTotal - 1]',
 4616 |     | //
 4617 |     | //  'qTotal0 := direction ? 
 4618 |     | //              qOrigin - b[indexKernelTotal - 1] : 
 4619 |     | //              qOrigin + b[indexKernelTotal - 1]',
 4620 |     | //
 4621 |     | //  'cTotal1 := c[indexKernelTotal]',
 4622 |     | //
 4623 |     | //  'qTotal1 := direction ? 
 4624 |     | //              qOrigin - b[indexKernelTotal] : 
 4625 |     | //              qOrigin + b[indexKernelTotal]'.
 4626 |     | //
 4627 |     | // The pair '(cTotal0, qTotal0)' is stored in the memory space which is pointed
 4628 |     | // to by '_total0_' and similarly, the pair '(cTotal1, qTotal1)' is stored in
 4629 |     | // the memory space which is pointed to by '_total1_'.
 4630 |     | //
 4631 |     | // The 64 bytes memory space which is pointed to by '_total0_' hosts the
 4632 |     | // following values:
 4633 |     | //
 4634 |     | //  '_total0_.height() := (2 ** 15) * cTotal0',
 4635 |     | //  '_total0_.log() := (2 ** 59) * (16 + qTotal0)',
 4636 |     | //  '_total0_.sqrt(false) := (2 ** 216) * exp(- 8 - qTotal0 / 2)',
 4637 |     | //  '_total0_.sqrt(true) := (2 ** 216) * exp(- 8 + qTotal0 / 2)'.
 4638 |     | //
 4639 |     | // which can be accessed via 'PriceLibrary'. The vertical coordinate
 4640 |     | // '_total0_.height()' occupies 16 bits, the logarithmic price '_total0_.log()'
 4641 |     | // occupies 64 bits, whereas '_total0_.sqrt(false)' and '_total0_.sqrt(true)'
 4642 |     | // occupy 216 bits each.
 4643 |     | //
 4644 |     | // The 64 bytes memory space which is pointed to by '_total1_' hosts the
 4645 |     | // following values:
 4646 |     | //
 4647 |     | //  '_total1_.height() := (2 ** 15) * cTotal1',
 4648 |     | //  '_total1_.log() := (2 ** 59) * (16 + qTotal1)',
 4649 |     | //  '_total1_.sqrt(false) := (2 ** 216) * exp(- 8 - qTotal1 / 2)',
 4650 |     | //  '_total1_.sqrt(true) := (2 ** 216) * exp(- 8 + qTotal1 / 2)'.
 4651 |     | //
 4652 |     | // which can be accessed via 'PriceLibrary'. The vertical coordinate
 4653 |     | // '_total1_.height()' occupies 16 bits, the logarithmic price '_total1_.log()'
 4654 |     | // occupies 64 bits, whereas '_total1_.sqrt(false)' and '_total1_.sqrt(true)'
 4655 |     | // occupy 216 bits each.
 4656 |     | uint16 constant _total0_ = 1033;
 4657 |     | uint16 constant _total1_ = 1097;
 4658 |     | 
 4659 |     | // At every step of searching for 'qOvershoot', the range
 4660 |     | //
 4661 |     | //  'min(qBegin, qOvershoot) < h < max(qBegin, qOvershoot)'
 4662 |     | //
 4663 |     | // represents a piece of 'k(|. - qTarget|)'. If 'getZeroForOne() == false',
 4664 |     | // then we have:
 4665 |     | //
 4666 |     | //  'k(h - qTarget) == k_indexKernelForward(h - qTarget) :=
 4667 |     | //
 4668 |     | //                                  cForward1 - cForward0
 4669 |     | //                     cForward0 + ----------------------- * (h - qForward0)',
 4670 |     | //                                  qForward1 - qForward0
 4671 |     | //
 4672 |     | // for every 'qBegin < h < qOvershoot' and if 'getZeroForOne() == true', then
 4673 |     | // we have:
 4674 |     | //
 4675 |     | //  'k(qTarget - h) == k_indexKernelForward(qTarget - h) :=
 4676 |     | //
 4677 |     | //                                  cForward1 - cForward0
 4678 |     | //                     cForward0 + ----------------------- * (qForward0 - h)',
 4679 |     | //                                  qForward0 - qForward1
 4680 |     | //
 4681 |     | // for every 'qOvershoot < h < qBegin' where
 4682 |     | //
 4683 |     | //  'cForward0 := c[indexKernelForward - 1]',
 4684 |     | //
 4685 |     | //  'qForward0 := getZeroForOne() ? 
 4686 |     | //                qTarget - b[indexKernelForward - 1] : 
 4687 |     | //                qTarget + b[indexKernelForward - 1]',
 4688 |     | //
 4689 |     | //  'cForward1 := c[indexKernelForward]',
 4690 |     | //
 4691 |     | //  'qForward1 := getZeroForOne() ? 
 4692 |     | //                qTarget - b[indexKernelForward] : 
 4693 |     | //                qTarget + b[indexKernelForward]'.
 4694 |     | //
 4695 |     | // The pair '(cForward0, qForward0)' is stored in the memory space which is
 4696 |     | // pointed to by '_forward0_' and similarly, the pair '(cForward1, qForward1)'
 4697 |     | // is stored in the memory space which is pointed to by '_forward1_'.
 4698 |     | //
 4699 |     | // The 64 bytes memory space which is pointed to by '_forward0_' hosts the
 4700 |     | // following values:
 4701 |     | //
 4702 |     | //  '_forward0_.height() := (2 ** 15) * cForward0',
 4703 |     | //  '_forward0_.log() := (2 ** 59) * (16 + qForward0)',
 4704 |     | //  '_forward0_.sqrt(false) := (2 ** 216) * exp(- 8 - qForward0 / 2)',
 4705 |     | //  '_forward0_.sqrt(true) := (2 ** 216) * exp(- 8 + qForward0 / 2)'.
 4706 |     | //
 4707 |     | // which can be accessed via 'PriceLibrary'. The vertical coordinate
 4708 |     | // '_forward0_.height()' occupies 16 bits, the logarithmic price
 4709 |     | // '_forward0_.log()' occupies 64 bits, whereas '_forward0_.sqrt(false)' and
 4710 |     | // '_forward0_.sqrt(true)' occupy 216 bits each.
 4711 |     | //
 4712 |     | // The 64 bytes memory space which is pointed to by '_forward1_' hosts the
 4713 |     | // following values:
 4714 |     | //
 4715 |     | //  '_forward1_.height() := (2 ** 15) * cForward1',
 4716 |     | //  '_forward1_.log() := (2 ** 59) * (16 + qForward1)',
 4717 |     | //  '_forward1_.sqrt(false) := (2 ** 216) * exp(- 8 - qForward1 / 2)',
 4718 |     | //  '_forward1_.sqrt(true) := (2 ** 216) * exp(- 8 + qForward1 / 2)'.
 4719 |     | //
 4720 |     | // which can be accessed via 'PriceLibrary'. The vertical coordinate
 4721 |     | // '_forward1_.height()' occupies 16 bits, the logarithmic price
 4722 |     | // '_forward1_.log()' occupies 64 bits, whereas '_forward1_.sqrt(false)' and
 4723 |     | // '_forward1_.sqrt(true)' occupy 216 bits each.
 4724 |     | uint16 constant _forward0_ = 1161;
 4725 |     | uint16 constant _forward1_ = 1225;
 4726 |     | 
 4727 |     | // While searching for 'qTarget', the integral 'incomingCurrentToTarget' is
 4728 |     | // calculated. This integral is defined as follows:
 4729 |     | //
 4730 |     | //                                   - 8
 4731 |     | //    incomingCurrentToTarget      e
 4732 |     | //  '------------------------- := ------- * (
 4733 |     | //           2 ** 216                2
 4734 |     | //
 4735 |     | //                         / qCurrent                 / qTarget
 4736 |     | //                        |    - h / 2               |    + h / 2
 4737 |     | //     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh
 4738 |     | //                        |                          |
 4739 |     | //                       / qTarget                  / qCurrent
 4740 |     | //
 4741 |     | //   )'.
 4742 |     | //
 4743 |     | // The pointer below refers to the above integral in 'X216' representation
 4744 |     | // which takes up to 27 bytes.
 4745 |     | uint16 constant _incomingCurrentToTarget_ = 1287;
 4746 |     | 
 4747 |     | // While searching for 'qTarget', the integral 'currentToTarget' is calculated.
 4748 |     | // This integral is defined as follows:
 4749 |     | //
 4750 |     | //                           - 8
 4751 |     | //    currentToTarget      e
 4752 |     | //  '----------------- := ------- * (
 4753 |     | //       2 ** 216            2
 4754 |     | //
 4755 |     | //                         / qCurrent                 / qTarget
 4756 |     | //                        |    + h / 2               |    - h / 2
 4757 |     | //     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh
 4758 |     | //                        |                          |
 4759 |     | //                       / qTarget                  / qCurrent
 4760 |     | //
 4761 |     | //   )'
 4762 |     | //
 4763 |     | // The pointer below refers to the above integral in 'X216' representation
 4764 |     | // which takes up to 27 bytes.
 4765 |     | uint16 constant _currentToTarget_ = 1314;
 4766 |     | 
 4767 |     | // While searching for 'qTarget' and 'qOvershoot', we need to calculate the
 4768 |     | // following integral:
 4769 |     | //
 4770 |     | //                           - 8
 4771 |     | //    currentToOrigin      e
 4772 |     | //  '----------------- := ------- * (
 4773 |     | //       2 ** 216            2
 4774 |     | //
 4775 |     | //                         / qOrigin                  / qCurrent
 4776 |     | //                        |    - h / 2               |    + h / 2
 4777 |     | //     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh
 4778 |     | //                        |                          |
 4779 |     | //                       / qCurrent                 / qOrigin
 4780 |     | //
 4781 |     | //   )'.
 4782 |     | //
 4783 |     | // 'currentToOrigin' is used for the calculation of 'overshoot' as discussed in
 4784 |     | // 'Interval.sol'.
 4785 |     | //
 4786 |     | // The pointer below refers to the above integral in 'X216' representation
 4787 |     | // which takes up to 27 bytes.
 4788 |     | uint16 constant _currentToOrigin_ = 1341;
 4789 |     | 
 4790 |     | // While searching for 'qTarget' and 'qOvershoot', we need to calculate the
 4791 |     | // following integral:
 4792 |     | //
 4793 |     | //                              - 8
 4794 |     | //    currentToOvershoot      e
 4795 |     | //  '-------------------- := ------- * (
 4796 |     | //         2 ** 216             2
 4797 |     | //
 4798 |     | //                         / qCurrent                 / qOvershoot
 4799 |     | //                        |    + h / 2               |    - h / 2
 4800 |     | //     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh
 4801 |     | //                        |                          |
 4802 |     | //                       / qOvershoot               / qCurrent
 4803 |     | //
 4804 |     | //   )'
 4805 |     | //
 4806 |     | // 'currentToOvershoot' is used for the calculation of 'overshoot' as discussed
 4807 |     | // in 'Interval.sol'.
 4808 |     | //
 4809 |     | // The pointer below refers to the above integral in 'X216' representation
 4810 |     | // which takes up to 27 bytes.
 4811 |     | uint16 constant _currentToOvershoot_ = 1368;
 4812 |     | 
 4813 |     | // While searching for 'qOvershoot', we need to calculate the following
 4814 |     | // integral:
 4815 |     | //
 4816 |     | //                             - 8
 4817 |     | //    targetToOvershoot      e
 4818 |     | //  '------------------- := ------- * (
 4819 |     | //         2 ** 216            2
 4820 |     | //
 4821 |     | //     getZeroForOne()
 4822 |     | //
 4823 |     | //         / qTarget
 4824 |     | //        |    + h / 2
 4825 |     | //     ?  |  e         k(qTarget - h) dh
 4826 |     | //        |
 4827 |     | //       / qOvershoot
 4828 |     | //
 4829 |     | //         / qOvershoot
 4830 |     | //        |    - h / 2
 4831 |     | //     :  |  e         k(h - qTarget) dh
 4832 |     | //        |
 4833 |     | //       / qTarget
 4834 |     | //
 4835 |     | //   )'
 4836 |     | //
 4837 |     | // 'targetToOvershoot' is used for the calculation of 'overshoot' as discussed
 4838 |     | // in 'Interval.sol'.
 4839 |     | //
 4840 |     | // The pointer below refers to the above integral in 'X216' representation
 4841 |     | // which takes up to 27 bytes.
 4842 |     | uint16 constant _targetToOvershoot_ = 1395;
 4843 |     | 
 4844 |     | // While searching for 'qTarget' and 'qOvershoot', we need to calculate the
 4845 |     | // following integral:
 4846 |     | //
 4847 |     | //                             - 8
 4848 |     | //    originToOvershoot      e
 4849 |     | //  '------------------- := ------- * (
 4850 |     | //        2 ** 216             2
 4851 |     | //
 4852 |     | //     getZeroForOne() ? 
 4853 |     | //
 4854 |     | //       / qOrigin
 4855 |     | //      |    + h / 2
 4856 |     | //      |  e         k(qOrigin - h) dh :
 4857 |     | //      |
 4858 |     | //     / qTarget
 4859 |     | //
 4860 |     | //       / qTarget
 4861 |     | //      |    - h / 2
 4862 |     | //      |  e         k(h - qOrigin) dh
 4863 |     | //      |
 4864 |     | //     / qOrigin
 4865 |     | //
 4866 |     | //   )'
 4867 |     | //
 4868 |     | // 'originToOvershoot' is used for the calculation of 'overshoot' as discussed
 4869 |     | // in 'Interval.sol'.
 4870 |     | //
 4871 |     | // The pointer below refers to the above integral in 'X216' representation
 4872 |     | // which takes up to 27 bytes.
 4873 |     | uint16 constant _originToOvershoot_ = 1422;
 4874 |     | 
 4875 |     | uint16 constant _endOfInterval_ = 1449;
 4876 |     | 
 4877 |     | // Accrued Parameters
 4878 |     | // ----------------------------------------------------------------------------
 4879 |     | // The spaces that are pointed to by the following memory pointers contain
 4880 |     | // information about the accrued growth portions that are owed to the protocol
 4881 |     | // and the pool. After each swap or donate, the interval liquidity grows. A
 4882 |     | // portion of this growth goes to the protocol. A portion of the remaining
 4883 |     | // growth goes to the pool owner. These values are compactly written on
 4884 |     | // protocol's storage in which they occupy exactly one slot.
 4885 |     | uint16 constant _accruedParams_ = 1449;
 4886 |     | 
 4887 |     | // This 32 bytes memory space hosts the 'X127' representation of 'accrued0'
 4888 |     | // where
 4889 |     | //
 4890 |     | //    accrued0
 4891 |     | //  '----------'
 4892 |     | //    2 ** 127
 4893 |     | //
 4894 |     | // is the total unclaimed amount in 'tag0' owed to both the protocol and the
 4895 |     | // pool owner.
 4896 |     | uint16 constant _accrued0_ = 1449;
 4897 |     | 
 4898 |     | // This 32 bytes memory space hosts the 'X127' representation of 'accrued1'
 4899 |     | // where
 4900 |     | //
 4901 |     | //    accrued1
 4902 |     | //  '----------'
 4903 |     | //    2 ** 127
 4904 |     | //
 4905 |     | // is the total unclaimed amount in 'tag1' owed to both the protocol and the
 4906 |     | // pool owner.
 4907 |     | uint16 constant _accrued1_ = 1481;
 4908 |     | 
 4909 |     | // This 3 bytes memory space hosts the 'X23' representation of 'poolRatio0'
 4910 |     | // where
 4911 |     | //
 4912 |     | //    poolRatio0     accrued0
 4913 |     | //  '------------ * ----------'
 4914 |     | //     2 ** 23       2 ** 127
 4915 |     | //
 4916 |     | // is the accrued amount in 'tag0' owed to the pool and
 4917 |     | //
 4918 |     | //    oneX23 - poolRatio0     accrued0
 4919 |     | //  '--------------------- * ----------'
 4920 |     | //          2 ** 23           2 ** 127
 4921 |     | //
 4922 |     | // is the accrued amount in 'tag0' owed to the protocol.
 4923 |     | uint16 constant _poolRatio0_ = 1513;
 4924 |     | 
 4925 |     | // This 3 bytes memory space hosts the 'X23' representation of 'poolRatio1'
 4926 |     | // where
 4927 |     | //
 4928 |     | //    poolRatio1     accrued1
 4929 |     | //  '------------ * ----------'
 4930 |     | //     2 ** 23       2 ** 127
 4931 |     | //
 4932 |     | // is the accrued amount in 'tag1' owed to the pool and
 4933 |     | //
 4934 |     | //    oneX23 - poolRatio1     accrued1
 4935 |     | //  '--------------------- * ----------'
 4936 |     | //          2 ** 23           2 ** 127
 4937 |     | //
 4938 |     | // is the accrued amount in 'tag1' owed to the protocol.
 4939 |     | uint16 constant _poolRatio1_ = 1516;
 4940 |     | 
 4941 |     | // Pointers
 4942 |     | // ----------------------------------------------------------------------------
 4943 |     | // The following memory pointers give access to data with dynamic size.
 4944 |     | uint16 constant _pointers_ = 1519;
 4945 |     | 
 4946 |     | // The content of this 32 bytes memory space points to the beginning of the
 4947 |     | // kernel.
 4948 |     | // The memory space starting from 'getKernel()' to
 4949 |     | // 'getKernel() + 64 * (getKernelLength() - 1)' hosts the kernel breakpoints
 4950 |     | // that are loaded from the bytecode of the storage smart contract (64 bytes
 4951 |     | // for each breakpoint of the kernel function except for '(b[0], c[0])' which
 4952 |     | // is omitted).
 4953 |     | uint16 constant _kernel_ = 1519;
 4954 |     | 
 4955 |     | // The content of this 32 bytes memory space points to the beginning of the
 4956 |     | // curve sequence. The memory space starting from 'getCurve()' to
 4957 |     | // 'getCurve() + 8 * getCurveLength()' hosts the curve sequence which is loaded
 4958 |     | // from the protocol's storage (8 bytes for each member of the curve sequence).
 4959 |     | uint16 constant _curve_ = 1551;
 4960 |     | 
 4961 |     | // The content of this 32 bytes memory space points to the beginning of
 4962 |     | // 'hookData'. The memory space starting from 'getHookData()' to
 4963 |     | // 'getHookData() + getHookDataByteCount()' hosts 'hookData' which is loaded
 4964 |     | // from calldata.
 4965 |     | uint16 constant _hookData_ = 1583;
 4966 |     | 
 4967 |     | // This 2 bytes memory space hosts the number of breakpoints of the kernel
 4968 |     | // function which is calculated from the size of the storage smart contract.
 4969 |     | uint16 constant _kernelLength_ = 1615;
 4970 |     | 
 4971 |     | // This 2 bytes memory space hosts the number of members of the curve sequence.
 4972 |     | uint16 constant _curveLength_ = 1617;
 4973 |     | 
 4974 |     | // This 2 bytes memory space hosts the number of bytes that 'hookData'
 4975 |     | // occupies.
 4976 |     | uint16 constant _hookDataByteCount_ = 1619;
 4977 |     | 
 4978 |     | // Dynamic Parameters
 4979 |     | // ----------------------------------------------------------------------------
 4980 |     | // The following memory pointers are dedicated to dynamic parameters of the
 4981 |     | // pool that may change with each swap. Dynamic parameters are stored in
 4982 |     | // protocol's storage and take a total of three slots. In the event that
 4983 |     | // 'staticParamsStoragePointer' overflows and
 4984 |     | // 'staticParamsStoragePointerExtension' is needed, a fourth storage slot is
 4985 |     | // populated, rendering interactions with the pool more expensive.
 4986 |     | uint16 constant _dynamicParams_ = 1621;
 4987 |     | 
 4988 |     | // The content of this 32 bytes memory space is referred to as
 4989 |     | // 'staticParamsStoragePointerExtension' which is closely related to
 4990 |     | // 'staticParamsStoragePointer'.
 4991 |     | //
 4992 |     | // If 'staticParamsStoragePointer < type(uint16).max', then
 4993 |     | // 'staticParamsStoragePointerExtension' is not written on protocol's storage
 4994 |     | // and we have:
 4995 |     | //
 4996 |     | //  'staticParamsStoragePointerExtension == staticParamsStoragePointer'
 4997 |     | //
 4998 |     | // If 'staticParamsStoragePointer == type(uint16).max', then
 4999 |     | // 'staticParamsStoragePointerExtension' populates a dedicated storage slot
 5000 |     | // whose content can be used to derive the address of the storage smart
 5001 |     | // contract that contains the static parameters and the kernel.
 5002 |     | uint16 constant _staticParamsStoragePointerExtension_ = 1621;
 5003 |     | 
 5004 |     | // The content of this 2 bytes memory space is used to retrieve the address of
 5005 |     | // the smart contract which holds the pool's static parameters and the kernel
 5006 |     | // in its bytecode. This value is incremented every time that any of the static
 5007 |     | // parameters are updated or when the kernel is modified. In the event of
 5008 |     | // overflow, this value is set to 'type(uint16).max' and the 32 bytes space
 5009 |     | // which is pointed to by '_staticParamsStoragePointerExtension_' is used to
 5010 |     | // store the value from which the address to the storage smart contract is
 5011 |     | // derived.
 5012 |     | uint16 constant _staticParamsStoragePointer_ = 1653;
 5013 |     | 
 5014 |     | // This 8 bytes memory space hosts 'logPriceCurrent' which is the offsetted
 5015 |     | // value of the current log price of the pool in 'X59' representation. More
 5016 |     | // precisely,
 5017 |     | //
 5018 |     | //  'logPriceCurrent := (2 ** 59) * (16 + qCurrent)'
 5019 |     | //
 5020 |     | // where 
 5021 |     | // 
 5022 |     | //  'qCurrent := log(pCurrent / pOffset)',
 5023 |     | //
 5024 |     | // and 'pCurrent' represents the current price of the pool.
 5025 |     | //
 5026 |     | // This value is also used to determine the end of the curve sequence while
 5027 |     | // reading the curve sequence from storage. Because the curve sequence does not
 5028 |     | // have a length slot, but its last member is equal to 'logPriceCurrent'.
 5029 |     | uint16 constant _logPriceCurrent_ = 1655;
 5030 |     | 
 5031 |     | // The total number of shares that are deposited in the current active
 5032 |     | // liquidity interval across all LPs.
 5033 |     | //
 5034 |     | // We keep track of the total share values in all of the liquidity intervals
 5035 |     | // via the mapping 'sharesDelta' within protocol's storage. Let 'qBoundary'
 5036 |     | // denote an arbitrary boundary for a liquidity interval, i.e.,
 5037 |     | //
 5038 |     | //  'qBoundary == qLower + j * qSpacing'
 5039 |     | //
 5040 |     | // for some integer 'j'. Let 'sharesTotalLeft' and 'sharesTotalRight' denote
 5041 |     | // the total number of shares within the intervals
 5042 |     | //
 5043 |     | //  '[qBoundary - qSpacing, qBoundary]' and
 5044 |     | //  '[qBoundary, qBoundary + qSpacing]',
 5045 |     | //
 5046 |     | // respectively. Define:
 5047 |     | //
 5048 |     | //  'sharesDelta[qBoundary] := sharesTotalRight - sharesTotalLeft'.
 5049 |     | //
 5050 |     | // In other words, 'sharesDelta[qBoundary]' is defined as the difference
 5051 |     | // between the total number of shares within the two liquidity intervals that
 5052 |     | // contain 'qBoundary'.
 5053 |     | uint16 constant _sharesTotal_ = 1663;
 5054 |     | 
 5055 |     | // With each visit to a liquidity interval or as a result of donations, the
 5056 |     | // amount of liquidity which is allocated to a single LP share increases. We
 5057 |     | // use the parameter 'growth' to keep track of liquidity per share for the
 5058 |     | // active interval. 'growth' is stored in 'X111' format and we always have
 5059 |     | // 'oneX111 <= growth <= maxGrowth == 1 << 127'.
 5060 |     | //
 5061 |     | // Let 'pLower' and 'pUpper', respectively, denote the minimum and maximum
 5062 |     | // price in the current active liquidity interval and define
 5063 |     | //
 5064 |     | //  'qLower := log(pLower / pOffset)',
 5065 |     | //  'qUpper := log(pUpper / pOffset)'.
 5066 |     | //
 5067 |     | // Growth values across inactive intervals are kept track of using the mapping
 5068 |     | // 'growthMultiplier' as explained below.
 5069 |     | //
 5070 |     | // For every integer 'm >= 1', let 
 5071 |     | // 
 5072 |     | //    sqrtInverseOffset     growthMultiplier[qLower + m * qSpacing]
 5073 |     | //  '------------------- * -----------------------------------------'
 5074 |     | //        2 ** 127                         2 ** 208
 5075 |     | //
 5076 |     | // represent the total amount of 'tag0' corresponding to a single liquidity
 5077 |     | // provider's share from 'qLower + m * qSpacing' to '+oo' and let
 5078 |     | //
 5079 |     | //    sqrtOffset     growthMultiplier[qUpper - m * qSpacing]
 5080 |     | //  '------------ * -----------------------------------------'
 5081 |     | //     2 ** 127                     2 ** 208
 5082 |     | //
 5083 |     | // represent the total amount of 'tag1' corresponding to a single liquidity
 5084 |     | // provider's share from '-oo' to 'qLower'.
 5085 |     | //
 5086 |     | // For every integer 'm', let 'growth(m)' denote the 'growth' value for the
 5087 |     | // interval
 5088 |     | //
 5089 |     | //  '[qLower + m * qSpacing, qUpper + m * qSpacing]'.
 5090 |     | //
 5091 |     | // Hence, 'growth(0)' corresponds to '[qLower, qUpper]' which is stored in
 5092 |     | // the following memory space.
 5093 |     | //
 5094 |     | // According to the above definitions, for every integer 'm >= 1', we have
 5095 |     | //
 5096 |     | //    growthMultiplier[qLower + m * qSpacing]
 5097 |     | //  '----------------------------------------- := 
 5098 |     | //                    2 ** 208
 5099 |     | //   ---- +oo
 5100 |     | //   \            growth(+j)      (- qLower - j * qSpacing) / 2
 5101 |     | //   /           ------------ * e                               '.
 5102 |     | //   ---- j = m    2 ** 111
 5103 |     | //
 5104 |     | // and
 5105 |     | //
 5106 |     | //    growthMultiplier[qUpper - m * qSpacing]
 5107 |     | //  '----------------------------------------- := 
 5108 |     | //                    2 ** 208
 5109 |     | //   ---- +oo
 5110 |     | //   \            growth(-j)      (+ qUpper - j * qSpacing) / 2
 5111 |     | //   /           ------------ * e                               '.
 5112 |     | //   ---- j = m    2 ** 111
 5113 |     | //
 5114 |     | // The following illustration further elaborates the notion of 'growth' and
 5115 |     | // 'growthMultiplier':
 5116 |     | //
 5117 |     | //                                         growthMultiplier[qUpper + qSpacing]
 5118 |     | //                                                                    |-->
 5119 |     | //       growthMultiplier[qLower - qSpacing]                          |
 5120 |     | //           <--|                                                     |
 5121 |     | //              |                        growthMultiplier[qUpper]     |
 5122 |     | //              |                                   |-->              |
 5123 |     | //              |      growthMultiplier[qLower]     |                 |
 5124 |     | //              |              <--|                 |                 |
 5125 |     | //              |                 |     growth      |                 |
 5126 |     | //              |                 |       ==        |                 |
 5127 |     | //              |    growth(-1)   |    growth(0)    |    growth(+1)   |
 5128 |     | //       ... <--+-----------------+-----------------+-----------------+--> ...
 5129 |     | //                                |                 |
 5130 |     | //                              qLower           qUpper
 5131 |     | //
 5132 |     | // In the above figure, 'growthMultiplier[qUpper]' and
 5133 |     | // 'growthMultiplier[qUpper + qSpacing]' point towards '+oo' as well as every
 5134 |     | // growthMultiplier[qLower + m * qSpacing] for positive integers 'm'.
 5135 |     | //
 5136 |     | // On the contrary, 'growthMultiplier[qLower]' and
 5137 |     | // 'growthMultiplier[qLower - qSpacing]' point towards '-oo' as well as every
 5138 |     | // growthMultiplier[qUpper - m * qSpacing] for positive integers 'm'.
 5139 |     | uint16 constant _growth_ = 1679;
 5140 |     | 
 5141 |     | // Let 'pCurrent' and 'pUpper' represent the current price and the maximum
 5142 |     | // price of the active liquidity interval, respectively, and define:
 5143 |     | //
 5144 |     | // 'qCurrent := log(pCurrent / pOffset)',
 5145 |     | // 'qUpper := log(pUpper / pOffset)'.
 5146 |     | //
 5147 |     | // The memory space which is pointed to by '_integral0_' hosts the following
 5148 |     | // integral in 'X216' representation which takes up to 27 bytes:
 5149 |     | //
 5150 |     | //                     - 8     / qUpper
 5151 |     | //    integral0      e        |    - h / 2
 5152 |     | //  '----------- := ------- * |  e         k(w(h)) dh'.
 5153 |     | //    2 ** 216         2      |
 5154 |     | //                           / qCurrent
 5155 |     | //
 5156 |     | // The total reserve of 'tag0' in the active liquidity interval can be derived
 5157 |     | // from the following formula:
 5158 |     | //
 5159 |     | //  'totalReserveOfTag0 == sqrtInverseOffset * sharesTotal *
 5160 |     | //
 5161 |     | //                           growth       integral0
 5162 |     | //                         ---------- * -------------
 5163 |     | //                          2 ** 111     outgoingMax
 5164 |     | //
 5165 |     | uint16 constant _integral0_ = 1695;
 5166 |     | 
 5167 |     | // Let 'pCurrent' and 'pLower' represent the current price and the minimum
 5168 |     | // price of the active liquidity interval, respectively, and define:
 5169 |     | //
 5170 |     | // 'qCurrent := log(pCurrent / pOffset)',
 5171 |     | // 'qLower := log(pLower / pOffset)'.
 5172 |     | //
 5173 |     | // The memory space which is pointed to by '_integral1_' hosts the following
 5174 |     | // integral in 'X216' representation which takes up to 27 bytes:
 5175 |     | //
 5176 |     | //                     - 8     / qCurrent
 5177 |     | //    integral1      e        |    + h / 2
 5178 |     | //  '----------- := ------- * |  e         k(w(h)) dh'.
 5179 |     | //    2 ** 216         2      |
 5180 |     | //                           / qLower
 5181 |     | //
 5182 |     | // The total reserve of 'tag1' in the active liquidity interval can be derived
 5183 |     | // from the following formula:
 5184 |     | //
 5185 |     | //  'totalReserveOfTag1 == sqrtOffset * sharesTotal *
 5186 |     | //
 5187 |     | //                           growth       integral1
 5188 |     | //                         ---------- * -------------
 5189 |     | //                          2 ** 111     outgoingMax
 5190 |     | //
 5191 |     | uint16 constant _integral1_ = 1722;
 5192 |     | 
 5193 |     | // For every pool, the static parameters and the kernel are encoded in the
 5194 |     | // source code of a storage smart contract which is deployed using a disposable
 5195 |     | // proxy contract. When deploying a new storage smart contract, its creation
 5196 |     | // code is stored in this 11 bytes memory space with static parameters and
 5197 |     | // kernel appearing immediately after. This way, a chunk of memory can be sent
 5198 |     | // to the proxy in order to deploy the storage smart contract.
 5199 |     | uint16 constant _deploymentCreationCode_ = 1749;
 5200 |     | 
 5201 |     | // Static Parameters
 5202 |     | // ----------------------------------------------------------------------------
 5203 |     | // The following memory pointers are dedicated to the static parameters of the
 5204 |     | // pool that do not change as frequently as dynamic parameters. They are stored
 5205 |     | // along with the kernel. Hence, everytime the kernel or any of the growth
 5206 |     | // portions are updated, the entire storage smart contract is redeployed.
 5207 |     | uint16 constant _staticParams_ = 1760;
 5208 |     | 
 5209 |     | // The arithmetically smaller tag to be traded by the pool. This value is
 5210 |     | // immutable. A tag may refer to native, ERC-20, ERC-6909, or ERC-1155 tokens
 5211 |     | // as described in 'Tag.sol'.
 5212 |     | uint16 constant _tag0_ = 1760;
 5213 |     | 
 5214 |     | // The arithmetically larger tag to be traded by the pool. This value is
 5215 |     | // immutable.
 5216 |     | uint16 constant _tag1_ = 1792;
 5217 |     | 
 5218 |     | // This memory space hosts the value:
 5219 |     | //
 5220 |     | // 'sqrtOffset := (2 ** 127) * sqrt(pOffset)'
 5221 |     | //
 5222 |     | // where the natural logarithm of 'pOffset' is an 'int8' which is encoded from
 5223 |     | // bit 181 to bit 188 of poolId.
 5224 |     | uint16 constant _sqrtOffset_ = 1824;
 5225 |     | 
 5226 |     | // This memory space hosts the value:
 5227 |     | //
 5228 |     | // 'sqrtInverseOffset := (2 ** 127) / sqrt(pOffset)'
 5229 |     | //
 5230 |     | // where the natural logarithm of 'pOffset' is an 'int8' which is encoded from
 5231 |     | // bit 181 to bit 188 of poolId.
 5232 |     | uint16 constant _sqrtInverseOffset_ = 1856;
 5233 |     | 
 5234 |     | // Let 'pLower' and 'pUpper' denote the minimum and maximum price in the active
 5235 |     | // liquidity interval, respectively, and define
 5236 |     | //
 5237 |     | //  'qSpacing := log(pUpper / pLower)',
 5238 |     | //
 5239 |     | // The 62 bytes memory space which is pointed to by '_spacing_' hosts the
 5240 |     | // following values:
 5241 |     | //
 5242 |     | //  '_spacing_.log() := (2 ** 59) * (16 + qSpacing)',
 5243 |     | //  '_spacing_.sqrt(false) := (2 ** 216) * exp(- qSpacing / 2)',
 5244 |     | //  '_spacing_.sqrt(true) := (2 ** 216) * exp(- 16 + qSpacing / 2)'.
 5245 |     | //
 5246 |     | // which can be accessed via 'PriceLibrary'. The logarithmic price
 5247 |     | // '_spacing_.log()' occupies 64 bits, whereas '_spacing_.sqrt(false)' and
 5248 |     | // '_spacing_.sqrt(true)' occupy 216 bits each.
 5249 |     | uint16 constant _spacing_ = 1888;
 5250 |     | 
 5251 |     | // Let 'pLower' and 'pUpper' denote the minimum and maximum price in the active
 5252 |     | // liquidity interval, respectively, and define
 5253 |     | //
 5254 |     | //  'qUpper := log(pUpper / pOffset)',
 5255 |     | //  'qLower := log(pLower / pOffset)',
 5256 |     | //  'qSpacing := log(pUpper / pLower)'.
 5257 |     | //
 5258 |     | // This 27 bytes memory space hosts 'outgoingMax' which is a kernel parameter.
 5259 |     | // The 'X216' representation of 'outgoingMax' is defined as follows:
 5260 |     | //
 5261 |     | //                       - 8     / qSpacing
 5262 |     | //    outgoingMax      e        |    - h / 2
 5263 |     | //  '------------- := ------- * |  e         k(h) dh'.
 5264 |     | //     2 ** 216          2      |
 5265 |     | //                             / 0
 5266 |     | //
 5267 |     | // 'outgoingMax' is used frequently for calculating any amount of 'tag0' and
 5268 |     | // 'tag1'. Because of this, we calculate 'outgoingMax' and its modular inverse
 5269 |     | // at the time of initialization or anytime that the kernel is modified and
 5270 |     | // then we store the resulting values among the static parameters.
 5271 |     | //
 5272 |     | // 'outgoingMax' can be calculated with the following two equivalent formulas
 5273 |     | // as well:
 5274 |     | //
 5275 |     | //                       - 8 + qLower / 2     / qUpper
 5276 |     | //    outgoingMax      e                     |    - h / 2
 5277 |     | //  '------------- := -------------------- * |  e         k(h - qLower) dh
 5278 |     | //     2 ** 216                 2            |
 5279 |     | //                                          / qLower
 5280 |     | //
 5281 |     | //                       - 8 - qUpper / 2     / qUpper
 5282 |     | //                     e                     |    + h / 2
 5283 |     | //                    -------------------- * |  e         k(qUpper - h) dh'.
 5284 |     | //                              2            |
 5285 |     | //                                          / qLower
 5286 |     | //
 5287 |     | // Notice that the above formulas are independent of the choice for 'qLower'
 5288 |     | // and 'qUpper', and they result in the same value as long as 
 5289 |     | // 'qUpper - qLower == qSpacing'.
 5290 |     | uint16 constant _outgoingMax_ = 1950;
 5291 |     | 
 5292 |     | // This 32 bytes memory space hosts 'outgoingMaxModularInverse' which is the
 5293 |     | // modular inverse of
 5294 |     | //
 5295 |     | //    outgoingMax 
 5296 |     | //  '-------------'
 5297 |     | //      2 ** n
 5298 |     | //
 5299 |     | // modulo '2 ** 256', where 'n' is the largest power of '2' that divides
 5300 |     | // 'outgoingMax'. This value is calculated at the time of initialization or
 5301 |     | // anytime that the kernel function is modified.
 5302 |     | //
 5303 |     | // Precalculation of 'outgoingMaxModularInverse' facilitates division by
 5304 |     | // 'outgoingMax' which is done frequently.
 5305 |     | uint16 constant _outgoingMaxModularInverse_ = 1977;
 5306 |     | 
 5307 |     | // Let 'pLower' and 'pUpper' denote the minimum and maximum price in the active
 5308 |     | // liquidity interval, respectively, and define
 5309 |     | //
 5310 |     | //  'qUpper := log(pUpper / pOffset)',
 5311 |     | //  'qLower := log(pLower / pOffset)',
 5312 |     | //  'qSpacing := log(pUpper / pLower)'.
 5313 |     | //
 5314 |     | // This 27 bytes memory space hosts 'outgoingMax' which is a kernel parameter.
 5315 |     | // The 'X216' representation of 'outgoingMax' is defined as follows:
 5316 |     | //
 5317 |     | //                       - 8 - qSpacing / 2     / qSpacing
 5318 |     | //    incomingMax      e                       |    + h / 2
 5319 |     | //  '------------- := ---------------------- * |  e         k(h) dh'.
 5320 |     | //     2 ** 216                 2              |
 5321 |     | //                                            / 0
 5322 |     | //
 5323 |     | // 'incomingMax' is used for calculating the incoming amount as we cross an
 5324 |     | // entire liquidity interval from 'qBack' to 'qNext'. Because of this, we
 5325 |     | // calculate 'incomingMax' at the time of initialization or anytime that the
 5326 |     | // kernel is modified and then we store the resulting value among the static
 5327 |     | // parameters.
 5328 |     | //
 5329 |     | // 'incomingMax' can be calculated with the following two equivalent formulas
 5330 |     | // as well:
 5331 |     | //
 5332 |     | //                       - 8 - qUpper / 2     / qUpper
 5333 |     | //    incomingMax      e                     |    + h / 2
 5334 |     | //  '------------- := -------------------- * |  e         k(h - qLower) dh
 5335 |     | //     2 ** 216                 2            |
 5336 |     | //                                          / qLower
 5337 |     | //
 5338 |     | //                       - 8 + qLower / 2     / qUpper
 5339 |     | //                     e                     |    - h / 2
 5340 |     | //                    -------------------- * |  e         k(qUpper - h) dh'.
 5341 |     | //                              2            |
 5342 |     | //                                          / qLower
 5343 |     | //
 5344 |     | // Notice that the above formulas are independent of the choice for 'qLower'
 5345 |     | // and 'qUpper', and they result in the same value as long as 
 5346 |     | // 'qUpper - qLower == qSpacing'.
 5347 |     | uint16 constant _incomingMax_ = 2009;
 5348 |     | 
 5349 |     | // The content of the 6 bytes memory space which is pointed to by
 5350 |     | // '_poolGrowthPortion_' dictates the portion of the growth that goes to the
 5351 |     | // pool owner followed by the protocol.
 5352 |     | //
 5353 |     | // The content of the 6 bytes memory space which is pointed to by
 5354 |     | // '_maxPoolGrowthPortion_' imposes a cap on the portion of the marginal growth
 5355 |     | // that goes to the pool owner followed by the protocol.
 5356 |     | //
 5357 |     | // The content of the 6 bytes memory space which is pointed to by
 5358 |     | // '_protocolGrowthPortion_' dictates the portion of the growth that goes to
 5359 |     | // the protocol.
 5360 |     | //
 5361 |     | // 'maxPoolGrowthPortion' and 'protocolGrowthPortion' are set by the protocol
 5362 |     | // slot or the sentinel contract. Any address can invoke a function to sync
 5363 |     | // these two values with the global portions.
 5364 |     | //
 5365 |     | // This value is set by the protocol slot or the sentinel contract.
 5366 |     | // Any address can invoke a function to sync this value with the global
 5367 |     | // portion.
 5368 |     | //
 5369 |     | // Let '[qLower, qUpper]' represent the active liquidity interval. As part of a
 5370 |     | // swap, assume that the price is moved from 'qCurrent' to 'qTarget' within
 5371 |     | // '[qLower, qUpper]'. Define:
 5372 |     | //
 5373 |     | //                                - 8     / qUpper
 5374 |     | //    integral0Incremented      e        |    - h / 2
 5375 |     | //  '---------------------- := ------- * |  e         k(w(h)) dh',
 5376 |     | //          2 ** 216              2      |
 5377 |     | //                                      / qTarget
 5378 |     | //
 5379 |     | //                                - 8     / qTarget
 5380 |     | //    integral1Incremented      e        |    + h / 2
 5381 |     | //  '---------------------- := ------- * |  e         k(w(h)) dh'.
 5382 |     | //          2 ** 216              2      |
 5383 |     | //                                      / qLower
 5384 |     | //
 5385 |     | // Now, assume that the curve sequence is updated and the function 'w' is
 5386 |     | // transformed into a new function 'wAmended' which is constructed based on the
 5387 |     | // updated curve sequence. Define:
 5388 |     | //
 5389 |     | //                            - 8     / qUpper
 5390 |     | //    integral0Amended      e        |    - h / 2
 5391 |     | //  '------------------ := ------- * |  e         k(wAmended(h)) dh',
 5392 |     | //        2 ** 216            2      |
 5393 |     | //                                  / qTarget
 5394 |     | //
 5395 |     | //                            - 8     / qTarget
 5396 |     | //    integral1Amended      e        |    + h / 2
 5397 |     | //  '------------------ := ------- * |  e         k(wAmended(h)) dh'.
 5398 |     | //        2 ** 216            2      |
 5399 |     | //                                  / qLower
 5400 |     | //
 5401 |     | // Then we have:
 5402 |     | //                              integral0Incremented
 5403 |     | //  'growthAmended := growth * ----------------------
 5404 |     | //                                integral0Amended
 5405 |     | //
 5406 |     | //                              integral1Incremented
 5407 |     | //                 == growth * ----------------------'.
 5408 |     | //                                integral1Amended
 5409 |     | //
 5410 |     | // Now, the marginal growth with respect to 'tag0' and 'tag1' can be defined
 5411 |     | // as:
 5412 |     | //
 5413 |     | //  'marginalGrowthOfTag0 := sqrtInverseOffset * sharesTotal * 
 5414 |     | //
 5415 |     | //                            growthAmended - growth     integral0Amended
 5416 |     | //                           ------------------------ * ------------------',
 5417 |     | //                                    2 ** 111             outgoingMax
 5418 |     | //
 5419 |     | //  'marginalGrowthOfTag1 := sqrtOffset * sharesTotal * 
 5420 |     | //
 5421 |     | //                            growthAmended - growth     integral1Amended
 5422 |     | //                           ------------------------ * ------------------'.
 5423 |     | //                                    2 ** 111             outgoingMax
 5424 |     | //
 5425 |     | // Hence, as a result of this swap, the amount of 'tag0' that goes to the
 5426 |     | // protocol is equal to:
 5427 |     | //
 5428 |     | //    protocolGrowthPortion
 5429 |     | //  '----------------------- * marginalGrowthOfTag0'
 5430 |     | //           2 ** 47
 5431 |     | //
 5432 |     | // and the amount of 'tag1' that goes to the protocol is equal to:
 5433 |     | //
 5434 |     | //    protocolGrowthPortion
 5435 |     | //  '----------------------- * marginalGrowthOfTag1'
 5436 |     | //           2 ** 47
 5437 |     | //
 5438 |     | // Additionally, the amount of 'tag0' that goes to the pool owner is equal to:
 5439 |     | //
 5440 |     | //    min(poolGrowthPortion, maxPoolGrowthPortion)
 5441 |     | //  '---------------------------------------------- * 
 5442 |     | //                      2 ** 47
 5443 |     | //
 5444 |     | //    oneX47 - protocolGrowthPortion
 5445 |     | //   -------------------------------- * marginalGrowthOfTag0'
 5446 |     | //               2 ** 47
 5447 |     | //
 5448 |     | // and the amount of 'tag1' that goes to the pool owner is equal to:
 5449 |     | //
 5450 |     | //    min(poolGrowthPortion, maxPoolGrowthPortion)
 5451 |     | //  '---------------------------------------------- * 
 5452 |     | //                      2 ** 47
 5453 |     | //
 5454 |     | //    oneX47 - protocolGrowthPortion
 5455 |     | //   -------------------------------- * marginalGrowthOfTag1'
 5456 |     | //               2 ** 47
 5457 |     | //
 5458 |     | uint16 constant _poolGrowthPortion_ = 2036;
 5459 |     | uint16 constant _maxPoolGrowthPortion_ = 2042;
 5460 |     | uint16 constant _protocolGrowthPortion_ = 2048;
 5461 |     | 
 5462 |     | // The number of members for the pending kernel. Once a new kernel is
 5463 |     | // introduced, it remains pending until transition to a new liquidity interval.
 5464 |     | // This value is an indicator for whether there exists a pending kernel.
 5465 |     | // This value is used to ensure that a sufficient amount of space is reserved
 5466 |     | // in memory for kernel, in case the pending kernel needs to be activated in
 5467 |     | // the middle of a swap, i.e., read from the new storage smart contract.
 5468 |     | uint16 constant _pendingKernelLength_ = 2054;
 5469 |     | 
 5470 |     | uint16 constant _endOfStaticParams_ = 2056;
 5471 |     | 
 5472 |     | // Modify Position Parameters
 5473 |     | // ----------------------------------------------------------------------------
 5474 |     | // The following memory pointers host the inputs and the resulting outputs of
 5475 |     | // the method 'modifyPosition'. An LP may choose any consecutive range of
 5476 |     | // liquidity intervals to deposit their liquidity. By doing so, the LP acquires
 5477 |     | // a number of shares in every liquidity interval that belongs to the given
 5478 |     | // range. The shares can be used later to withdraw liquidity along with any
 5479 |     | // accumulated growth which is accrued as a result of swap and donate actions.
 5480 |     | uint16 constant _modifyPositionInput_ = 248;
 5481 |     | 
 5482 |     | // Every LP position is characterized by two prices 'pMin' and 'pMax'. These
 5483 |     | // two prices, respectively, correspond to the left and the right boundaries of
 5484 |     | // the consecutive range in which the LP intends to deposit or withdraw
 5485 |     | // liquidity. The following two 8 bytes memory spaces, respectively, host:
 5486 |     | //
 5487 |     | //  '(2 ** 59) * (16 + log(pMin / pOffset))',
 5488 |     | //  '(2 ** 59) * (16 + log(pMax / pOffset))'.
 5489 |     | uint16 constant _logPriceMinOffsetted_ = 248;
 5490 |     | uint16 constant _logPriceMaxOffsetted_ = 256;
 5491 |     | 
 5492 |     | // This 32 bytes memory space hosts the number of shares to be added (positive)
 5493 |     | // or removed (negative).
 5494 |     | uint16 constant _shares_ = 264;
 5495 |     | 
 5496 |     | // The following two 32 bytes memory spaces, respectively, host:
 5497 |     | //
 5498 |     | //  'logPriceMin := (2 ** 59) * log(pMin)',
 5499 |     | //  'logPriceMax := (2 ** 59) * log(pMax)'.
 5500 |     | //
 5501 |     | // Both 'logPriceMin' and 'logPriceMax' must be equal to the active interval
 5502 |     | // boundaries modulo 'qSpacing'.
 5503 |     | uint16 constant _logPriceMin_ = 296;
 5504 |     | uint16 constant _logPriceMax_ = 328;
 5505 |     | 
 5506 |     | // The amount of 'tag0' to be added (positive) or removed (negative) in 'X127'
 5507 |     | // representation, as a result of modifyPosition.
 5508 |     | uint16 constant _positionAmount0_ = 360;
 5509 |     | // The amount of 'tag1' to be added (positive) or removed (negative) in 'X127'
 5510 |     | // representation, as a result of modifyPosition.
 5511 |     | uint16 constant _positionAmount1_ = 392;
 5512 |     | 
 5513 |     | uint16 constant _endOfModifyPosition_ = 424;
 5514 |     | 
 5515 |     | ////////////////////////////////////////////////////////////////////////////////
 5516 |     | // The remainder of this script contains automatically generated getter and
 5517 |     | // setter functions for the parameters introduced above.
 5518 |     | 
 5519 |     | function getFreeMemoryPointer() pure returns (
 5520 |     |   uint256 freeMemoryPointer
 5521 |     | ) {
 5522 |     |   assembly {
 5523 |     |     freeMemoryPointer := mload(_freeMemoryPointer_)
 5524 |     |   }
 5525 |     | }
 5526 |     | 
 5527 |     | function setFreeMemoryPointer(
 5528 |     |   uint256 freeMemoryPointer
 5529 |     | ) pure {
 5530 |     |   assembly {
 5531 |     |     mstore(_freeMemoryPointer_, freeMemoryPointer)
 5532 |     |   }
 5533 |     | }
 5534 |     | 
 5535 |     | function setHookSelector(
 5536 |     |   uint32 hookSelector
 5537 |     | ) pure {
 5538 |     |   assembly {
 5539 |     |     mstore(
 5540 |     |       _hookSelector_,
 5541 |     |       or(
 5542 |     |         shl(224, hookSelector),
 5543 |     |         shr(32, mload(add(_hookSelector_, 4)))
 5544 |     |       )
 5545 |     |     )
 5546 |     |   }
 5547 |     | }
 5548 |     | 
 5549 |     | function setHookInputHeader(
 5550 |     |   uint256 hookInputHeader
 5551 |     | ) pure {
 5552 |     |   assembly {
 5553 |     |     mstore(_hookInputHeader_, hookInputHeader)
 5554 |     |   }
 5555 |     | }
 5556 |     | 
 5557 |     | function getHookInputByteCount() pure returns (
 5558 |     |   uint256 hookInputByteCount
 5559 |     | ) {
 5560 |     |   assembly {
 5561 |     |     hookInputByteCount := mload(_hookInputByteCount_)
 5562 |     |   }
 5563 |     | }
 5564 |     | 
 5565 |     | function setHookInputByteCount(
 5566 |     |   uint256 hookInputByteCount
 5567 |     | ) pure {
 5568 |     |   assembly {
 5569 |     |     mstore(_hookInputByteCount_, hookInputByteCount)
 5570 |     |   }
 5571 |     | }
 5572 |     | 
 5573 |     | function setMsgSender(
 5574 |     |   address msgSender
 5575 |     | ) pure {
 5576 |     |   assembly {
 5577 |     |     mstore(
 5578 |     |       _msgSender_,
 5579 |     |       or(
 5580 |     |         shl(96, msgSender),
 5581 |     |         shr(160, mload(add(_msgSender_, 20)))
 5582 |     |       )
 5583 |     |     )
 5584 |     |   }
 5585 |     | }
 5586 |     | 
 5587 |     | function getPoolId() pure returns (
 5588 |     |   uint256 poolId
 5589 |     | ) {
 5590 |     |   assembly {
 5591 |     |     poolId := mload(_poolId_)
 5592 |     |   }
 5593 |     | }
 5594 |     | 
 5595 |     | function setPoolId(
 5596 |     |   uint256 poolId
 5597 |     | ) pure {
 5598 |     |   assembly {
 5599 |     |     mstore(_poolId_, poolId)
 5600 |     |   }
 5601 |     | }
 5602 |     | 
 5603 |     | function getCrossThreshold() pure returns (
 5604 |     |   uint256 crossThreshold
 5605 |     | ) {
 5606 |     |   assembly {
 5607 |     |     crossThreshold := shr(128, mload(_crossThreshold_))
 5608 |     |   }
 5609 |     | }
 5610 |     | 
 5611 |     | function setCrossThreshold(
 5612 |     |   uint256 crossThreshold
 5613 |     | ) pure {
 5614 |     |   assembly {
 5615 |     |     mstore(
 5616 |     |       _crossThreshold_,
 5617 |     |       or(
 5618 |     |         shl(128, crossThreshold),
 5619 |     |         shr(128, mload(add(_crossThreshold_, 16)))
 5620 |     |       )
 5621 |     |     )
 5622 |     |   }
 5623 |     | }
 5624 |     | 
 5625 |     | function getAmountSpecified() pure returns (
 5626 |     |   X127 amountSpecified
 5627 |     | ) {
 5628 |     |   assembly {
 5629 |     |     amountSpecified := mload(_amountSpecified_)
 5630 |     |   }
 5631 |     | }
 5632 |     | 
 5633 |     | function setAmountSpecified(
 5634 |     |   X127 amountSpecified
 5635 |     | ) pure {
 5636 |     |   assembly {
 5637 |     |     mstore(_amountSpecified_, amountSpecified)
 5638 |     |   }
 5639 |     | }
 5640 |     | 
 5641 |     | function getLogPriceLimit() pure returns (
 5642 |     |   X59 logPriceLimit
 5643 |     | ) {
 5644 |     |   assembly {
 5645 |     |     logPriceLimit := mload(_logPriceLimit_)
 5646 |     |   }
 5647 |     | }
 5648 |     | 
 5649 |     | function setLogPriceLimit(
 5650 |     |   X59 logPriceLimit
 5651 |     | ) pure {
 5652 |     |   assembly {
 5653 |     |     mstore(_logPriceLimit_, logPriceLimit)
 5654 |     |   }
 5655 |     | }
 5656 |     | 
 5657 |     | function getLogPriceLimitOffsetted() pure returns (
 5658 |     |   X59 logPriceLimitOffsetted
 5659 |     | ) {
 5660 |     |   assembly {
 5661 |     |     logPriceLimitOffsetted := shr(192, mload(_logPriceLimitOffsetted_))
 5662 |     |   }
 5663 |     | }
 5664 |     | 
 5665 |     | function setLogPriceLimitOffsetted(
 5666 |     |   X59 logPriceLimitOffsetted
 5667 |     | ) pure {
 5668 |     |   assembly {
 5669 |     |     mstore(
 5670 |     |       _logPriceLimitOffsetted_,
 5671 |     |       or(
 5672 |     |         shl(192, logPriceLimitOffsetted),
 5673 |     |         shr(64, mload(add(_logPriceLimitOffsetted_, 8)))
 5674 |     |       )
 5675 |     |     )
 5676 |     |   }
 5677 |     | }
 5678 |     | 
 5679 |     | function getZeroForOne() pure returns (
 5680 |     |   bool zeroForOne
 5681 |     | ) {
 5682 |     |   assembly {
 5683 |     |     zeroForOne := shr(255, mload(_zeroForOne_))
 5684 |     |   }
 5685 |     | }
 5686 |     | 
 5687 |     | function setZeroForOne(
 5688 |     |   bool zeroForOne
 5689 |     | ) pure {
 5690 |     |   assembly {
 5691 |     |     mstore8(_zeroForOne_, mul(0xFF, zeroForOne))
 5692 |     |   }
 5693 |     | }
 5694 |     | 
 5695 |     | function getExactInput() pure returns (
 5696 |     |   bool exactInput
 5697 |     | ) {
 5698 |     |   assembly {
 5699 |     |     exactInput := shr(255, mload(_exactInput_))
 5700 |     |   }
 5701 |     | }
 5702 |     | 
 5703 |     | function setExactInput(
 5704 |     |   bool exactInput
 5705 |     | ) pure {
 5706 |     |   assembly {
 5707 |     |     mstore8(_exactInput_, mul(0xFF, exactInput))
 5708 |     |   }
 5709 |     | }
 5710 |     | 
 5711 |     | function getIntegralLimit() pure returns (
 5712 |     |   X216 integralLimit
 5713 |     | ) {
 5714 |     |   assembly {
 5715 |     |     integralLimit := shr(40, mload(_integralLimit_))
 5716 |     |   }
 5717 |     | }
 5718 |     | 
 5719 |     | function setIntegralLimit(
 5720 |     |   X216 integralLimit
 5721 |     | ) pure {
 5722 |     |   assembly {
 5723 |     |     mstore(
 5724 |     |       _integralLimit_,
 5725 |     |       or(
 5726 |     |         shl(40, integralLimit),
 5727 |     |         shr(216, mload(add(_integralLimit_, 27)))
 5728 |     |       )
 5729 |     |     )
 5730 |     |   }
 5731 |     | }
 5732 |     | 
 5733 |     | function getIntegralLimitInterval() pure returns (
 5734 |     |   X216 integralLimitInterval
 5735 |     | ) {
 5736 |     |   assembly {
 5737 |     |     integralLimitInterval := shr(40, mload(_integralLimitInterval_))
 5738 |     |   }
 5739 |     | }
 5740 |     | 
 5741 |     | function setIntegralLimitInterval(
 5742 |     |   X216 integralLimitInterval
 5743 |     | ) pure {
 5744 |     |   assembly {
 5745 |     |     mstore(
 5746 |     |       _integralLimitInterval_,
 5747 |     |       or(
 5748 |     |         shl(40, integralLimitInterval),
 5749 |     |         shr(216, mload(add(_integralLimitInterval_, 27)))
 5750 |     |       )
 5751 |     |     )
 5752 |     |   }
 5753 |     | }
 5754 |     | 
 5755 |     | function getAmount0() pure returns (
 5756 |     |   X127 amount0
 5757 |     | ) {
 5758 |     |   assembly {
 5759 |     |     amount0 := mload(_amount0_)
 5760 |     |   }
 5761 |     | }
 5762 |     | 
 5763 |     | function setAmount0(
 5764 |     |   X127 amount0
 5765 |     | ) pure {
 5766 |     |   assembly {
 5767 |     |     mstore(_amount0_, amount0)
 5768 |     |   }
 5769 |     | }
 5770 |     | 
 5771 |     | function getAmount1() pure returns (
 5772 |     |   X127 amount1
 5773 |     | ) {
 5774 |     |   assembly {
 5775 |     |     amount1 := mload(_amount1_)
 5776 |     |   }
 5777 |     | }
 5778 |     | 
 5779 |     | function setAmount1(
 5780 |     |   X127 amount1
 5781 |     | ) pure {
 5782 |     |   assembly {
 5783 |     |     mstore(_amount1_, amount1)
 5784 |     |   }
 5785 |     | }
 5786 |     | 
 5787 |     | function getBackGrowthMultiplier() pure returns (
 5788 |     |   X208 backGrowthMultiplier
 5789 |     | ) {
 5790 |     |   assembly {
 5791 |     |     backGrowthMultiplier := mload(_backGrowthMultiplier_)
 5792 |     |   }
 5793 |     | }
 5794 |     | 
 5795 |     | function setBackGrowthMultiplier(
 5796 |     |   X208 backGrowthMultiplier
 5797 |     | ) pure {
 5798 |     |   assembly {
 5799 |     |     mstore(_backGrowthMultiplier_, backGrowthMultiplier)
 5800 |     |   }
 5801 |     | }
 5802 |     | 
 5803 |     | function getNextGrowthMultiplier() pure returns (
 5804 |     |   X208 nextGrowthMultiplier
 5805 |     | ) {
 5806 |     |   assembly {
 5807 |     |     nextGrowthMultiplier := mload(_nextGrowthMultiplier_)
 5808 |     |   }
 5809 |     | }
 5810 |     | 
 5811 |     | function setNextGrowthMultiplier(
 5812 |     |   X208 nextGrowthMultiplier
 5813 |     | ) pure {
 5814 |     |   assembly {
 5815 |     |     mstore(_nextGrowthMultiplier_, nextGrowthMultiplier)
 5816 |     |   }
 5817 |     | }
 5818 |     | 
 5819 |     | function getDirection() pure returns (
 5820 |     |   bool direction
 5821 |     | ) {
 5822 |     |   assembly {
 5823 |     |     direction := shr(255, mload(_direction_))
 5824 |     |   }
 5825 |     | }
 5826 |     | 
 5827 |     | function setDirection(
 5828 |     |   bool direction
 5829 |     | ) pure {
 5830 |     |   assembly {
 5831 |     |     mstore8(_direction_, mul(0xFF, direction))
 5832 |     |   }
 5833 |     | }
 5834 |     | 
 5835 |     | function getIndexCurve() pure returns (
 5836 |     |   Index indexCurve
 5837 |     | ) {
 5838 |     |   assembly {
 5839 |     |     indexCurve := shr(240, mload(_indexCurve_))
 5840 |     |   }
 5841 |     | }
 5842 |     | 
 5843 |     | function setIndexCurve(
 5844 |     |   Index indexCurve
 5845 |     | ) pure {
 5846 |     |   assembly {
 5847 |     |     mstore(
 5848 |     |       _indexCurve_,
 5849 |     |       or(
 5850 |     |         shl(240, indexCurve),
 5851 |     |         shr(16, mload(add(_indexCurve_, 2)))
 5852 |     |       )
 5853 |     |     )
 5854 |     |   }
 5855 |     | }
 5856 |     | 
 5857 |     | function getLogPriceLimitOffsettedWithinInterval() pure returns (
 5858 |     |   X59 logPriceLimitOffsettedWithinInterval
 5859 |     | ) {
 5860 |     |   assembly {
 5861 |     |     logPriceLimitOffsettedWithinInterval := 
 5862 |     |       shr(192, mload(_logPriceLimitOffsettedWithinInterval_))
 5863 |     |   }
 5864 |     | }
 5865 |     | 
 5866 |     | function setLogPriceLimitOffsettedWithinInterval(
 5867 |     |   X59 logPriceLimitOffsettedWithinInterval
 5868 |     | ) pure {
 5869 |     |   assembly {
 5870 |     |     mstore(
 5871 |     |       _logPriceLimitOffsettedWithinInterval_,
 5872 |     |       or(
 5873 |     |         shl(192, logPriceLimitOffsettedWithinInterval),
 5874 |     |         shr(64, mload(add(_logPriceLimitOffsettedWithinInterval_, 8)))
 5875 |     |       )
 5876 |     |     )
 5877 |     |   }
 5878 |     | }
 5879 |     | 
 5880 |     | function getAccrued0() pure returns (
 5881 |     |   X127 accrued0
 5882 |     | ) {
 5883 |     |   assembly {
 5884 |     |     accrued0 := mload(_accrued0_)
 5885 |     |   }
 5886 |     | }
 5887 |     | 
 5888 |     | function setAccrued0(
 5889 |     |   X127 accrued0
 5890 |     | ) pure {
 5891 |     |   assembly {
 5892 |     |     mstore(_accrued0_, accrued0)
 5893 |     |   }
 5894 |     | }
 5895 |     | 
 5896 |     | function getAccrued1() pure returns (
 5897 |     |   X127 accrued1
 5898 |     | ) {
 5899 |     |   assembly {
 5900 |     |     accrued1 := mload(_accrued1_)
 5901 |     |   }
 5902 |     | }
 5903 |     | 
 5904 |     | function setAccrued1(
 5905 |     |   X127 accrued1
 5906 |     | ) pure {
 5907 |     |   assembly {
 5908 |     |     mstore(_accrued1_, accrued1)
 5909 |     |   }
 5910 |     | }
 5911 |     | 
 5912 |     | function getPoolRatio0() pure returns (
 5913 |     |   X23 poolRatio0
 5914 |     | ) {
 5915 |     |   assembly {
 5916 |     |     poolRatio0 := shr(232, mload(_poolRatio0_))
 5917 |     |   }
 5918 |     | }
 5919 |     | 
 5920 |     | function setPoolRatio0(
 5921 |     |   X23 poolRatio0
 5922 |     | ) pure {
 5923 |     |   assembly {
 5924 |     |     mstore(
 5925 |     |       _poolRatio0_,
 5926 |     |       or(
 5927 |     |         shl(232, poolRatio0),
 5928 |     |         shr(24, mload(add(_poolRatio0_, 3)))
 5929 |     |       )
 5930 |     |     )
 5931 |     |   }
 5932 |     | }
 5933 |     | 
 5934 |     | function getPoolRatio1() pure returns (
 5935 |     |   X23 poolRatio1
 5936 |     | ) {
 5937 |     |   assembly {
 5938 |     |     poolRatio1 := shr(232, mload(_poolRatio1_))
 5939 |     |   }
 5940 |     | }
 5941 |     | 
 5942 |     | function setPoolRatio1(
 5943 |     |   X23 poolRatio1
 5944 |     | ) pure {
 5945 |     |   assembly {
 5946 |     |     mstore(
 5947 |     |       _poolRatio1_,
 5948 |     |       or(
 5949 |     |         shl(232, poolRatio1),
 5950 |     |         shr(24, mload(add(_poolRatio1_, 3)))
 5951 |     |       )
 5952 |     |     )
 5953 |     |   }
 5954 |     | }
 5955 |     | 
 5956 |     | function getKernel() pure returns (
 5957 |     |   Kernel kernel
 5958 |     | ) {
 5959 |     |   assembly {
 5960 |     |     kernel := mload(_kernel_)
 5961 |     |   }
 5962 |     | }
 5963 |     | 
 5964 |     | function setKernel(
 5965 |     |   Kernel kernel
 5966 |     | ) pure {
 5967 |     |   assembly {
 5968 |     |     mstore(_kernel_, kernel)
 5969 |     |   }
 5970 |     | }
 5971 |     | 
 5972 |     | function getCurve() pure returns (
 5973 |     |   Curve curve
 5974 |     | ) {
 5975 |     |   assembly {
 5976 |     |     curve := mload(_curve_)
 5977 |     |   }
 5978 |     | }
 5979 |     | 
 5980 |     | function setCurve(
 5981 |     |   Curve curve
 5982 |     | ) pure {
 5983 |     |   assembly {
 5984 |     |     mstore(_curve_, curve)
 5985 |     |   }
 5986 |     | }
 5987 |     | 
 5988 |     | function getHookData() pure returns (
 5989 |     |   uint256 hookData
 5990 |     | ) {
 5991 |     |   assembly {
 5992 |     |     hookData := mload(_hookData_)
 5993 |     |   }
 5994 |     | }
 5995 |     | 
 5996 |     | function setHookData(
 5997 |     |   uint256 hookData
 5998 |     | ) pure {
 5999 |     |   assembly {
 6000 |     |     mstore(_hookData_, hookData)
 6001 |     |   }
 6002 |     | }
 6003 |     | 
 6004 |     | function getKernelLength() pure returns (
 6005 |     |   Index kernelLength
 6006 |     | ) {
 6007 |     |   assembly {
 6008 |     |     kernelLength := shr(240, mload(_kernelLength_))
 6009 |     |   }
 6010 |     | }
 6011 |     | 
 6012 |     | function setKernelLength(
 6013 |     |   Index kernelLength
 6014 |     | ) pure {
 6015 |     |   assembly {
 6016 |     |     mstore(
 6017 |     |       _kernelLength_,
 6018 |     |       or(
 6019 |     |         shl(240, kernelLength),
 6020 |     |         shr(16, mload(add(_kernelLength_, 2)))
 6021 |     |       )
 6022 |     |     )
 6023 |     |   }
 6024 |     | }
 6025 |     | 
 6026 |     | function getCurveLength() pure returns (
 6027 |     |   Index curveLength
 6028 |     | ) {
 6029 |     |   assembly {
 6030 |     |     curveLength := shr(240, mload(_curveLength_))
 6031 |     |   }
 6032 |     | }
 6033 |     | 
 6034 |     | function setCurveLength(
 6035 |     |   Index curveLength
 6036 |     | ) pure {
 6037 |     |   assembly {
 6038 |     |     mstore(
 6039 |     |       _curveLength_,
 6040 |     |       or(
 6041 |     |         shl(240, curveLength),
 6042 |     |         shr(16, mload(add(_curveLength_, 2)))
 6043 |     |       )
 6044 |     |     )
 6045 |     |   }
 6046 |     | }
 6047 |     | 
 6048 |     | function getHookDataByteCount() pure returns (
 6049 |     |   uint16 hookDataByteCount
 6050 |     | ) {
 6051 |     |   assembly {
 6052 |     |     hookDataByteCount := shr(240, mload(_hookDataByteCount_))
 6053 |     |   }
 6054 |     | }
 6055 |     | 
 6056 |     | function setHookDataByteCount(
 6057 |     |   uint16 hookDataByteCount
 6058 |     | ) pure {
 6059 |     |   assembly {
 6060 |     |     mstore(
 6061 |     |       _hookDataByteCount_,
 6062 |     |       or(
 6063 |     |         shl(240, hookDataByteCount),
 6064 |     |         shr(16, mload(add(_hookDataByteCount_, 2)))
 6065 |     |       )
 6066 |     |     )
 6067 |     |   }
 6068 |     | }
 6069 |     | 
 6070 |     | function getStaticParamsStoragePointerExtension() pure returns (
 6071 |     |   uint256 staticParamsStoragePointerExtension
 6072 |     | ) {
 6073 |     |   assembly {
 6074 |     |     staticParamsStoragePointerExtension := 
 6075 |     |       mload(_staticParamsStoragePointerExtension_)
 6076 |     |   }
 6077 |     | }
 6078 |     | 
 6079 |     | function setStaticParamsStoragePointerExtension(
 6080 |     |   uint256 staticParamsStoragePointerExtension
 6081 |     | ) pure {
 6082 |     |   assembly {
 6083 |     |     mstore(
 6084 |     |       _staticParamsStoragePointerExtension_,
 6085 |     |       staticParamsStoragePointerExtension
 6086 |     |     )
 6087 |     |   }
 6088 |     | }
 6089 |     | 
 6090 |     | function getGrowth() pure returns (
 6091 |     |   X111 growth
 6092 |     | ) {
 6093 |     |   assembly {
 6094 |     |     growth := shr(128, mload(_growth_))
 6095 |     |   }
 6096 |     | }
 6097 |     | 
 6098 |     | function setGrowth(
 6099 |     |   X111 growth
 6100 |     | ) pure {
 6101 |     |   assembly {
 6102 |     |     mstore(
 6103 |     |       _growth_,
 6104 |     |       or(
 6105 |     |         shl(128, growth),
 6106 |     |         shr(128, mload(add(_growth_, 16)))
 6107 |     |       )
 6108 |     |     )
 6109 |     |   }
 6110 |     | }
 6111 |     | 
 6112 |     | function getIntegral0() pure returns (
 6113 |     |   X216 integral0
 6114 |     | ) {
 6115 |     |   assembly {
 6116 |     |     integral0 := shr(40, mload(_integral0_))
 6117 |     |   }
 6118 |     | }
 6119 |     | 
 6120 |     | function setIntegral0(
 6121 |     |   X216 integral0
 6122 |     | ) pure {
 6123 |     |   assembly {
 6124 |     |     mstore(
 6125 |     |       _integral0_,
 6126 |     |       or(
 6127 |     |         shl(40, integral0),
 6128 |     |         shr(216, mload(add(_integral0_, 27)))
 6129 |     |       )
 6130 |     |     )
 6131 |     |   }
 6132 |     | }
 6133 |     | 
 6134 |     | function getIntegral1() pure returns (
 6135 |     |   X216 integral1
 6136 |     | ) {
 6137 |     |   assembly {
 6138 |     |     integral1 := shr(40, mload(_integral1_))
 6139 |     |   }
 6140 |     | }
 6141 |     | 
 6142 |     | function setIntegral1(
 6143 |     |   X216 integral1
 6144 |     | ) pure {
 6145 |     |   assembly {
 6146 |     |     mstore(
 6147 |     |       _integral1_,
 6148 |     |       or(
 6149 |     |         shl(40, integral1),
 6150 |     |         shr(216, mload(add(_integral1_, 27)))
 6151 |     |       )
 6152 |     |     )
 6153 |     |   }
 6154 |     | }
 6155 |     | 
 6156 |     | function getSharesTotal() pure returns (
 6157 |     |   uint256 sharesTotal
 6158 |     | ) {
 6159 |     |   assembly {
 6160 |     |     sharesTotal := shr(128, mload(_sharesTotal_))
 6161 |     |   }
 6162 |     | }
 6163 |     | 
 6164 |     | function setSharesTotal(
 6165 |     |   uint256 sharesTotal
 6166 |     | ) pure {
 6167 |     |   assembly {
 6168 |     |     mstore(
 6169 |     |       _sharesTotal_,
 6170 |     |       or(
 6171 |     |         shl(128, sharesTotal),
 6172 |     |         shr(128, mload(add(_sharesTotal_, 16)))
 6173 |     |       )
 6174 |     |     )
 6175 |     |   }
 6176 |     | }
 6177 |     | 
 6178 |     | function getStaticParamsStoragePointer() pure returns (
 6179 |     |   uint16 staticParamsStoragePointer
 6180 |     | ) {
 6181 |     |   assembly {
 6182 |     |     staticParamsStoragePointer := shr(240, mload(_staticParamsStoragePointer_))
 6183 |     |   }
 6184 |     | }
 6185 |     | 
 6186 |     | function setStaticParamsStoragePointer(
 6187 |     |   uint16 staticParamsStoragePointer
 6188 |     | ) pure {
 6189 |     |   assembly {
 6190 |     |     mstore(
 6191 |     |       _staticParamsStoragePointer_,
 6192 |     |       or(
 6193 |     |         shl(240, staticParamsStoragePointer),
 6194 |     |         shr(16, mload(add(_staticParamsStoragePointer_, 2)))
 6195 |     |       )
 6196 |     |     )
 6197 |     |   }
 6198 |     | }
 6199 |     | 
 6200 |     | function getLogPriceCurrent() pure returns (
 6201 |     |   X59 logPriceCurrent
 6202 |     | ) {
 6203 |     |   assembly {
 6204 |     |     logPriceCurrent := shr(192, mload(_logPriceCurrent_))
 6205 |     |   }
 6206 |     | }
 6207 |     | 
 6208 |     | function setLogPriceCurrent(
 6209 |     |   X59 logPriceCurrent
 6210 |     | ) pure {
 6211 |     |   assembly {
 6212 |     |     mstore(
 6213 |     |       _logPriceCurrent_,
 6214 |     |       or(
 6215 |     |         shl(192, logPriceCurrent),
 6216 |     |         shr(64, mload(add(_logPriceCurrent_, 8)))
 6217 |     |       )
 6218 |     |     )
 6219 |     |   }
 6220 |     | }
 6221 |     | 
 6222 |     | function setDeploymentCreationCode(
 6223 |     |   uint256 deploymentCreationCode
 6224 |     | ) pure {
 6225 |     |   assembly {
 6226 |     |     mstore(
 6227 |     |       _deploymentCreationCode_,
 6228 |     |       or(
 6229 |     |         shl(168, deploymentCreationCode),
 6230 |     |         shr(88, mload(add(_deploymentCreationCode_, 11)))
 6231 |     |       )
 6232 |     |     )
 6233 |     |   }
 6234 |     | }
 6235 |     | 
 6236 |     | function getTag0() pure returns (
 6237 |     |   Tag tag0
 6238 |     | ) {
 6239 |     |   assembly {
 6240 |     |     tag0 := mload(_tag0_)
 6241 |     |   }
 6242 |     | }
 6243 |     | 
 6244 |     | function setTag0(
 6245 |     |   Tag tag0
 6246 |     | ) pure {
 6247 |     |   assembly {
 6248 |     |     mstore(_tag0_, tag0)
 6249 |     |   }
 6250 |     | }
 6251 |     | 
 6252 |     | function getTag1() pure returns (
 6253 |     |   Tag tag1
 6254 |     | ) {
 6255 |     |   assembly {
 6256 |     |     tag1 := mload(_tag1_)
 6257 |     |   }
 6258 |     | }
 6259 |     | 
 6260 |     | function setTag1(
 6261 |     |   Tag tag1
 6262 |     | ) pure {
 6263 |     |   assembly {
 6264 |     |     mstore(_tag1_, tag1)
 6265 |     |   }
 6266 |     | }
 6267 |     | 
 6268 |     | function getSqrtOffset() pure returns (
 6269 |     |   X127 sqrtOffset
 6270 |     | ) {
 6271 |     |   assembly {
 6272 |     |     sqrtOffset := mload(_sqrtOffset_)
 6273 |     |   }
 6274 |     | }
 6275 |     | 
 6276 |     | function setSqrtOffset(
 6277 |     |   X127 sqrtOffset
 6278 |     | ) pure {
 6279 |     |   assembly {
 6280 |     |     mstore(_sqrtOffset_, sqrtOffset)
 6281 |     |   }
 6282 |     | }
 6283 |     | 
 6284 |     | function getSqrtInverseOffset() pure returns (
 6285 |     |   X127 sqrtInverseOffset
 6286 |     | ) {
 6287 |     |   assembly {
 6288 |     |     sqrtInverseOffset := mload(_sqrtInverseOffset_)
 6289 |     |   }
 6290 |     | }
 6291 |     | 
 6292 |     | function setSqrtInverseOffset(
 6293 |     |   X127 sqrtInverseOffset
 6294 |     | ) pure {
 6295 |     |   assembly {
 6296 |     |     mstore(_sqrtInverseOffset_, sqrtInverseOffset)
 6297 |     |   }
 6298 |     | }
 6299 |     | 
 6300 |     | function getOutgoingMax() pure returns (
 6301 |     |   X216 outgoingMax
 6302 |     | ) {
 6303 |     |   assembly {
 6304 |     |     outgoingMax := shr(40, mload(_outgoingMax_))
 6305 |     |   }
 6306 |     | }
 6307 |     | 
 6308 |     | function setOutgoingMax(
 6309 |     |   X216 outgoingMax
 6310 |     | ) pure {
 6311 |     |   assembly {
 6312 |     |     mstore(
 6313 |     |       _outgoingMax_,
 6314 |     |       or(
 6315 |     |         shl(40, outgoingMax),
 6316 |     |         shr(216, mload(add(_outgoingMax_, 27)))
 6317 |     |       )
 6318 |     |     )
 6319 |     |   }
 6320 |     | }
 6321 |     | 
 6322 |     | function getOutgoingMaxModularInverse() pure returns (
 6323 |     |   uint256 outgoingMaxModularInverse
 6324 |     | ) {
 6325 |     |   assembly {
 6326 |     |     outgoingMaxModularInverse := mload(_outgoingMaxModularInverse_)
 6327 |     |   }
 6328 |     | }
 6329 |     | 
 6330 |     | function setOutgoingMaxModularInverse(
 6331 |     |   uint256 outgoingMaxModularInverse
 6332 |     | ) pure {
 6333 |     |   assembly {
 6334 |     |     mstore(_outgoingMaxModularInverse_, outgoingMaxModularInverse)
 6335 |     |   }
 6336 |     | }
 6337 |     | 
 6338 |     | function getIncomingMax() pure returns (
 6339 |     |   X216 incomingMax
 6340 |     | ) {
 6341 |     |   assembly {
 6342 |     |     incomingMax := shr(40, mload(_incomingMax_))
 6343 |     |   }
 6344 |     | }
 6345 |     | 
 6346 |     | function setIncomingMax(
 6347 |     |   X216 incomingMax
 6348 |     | ) pure {
 6349 |     |   assembly {
 6350 |     |     mstore(
 6351 |     |       _incomingMax_,
 6352 |     |       or(
 6353 |     |         shl(40, incomingMax),
 6354 |     |         shr(216, mload(add(_incomingMax_, 27)))
 6355 |     |       )
 6356 |     |     )
 6357 |     |   }
 6358 |     | }
 6359 |     | 
 6360 |     | function getPoolGrowthPortion() pure returns (
 6361 |     |   X47 poolGrowthPortion
 6362 |     | ) {
 6363 |     |   assembly {
 6364 |     |     poolGrowthPortion := shr(208, mload(_poolGrowthPortion_))
 6365 |     |   }
 6366 |     | }
 6367 |     | 
 6368 |     | function setPoolGrowthPortion(
 6369 |     |   X47 poolGrowthPortion
 6370 |     | ) pure {
 6371 |     |   assembly {
 6372 |     |     mstore(
 6373 |     |       _poolGrowthPortion_,
 6374 |     |       or(
 6375 |     |         shl(208, poolGrowthPortion),
 6376 |     |         shr(48, mload(add(_poolGrowthPortion_, 6)))
 6377 |     |       )
 6378 |     |     )
 6379 |     |   }
 6380 |     | }
 6381 |     | 
 6382 |     | function getMaxPoolGrowthPortion() pure returns (
 6383 |     |   X47 maxPoolGrowthPortion
 6384 |     | ) {
 6385 |     |   assembly {
 6386 |     |     maxPoolGrowthPortion := shr(208, mload(_maxPoolGrowthPortion_))
 6387 |     |   }
 6388 |     | }
 6389 |     | 
 6390 |     | function setMaxPoolGrowthPortion(
 6391 |     |   X47 maxPoolGrowthPortion
 6392 |     | ) pure {
 6393 |     |   assembly {
 6394 |     |     mstore(
 6395 |     |       _maxPoolGrowthPortion_,
 6396 |     |       or(
 6397 |     |         shl(208, maxPoolGrowthPortion),
 6398 |     |         shr(48, mload(add(_maxPoolGrowthPortion_, 6)))
 6399 |     |       )
 6400 |     |     )
 6401 |     |   }
 6402 |     | }
 6403 |     | 
 6404 |     | function getProtocolGrowthPortion() pure returns (
 6405 |     |   X47 protocolGrowthPortion
 6406 |     | ) {
 6407 |     |   assembly {
 6408 |     |     protocolGrowthPortion := shr(208, mload(_protocolGrowthPortion_))
 6409 |     |   }
 6410 |     | }
 6411 |     | 
 6412 |     | function setProtocolGrowthPortion(
 6413 |     |   X47 protocolGrowthPortion
 6414 |     | ) pure {
 6415 |     |   assembly {
 6416 |     |     mstore(
 6417 |     |       _protocolGrowthPortion_,
 6418 |     |       or(
 6419 |     |         shl(208, protocolGrowthPortion),
 6420 |     |         shr(48, mload(add(_protocolGrowthPortion_, 6)))
 6421 |     |       )
 6422 |     |     )
 6423 |     |   }
 6424 |     | }
 6425 |     | 
 6426 |     | function getPendingKernelLength() pure returns (
 6427 |     |   Index pendingKernelLength
 6428 |     | ) {
 6429 |     |   assembly {
 6430 |     |     pendingKernelLength := shr(240, mload(_pendingKernelLength_))
 6431 |     |   }
 6432 |     | }
 6433 |     | 
 6434 |     | function setPendingKernelLength(
 6435 |     |   Index pendingKernelLength
 6436 |     | ) pure {
 6437 |     |   assembly {
 6438 |     |     mstore(
 6439 |     |       _pendingKernelLength_,
 6440 |     |       or(
 6441 |     |         shl(240, pendingKernelLength),
 6442 |     |         shr(16, mload(add(_pendingKernelLength_, 2)))
 6443 |     |       )
 6444 |     |     )
 6445 |     |   }
 6446 |     | }
 6447 |     | 
 6448 |     | function getLogPriceMinOffsetted() pure returns (
 6449 |     |   X59 logPriceMinOffsetted
 6450 |     | ) {
 6451 |     |   assembly {
 6452 |     |     logPriceMinOffsetted := shr(192, mload(_logPriceMinOffsetted_))
 6453 |     |   }
 6454 |     | }
 6455 |     | 
 6456 |     | function setLogPriceMinOffsetted(
 6457 |     |   X59 logPriceMinOffsetted
 6458 |     | ) pure {
 6459 |     |   assembly {
 6460 |     |     mstore(
 6461 |     |       _logPriceMinOffsetted_,
 6462 |     |       or(
 6463 |     |         shl(192, logPriceMinOffsetted),
 6464 |     |         shr(64, mload(add(_logPriceMinOffsetted_, 8)))
 6465 |     |       )
 6466 |     |     )
 6467 |     |   }
 6468 |     | }
 6469 |     | 
 6470 |     | function getLogPriceMaxOffsetted() pure returns (
 6471 |     |   X59 logPriceMaxOffsetted
 6472 |     | ) {
 6473 |     |   assembly {
 6474 |     |     logPriceMaxOffsetted := shr(192, mload(_logPriceMaxOffsetted_))
 6475 |     |   }
 6476 |     | }
 6477 |     | 
 6478 |     | function setLogPriceMaxOffsetted(
 6479 |     |   X59 logPriceMaxOffsetted
 6480 |     | ) pure {
 6481 |     |   assembly {
 6482 |     |     mstore(
 6483 |     |       _logPriceMaxOffsetted_,
 6484 |     |       or(
 6485 |     |         shl(192, logPriceMaxOffsetted),
 6486 |     |         shr(64, mload(add(_logPriceMaxOffsetted_, 8)))
 6487 |     |       )
 6488 |     |     )
 6489 |     |   }
 6490 |     | }
 6491 |     | 
 6492 |     | function getShares() pure returns (
 6493 |     |   int256 shares
 6494 |     | ) {
 6495 |     |   assembly {
 6496 |     |     shares := mload(_shares_)
 6497 |     |   }
 6498 |     | }
 6499 |     | 
 6500 |     | function setShares(
 6501 |     |   int256 shares
 6502 |     | ) pure {
 6503 |     |   assembly {
 6504 |     |     mstore(_shares_, shares)
 6505 |     |   }
 6506 |     | }
 6507 |     | 
 6508 |     | function getLogPriceMin() pure returns (
 6509 |     |   X59 logPriceMin
 6510 |     | ) {
 6511 |     |   assembly {
 6512 |     |     logPriceMin := mload(_logPriceMin_)
 6513 |     |   }
 6514 |     | }
 6515 |     | 
 6516 |     | function setLogPriceMin(
 6517 |     |   X59 logPriceMin
 6518 |     | ) pure {
 6519 |     |   assembly {
 6520 |     |     mstore(_logPriceMin_, logPriceMin)
 6521 |     |   }
 6522 |     | }
 6523 |     | 
 6524 |     | function getLogPriceMax() pure returns (
 6525 |     |   X59 logPriceMax
 6526 |     | ) {
 6527 |     |   assembly {
 6528 |     |     logPriceMax := mload(_logPriceMax_)
 6529 |     |   }
 6530 |     | }
 6531 |     | 
 6532 |     | function setLogPriceMax(
 6533 |     |   X59 logPriceMax
 6534 |     | ) pure {
 6535 |     |   assembly {
 6536 |     |     mstore(_logPriceMax_, logPriceMax)
 6537 |     |   }
 6538 |     | }
 6539 |     | 
 6540 |     | function getPositionAmount0() pure returns (
 6541 |     |   int256 positionAmount0
 6542 |     | ) {
 6543 |     |   assembly {
 6544 |     |     positionAmount0 := mload(_positionAmount0_)
 6545 |     |   }
 6546 |     | }
 6547 |     | 
 6548 |     | function setPositionAmount0(
 6549 |     |   int256 positionAmount0
 6550 |     | ) pure {
 6551 |     |   assembly {
 6552 |     |     mstore(_positionAmount0_, positionAmount0)
 6553 |     |   }
 6554 |     | }
 6555 |     | 
 6556 |     | function getPositionAmount1() pure returns (
 6557 |     |   int256 positionAmount1
 6558 |     | ) {
 6559 |     |   assembly {
 6560 |     |     positionAmount1 := mload(_positionAmount1_)
 6561 |     |   }
 6562 |     | }
 6563 |     | 
 6564 |     | function setPositionAmount1(
 6565 |     |   int256 positionAmount1
 6566 |     | ) pure {
 6567 |     |   assembly {
 6568 |     |     mstore(_positionAmount1_, positionAmount1)
 6569 |     |   }
 6570 |     | }

/home/training/contracts/utilities/Price.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {X15} from "./X15.sol";
   5 |     | import {X59} from "./X59.sol";
   6 |     | import {X216} from "./X216.sol";
   7 |     | 
   8 |     | library PriceLibrary {
   9 |     |   using PriceLibrary for uint256;
  10 |     | 
  11 |     |   /// @notice Stores a given price in a given memory location with the 
  12 |     |   /// following layout:
  13 |     |   ///
  14 |     |   ///  pointer
  15 |     |   ///     |
  16 |     |   ///     +--------+---------------------------+---------------------------+
  17 |     |   ///     | 8 byte |          27 byte          |          27 byte          |
  18 |     |   ///     +--------+---------------------------+---------------------------+
  19 |     |   ///     |        |                           |
  20 |     |   ///     |        |                            \
  21 |     |   ///     |        |                             sqrtInversePrice
  22 |     |   ///     |         \
  23 |     |   ///     |          sqrtPrice
  24 |     |   ///      \
  25 |     |   ///       logPrice
  26 |     |   ///
  27 |     |   /// 'pointer' should not be less than '32'.
  28 |     |   /// 'logPrice' should be non-negative and less than '2 ** 64'.
  29 |     |   /// 'sqrtPrice' should be non-negative and less than 'oneX216'.
  30 |     |   /// 'sqrtInversePrice' should be non-negative and less than 'oneX216'.
  31 | *   |   function storePrice(
  32 |     |     uint256 pointer,
  33 |     |     X59 logPrice,
  34 |     |     X216 sqrtPrice,
  35 |     |     X216 sqrtInversePrice
  36 |     |   ) internal pure {
  37 | *   |     assembly {
  38 |     |       // The preceding slot is cached so that it can be restored after we place
  39 |     |       // all values in their appropriate memory locations.
  40 |     |       // The subtraction is safe because of the input requirement on 'pointer'.
  41 | *   |       let precedingPointer := sub(pointer, 32)
  42 | *   |       let precedingSlot := mload(precedingPointer)
  43 |     | 
  44 |     |       // We move '64 + 216 + 216' bits forward to reach the following location:
  45 |     |       //
  46 |     |       //                                                          pointer + 62
  47 |     |       //                                                                  \
  48 |     |       //                                                                   |
  49 |     |       //  +--------+---------------------------+---------------------------+
  50 |     |       //  | 8 byte |          27 byte          |          27 byte          |
  51 |     |       //  +--------+---------------------------+---------------------------+
  52 |     |       //  |        |                           |
  53 |     |       //  |        |                            \
  54 |     |       //  |        |                             sqrtInversePrice
  55 |     |       //  |         \
  56 |     |       //  |          sqrtPrice
  57 |     |       //   \
  58 |     |       //    logPrice
  59 |     |       //
  60 |     |       // Then we move '256' bits backward to point to the beginning of the slot
  61 |     |       // whose least significant '216' bits are supposed to host
  62 |     |       // 'sqrtInversePrice'.
  63 |     |       //
  64 |     |       // '64 + 216 + 216 - 256' bits == '30' bytes.
  65 | *   |       mstore(add(pointer, 30), sqrtInversePrice)
  66 |     | 
  67 |     |       // We move '64 + 216' bits forward to reach the following location:
  68 |     |       //
  69 |     |       //                                  pointer + 35
  70 |     |       //                                       |
  71 |     |       //  +--------+---------------------------+---------------------------+
  72 |     |       //  | 8 byte |          27 byte          |          27 byte          |
  73 |     |       //  +--------+---------------------------+---------------------------+
  74 |     |       //  |        |                           |
  75 |     |       //  |        |                            \
  76 |     |       //  |        |                             sqrtInversePrice
  77 |     |       //  |         \
  78 |     |       //  |          sqrtPrice
  79 |     |       //   \
  80 |     |       //    logPrice
  81 |     |       //
  82 |     |       // Then we move '256' bits backward to point to the beginning of the slot
  83 |     |       // whose least significant '216' bits are supposed to host 'sqrtPrice'.
  84 |     |       //
  85 |     |       // '64 + 216 - 256' bits == '3' bytes.
  86 | *   |       mstore(add(pointer, 3), sqrtPrice)
  87 |     | 
  88 |     |       // We move '64' bits forward to reach the following location:
  89 |     |       //
  90 |     |       //      pointer + 8
  91 |     |       //           |
  92 |     |       //  +--------+---------------------------+---------------------------+
  93 |     |       //  | 8 byte |          27 byte          |          27 byte          |
  94 |     |       //  +--------+---------------------------+---------------------------+
  95 |     |       //  |        |                           |
  96 |     |       //  |        |                            \
  97 |     |       //  |        |                             sqrtInversePrice
  98 |     |       //  |         \
  99 |     |       //  |          sqrtPrice
 100 |     |       //   \
 101 |     |       //    logPrice
 102 |     |       //
 103 |     |       // Then we move '256' bits backward to point to the beginning of the slot
 104 |     |       // whose least significant '64' bits are supposed to host 'logPrice'.
 105 |     |       //
 106 |     |       // '64 - 256' bits == '-24' bytes.
 107 |     |       //
 108 |     |       // The subtraction is safe because of the input requirement on 'pointer'.
 109 | *   |       mstore(sub(pointer, 24), logPrice)
 110 |     | 
 111 |     |       // The preceding slot is restored.
 112 | *   |       mstore(precedingPointer, precedingSlot)
 113 |     |     }
 114 |     |   }
 115 |     | 
 116 |     |   /// @notice Calculates the sqrt and sqrtInverse of a given logPrice and
 117 |     |   /// stores everything in the given memory location with the following
 118 |     |   /// layout:
 119 |     |   ///
 120 |     |   ///  pointer
 121 |     |   ///     |
 122 |     |   ///     +--------+---------------------------+---------------------------+
 123 |     |   ///     | 8 byte |          27 byte          |          27 byte          |
 124 |     |   ///     +--------+---------------------------+---------------------------+
 125 |     |   ///     |        |                           |
 126 |     |   ///     |        |                            \
 127 |     |   ///     |        |                             sqrtInversePrice
 128 |     |   ///     |         \
 129 |     |   ///     |          sqrtPrice
 130 |     |   ///      \
 131 |     |   ///       logPrice
 132 |     |   ///
 133 |     |   /// 'pointer' should not be less than '32' and 'pointer + 30' should not
 134 |     |   /// overflow.
 135 |     |   ///
 136 |     |   /// 'logPrice' should be greater than 0 and less than (2 ** 64).
 137 |     |   function storePrice(
 138 |     |     uint256 pointer,
 139 |     |     X59 logPrice
 140 |     |   ) internal pure {
 141 |     |     // The requirements of 'exp' are satisfied here because 
 142 |     |     // '0 < logPrice < 2 ** 64'.
 143 |     |     (X216 sqrtPrice, X216 sqrtInversePrice) = logPrice.exp();
 144 |     | 
 145 |     |     // The requirements of 'storePrice' are satisfied here, because of the
 146 |     |     // input requirement on 'pointer' and because both outputs of 'exp' are
 147 |     |     // less than 'oneX216':
 148 |     |     //
 149 |     |     // '0 < logPrice' -> '(2 ** 216) * exp(- logPrice / (2 ** 60)) < 2 ** 216'
 150 |     |     //
 151 |     |     // 'logPrice < 2 ** 64' -> 
 152 |     |     // '(2 ** 216) * exp(- 16 + logPrice / (2 ** 60)) < 2 ** 216'
 153 |     |     //
 154 |     |     pointer.storePrice(logPrice, sqrtPrice, sqrtInversePrice);
 155 |     |   }
 156 |     | 
 157 |     |   /// @notice Stores a given price in a given memory location with the
 158 |     |   /// following layout:
 159 |     |   ///
 160 |     |   ///   pointer
 161 |     |   ///      |
 162 |     |   ///   +--+--------+---------------------------+---------------------------+
 163 |     |   ///   |  | 8 byte |          27 byte          |          27 byte          |
 164 |     |   ///   +--+--------+---------------------------+---------------------------+
 165 |     |   ///   |  |        |                           |
 166 |     |   ///   |  |        |                            \
 167 |     |   ///   |  |        |                             sqrtInversePrice
 168 |     |   ///   |  |         \
 169 |     |   ///   |  |          sqrtPrice
 170 |     |   ///   |   \
 171 |     |   ///   |    logPrice
 172 |     |   ///    \
 173 |     |   ///     heightPrice
 174 |     |   ///
 175 |     |   /// 'pointer' should not be less than '34'.
 176 |     |   /// 'heightPrice' should be less than or equal to 'oneX15'.
 177 |     |   /// 'logPrice' should be non-negative and less than (2 ** 64).
 178 |     |   /// 'sqrtPrice' should be non-negative and less than 'oneX216'.
 179 |     |   /// 'sqrtInversePrice' should be non-negative and less than 'oneX216'.
 180 | *   |   function storePrice(
 181 |     |     uint256 pointer,
 182 |     |     X15 heightPrice,
 183 |     |     X59 logPrice,
 184 |     |     X216 sqrtPrice,
 185 |     |     X216 sqrtInversePrice
 186 |     |   ) internal pure {
 187 | *   |     assembly {
 188 |     |       // The preceding slot is cached so that it can be restored after we place
 189 |     |       // all values in their appropriate memory location.
 190 |     |       // The subtraction is safe because of the input requirement on 'pointer'.
 191 | *   |       let precedingPointer := sub(pointer, 34)
 192 | *   |       let precedingSlot := mload(precedingPointer)
 193 |     | 
 194 |     |       // We move '64 + 216 + 216' bits forward to reach the following location:
 195 |     |       //
 196 |     |       //                                                          pointer + 62
 197 |     |       //                                                                     \
 198 |     |       //                                                                      |
 199 |     |       //  +--+--------+---------------------------+---------------------------+
 200 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 201 |     |       //  +--+--------+---------------------------+---------------------------+
 202 |     |       //  |  |        |                           |
 203 |     |       //  |  |        |                            \
 204 |     |       //  |  |        |                             sqrtInversePrice
 205 |     |       //  |  |         \
 206 |     |       //  |  |          sqrtPrice
 207 |     |       //  |   \
 208 |     |       //  |    logPrice
 209 |     |       //   \
 210 |     |       //    heightPrice
 211 |     |       //
 212 |     |       // Then we move '256' bits backward to point to the beginning of the slot
 213 |     |       // whose least significant '216' bits are supposed to host
 214 |     |       // 'sqrtInversePrice'.
 215 |     |       //
 216 |     |       // '64 + 216 + 216 - 256' bits == '30' bytes.
 217 | *   |       mstore(add(pointer, 30), sqrtInversePrice)
 218 |     | 
 219 |     |       // We move '64 + 216' bits forward to reach the following location:
 220 |     |       //
 221 |     |       //                                  pointer + 35
 222 |     |       //                                         \
 223 |     |       //                                          |
 224 |     |       //  +--+--------+---------------------------+---------------------------+
 225 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 226 |     |       //  +--+--------+---------------------------+---------------------------+
 227 |     |       //  |  |        |                           |
 228 |     |       //  |  |        |                            \
 229 |     |       //  |  |        |                             sqrtInversePrice
 230 |     |       //  |  |         \
 231 |     |       //  |  |          sqrtPrice
 232 |     |       //  |   \
 233 |     |       //  |    logPrice
 234 |     |       //   \
 235 |     |       //    heightPrice
 236 |     |       //
 237 |     |       // Then we move '256' bits backward to point to the beginning of the slot
 238 |     |       // whose least significant '216' bits are supposed to host 'sqrtPrice'.
 239 |     |       //
 240 |     |       // '64 + 216 - 256' bits == '3' bytes.
 241 | *   |       mstore(add(pointer, 3), sqrtPrice)
 242 |     | 
 243 |     |       // We move '64' bits forward to reach the following location:
 244 |     |       //
 245 |     |       //      pointer + 8
 246 |     |       //             \
 247 |     |       //              |
 248 |     |       //  +--+--------+---------------------------+---------------------------+
 249 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 250 |     |       //  +--+--------+---------------------------+---------------------------+
 251 |     |       //  |  |        |                           |
 252 |     |       //  |  |        |                            \
 253 |     |       //  |  |        |                             sqrtInversePrice
 254 |     |       //  |  |         \
 255 |     |       //  |  |          sqrtPrice
 256 |     |       //  |   \
 257 |     |       //  |    logPrice
 258 |     |       //   \
 259 |     |       //    heightPrice
 260 |     |       //
 261 |     |       // Then we move '256' bits backward to point to the beginning of the slot
 262 |     |       // whose least significant '64' bits are supposed to host 'logPrice'.
 263 |     |       //
 264 |     |       // '64 - 256' bits == '-24' bytes.
 265 |     |       // The subtraction is safe because of the input requirement on 'pointer'.
 266 | *   |       mstore(sub(pointer, 24), logPrice)
 267 |     | 
 268 |     |       // We move '256' bits backward to point to the beginning of the slot
 269 |     |       // whose least significant '16' bits are supposed to host 'heightPrice'.
 270 |     |       //
 271 |     |       // '0 - 256' bits == '-32' bytes.
 272 |     |       // The subtraction is safe because of the input requirement on 'pointer'.
 273 | *   |       mstore(sub(pointer, 32), heightPrice)
 274 |     | 
 275 |     |       // The preceding slot is restored.
 276 | *   |       mstore(precedingPointer, precedingSlot)
 277 |     |     }
 278 |     |   }
 279 |     | 
 280 |     |   /// @notice Returns the height of a price given its memory pointer with the 
 281 |     |   /// following layout:
 282 |     |   ///
 283 |     |   ///       pointer
 284 |     |   ///      /
 285 |     |   ///     |
 286 |     |   ///  +--+--------+---------------------------+---------------------------+
 287 |     |   ///  |  | 8 byte |          27 byte          |          27 byte          |
 288 |     |   ///  +--+--------+---------------------------+---------------------------+
 289 |     |   ///  |  |        |                           |
 290 |     |   ///  |  |        |                            \
 291 |     |   ///  |  |        |                             sqrtInversePrice
 292 |     |   ///  |  |         \
 293 |     |   ///  |  |          sqrtPrice
 294 |     |   ///  |   \
 295 |     |   ///  |    logPrice
 296 |     |   ///   \
 297 |     |   ///    heightPrice
 298 |     |   ///
 299 | *   |   function height(
 300 |     |     uint256 pointer
 301 |     |   ) internal pure returns (
 302 | *   |     X15 value
 303 |     |   ) {
 304 |     |     assembly {
 305 |     |       // We move '2' bytes backward to read the slot whose most significant
 306 |     |       // '16' bits host 'height'.
 307 |     |       //
 308 |     |       //    pointer - 2
 309 |     |       //   /
 310 |     |       //  |
 311 |     |       //  +--+--------+---------------------------+---------------------------+
 312 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 313 |     |       //  +--+--------+---------------------------+---------------------------+
 314 |     |       //  |  |        |                           |
 315 |     |       //  |  |        |                            \
 316 |     |       //  |  |        |                             sqrtInversePrice
 317 |     |       //  |  |         \
 318 |     |       //  |  |          sqrtPrice
 319 |     |       //  |   \
 320 |     |       //  |    logPrice
 321 |     |       //   \
 322 |     |       //    heightPrice
 323 |     |       //
 324 |     |       // Then we shift the content by '240' bits to the right in order to get
 325 |     |       // 'height'.
 326 |     |       //
 327 |     |       // The subtraction is safe, because the pointer refer to a price with
 328 |     |       // height and therefore its value is not less than '2'.
 329 | *   |       value := shr(240, mload(sub(pointer, 2)))
 330 |     |     }
 331 |     |   }
 332 |     | 
 333 |     |   /// @notice Returns the logarithm of a price given its memory pointer with
 334 |     |   /// the following layout:
 335 |     |   ///
 336 |     |   ///       pointer
 337 |     |   ///      /
 338 |     |   ///     |
 339 |     |   ///  +--+--------+---------------------------+---------------------------+
 340 |     |   ///  |  | 8 byte |          27 byte          |          27 byte          |
 341 |     |   ///  +--+--------+---------------------------+---------------------------+
 342 |     |   ///  |  |        |                           |
 343 |     |   ///  |  |        |                            \
 344 |     |   ///  |  |        |                             sqrtInversePrice
 345 |     |   ///  |  |         \
 346 |     |   ///  |  |          sqrtPrice
 347 |     |   ///  |   \
 348 |     |   ///  |    logPrice
 349 |     |   ///   \
 350 |     |   ///    heightPrice
 351 |     |   ///
 352 | *   |   function log(
 353 |     |     uint256 pointer
 354 |     |   ) internal pure returns (
 355 | *   |     X59 logPrice
 356 |     |   ) {
 357 |     |     assembly {
 358 |     |       // The given pointer refers to the slot whose most significant '64' bits
 359 |     |       // host 'logPrice'. We read this slot and then we shift the content by
 360 |     |       // '192' bits to the right in order to get 'logPrice'.
 361 | *   |       logPrice := shr(192, mload(pointer))
 362 |     |     }
 363 |     |   }
 364 |     | 
 365 |     |   /// @notice Returns the 'sqrtPrice' or 'sqrtInversePrice' given a memory 
 366 |     |   /// pointer with the following layout:
 367 |     |   ///
 368 |     |   ///       pointer
 369 |     |   ///      /
 370 |     |   ///     |
 371 |     |   ///  +--+--------+---------------------------+---------------------------+
 372 |     |   ///  |  | 8 byte |          27 byte          |          27 byte          |
 373 |     |   ///  +--+--------+---------------------------+---------------------------+
 374 |     |   ///  |  |        |                           |
 375 |     |   ///  |  |        |                            \
 376 |     |   ///  |  |        |                             sqrtInversePrice
 377 |     |   ///  |  |         \
 378 |     |   ///  |  |          sqrtPrice
 379 |     |   ///  |   \
 380 |     |   ///  |    logPrice
 381 |     |   ///   \
 382 |     |   ///    heightPrice
 383 |     |   ///
 384 | *   |   function sqrt(
 385 |     |     uint256 pointer,
 386 |     |     bool inverse
 387 |     |   ) internal pure returns (
 388 | *   |     X216 value
 389 |     |   ) {
 390 |     |     assembly {
 391 |     |       // If 'inverse == true' then we move '35' bytes forward to read the slot
 392 |     |       // whose most significant '216' bits host 'sqrtPriceInverse'.
 393 |     |       //
 394 |     |       //                                  pointer + 35
 395 |     |       //                                         \
 396 |     |       //                                          |
 397 |     |       //  +--+--------+---------------------------+---------------------------+
 398 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 399 |     |       //  +--+--------+---------------------------+---------------------------+
 400 |     |       //  |  |        |                           |
 401 |     |       //  |  |        |                            \
 402 |     |       //  |  |        |                             sqrtInversePrice
 403 |     |       //  |  |         \
 404 |     |       //  |  |          sqrtPrice
 405 |     |       //  |   \
 406 |     |       //  |    logPrice
 407 |     |       //   \
 408 |     |       //    heightPrice
 409 |     |       //
 410 |     |       // Then we shift the content by '40' bits to the right in order to get
 411 |     |       // 'sqrtPriceInverse'.
 412 |     |       //
 413 |     |       // If 'inverse == false' then we move '8' bytes forward to read the slot
 414 |     |       // whose most significant '216' bits host 'sqrtPrice'.
 415 |     |       //
 416 |     |       //      pointer + 8
 417 |     |       //             \
 418 |     |       //              |
 419 |     |       //  +--+--------+---------------------------+---------------------------+
 420 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 421 |     |       //  +--+--------+---------------------------+---------------------------+
 422 |     |       //  |  |        |                           |
 423 |     |       //  |  |        |                            \
 424 |     |       //  |  |        |                             sqrtInversePrice
 425 |     |       //  |  |         \
 426 |     |       //  |  |          sqrtPrice
 427 |     |       //  |   \
 428 |     |       //  |    logPrice
 429 |     |       //   \
 430 |     |       //    heightPrice
 431 |     |       //
 432 |     |       // Then we shift the content by '40' bits to the right in order to get
 433 |     |       // 'sqrtPrice'.
 434 |     |       //
 435 |     |       // The additions and the multiplication are safe because 
 436 |     |       // 'iszero(inverse)' is a boolean.
 437 | *   |       value := shr(
 438 | *   |         40,
 439 | *   |         mload(
 440 | *   |           add(
 441 | *   |             sub(35, mul(27, iszero(inverse))), // inverse ? 35 : 8
 442 | *   |             pointer
 443 |     |           )
 444 |     |         )
 445 |     |       )
 446 |     |     }
 447 |     |   }
 448 |     | 
 449 |     |   /// @notice Copies a price from one memory pointer to another each with the 
 450 |     |   /// following layout:
 451 |     |   ///
 452 |     |   ///  pointer
 453 |     |   ///     |
 454 |     |   ///     +--------+---------------------------+---------------------------+
 455 |     |   ///     | 8 byte |          27 byte          |          27 byte          |
 456 |     |   ///     +--------+---------------------------+---------------------------+
 457 |     |   ///     |        |                           |
 458 |     |   ///     |        |                            \
 459 |     |   ///     |        |                             sqrtInversePrice
 460 |     |   ///     |         \
 461 |     |   ///     |          sqrtPrice
 462 |     |   ///      \
 463 |     |   ///       logPrice
 464 |     |   ///
 465 |     |   function copyPrice(
 466 |     |     uint256 pointer0,
 467 |     |     uint256 pointer1
 468 |     |   ) internal pure {
 469 |     |     assembly {
 470 |     |       // Each price contains '62' bytes which is copied from one place to the
 471 |     |       // next.
 472 |     |       mcopy(pointer0, pointer1, 62)
 473 |     |     }
 474 |     |   }
 475 |     |  
 476 |     |   /// @notice Copies a price with height from one memory pointer to another
 477 |     |   /// each with the following layout:
 478 |     |   ///
 479 |     |   ///       pointer
 480 |     |   ///      /
 481 |     |   ///     |
 482 |     |   ///  +--+--------+---------------------------+---------------------------+
 483 |     |   ///  |  | 8 byte |          27 byte          |          27 byte          |
 484 |     |   ///  +--+--------+---------------------------+---------------------------+
 485 |     |   ///  |  |        |                           |
 486 |     |   ///  |  |        |                            \
 487 |     |   ///  |  |        |                             sqrtInversePrice
 488 |     |   ///  |  |         \
 489 |     |   ///  |  |          sqrtPrice
 490 |     |   ///  |   \
 491 |     |   ///  |    logPrice
 492 |     |   ///   \
 493 |     |   ///    heightPrice
 494 |     |   ///
 495 |     |   function copyPriceWithHeight(
 496 |     |     uint256 pointer0,
 497 |     |     uint256 pointer1
 498 |     |   ) internal pure {
 499 |     |     assembly {
 500 |     |       // Each price contains '64' bytes which is copied from one place to the
 501 |     |       // next. We move two bytes backward to point to the beginning of 'height'
 502 |     |       // as opposed to the end of 'height':
 503 |     |       //
 504 |     |       //    pointer
 505 |     |       //   /
 506 |     |       //  |
 507 |     |       //  +--+--------+---------------------------+---------------------------+
 508 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 509 |     |       //  +--+--------+---------------------------+---------------------------+
 510 |     |       //  |  |        |                           |
 511 |     |       //  |  |        |                            \
 512 |     |       //  |  |        |                             sqrtInversePrice
 513 |     |       //  |  |         \
 514 |     |       //  |  |          sqrtPrice
 515 |     |       //  |   \
 516 |     |       //  |    logPrice
 517 |     |       //   \
 518 |     |       //    heightPrice
 519 |     |       //
 520 |     |       // The subtractions are safe, because both pointers refer to prices with
 521 |     |       // height and therefore their values are not less than '2'.
 522 |     |       mcopy(sub(pointer0, 2), sub(pointer1, 2), 64)
 523 |     |     }
 524 |     |   }
 525 |     | 
 526 |     |   /// @notice Given the memory pointer for a pair of prices with height, this
 527 |     |   /// function reads the corresponding horizontal and vertical coordinates.
 528 |     |   /// 'pointer' refers to the first price and 'pointer + 64' refers to the
 529 |     |   /// second one.
 530 | *   |   function segment(
 531 |     |     uint256 pointer
 532 |     |   ) internal pure returns (
 533 | *   |     X59 b0,
 534 | *   |     X59 b1,
 535 | *   |     X15 c0,
 536 | *   |     X15 c1
 537 |     |   ) {
 538 | *   |     c0 = pointer.height();
 539 | *   |     b0 = pointer.log();
 540 |     | 
 541 |     |     // We move '64' bytes forward to point to the second price.
 542 |     |     unchecked {
 543 | *   |       pointer += 64;
 544 |     |     }
 545 |     | 
 546 | *   |     c1 = pointer.height();
 547 | *   |     b1 = pointer.log();
 548 |     |   }
 549 |     | }

/home/training/contracts/utilities/Tag.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {X59} from "./X59.sol";
   5 |     | 
   6 |     | // Type 'Tag' may refer to any of the followings:
   7 |     | //
   8 |     | // - Native token corresponding to 'Tag.wrap(0)'.
   9 |     | //
  10 |     | // - An ERC-20 address, i.e., 'Tag.wrap(uint256(uint160(tokenAddress)))'.
  11 |     | //
  12 |     | // - An ERC-1155 token whose value is determined by hashing token address and
  13 |     | // token ID, i.e., 
  14 |     | // 'Tag.wrap(uint256(keccak256(abi.encodePacked(tokenAddress, tokenId))))'.
  15 |     | //
  16 |     | // - An ERC-6909 token whose value is determined by hashing token address and
  17 |     | // token ID, i.e., 
  18 |     | // 'Tag.wrap(uint256(keccak256(abi.encodePacked(tokenAddress, tokenId))))'.
  19 |     | //
  20 |     | // - A nofeeswap position whose value is determined by hashing, poolId and
  21 |     | // min/max position boundaries, i.e., 
  22 |     | // 'Tag.wrap(uint256(keccak256(abi.encodePacked(
  23 |     | //    poolId,
  24 |     | //    qMin,
  25 |     | //    qMax
  26 |     | //  ))))'.
  27 |     | //
  28 |     | type Tag is uint256;
  29 |     | 
  30 |     | Tag constant native = Tag.wrap(0);
  31 |     | 
  32 |     | using {equals as ==, notEqual as !=} for Tag global;
  33 |     | using {lessThan as <, greaterThan as >} for Tag global;
  34 |     | using {
  35 |     |   lessThanOrEqualTo as <=,
  36 |     |   greaterThanOrEqualTo as >=
  37 |     | } for Tag global;
  38 |     | 
  39 |     | function equals(
  40 |     |   Tag value0,
  41 |     |   Tag value1
  42 |     | ) pure returns (
  43 |     |   bool result
  44 |     | ) {
  45 |     |   assembly {
  46 |     |     result := eq(value0, value1)
  47 |     |   }
  48 |     | }
  49 |     | 
  50 |     | function notEqual(
  51 |     |   Tag value0,
  52 |     |   Tag value1
  53 |     | ) pure returns (
  54 |     |   bool result
  55 |     | ) {
  56 |     |   return !(value0 == value1);
  57 |     | }
  58 |     | 
  59 |     | function lessThan(
  60 |     |   Tag value0,
  61 |     |   Tag value1
  62 |     | ) pure returns (
  63 |     |   bool result
  64 |     | ) {
  65 |     |   assembly {
  66 |     |     result := lt(value0, value1)
  67 |     |   }
  68 |     | }
  69 |     | 
  70 |     | function greaterThan(
  71 |     |   Tag value0,
  72 |     |   Tag value1
  73 |     | ) pure returns (
  74 |     |   bool result
  75 |     | ) {
  76 |     |   assembly {
  77 |     |     result := gt(value0, value1)
  78 |     |   }
  79 |     | }
  80 |     | 
  81 |     | function lessThanOrEqualTo(
  82 |     |   Tag value0,
  83 |     |   Tag value1
  84 |     | ) pure returns (
  85 |     |   bool result
  86 |     | ) {
  87 |     |   return !(value0 > value1);
  88 |     | }
  89 |     | 
  90 |     | function greaterThanOrEqualTo(
  91 |     |   Tag value0,
  92 |     |   Tag value1
  93 |     | ) pure returns (
  94 |     |   bool result
  95 |     | ) {
  96 |     |   return !(value0 < value1);
  97 |     | }
  98 |     | 
  99 |     | library TagLibrary {
 100 |     |   /// @notice Generates a tag given an ERC-20 address.
 101 |     |   /// @param tokenAddress The given ERC-20 address to be transformed to the
 102 |     |   /// type 'tag'.
 103 |     |   function tag(
 104 |     |     address tokenAddress
 105 |     |   ) internal pure returns (
 106 |     |     Tag tokenTag
 107 |     |   ) {
 108 |     |     assembly {
 109 |     |       tokenTag := and(tokenAddress, sub(shl(160, 1), 1))
 110 |     |     }
 111 |     |   }
 112 |     | 
 113 |     |   /// @notice Generates a tag given a multi-token address and tokenId.
 114 |     |   /// @param tokenAddress The given multi-token address to be transformed to
 115 |     |   /// the type 'tag'.
 116 |     |   /// @param tokenId The given multi-token id to be used to generate 'tag'.
 117 |     |   function tag(
 118 |     |     address tokenAddress,
 119 |     |     uint256 tokenId
 120 |     |   ) internal pure returns (
 121 |     |     Tag tokenTag
 122 |     |   ) {
 123 |     |     assembly {
 124 |     |       mstore(20, tokenAddress)
 125 |     |       mstore(0, tokenId)
 126 |     |       tokenTag := keccak256(0, 52)
 127 |     |     }
 128 |     |   }
 129 |     | 
 130 |     |   /// @notice Generates a tag given a nofeeswap liquidity position.
 131 |     |   /// @param poolId The pool identifier hosting this liquidity position.
 132 |     |   /// @param qMin Equal to '(2 ** 59) * log(pMin)' where 'pMin' is the left
 133 |     |   /// position boundary.
 134 |     |   /// @param qMax Equal to '(2 ** 59) * log(pMax)' where 'pMax' is the right
 135 |     |   /// position boundary.
 136 |     |   function tag(
 137 |     |     uint256 poolId,
 138 |     |     X59 qMin,
 139 |     |     X59 qMax
 140 |     |   ) internal pure returns (
 141 |     |     Tag positionTag
 142 |     |   ) {
 143 |     |     assembly {
 144 |     |       // Cache the free memory pointer so that the third memory slot can be
 145 |     |       // used for hashing.
 146 |     |       let freeMemoryPointer := mload(0x40)
 147 |     |       mstore(64, qMax)
 148 |     |       mstore(32, qMin)
 149 |     |       mstore(0, poolId)
 150 |     |       positionTag := keccak256(0, 96)
 151 |     |       // The 'freeMemoryPointer' is restored.
 152 |     |       mstore(0x40, freeMemoryPointer)
 153 |     |     }
 154 |     |   }
 155 |     | }

/home/training/contracts/utilities/X111.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {X208} from "./X208.sol";
   5 |     | import {X216} from "./X216.sol";
   6 |     | import {FullMathLibrary} from "./FullMath.sol";
   7 |     | 
   8 |     | // Type 'X111' is dedicated to growth and liquidity values.
   9 |     | type X111 is int256;
  10 |     | 
  11 |     | using X111Library for X111 global;
  12 |     | 
  13 |     | X111 constant zeroX111 = X111.wrap(0);
  14 |     | X111 constant oneX111 = X111.wrap(1 << 111);
  15 |     | X111 constant maxGrowth = X111.wrap(1 << 127);
  16 |     | 
  17 |     | using {equals as ==, notEqual as !=} for X111 global;
  18 |     | using {lessThan as <, greaterThan as >} for X111 global;
  19 |     | using {
  20 |     |   lessThanOrEqualTo as <=,
  21 |     |   greaterThanOrEqualTo as >=
  22 |     | } for X111 global;
  23 |     | using {add as +, sub as -} for X111 global;
  24 |     | 
  25 |     | function equals(
  26 |     |   X111 value0,
  27 |     |   X111 value1
  28 |     | ) pure returns (
  29 |     |   bool result
  30 |     | ) {
  31 |     |   assembly {
  32 |     |     result := eq(value0, value1)
  33 |     |   }
  34 |     | }
  35 |     | 
  36 |     | function notEqual(
  37 |     |   X111 value0,
  38 |     |   X111 value1
  39 |     | ) pure returns (
  40 |     |   bool result
  41 |     | ) {
  42 |     |   return !(value0 == value1);
  43 |     | }
  44 |     | 
  45 |     | function lessThan(
  46 |     |   X111 value0,
  47 |     |   X111 value1
  48 |     | ) pure returns (
  49 |     |   bool result
  50 |     | ) {
  51 |     |   assembly {
  52 |     |     result := slt(value0, value1)
  53 |     |   }
  54 |     | }
  55 |     | 
  56 |     | function greaterThan(
  57 |     |   X111 value0,
  58 |     |   X111 value1
  59 |     | ) pure returns (
  60 |     |   bool result
  61 |     | ) {
  62 |     |   assembly {
  63 |     |     result := sgt(value0, value1)
  64 |     |   }
  65 |     | }
  66 |     | 
  67 |     | function lessThanOrEqualTo(
  68 |     |   X111 value0,
  69 |     |   X111 value1
  70 |     | ) pure returns (
  71 |     |   bool result
  72 |     | ) {
  73 |     |   return !(value0 > value1);
  74 |     | }
  75 |     | 
  76 |     | function greaterThanOrEqualTo(
  77 |     |   X111 value0,
  78 |     |   X111 value1
  79 |     | ) pure returns (
  80 |     |   bool result
  81 |     | ) {
  82 |     |   return !(value0 < value1);
  83 |     | }
  84 |     | 
  85 |     | // Overflow/underflow should be avoided externally.
  86 |     | function add(
  87 |     |   X111 value0,
  88 |     |   X111 value1
  89 |     | ) pure returns (
  90 |     |   X111 result
  91 |     | ) {
  92 |     |   assembly {
  93 |     |     result := add(value0, value1)
  94 |     |   }
  95 |     | }
  96 |     | 
  97 |     | // Overflow/underflow should be avoided externally.
  98 |     | function sub(
  99 |     |   X111 value0,
 100 |     |   X111 value1
 101 |     | ) pure returns (
 102 |     |   X111 result
 103 |     | ) {
 104 |     |   assembly {
 105 |     |     result := sub(value0, value1)
 106 |     |   }
 107 |     | }
 108 |     | 
 109 |     | function min(
 110 |     |   X111 value0,
 111 |     |   X111 value1
 112 |     | ) pure returns (
 113 |     |   X111 result
 114 |     | ) {
 115 |     |   return (value0 < value1) ? value0 : value1;
 116 |     | }
 117 |     | 
 118 |     | function max(
 119 |     |   X111 value0,
 120 |     |   X111 value1
 121 |     | ) pure returns (
 122 |     |   X111 result
 123 |     | ) {
 124 |     |   return (value0 < value1) ? value1 : value0;
 125 |     | }
 126 |     | 
 127 |     | library X111Library {
 128 |     |   /// @notice Calculates 'liquidity == growth * shares'.
 129 |     |   /// 'growth' should not be less than 'oneX111'.
 130 |     |   /// 'growth' should be less than or equal to '1 << 127'.
 131 |     |   /// 'shares' should be less than '1 << 127'
 132 |     |   function times(
 133 |     |     X111 growth,
 134 |     |     uint256 shares
 135 |     |   ) internal pure returns (
 136 |     |     X111 liquidity
 137 |     |   ) {
 138 |     |     assembly {
 139 |     |       // Multiplication is safe because of the input requirements.
 140 |     |       liquidity := mul(growth, shares)
 141 |     |     }
 142 |     |   }
 143 |     | 
 144 |     |   /// @notice Calculates 'liquidity == growth * shares'.
 145 |     |   /// 'growth' should not be less than 'oneX111'.
 146 |     |   /// 'growth' should be less than or equal to '1 << 127'.
 147 |     |   /// 'shares' should be greater than '- (1 << 127)'.
 148 |     |   /// 'shares' should be less than '1 << 127'.
 149 |     |   function times(
 150 |     |     X111 growth,
 151 |     |     int256 shares
 152 |     |   ) internal pure returns (
 153 |     |     X111 liquidity
 154 |     |   ) {
 155 |     |     assembly {
 156 |     |       // Multiplication is safe because of the input requirements.
 157 |     |       liquidity := mul(growth, shares)
 158 |     |     }
 159 |     |   }
 160 |     | 
 161 |     |   /// @notice Calculates
 162 |     |   /// '(value * multiplier) / ((2 ** 119) * exp(-8))'
 163 |     |   /// 'growth' should not be less than 'oneX111'.
 164 |     |   /// 'growth' should be less than or equal to '1 << 127'.
 165 |     |   /// 'multiplier' should be non-negative and less than 'oneX216'.
 166 |     |   function mulDivByExpInv8(
 167 |     |     X111 growth,
 168 |     |     X216 multiplier
 169 |     |   ) internal pure returns (
 170 |     |     X208 product
 171 |     |   ) {
 172 |     |     // Both castings are safe because
 173 |     |     // 'growth >= oneX111' and 'multiplier >= zeroX216'
 174 |     |     ( ,  , uint256 q2) = FullMathLibrary.mul768(
 175 |     |       // (2 ** 244) * exp(8)
 176 |     |       0xBA4F53EA38636F85F007042540AE8EF33225E9A7AB4F4473A86D4A8FDD1A5B82,
 177 |     |       // The shift is safe because 'oneX111 <= growth <= (1 << 127)'
 178 |     |       uint256(X111.unwrap(growth)) << 110,
 179 |     |       // The shift is safe because '0 <= multiplier <= oneX216'
 180 |     |       uint256(X216.unwrap(multiplier)) << 39
 181 |     |     );
 182 |     |     product = X208.wrap(q2);
 183 |     |   }
 184 |     | }

/home/training/contracts/utilities/X127.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {X23} from "./X23.sol";
   5 |     | import {X216} from "./X216.sol";
   6 |     | import {SafeAddFailed} from "./Errors.sol";
   7 |     | import {FullMathLibrary} from "./FullMath.sol";
   8 |     | 
   9 |     | // Type 'X127' is used for 'sqrtOffset', 'sqrtInverseOffset', and token
  10 |     | // amounts.
  11 |     | type X127 is int256;
  12 |     | 
  13 |     | using X127Library for X127 global;
  14 |     | 
  15 |     | X127 constant oneX127 = X127.wrap(1 << 127);
  16 |     | X127 constant zeroX127 = X127.wrap(0);
  17 |     | X127 constant epsilonX127 = X127.wrap(1);
  18 |     | // 104 = 231 - 127 digits of non-decimal
  19 |     | X127 constant accruedMax = X127.wrap((1 << 231) - 1);
  20 |     | 
  21 |     | using {equals as ==, notEquals as !=} for X127 global;
  22 |     | using {lessThan as <, greaterThan as >} for X127 global;
  23 |     | using {
  24 |     |   lessThanOrEqualTo as <=,
  25 |     |   greaterThanOrEqualTo as >=
  26 |     | } for X127 global;
  27 |     | using {add as +, sub as -, safeAdd as &} for X127 global;
  28 |     | 
  29 |     | function equals(
  30 |     |   X127 value0,
  31 |     |   X127 value1
  32 |     | ) pure returns (
  33 |     |   bool result
  34 |     | ) {
  35 |     |   assembly {
  36 |     |     result := eq(value0, value1)
  37 |     |   }
  38 |     | }
  39 |     | 
  40 |     | function notEquals(
  41 |     |   X127 value0,
  42 |     |   X127 value1
  43 |     | ) pure returns (
  44 |     |   bool result
  45 |     | ) {
  46 |     |   return !(value0 == value1);
  47 |     | }
  48 |     | 
  49 |     | function lessThan(
  50 |     |   X127 value0,
  51 |     |   X127 value1
  52 |     | ) pure returns (
  53 |     |   bool result
  54 |     | ) {
  55 |     |   assembly {
  56 |     |     result := slt(value0, value1)
  57 |     |   }
  58 |     | }
  59 |     | 
  60 |     | function greaterThan(
  61 |     |   X127 value0,
  62 |     |   X127 value1
  63 |     | ) pure returns (
  64 |     |   bool result
  65 |     | ) {
  66 |     |   assembly {
  67 |     |     result := sgt(value0, value1)
  68 |     |   }
  69 |     | }
  70 |     | 
  71 |     | function lessThanOrEqualTo(
  72 |     |   X127 value0,
  73 |     |   X127 value1
  74 |     | ) pure returns (
  75 |     |   bool result
  76 |     | ) {
  77 |     |   return !(value0 > value1);
  78 |     | }
  79 |     | 
  80 |     | function greaterThanOrEqualTo(
  81 |     |   X127 value0,
  82 |     |   X127 value1
  83 |     | ) pure returns (
  84 |     |   bool result
  85 |     | ) {
  86 |     |   return !(value0 < value1);
  87 |     | }
  88 |     | 
  89 |     | // Overflow/underflow should be avoided externally.
  90 |     | function add(
  91 |     |   X127 value0,
  92 |     |   X127 value1
  93 |     | ) pure returns (
  94 |     |   X127 result
  95 |     | ) {
  96 |     |   assembly {
  97 |     |     result := add(value0, value1)
  98 |     |   }
  99 |     | }
 100 |     | 
 101 |     | // Overflow/underflow should be avoided externally.
 102 |     | function sub(
 103 |     |   X127 value0,
 104 |     |   X127 value1
 105 |     | ) pure returns (
 106 |     |   X127 result
 107 |     | ) {
 108 |     |   assembly {
 109 |     |     result := sub(value0, value1)
 110 |     |   }
 111 |     | }
 112 |     | 
 113 |     | // Throws in case of overflow/underflow.
 114 |     | function safeAdd(
 115 |     |   X127 value0,
 116 |     |   X127 value1
 117 |     | ) pure returns (
 118 |     |   X127 result
 119 |     | ) {
 120 |     |   // We first add the two values unsafely and then examine the result.
 121 |     |   result = value0 + value1;
 122 |     |   
 123 |     |   // The following requirement is satisfied if and only if 'result' does not
 124 |     |   // overflow or underflow. Because,
 125 |     |   // - overflow implies that both 'value0' and 'value1' are positive but
 126 |     |   // 'result' is negative which contradicts the following requirement.
 127 |     |   // - underflow implies that both 'value0' and 'value1' are negative but
 128 |     |   // 'result' is positive which contradicts the following requirement as well.
 129 |     |   // - Lastly, in case of no overflow/underflow, the following requirement is
 130 |     |   // trivial.
 131 |     |   require(
 132 |     |     (value1 >= zeroX127) == (result >= value0),
 133 |     |     SafeAddFailed(value0, value1)
 134 |     |   );
 135 |     | }
 136 |     | 
 137 |     | function min(
 138 |     |   X127 value0,
 139 |     |   X127 value1
 140 |     | ) pure returns (
 141 |     |   X127 result
 142 |     | ) {
 143 |     |   return (value0 < value1) ? value0 : value1;
 144 |     | }
 145 |     | 
 146 |     | function max(
 147 |     |   X127 value0,
 148 |     |   X127 value1
 149 |     | ) pure returns (
 150 |     |   X127 result
 151 |     | ) {
 152 |     |   return (value0 < value1) ? value1 : value0;
 153 |     | }
 154 |     | 
 155 |     | library X127Library {
 156 |     |   /// @notice Calculates 'value * multiplier / (2 ** 23)'
 157 |     |   /// 'value' should be non-negative.
 158 |     |   /// 'value * multiplier' should be less than '2 ** 256'.
 159 |     |   function times(
 160 |     |     X127 value,
 161 |     |     X23 multiplier
 162 |     |   ) internal pure returns (
 163 |     |     X127 product
 164 |     |   ) {
 165 |     |     // The multiplication is safe because of the input requirement.
 166 |     |     assembly {
 167 |     |       product := shr(23, mul(value, multiplier))
 168 |     |     }
 169 |     |   }
 170 |     | 
 171 |     |   /// @notice Calculates '(value * numerator) / denominator'
 172 |     |   /// Overflow and division by zero should be avoided externally.
 173 |     |   /// All input values should be non-negative.
 174 |     |   function mulDiv(
 175 |     |     X127 value,
 176 |     |     X216 numerator,
 177 |     |     X216 denominator
 178 |     |   ) internal pure returns (
 179 |     |     X127 result
 180 |     |   ) {
 181 |     |     result = X127.wrap(
 182 |     |       // Casting to 'int256' is safe because overflow is handled externally.
 183 |     |       int256(
 184 |     |         // The three castings are safe because of the input requirement.
 185 |     |         // The requirements of 'mulDiv' are met because overflow is handled
 186 |     |         // externally.
 187 |     |         FullMathLibrary.mulDiv(
 188 |     |           uint256(X127.unwrap(value)),
 189 |     |           uint256(X216.unwrap(numerator)),
 190 |     |           uint256(X216.unwrap(denominator))
 191 |     |         )
 192 |     |       )
 193 |     |     );
 194 |     |   }
 195 |     | 
 196 |     |   /// @notice Transforms type X127 to the integer 'value / (2 ** 127)' while
 197 |     |   /// maintaining the sign. Rounds towards negative infinity.
 198 |     |   function toInteger(
 199 |     |     X127 value
 200 |     |   ) internal pure returns (
 201 |     |     int256 result
 202 |     |   ) {
 203 |     |     assembly {
 204 |     |       result := sar(127, value)
 205 |     |     }
 206 |     |   }
 207 |     | 
 208 |     |   /// @notice Transforms type X127 to the integer 'value / (2 ** 127)' while
 209 |     |   /// maintaining the sign.
 210 |     |   /// Rounds towards positive infinity.
 211 |     |   /// 'value' should be greater than '- 2 ** 255'.
 212 |     |   function toIntegerRoundUp(
 213 |     |     X127 value
 214 |     |   ) internal pure returns (
 215 |     |     int256 result
 216 |     |   ) {
 217 |     |     // The inner subtraction is safe because 'value > - 2 ** 255'.
 218 |     |     // The outer subtraction is safe because 
 219 |     |     // '- 2 ** 128 < (0 - value) / (2 ** 127) < 2 ** 128'
 220 |     |     assembly {
 221 |     |       result := sub(0, sar(127, sub(0, value)))
 222 |     |     }
 223 |     |   }
 224 |     | }

/home/training/contracts/utilities/X15.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | // Type 'X15' is dedicated to the vertical coordinates of the kernel
   5 |     | // breakpoints. The distribution of liquidity within every interval is governed
   6 |     | // by a piecewise linear kernel function. The kernel function is characterized
   7 |     | // by a list of breakpoints given by the pool owner. The vertical coordinate of
   8 |     | // each breakpoint is a number within the interval [0, 1] which is stored in
   9 |     | // 'X15' format, with '2 ** 15' representing 1.
  10 |     | type X15 is uint256;
  11 |     | 
  12 | *   | X15 constant zeroX15 = X15.wrap(0);
  13 |     | X15 constant oneX15 = X15.wrap(1 << 15);
  14 |     | 
  15 |     | using {equals as ==, notEqual as !=} for X15 global;
  16 |     | using {lessThan as <, greaterThan as >} for X15 global;
  17 |     | using {
  18 |     |   lessThanOrEqualTo as <=,
  19 |     |   greaterThanOrEqualTo as >=
  20 |     | } for X15 global;
  21 |     | using {add as +, sub as -} for X15 global;
  22 |     | 
  23 | *   | function equals(
  24 |     |   X15 value0,
  25 |     |   X15 value1
  26 |     | ) pure returns (
  27 | *   |   bool result
  28 |     | ) {
  29 |     |   assembly {
  30 | *   |     result := eq(value0, value1)
  31 |     |   }
  32 |     | }
  33 |     | 
  34 |     | function notEqual(
  35 |     |   X15 value0,
  36 |     |   X15 value1
  37 |     | ) pure returns (
  38 |     |   bool result
  39 |     | ) {
  40 |     |   return !(value0 == value1);
  41 |     | }
  42 |     | 
  43 | *   | function lessThan(
  44 |     |   X15 value0,
  45 |     |   X15 value1
  46 |     | ) pure returns (
  47 | *   |   bool result
  48 |     | ) {
  49 |     |   assembly {
  50 | *   |     result := lt(value0, value1)
  51 |     |   }
  52 |     | }
  53 |     | 
  54 |     | function greaterThan(
  55 |     |   X15 value0,
  56 |     |   X15 value1
  57 |     | ) pure returns (
  58 |     |   bool result
  59 |     | ) {
  60 |     |   assembly {
  61 |     |     result := gt(value0, value1)
  62 |     |   }
  63 |     | }
  64 |     | 
  65 |     | function lessThanOrEqualTo(
  66 |     |   X15 value0,
  67 |     |   X15 value1
  68 |     | ) pure returns (
  69 |     |   bool result
  70 |     | ) {
  71 |     |   return !(value0 > value1);
  72 |     | }
  73 |     | 
  74 |     | function greaterThanOrEqualTo(
  75 |     |   X15 value0,
  76 |     |   X15 value1
  77 |     | ) pure returns (
  78 |     |   bool result
  79 |     | ) {
  80 |     |   return !(value0 < value1);
  81 |     | }
  82 |     | 
  83 |     | // Overflow should be avoided externally.
  84 |     | function add(
  85 |     |   X15 value0,
  86 |     |   X15 value1
  87 |     | ) pure returns (
  88 |     |   X15 result
  89 |     | ) {
  90 |     |   assembly {
  91 |     |     result := add(value0, value1)
  92 |     |   }
  93 |     | }
  94 |     | 
  95 |     | // Underflow should be avoided externally.
  96 | *   | function sub(
  97 |     |   X15 value0,
  98 |     |   X15 value1
  99 |     | ) pure returns (
 100 | *   |   X15 result
 101 |     | ) {
 102 |     |   assembly {
 103 | *   |     result := sub(value0, value1)
 104 |     |   }
 105 |     | }

/home/training/contracts/utilities/X208.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {X111} from "./X111.sol";
   5 |     | import {X216} from "./X216.sol";
   6 |     | import {FullMathLibrary} from "./FullMath.sol";
   7 |     | 
   8 |     | // Type 'X208' is dedicated to growth multipliers.
   9 |     | type X208 is uint256;
  10 |     | 
  11 |     | using X208Library for X208 global;
  12 |     | 
  13 |     | X208 constant zeroX208 = X208.wrap(0);
  14 |     | // (2 ** 208) * exp(+8)
  15 |     | X208 constant exp8X208 = X208.wrap(
  16 |     |   0x000000000BA4F53EA38636F85F007042540AE8EF33225E9A7AB4F4473A86D4A8
  17 |     | );
  18 |     | 
  19 |     | using {equals as ==, notEquals as !=} for X208 global;
  20 |     | using {lessThan as <, greaterThan as >} for X208 global;
  21 |     | using {
  22 |     |   lessThanOrEqualTo as <=,
  23 |     |   greaterThanOrEqualTo as >=
  24 |     | } for X208 global;
  25 |     | using {add as +, sub as -} for X208 global;
  26 |     | 
  27 |     | function equals(
  28 |     |   X208 value0,
  29 |     |   X208 value1
  30 |     | ) pure returns (
  31 |     |   bool result
  32 |     | ) {
  33 |     |   assembly {
  34 |     |     result := eq(value0, value1)
  35 |     |   }
  36 |     | }
  37 |     | 
  38 |     | function notEquals(
  39 |     |   X208 value0,
  40 |     |   X208 value1
  41 |     | ) pure returns (
  42 |     |   bool result
  43 |     | ) {
  44 |     |   return !(value0 == value1);
  45 |     | }
  46 |     | 
  47 |     | function lessThan(
  48 |     |   X208 value0,
  49 |     |   X208 value1
  50 |     | ) pure returns (
  51 |     |   bool result
  52 |     | ) {
  53 |     |   assembly {
  54 |     |     result := lt(value0, value1)
  55 |     |   }
  56 |     | }
  57 |     | 
  58 |     | function greaterThan(
  59 |     |   X208 value0,
  60 |     |   X208 value1
  61 |     | ) pure returns (
  62 |     |   bool result
  63 |     | ) {
  64 |     |   assembly {
  65 |     |     result := gt(value0, value1)
  66 |     |   }
  67 |     | }
  68 |     | 
  69 |     | function lessThanOrEqualTo(
  70 |     |   X208 value0,
  71 |     |   X208 value1
  72 |     | ) pure returns (
  73 |     |   bool result
  74 |     | ) {
  75 |     |   return !(value0 > value1);
  76 |     | }
  77 |     | 
  78 |     | function greaterThanOrEqualTo(
  79 |     |   X208 value0,
  80 |     |   X208 value1
  81 |     | ) pure returns (
  82 |     |   bool result
  83 |     | ) {
  84 |     |   return !(value0 < value1);
  85 |     | }
  86 |     | 
  87 |     | // Overflow should be avoided externally.
  88 |     | function add(
  89 |     |   X208 value0,
  90 |     |   X208 value1
  91 |     | ) pure returns (
  92 |     |   X208 result
  93 |     | ) {
  94 |     |   assembly {
  95 |     |     result := add(value0, value1)
  96 |     |   }
  97 |     | }
  98 |     | 
  99 |     | // Underflow should be avoided externally.
 100 |     | function sub(
 101 |     |   X208 value0,
 102 |     |   X208 value1
 103 |     | ) pure returns (
 104 |     |   X208 result
 105 |     | ) {
 106 |     |   assembly {
 107 |     |     result := sub(value0, value1)
 108 |     |   }
 109 |     | }
 110 |     | 
 111 |     | library X208Library {
 112 |     |   /// @notice Calculates '(value * numerator) / denominator'
 113 |     |   /// Overflow and division by zero should be avoided externally.
 114 |     |   /// 'numerator' and 'denominator' values should be non-negative.
 115 |     |   function mulDiv(
 116 |     |     X208 value,
 117 |     |     X216 numerator,
 118 |     |     X216 denominator
 119 |     |   ) internal pure returns (
 120 |     |     X208 result
 121 |     |   ) {
 122 |     |     // Both castings are safe because of the non-negative requirement on both
 123 |     |     // 'numerator' and 'denominator'.
 124 |     |     result = X208.wrap(
 125 |     |       FullMathLibrary.mulDiv(
 126 |     |         X208.unwrap(value),
 127 |     |         uint256(X216.unwrap(numerator)),
 128 |     |         uint256(X216.unwrap(denominator))
 129 |     |       )
 130 |     |     );
 131 |     |   }
 132 |     | 
 133 |     |   /// @notice Calculates
 134 |     |   /// '(value * multiplier) / ((2 ** 313) * exp(-8))'
 135 |     |   /// 'multiplier' should be non-negative.
 136 |     |   function mulDivByExpInv8(
 137 |     |     X208 value,
 138 |     |     X216 multiplier
 139 |     |   ) internal pure returns (
 140 |     |     X111 product
 141 |     |   ) {
 142 |     |     ( ,  , uint256 q2) = FullMathLibrary.mul768(
 143 |     |       // (2 ** 244) * exp(8)
 144 |     |       0xBA4F53EA38636F85F007042540AE8EF33225E9A7AB4F4473A86D4A8FDD1A5B82,
 145 |     |       X208.unwrap(value),
 146 |     |       // Casting is safe because of the non-negative requirement on
 147 |     |       // 'multiplier'.
 148 |     |       uint256(X216.unwrap(multiplier))
 149 |     |     );
 150 |     |     unchecked {
 151 |     |       // Casting is safe because 'q2 >> 45' never exceeds 'type(int256).max'.
 152 |     |       // '45 == 244 + 208 + 216 - 512 - 111'
 153 |     |       product = X111.wrap(int256(q2 >> 45));
 154 |     |     }
 155 |     |   }
 156 |     | }

/home/training/contracts/utilities/X216.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {FullMathLibrary} from "./FullMath.sol";
   5 |     | 
   6 |     | // Type 'X216' is dedicated to integrals and sqrt of price values.
   7 |     | type X216 is int256;
   8 |     | 
   9 |     | using X216Library for X216 global;
  10 |     | 
  11 |     | X216 constant oneX216 = X216.wrap(1 << 216);
  12 | *   | X216 constant zeroX216 = X216.wrap(0);
  13 |     | X216 constant epsilonX216 = X216.wrap(1);
  14 |     | // (2 ** 216) * exp(-8)
  15 |     | X216 constant expInverse8X216 = X216.wrap(
  16 | *   |   0x00000000000015FC21041027ACBBFCD46780FEE71EAD23FBCB7F4A81E58767EF
  17 |     | );
  18 |     | 
  19 |     | using {equals as ==, notEquals as !=} for X216 global;
  20 |     | using {lessThan as <, greaterThan as >} for X216 global;
  21 |     | using {
  22 |     |   lessThanOrEqualTo as <=,
  23 |     |   greaterThanOrEqualTo as >=
  24 |     | } for X216 global;
  25 |     | using {add as +, sub as -} for X216 global;
  26 |     | using {mul as *, cheapMul as &} for X216 global;
  27 |     | using {mulDivByExpInv8 as %, mulDivByExpInv16 as ^} for X216 global;
  28 |     | 
  29 | *   | function equals(
  30 |     |   X216 value0,
  31 |     |   X216 value1
  32 |     | ) pure returns (
  33 | *   |   bool result
  34 |     | ) {
  35 |     |   assembly {
  36 | *   |     result := eq(value0, value1)
  37 |     |   }
  38 |     | }
  39 |     | 
  40 |     | function notEquals(
  41 |     |   X216 value0,
  42 |     |   X216 value1
  43 |     | ) pure returns (
  44 |     |   bool result
  45 |     | ) {
  46 |     |   return !(value0 == value1);
  47 |     | }
  48 |     | 
  49 |     | function lessThan(
  50 |     |   X216 value0,
  51 |     |   X216 value1
  52 |     | ) pure returns (
  53 |     |   bool result
  54 |     | ) {
  55 |     |   assembly {
  56 |     |     result := slt(value0, value1)
  57 |     |   }
  58 |     | }
  59 |     | 
  60 | *   | function greaterThan(
  61 |     |   X216 value0,
  62 |     |   X216 value1
  63 |     | ) pure returns (
  64 | *   |   bool result
  65 |     | ) {
  66 |     |   assembly {
  67 | *   |     result := sgt(value0, value1)
  68 |     |   }
  69 |     | }
  70 |     | 
  71 | *   | function lessThanOrEqualTo(
  72 |     |   X216 value0,
  73 |     |   X216 value1
  74 |     | ) pure returns (
  75 | *   |   bool result
  76 |     | ) {
  77 | *   |   return !(value0 > value1);
  78 |     | }
  79 |     | 
  80 |     | function greaterThanOrEqualTo(
  81 |     |   X216 value0,
  82 |     |   X216 value1
  83 |     | ) pure returns (
  84 |     |   bool result
  85 |     | ) {
  86 |     |   return !(value0 < value1);
  87 |     | }
  88 |     | 
  89 |     | // Overflow/underflow should be avoided externally.
  90 |     | function add(
  91 |     |   X216 value0,
  92 |     |   X216 value1
  93 |     | ) pure returns (
  94 |     |   X216 result
  95 |     | ) {
  96 |     |   assembly {
  97 |     |     result := add(value0, value1)
  98 |     |   }
  99 |     | }
 100 |     | 
 101 |     | // Overflow/underflow should be avoided externally.
 102 | *   | function sub(
 103 |     |   X216 value0,
 104 |     |   X216 value1
 105 |     | ) pure returns (
 106 | *   |   X216 result
 107 |     | ) {
 108 |     |   assembly {
 109 | *   |     result := sub(value0, value1)
 110 |     |   }
 111 |     | }
 112 |     | 
 113 |     | // Calculates '(value0 * value1) / (2 ** 216)'.
 114 |     | // Overflow/underflow should be avoided externally.
 115 |     | // Both values should be greater than '- 2 ** 255'.
 116 | *   | function mul(
 117 |     |   X216 value0,
 118 |     |   X216 value1
 119 |     | ) pure returns (
 120 | *   |   X216 result
 121 |     | ) {
 122 |     |   // Let 's := value0 * value1 - (2 ** 256 - 1) * p'
 123 |     |   // Let 'r := value0 * value1 - (2 ** 216) * q'
 124 |     |   // Then 's - r == (2 ** 216) * q' [modulo '2 ** 256 - 1']
 125 |     |   // Then 'q == (2 ** 40) * (s - r)' [modulo '2 ** 256 - 1']
 126 |     |   assembly {
 127 | *   |     result := mulmod(
 128 | *   |       addmod(
 129 |     |         // We account for the additional term '2 ** 256' in two's complement
 130 |     |         // representation by subtracting 'slt(value, 0)'. Because if a two's
 131 |     |         // complement representation 'value' correspond to a negative number,
 132 |     |         // we have:
 133 |     |         //
 134 |     |         // 'value - 2 ** 256 == value - 1' [modulo 2 ** 256 - 1]
 135 |     |         //
 136 |     |         // Both subtractions are safe due to the input requirement.
 137 | *   |         mulmod(
 138 | *   |           sub(value0, slt(value0, 0)),
 139 | *   |           sub(value1, slt(value1, 0)),
 140 | *   |           not(0)
 141 |     |         ), // s
 142 |     |         // Here, we do not need to account for the additional term '2 ** 256'
 143 |     |         // in two's complement representation because if a two's complement
 144 |     |         // representation 'value' is negative, we have:
 145 |     |         //
 146 |     |         // 'value - 2 ** 256 == value' [modulo 2 ** 216]
 147 |     |         //
 148 |     |         // The subtraction is safe because '2 ** 216 < 2 ** 256 - 1'.
 149 | *   |         sub(not(0), mulmod(value0, value1, shl(216, 1))), // 0 - r
 150 | *   |         not(0)
 151 |     |       ),
 152 | *   |       shl(40, 1),
 153 | *   |       not(0)
 154 |     |     )
 155 |     |   }
 156 |     | }
 157 |     | 
 158 |     | // Calculates '(value0 * value1) / (2 ** 216)'.
 159 |     | // 'value0' and 'value1' should be non-negative and less than 'oneX216'.
 160 |     | function cheapMul(
 161 |     |   X216 value0,
 162 |     |   X216 value1
 163 |     | ) pure returns (
 164 |     |   X216 result
 165 |     | ) {
 166 |     |   // Let 's := value0 * value1 - (2 ** 216 - 1) * p'
 167 |     |   // Let 'r := value0 * value1 - (2 ** 216) * q'
 168 |     |   // Then 's - r == q' [modulo '2 ** 216 - 1']
 169 |     |   // Because of the input requirements, 'q' does not exceed '2 ** 216 - 1'
 170 |     |   // which concludes that: 's - r == q'.
 171 |     |   assembly {
 172 |     |     result := addmod(
 173 |     |       mulmod(value0, value1, sub(shl(216, 1), 1)), // s
 174 |     |       // The subtraction is safe because the output of 'mulmod' does not exceed
 175 |     |       // '2 ** 216 - 1'.
 176 |     |       sub(sub(shl(216, 1), 1), mulmod(value0, value1, shl(216, 1))), // 0 - r
 177 |     |       sub(shl(216, 1), 1)
 178 |     |     )
 179 |     |   }
 180 |     | }
 181 |     | 
 182 |     | // Calculates '(value0 * value1) / ((2 ** 216) * exp(-8))'.
 183 |     | //
 184 |     | // The following approximation is used: '(2 ** 216) * exp(-8) ~= b / a' where
 185 |     | // 'a = 0xF8F6376C44' and 
 186 |     | // 'b = 0x1561650620DABB6A84B684E2A7E5A47CAA0A0905210083F0E3B551AABF84E9'
 187 |     | //
 188 |     | // Overflow should be avoided externally.
 189 |     | // Both values should be non-negative.
 190 |     | // 'value0' should be less than 'oneX216'.
 191 |     | function mulDivByExpInv8(
 192 |     |   X216 value0,
 193 |     |   X216 value1
 194 |     | ) pure returns (
 195 |     |   X216 result
 196 |     | ) {
 197 |     |   // Let 's := value0 * value1 * a - (2 ** 256) * p'
 198 |     |   // Let 'r := value0 * value1 * a - b * q'
 199 |     |   // Then 's - r == b * q' [modulo '2 ** 256']
 200 |     |   assembly {
 201 |     |     // Multiplication is safe because of the input requirement:
 202 |     |     // '0 <= value0 < oneX216'.
 203 |     |     result := mul(value0, 0xF8F6376C44)
 204 |     |     result := mul(
 205 |     |       // s - r
 206 |     |       sub(
 207 |     |         // s
 208 |     |         mul(result, value1),
 209 |     |         // r
 210 |     |         mulmod(
 211 |     |           result,
 212 |     |           value1,
 213 |     |           0x1561650620DABB6A84B684E2A7E5A47CAA0A0905210083F0E3B551AABF84E9 // b
 214 |     |         )
 215 |     |       ),
 216 |     |       // modular inverse of 'b' modulo '2 ** 256'
 217 |     |       0x28256938C4923FF15AB260970AA81F81C15E6F5EF3AF38DC210569E77DB19359
 218 |     |     )
 219 |     |   }
 220 |     | }
 221 |     | 
 222 |     | // Calculates '(value0 * value1) / ((2 ** 216) * exp(-16))'.
 223 |     | //
 224 |     | // The following approximation is used: '(2 ** 216) * exp(-16) ~= b / a' where
 225 |     | // 'a = 0x27D117D7B * 0x2EC3A856' and 
 226 |     | // 'b = 0xDBB82F7041B890FE67970A62A3568CC34DF9DCB17CC3A2A6A027850E7E3724F9'
 227 |     | //
 228 |     | // Overflow should be avoided externally.
 229 |     | // Both values should be non-negative.
 230 |     | // 'value0' and 'value1' should be less than 'oneX216'.
 231 |     | function mulDivByExpInv16(
 232 |     |   X216 value0,
 233 |     |   X216 value1
 234 |     | ) pure returns (
 235 |     |   X216 result
 236 |     | ) {
 237 |     |   // Let 's := value0 * value1 * a - (2 ** 256) * p'
 238 |     |   // Let 'r := value0 * value1 * a - b * q'
 239 |     |   // Then 's - r == b * q' [modulo '2 ** 256']
 240 |     |   assembly {
 241 |     |     // Both of the following multiplications are safe because of the input
 242 |     |     // requirements:
 243 |     |     // '0 <= value0 < oneX216'.
 244 |     |     // '0 <= value1 < oneX216'.
 245 |     |     value0 := mul(value0, 0x27D117D7B)
 246 |     |     value1 := mul(value1, 0x2EC3A856)
 247 |     |     result := mul(
 248 |     |       // s - r
 249 |     |       sub(
 250 |     |         // s
 251 |     |         mul(value0, value1),
 252 |     |         // r
 253 |     |         mulmod(
 254 |     |           value0,
 255 |     |           value1,
 256 |     |           // b
 257 |     |           0xDBB82F7041B890FE67970A62A3568CC34DF9DCB17CC3A2A6A027850E7E3724F9
 258 |     |         )
 259 |     |       ),
 260 |     |       // modular inverse of 'b' modulo '2 ** 256'
 261 |     |       0x7F6AF8233BADA11DD406B4458454ED9904D7AF796BE7AA4885B23E25B6985D49
 262 |     |     )
 263 |     |   }
 264 |     | }
 265 |     | 
 266 |     | function min(
 267 |     |   X216 value0,
 268 |     |   X216 value1
 269 |     | ) pure returns (
 270 |     |   X216 result
 271 |     | ) {
 272 |     |   return (value0 < value1) ? value0 : value1;
 273 |     | }
 274 |     | 
 275 |     | function max(
 276 |     |   X216 value0,
 277 |     |   X216 value1
 278 |     | ) pure returns (
 279 |     |   X216 result
 280 |     | ) {
 281 |     |   return (value0 < value1) ? value1 : value0;
 282 |     | }
 283 |     | 
 284 |     | /// @notice Returns the minimum of two unsigned fractions. '0 / 0' is 
 285 |     | /// interpreted as infinity. 'which == false' and 'which == true' indicate
 286 |     | /// '(numerator0, denominator0)' and '(numerator1, denominator1)',
 287 |     | /// respectively.
 288 |     | /// All four values should be non-negative.
 289 |     | /// At least one 'denominator' should be non-zero.
 290 |     | function minFractions(
 291 |     |   X216 numerator0,
 292 |     |   X216 denominator0,
 293 |     |   X216 numerator1,
 294 |     |   X216 denominator1
 295 |     | ) pure returns (
 296 |     |   X216 numerator,
 297 |     |   X216 denominator,
 298 |     |   bool which
 299 |     | ) {
 300 |     |   if (numerator0 == zeroX216) {
 301 |     |     if (denominator0 == zeroX216) {
 302 |     |       return (numerator1, denominator1, true);
 303 |     |     }
 304 |     |   }
 305 |     |   // Castings are safe because all four values are non-negative.
 306 |     |   (uint256 lsb0, uint256 msb0) = FullMathLibrary.mul512(
 307 |     |     uint256(X216.unwrap(numerator0)),
 308 |     |     uint256(X216.unwrap(denominator1))
 309 |     |   );
 310 |     |   (uint256 lsb1, uint256 msb1) = FullMathLibrary.mul512(
 311 |     |     uint256(X216.unwrap(numerator1)),
 312 |     |     uint256(X216.unwrap(denominator0))
 313 |     |   );
 314 |     |   (numerator, denominator, which) = 
 315 |     |     ((msb1 > msb0) || ((msb1 == msb0) && (lsb1 >= lsb0))) ? 
 316 |     |     (numerator0, denominator0, false) : 
 317 |     |     (numerator1, denominator1, true);
 318 |     | }
 319 |     | 
 320 |     | library X216Library {
 321 |     |   /// @notice Calculates 'value * exp(1 / (2 ** 60))'.
 322 |     |   /// Overflow should be avoided externally.
 323 |     |   /// 'value' should be non-negative.
 324 |     |   function multiplyByExpEpsilon(
 325 |     |     X216 value
 326 |     |   ) internal pure returns (
 327 |     |     X216 result
 328 |     |   ) {
 329 |     |     // Let 'a := floor((2 ** 256) * exp(-1 / (2 ** 60)))'
 330 |     |     // Let 'r := (2 ** 256) * value - a * q'
 331 |     |     // Let 'b := modularInverse(- a, 2 ** 256)'
 332 |     |     // Then 'q == b * r' [modulo '2 ** 256']
 333 |     |     assembly {
 334 |     |       result := mul(
 335 |     |         // r
 336 |     |         mulmod(
 337 |     |           value,
 338 |     |           // We are subtracting by 'a' because '2 ** 256' does not fit, which
 339 |     |           // is okay because the multiplication is done modulo 'a'.
 340 |     |           // 2 ** 256 - a
 341 |     |           0xFFFFFFFFFFFFFFF8000000000000002AAAAAAAAAAAAAAA001,
 342 |     |           // a
 343 |     |           0xFFFFFFFFFFFFFFF0000000000000007FFFFFFFFFFFFFFD555555555555555FFF
 344 |     |         ),
 345 |     |         // b
 346 |     |         0xAA3ED2381A8B1241D16168FD77EF989ED2B13BE12B716AA23F35ED0E39556001
 347 |     |       )
 348 |     |     }
 349 |     |   }
 350 |     | 
 351 |     |   /// @notice Calculates 'value / exp(1 / (2 ** 60))'.
 352 |     |   /// 'value' should be non-negative.
 353 |     |   function divideByExpEpsilon(
 354 |     |     X216 value
 355 |     |   ) internal pure returns (
 356 |     |     X216 result
 357 |     |   ) {
 358 |     |     assembly {
 359 |     |       // Let 'a := floor((2 ** 256 - 1) * exp(-1 / (2 ** 60)))'.
 360 |     |       // Let 's := value * a - q * not(0)'.
 361 |     |       // Let 'r := value * a'.
 362 |     |       // Then 's - r == - q * not(0) == q'.
 363 |     |       result := sub(
 364 |     |         // s
 365 |     |         mulmod(
 366 |     |           value,
 367 |     |           // a
 368 |     |           0xFFFFFFFFFFFFFFF0000000000000007FFFFFFFFFFFFFFD555555555555555FFE,
 369 |     |           not(0)
 370 |     |         ),
 371 |     |         // r
 372 |     |         mul(
 373 |     |           value,
 374 |     |           // a
 375 |     |           0xFFFFFFFFFFFFFFF0000000000000007FFFFFFFFFFFFFFD555555555555555FFE
 376 |     |         )
 377 |     |       )
 378 |     |     }
 379 |     |   }
 380 |     | 
 381 |     |   /// @notice Calculates '(value * numerator) / denominator'
 382 |     |   /// Overflow and division by zero should be avoided externally.
 383 |     |   /// All input values should be non-negative.
 384 |     |   function mulDiv(
 385 |     |     X216 value,
 386 |     |     X216 numerator,
 387 |     |     X216 denominator
 388 |     |   ) internal pure returns (
 389 |     |     X216 result
 390 |     |   ) {
 391 |     |     result = X216.wrap(
 392 |     |       // Casting is safe because overflow is handled externally.
 393 |     |       int256(
 394 |     |         // All three castings are safe due to the input requirements.
 395 |     |         FullMathLibrary.mulDiv(
 396 |     |           uint256(X216.unwrap(value)),
 397 |     |           uint256(X216.unwrap(numerator)),
 398 |     |           uint256(X216.unwrap(denominator))
 399 |     |         )
 400 |     |       )
 401 |     |     );
 402 |     |   }
 403 |     | 
 404 |     |   /// @notice Calculates '(value * numerator) / denominator' when 
 405 |     |   /// 'value * numerator < denominator * (denominator - 1)'.
 406 |     |   /// value should be non-negative
 407 |     |   function cheapMulDiv(
 408 |     |     X216 value,
 409 |     |     uint256 numerator,
 410 |     |     uint256 denominator
 411 |     |   ) internal pure returns (
 412 |     |     X216 result
 413 |     |   ) {
 414 |     |     result = X216.wrap(
 415 |     |       // Casting is safe because overflow is handled externally.
 416 |     |       int256(
 417 |     |         // The requirement of 'cheapMulDiv' is met because of the above input
 418 |     |         // requirement.
 419 |     |         FullMathLibrary.cheapMulDiv(
 420 |     |           // Casting is safe due to the input requirement in 'value'.
 421 |     |           uint256(X216.unwrap(value)),
 422 |     |           numerator,
 423 |     |           denominator
 424 |     |         )
 425 |     |       )
 426 |     |     );
 427 |     |   }
 428 |     | }

/home/training/contracts/utilities/X23.sol
  1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
  2 |     | pragma solidity ^0.8.28;
  3 |     | 
  4 |     | // Type 'X23' is dedicated to pool growth ratios which determine the ratio of
  5 |     | // the accrued growth portions that belong to a pool owner. 'oneX23' represents
  6 |     | // 100%.
  7 |     | type X23 is uint256;
  8 |     | 
  9 |     | X23 constant zeroX23 = X23.wrap(0);
 10 |     | X23 constant oneX23 = X23.wrap(1 << 23);
 11 |     | 
 12 |     | using {add as +, sub as -} for X23 global;
 13 |     | 
 14 |     | // Overflow should be avoided externally.
 15 |     | function add(
 16 |     |   X23 value0,
 17 |     |   X23 value1
 18 |     | ) pure returns (
 19 |     |   X23 result
 20 |     | ) {
 21 |     |   assembly {
 22 |     |     result := add(value0, value1)
 23 |     |   }
 24 |     | }
 25 |     | 
 26 |     | // Underflow should be avoided externally.
 27 |     | function sub(
 28 |     |   X23 value0,
 29 |     |   X23 value1
 30 |     | ) pure returns (
 31 |     |   X23 result
 32 |     | ) {
 33 |     |   assembly {
 34 |     |     result := sub(value0, value1)
 35 |     |   }
 36 |     | }

/home/training/contracts/utilities/X47.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | // Type 'X47' is dedicated to growth portions. Interval liquidity can grow as a
   5 |     | // result of a swap or a donation. A portion of this growth goes to the
   6 |     | // protocol. A portion of the remaining growth goes to the pool owner. These
   7 |     | // portions are stored as 'X47' type with 'oneX47' representing 100%.
   8 |     | type X47 is uint256;
   9 |     | 
  10 |     | X47 constant zeroX47 = X47.wrap(0);
  11 |     | // Largest valid value for growth portions:
  12 |     | X47 constant oneX47 = X47.wrap(1 << 47);
  13 |     | // An invalid value for growth portions which is used as an indicator:
  14 |     | X47 constant maxX47 = X47.wrap(type(uint48).max);
  15 |     | 
  16 |     | using {equals as ==, notEqual as !=} for X47 global;
  17 |     | using {lessThan as <, greaterThan as >} for X47 global;
  18 |     | using {
  19 |     |   lessThanOrEqualTo as <=,
  20 |     |   greaterThanOrEqualTo as >=
  21 |     | } for X47 global;
  22 |     | 
  23 |     | function equals(
  24 |     |   X47 value0,
  25 |     |   X47 value1
  26 |     | ) pure returns (
  27 |     |   bool result
  28 |     | ) {
  29 |     |   assembly {
  30 |     |     result := eq(value0, value1)
  31 |     |   }
  32 |     | }
  33 |     | 
  34 |     | function notEqual(
  35 |     |   X47 value0,
  36 |     |   X47 value1
  37 |     | ) pure returns (
  38 |     |   bool result
  39 |     | ) {
  40 |     |   return !(value0 == value1);
  41 |     | }
  42 |     | 
  43 |     | function lessThan(
  44 |     |   X47 value0,
  45 |     |   X47 value1
  46 |     | ) pure returns (
  47 |     |   bool result
  48 |     | ) {
  49 |     |   assembly {
  50 |     |     result := lt(value0, value1)
  51 |     |   }
  52 |     | }
  53 |     | 
  54 |     | function greaterThan(
  55 |     |   X47 value0,
  56 |     |   X47 value1
  57 |     | ) pure returns (
  58 |     |   bool result
  59 |     | ) {
  60 |     |   assembly {
  61 |     |     result := gt(value0, value1)
  62 |     |   }
  63 |     | }
  64 |     | 
  65 |     | function lessThanOrEqualTo(
  66 |     |   X47 value0,
  67 |     |   X47 value1
  68 |     | ) pure returns (
  69 |     |   bool result
  70 |     | ) {
  71 |     |   return !(value0 > value1);
  72 |     | }
  73 |     | 
  74 |     | function greaterThanOrEqualTo(
  75 |     |   X47 value0,
  76 |     |   X47 value1
  77 |     | ) pure returns (
  78 |     |   bool result
  79 |     | ) {
  80 |     |   return !(value0 < value1);
  81 |     | }
  82 |     | 
  83 |     | function min(
  84 |     |   X47 value0,
  85 |     |   X47 value1
  86 |     | ) pure returns (
  87 |     |   X47 result
  88 |     | ) {
  89 |     |   return (value0 < value1) ? value0 : value1;
  90 |     | }
  91 |     | 
  92 |     | function max(
  93 |     |   X47 value0,
  94 |     |   X47 value1
  95 |     | ) pure returns (
  96 |     |   X47 result
  97 |     | ) {
  98 |     |   return (value0 < value1) ? value1 : value0;
  99 |     | }

/home/training/contracts/utilities/X59.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {X15} from "./X15.sol";
   5 |     | import {X74} from "./X74.sol";
   6 |     | import {X127} from "./X127.sol";
   7 |     | import {X216} from "./X216.sol";
   8 |     | import {FullMathLibrary} from "./FullMath.sol";
   9 |     | 
  10 |     | // Type 'X59' is dedicated to the natural logarithm of price.
  11 |     | type X59 is int256;
  12 |     | 
  13 |     | using X59Library for X59 global;
  14 |     | 
  15 |     | X59 constant zeroX59 = X59.wrap(0);
  16 | *   | X59 constant epsilonX59 = X59.wrap(1);
  17 |     | X59 constant oneX59 = X59.wrap(1 << 59);
  18 | *   | X59 constant twoX59 = X59.wrap(2 << 59);
  19 |     | X59 constant threeX59 = X59.wrap(3 << 59);
  20 |     | X59 constant fourX59 = X59.wrap(4 << 59);
  21 |     | X59 constant sixteenX59 = X59.wrap(16 << 59);
  22 | *   | X59 constant thirtyTwoX59 = X59.wrap(32 << 59);
  23 |     | X59 constant minLogSpacing = X59.wrap((1 << 59) >> 19);
  24 |     | X59 constant minLogStep = X59.wrap((1 << 59) >> 27);
  25 |     | X59 constant minLogOffset = X59.wrap(0 - int256(90 << 59));
  26 |     | X59 constant maxLogOffset = X59.wrap(90 << 59);
  27 |     | X59 constant minX59 = X59.wrap(0 - type(int256).max);
  28 |     | X59 constant maxX59 = X59.wrap(type(int256).max);
  29 |     | 
  30 |     | using {equals as ==, notEqual as !=} for X59 global;
  31 |     | using {lessThan as <, greaterThan as >} for X59 global;
  32 |     | using {
  33 |     |   lessThanOrEqualTo as <=,
  34 |     |   greaterThanOrEqualTo as >=
  35 |     | } for X59 global;
  36 |     | using {add as +, sub as -} for X59 global;
  37 |     | using {mod as %} for X59 global;
  38 |     | 
  39 | *   | function equals(
  40 |     |   X59 value0,
  41 |     |   X59 value1
  42 |     | ) pure returns (
  43 | *   |   bool result
  44 |     | ) {
  45 |     |   assembly {
  46 | *   |     result := eq(value0, value1)
  47 |     |   }
  48 |     | }
  49 |     | 
  50 | *   | function notEqual(
  51 |     |   X59 value0,
  52 |     |   X59 value1
  53 |     | ) pure returns (
  54 | *   |   bool result
  55 |     | ) {
  56 | *   |   return !(value0 == value1);
  57 |     | }
  58 |     | 
  59 | *   | function lessThan(
  60 |     |   X59 value0,
  61 |     |   X59 value1
  62 |     | ) pure returns (
  63 | *   |   bool result
  64 |     | ) {
  65 |     |   assembly {
  66 | *   |     result := slt(value0, value1)
  67 |     |   }
  68 |     | }
  69 |     | 
  70 |     | function greaterThan(
  71 |     |   X59 value0,
  72 |     |   X59 value1
  73 |     | ) pure returns (
  74 |     |   bool result
  75 |     | ) {
  76 |     |   assembly {
  77 |     |     result := sgt(value0, value1)
  78 |     |   }
  79 |     | }
  80 |     | 
  81 |     | function lessThanOrEqualTo(
  82 |     |   X59 value0,
  83 |     |   X59 value1
  84 |     | ) pure returns (
  85 |     |   bool result
  86 |     | ) {
  87 |     |   return !(value0 > value1);
  88 |     | }
  89 |     | 
  90 |     | function greaterThanOrEqualTo(
  91 |     |   X59 value0,
  92 |     |   X59 value1
  93 |     | ) pure returns (
  94 |     |   bool result
  95 |     | ) {
  96 |     |   return !(value0 < value1);
  97 |     | }
  98 |     | 
  99 |     | // Overflow/underflow should be avoided externally.
 100 | *   | function add(
 101 |     |   X59 value0,
 102 |     |   X59 value1
 103 |     | ) pure returns (
 104 | *   |   X59 result
 105 |     | ) {
 106 |     |   assembly {
 107 | *   |     result := add(value0, value1)
 108 |     |   }
 109 |     | }
 110 |     | 
 111 |     | // Overflow/underflow should be avoided externally.
 112 | *   | function sub(
 113 |     |   X59 value0,
 114 |     |   X59 value1
 115 |     | ) pure returns (
 116 | *   |   X59 result
 117 |     | ) {
 118 |     |   assembly {
 119 | *   |     result := sub(value0, value1)
 120 |     |   }
 121 |     | }
 122 |     | 
 123 |     | // 'value' should be non-negative.
 124 |     | // 'modulus' should be positive.
 125 |     | function mod(
 126 |     |   X59 value,
 127 |     |   X59 modulus
 128 |     | ) pure returns (
 129 |     |   X59 result
 130 |     | ) {
 131 |     |   assembly {
 132 |     |     result := mod(value, modulus)
 133 |     |   }
 134 |     | }
 135 |     | 
 136 | *   | function min(
 137 |     |   X59 value0,
 138 |     |   X59 value1
 139 |     | ) pure returns (
 140 | *   |   X59 result
 141 |     | ) {
 142 | *   |   return (value0 < value1) ? value0 : value1;
 143 |     | }
 144 |     | 
 145 | *   | function max(
 146 |     |   X59 value0,
 147 |     |   X59 value1
 148 |     | ) pure returns (
 149 | *   |   X59 result
 150 |     | ) {
 151 | *   |   return (value0 < value1) ? value1 : value0;
 152 |     | }
 153 |     | 
 154 |     | library X59Library {
 155 |     |   // Overflow should be avoided externally.
 156 |     |   // 'value0' should be non-negative.
 157 | *   |   function times(
 158 |     |     X59 value0,
 159 |     |     X15 value1
 160 |     |   ) internal pure returns (
 161 | *   |     X74 result
 162 |     |   ) {
 163 |     |     assembly {
 164 | *   |       result := mul(value0, value1)
 165 |     |     }
 166 |     |   }
 167 |     | 
 168 |     |   /// @notice Calculates '(value * numerator) / denominator' when 
 169 |     |   /// 'value * numerator < denominator * (denominator - 1)'.
 170 |     |   /// The three inputs should be non-negative.
 171 |     |   function cheapMulDiv(
 172 |     |     X59 value,
 173 |     |     X216 numerator,
 174 |     |     X216 denominator
 175 |     |   ) internal pure returns (
 176 |     |     X59 result
 177 |     |   ) {
 178 |     |     // The three castings to 'uint256' are safe because of the 'non-negative'
 179 |     |     // requirement on input values.
 180 |     |     //
 181 |     |     // The casting to 'int256' is safe because
 182 |     |     // 'value * numerator / denominator < denominator - 1 <= 2 ** 255 - 2'.
 183 |     |     //
 184 |     |     // The requirement of 'cheapMulDiv' are met because of the above input
 185 |     |     // requirement.
 186 |     |     result = X59.wrap(int256(FullMathLibrary.cheapMulDiv(
 187 |     |       uint256(X59.unwrap(value)),
 188 |     |       uint256(X216.unwrap(numerator)),
 189 |     |       uint256(X216.unwrap(denominator))
 190 |     |     )));
 191 |     |   }
 192 |     | 
 193 |     |   /// @notice Calculates
 194 |     |   /// '(value * multiplier0 * multiplier1) / ((2 ** (216 + 59)) * exp(-16))'
 195 |     |   /// Overflow should be avoided externally.
 196 |     |   /// All three inputs should be non-negative.
 197 |     |   function mulDivByExpInv16(
 198 |     |     X59 value,
 199 |     |     X216 multiplier0,
 200 |     |     X216 multiplier1
 201 |     |   ) internal pure returns (
 202 |     |     X216 product
 203 |     |   ) {
 204 |     |     assembly {
 205 |     |       // Let 'r := value * multiplier0 * multiplier1 
 206 |     |       //         - floor((2 ** 275) * exp(-16)) * q'.
 207 |     |       //
 208 |     |       // Let 's := value * multiplier0 * multiplier1 - (2 ** 256) * p'.
 209 |     |       //
 210 |     |       // Then 's - r == floor((2 ** 275) * exp(-16)) * q' [modulo '2 ** 256']
 211 |     |       product := mul(
 212 |     |         sub(
 213 |     |           // s
 214 |     |           mul(mul(value, multiplier0), multiplier1),
 215 |     |           // r
 216 |     |           mulmod(
 217 |     |             mulmod(
 218 |     |               value,
 219 |     |               multiplier0,
 220 |     |               // floor((2 ** 275) * exp(-16))
 221 |     |               0xF1AADDD7742E56D32FB9F997447D9E6314DB84884FABAB26BF059AF9BC20B61
 222 |     |             ),
 223 |     |             multiplier1,
 224 |     |             // floor((2 ** 275) * exp(-16))
 225 |     |             0xF1AADDD7742E56D32FB9F997447D9E6314DB84884FABAB26BF059AF9BC20B61
 226 |     |           )
 227 |     |         ),
 228 |     |         // modularInverse(floor((2 ** 275) * exp(-16)), 2 ** 256)
 229 |     |         0xD49C04AF80AF1EA5F98F85886B450A4B264FC14874F9F64143836145A37DD8A1
 230 |     |       )
 231 |     |     }
 232 |     |   }
 233 |     | 
 234 |     |   /// @notice Calculates '(2 ** 256) * exp(- x / (2 ** 60))'.
 235 |     |   /// "Pade Approximant" is employed for this purpose:
 236 |     |   /// 'exp(- x / (2 ** 60)) ~= ((u(x) - v(x)) / (u(x) + v(x))) ** (2 ** 14)'
 237 |     |   /// where
 238 |     |   ///                x ** 2      x ** 4       x ** 6          x ** 8
 239 |     |   /// 'u(x) = 1 + 7 --------- + --------- + ----------- + --------------'
 240 |     |   ///                15<<150     39<<300     6435<<449     2027025<<600
 241 |     |   /// and
 242 |     |   ///            x       x ** 3       x ** 5        x ** 7
 243 |     |   /// 'v(x) = ------- + --------- + ---------- + -------------'.
 244 |     |   ///          1<<75     15<<224     585<<374     225225<<523
 245 |     |   ///
 246 |     |   /// This formula can be reproduced via the following Mathematica command:
 247 |     |   /// 'PadeApproximant[Exp[- x / (2 ^ 74)], {x, 0, 8}]'.
 248 |     |   ///
 249 |     |   /// Input should be greater than '0' and less than '2 ** 64'.
 250 | *   |   function expInverse(
 251 |     |     X59 value
 252 |     |   ) internal pure returns (
 253 | *   |     uint256 exponentialInverse
 254 |     |   ) {
 255 |     |     unchecked {
 256 |     |       // Casting is safe because 'value' is between '0' and '2 ** 64'.
 257 | *   |       uint256 x = uint256(X59.unwrap(value));
 258 |     |       
 259 |     |       // x ** 2
 260 | *   |       uint256 x2 = x * x;
 261 |     |       
 262 |     |       // x ** 4
 263 | *   |       uint256 x4 = x2 * x2;
 264 |     | 
 265 |     |       // (x ** 6) / (2 ** 128)
 266 | *   |       uint256 x6;
 267 |     |       assembly {
 268 |     |         // Let 'r := x2 * x4 - (2 ** 128) * q'
 269 |     |         // Let 's := x2 * x4 - (2 ** 256 - 1) * p'
 270 |     |         // Then 's - r == (2 ** 128) * q' [modulo '2 ** 256 - 1']
 271 |     |         // And 'q == (2 ** 128) * (s - r)' [modulo '2 ** 256 - 1']
 272 |     |         // Calculation modulo '2 ** 256 - 1' is safe because:
 273 |     |         // '((2 ** 64 - 1) ** 6) / (2 ** 128) < 2 ** 256 - 1'
 274 | *   |         x6 := mulmod(
 275 |     |           // The subtraction is safe because the remainder is greater than or
 276 |     |           // equal to the second one.
 277 | *   |           sub(mulmod(x2, x4, not(0)), mulmod(x2, x4, shl(128, 1))),
 278 | *   |           shl(128, 1),
 279 | *   |           not(0)
 280 |     |         )
 281 |     |       }
 282 |     | 
 283 |     |       // (x ** 8) / (2 ** 256)
 284 | *   |       uint256 x8;
 285 |     |       assembly {
 286 |     |         // Let 'r := x4 * x4 - (2 ** 256) * q'
 287 |     |         // Let 's := x4 * x4 - (2 ** 256 - 1) * p'
 288 |     |         // Then 's - r == q' [modulo '2 ** 256 - 1']
 289 |     |         // Calculation modulo '2 ** 256 - 1' is safe because:
 290 |     |         // '((2 ** 64 - 1) ** 8) / (2 ** 256) < 2 ** 256 - 1'
 291 | *   |         x8 := sub(mulmod(x4, x4, not(0)), mul(x4, x4))
 292 |     |       }
 293 |     | 
 294 |     |       // (2 ** 254) * u(x)
 295 |     |       // The additions are safe because the first term is '1 << 254' and none
 296 |     |       // of the other terms exceed '1 << 250'.
 297 | *   |       uint256 a = 
 298 | *   |         ((x2 * (7 << 104)) / 15) + 
 299 | *   |         (x4 / (39 << 46)) + 
 300 | *   |         (x6 / (6435 << 67)) + 
 301 | *   |         (x8 / (2027025 << 90)) + 
 302 | *   |         (1 << 254);
 303 |     | 
 304 |     |       // (2 ** 254) * v(x)
 305 |     |       // The additions are safe because the first term is '1 << 255' and none
 306 |     |       // of the other terms exceed '1 << 250'.
 307 | *   |       uint256 b = 
 308 | *   |         ((x2 << 106) / 15) + 
 309 | *   |         (x4 / (585 << 44)) + 
 310 | *   |         (x6 / (225225 << 65)) + 
 311 | *   |         (1 << 255);
 312 |     |         
 313 |     |       assembly {
 314 |     |         // Here we multiply the result by (x / (2 ** 76)).
 315 |     |         // Let 'r := x * b - (2 ** 76) * q'
 316 |     |         // Let 's := x * b - (2 ** 256 - 1) * p'
 317 |     |         // Then 's - r == (2 ** 76) * q' [modulo '2 ** 256 - 1']
 318 |     |         // And 'q == (2 ** 180) * (s - r)' [modulo '2 ** 256 - 1']
 319 |     |         // Calculation modulo '2 ** 256 - 1' is safe because:
 320 |     |         // 'b < 2 ** 256 - 1'
 321 | *   |         b := mulmod(
 322 |     |           // The subtraction is safe because the remainder is greater than or
 323 |     |           // equal to the second one.
 324 | *   |           sub(mulmod(x, b, not(0)), mulmod(x, b, shl(76, 1))),
 325 | *   |           shl(180, 1),
 326 | *   |           not(0)
 327 |     |         )
 328 |     |       }
 329 |     | 
 330 |     |       // (2 ** 256) * (u(x) - v(x)) / (u(x) + v(x))
 331 |     |       // Since '(2 ** 254) * (a - b) - (a + b) * (a + b - 1)' is a
 332 |     |       // decreasing function with respect to 'x', it suffices to verify
 333 |     |       // that '(2 ** 254) * (a - b) - (a + b) * (a + b - 1) < 0' only for
 334 |     |       // 'x == 1' which is true. Hence, the requirement of 'cheapMulDiv' is
 335 |     |       // satisfied.
 336 | *   |       a = FullMathLibrary.cheapMulDiv(a - b, 1 << 254, a + b) << 2;
 337 |     | 
 338 |     |       // Next, we compute 'f(f(f(f(f(f(f(f(f(f(f(f(f(f(a))))))))))))))'
 339 |     |       // where 'f(y) = (y ** 2) / (2 ** 256 - 1) ~ (y ** 2) / (2 ** 256)'
 340 |     |       // This is because of the '2 ** 14' term which was discussed before.
 341 |     |       assembly {
 342 | *   |         a := sub(
 343 | *   |           mulmod(a, a, not(0)), // s := a * a - q * not(0)
 344 | *   |           mul(a, a) // r := a * a
 345 |     |         ) // s - r == - q * not(0) == q
 346 | *   |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 347 | *   |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 348 | *   |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 349 | *   |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 350 | *   |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 351 | *   |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 352 | *   |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 353 | *   |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 354 | *   |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 355 | *   |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 356 | *   |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 357 | *   |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 358 | *   |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 359 |     |       }
 360 |     | 
 361 | *   |       return a;
 362 |     |     }
 363 |     |   }
 364 |     | 
 365 |     |   /// @notice Transforms natural logarithm of price to square root of price.
 366 |     |   /// @param value The input whose exponential to be calculated.
 367 |     |   /// @return exponentialInverse is '(2 ** 216) * exp(- x / (2 ** 60))'
 368 |     |   /// @return exponentialOverExp16 is '(2 ** 216) * exp(- 16 + x / (2 ** 60))'
 369 |     |   /// Input should be greater than 0 and less than (2 ** 64).
 370 | *   |   function exp(
 371 |     |     X59 value
 372 |     |   ) internal pure returns (
 373 | *   |     X216 exponentialInverse,
 374 | *   |     X216 exponentialOverExp16
 375 | *   |   ) {
 376 |     |     // The requirements of 'expInverse' are the same as the requirements here.
 377 | *   |     uint256 a = expInverse(value);
 378 |     | 
 379 |     |     // Since '0 < value < 2 ** 64', we have
 380 |     |     // '(2 ** 256) * exp(-16) < a < (2 ** 256)', hence
 381 |     |     // '(2 ** 472) * exp(-16) < a * (a - 1)' and the requirements of
 382 |     |     // 'cheapMulDiv' are satisfied.
 383 |     |     //
 384 |     |     // Casting to 'int256' is safe because the output of 'cheapMulDiv' is
 385 |     |     // non-negative and it is less than 'oneX216'.
 386 |     |     //
 387 |     |     // So, we can calculate '(2 ** 472) * exp(-16) / a' as follows:
 388 | *   |     exponentialOverExp16 = X216.wrap(int256(FullMathLibrary.cheapMulDiv(
 389 |     |       // (2 ** 279) * exp(-16)
 390 | *   |       0xF1AADDD7742E56D32FB9F997447D9E6314DB84884FABAB26BF059AF9BC20B609,
 391 | *   |       1 << 193,
 392 | *   |       a
 393 |     |     )));
 394 |     | 
 395 |     |     // Casting to 'int256' is safe because 'a >> 40' is non-negative and it is
 396 |     |     // less than 'oneX216'.
 397 | *   |     exponentialInverse = X216.wrap(int256(a >> 40));
 398 |     |   }
 399 |     | 
 400 |     |   /// @notice Transforms natural logarithm of price to square root of price.
 401 |     |   /// "Pade Approximant" is employed for this purpose:
 402 |     |   /// 'exp(- x / (2 ** 60)) ~= ((u(x) - v(x)) / (u(x) + v(x))) ** (2 ** 48)'
 403 |     |   /// where
 404 |     |   ///              x ** 2
 405 |     |   /// 'u(x) = 1 + --------'
 406 |     |   ///              3<<218
 407 |     |   /// and
 408 |     |   ///             x
 409 |     |   /// 'v(x) = --------'.
 410 |     |   ///          1<<109
 411 |     |   ///
 412 |     |   /// This formula can be reproduced via the following Mathematica command:
 413 |     |   /// 'PadeApproximant[Exp[- x / (2 ^ 108)], {x, 0, 2}]'.
 414 |     |   ///
 415 |     |   /// @param value The input whose exponential to be calculated.
 416 |     |   /// @return exponentialInverse is '(2 ** 256) * exp(- x / (2 ** 60))'
 417 |     |   /// Input should be positive and less than '2 * maxLogOffset'.
 418 |     |   function expOffset(
 419 |     |     X59 value
 420 |     |   ) internal pure returns (
 421 |     |     uint256 exponentialInverse
 422 |     |   ) {
 423 |     |     unchecked {
 424 |     |       // Casting is safe because 'value' is between '0' and '2 ** 64'.
 425 |     |       uint256 x = uint256(X59.unwrap(value));
 426 |     | 
 427 |     |       // (2 ** 255) * u(x)
 428 |     |       // The multiplication and addition are safe because 'x < 2 ** 64'.
 429 |     |       uint256 a = (((x * x) << 37) / 3) + (1 << 255);
 430 |     | 
 431 |     |       // (2 ** 255) * v(x)
 432 |     |       // The shift is safe because 'x < 2 ** 64'.
 433 |     |       x <<= 146;
 434 |     | 
 435 |     |       // The requirements of 'cheapMulDiv' are satisfied because
 436 |     |       // (a - x) * (2 ** 254) - (a + x) (a + x - 1) is a decreasing function
 437 |     |       // with respect to 'x'. Hence, we just need to verify that it is negative
 438 |     |       // for 'x == 1' which is true.
 439 |     |       a = FullMathLibrary.cheapMulDiv(a - x, 1 << 254, a + x) << 2;
 440 |     | 
 441 |     |       // Next, we apply the function 
 442 |     |       // 'f(y) = (y ** 2) / (2 ** 256 - 1) ~ (y ** 2) / (2 ** 256)', 48 times.
 443 |     |       // This is because of the '2 ** 48' term which was discussed before.
 444 |     |       assembly {
 445 |     |         a := sub(
 446 |     |           mulmod(a, a, not(0)), // s := a * a - q * not(0)
 447 |     |           mul(a, a) // r := a * a
 448 |     |         ) // s - r == - q * not(0) == q
 449 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 450 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 451 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 452 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 453 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 454 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 455 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 456 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 457 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 458 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 459 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 460 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 461 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 462 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 463 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 464 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 465 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 466 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 467 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 468 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 469 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 470 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 471 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 472 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 473 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 474 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 475 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 476 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 477 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 478 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 479 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 480 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 481 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 482 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 483 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 484 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 485 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 486 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 487 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 488 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 489 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 490 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 491 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 492 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 493 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 494 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 495 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 496 |     |       }
 497 |     | 
 498 |     |       return a;
 499 |     |     }
 500 |     |   }
 501 |     | 
 502 |     |   /// @notice Transforms natural logarithm of price in two's complement to
 503 |     |   /// square root of price.
 504 |     |   /// Input should be between 'minLogOffset' and 'maxLogOffset'.
 505 |     |   /// @param logOffset The input whose exponential to be calculated.
 506 |     |   /// @return sqrtOffset is '(2 ** 127) * exp(logOffset / (2 ** 60))'
 507 |     |   function logToSqrtOffset(
 508 |     |     X59 logOffset
 509 |     |   ) internal pure returns (
 510 |     |     X127 sqrtOffset
 511 |     |   ) {
 512 |     |     // '(2 ** 256) * exp(- (maxLogOffset - logOffset) / (2 ** 60))'
 513 |     |     // The requirements of 'expOffset' are satisfied here because:
 514 |     |     // 'minLogOffset < logOffset < maxLogOffset'
 515 |     |     // '0 < maxLogOffset - logOffset < 
 516 |     |     //      maxLogOffset - minLogOffset == 2 * maxLogOffset'.
 517 |     |     uint256 exponential = (maxLogOffset - logOffset).expOffset();
 518 |     |     // (2 ** (256 + 191)) * exp(- (maxLogOffset - logOffset) / (2 ** 60)) / 
 519 |     |     // ((2 ** 320) * exp(-45))
 520 |     |     assembly {
 521 |     |       // Let 's := exponential * (2 ** 191) - (2 ** 256) * p'
 522 |     |       // Let 'r := exponential * (2 ** 191) - floor((2 ** 320) * exp(-45)) * q'
 523 |     |       // Then 's - r == floor((2 ** 320) * exp(-45)) * q' [modulo '2 ** 256']
 524 |     |       sqrtOffset := mul(
 525 |     |         // s - r
 526 |     |         sub(
 527 |     |           // s
 528 |     |           mul(exponential, shl(191, 1)), // Because '256 + 191 - 320 == 127'
 529 |     |           // r
 530 |     |           mulmod(
 531 |     |             exponential,
 532 |     |             shl(191, 1),
 533 |     |             // floor((2 ** 320) * exp(-45))
 534 |     |             0x872DB9E8FFA9E7D41F2AAF39897B91E4002E70FCEED391471FAD73D51503772D
 535 |     |           )
 536 |     |         ),
 537 |     |         // modularInverse(floor((2 ** 320) * exp(-45)), 2 ** 256)
 538 |     |         0xCF8E41E6C4D4AA5E9CC597C10CD32EACD30C44F750A8FFDB1A8863DD8F72F0A5
 539 |     |       )
 540 |     |     }
 541 |     |   }
 542 |     | }

/home/training/contracts/utilities/X74.sol
  1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
  2 |     | pragma solidity ^0.8.28;
  3 |     | 
  4 |     | import {X216} from "./X216.sol";
  5 |     | 
  6 |     | // Type 'X74' is used as an intermediate type when searching for precise log
  7 |     | // price movement corresponding to the specified outgoing/incoming token 
  8 |     | // amounts.
  9 |     | type X74 is int256;
 10 |     | 
 11 |     | X74 constant zeroX74 = X74.wrap(0);
 12 |     | 
 13 |     | using {equals as ==, notEqual as !=} for X74 global;
 14 |     | using {add as +, sub as -} for X74 global;
 15 |     | 
 16 |     | using X74Library for X74 global;
 17 |     | 
 18 |     | function equals(
 19 |     |   X74 value0,
 20 |     |   X74 value1
 21 |     | ) pure returns (
 22 |     |   bool result
 23 |     | ) {
 24 |     |   assembly {
 25 |     |     result := eq(value0, value1)
 26 |     |   }
 27 |     | }
 28 |     | 
 29 |     | function notEqual(
 30 |     |   X74 value0,
 31 |     |   X74 value1
 32 |     | ) pure returns (
 33 |     |   bool result
 34 |     | ) {
 35 |     |   return !(value0 == value1);
 36 |     | }
 37 |     | 
 38 |     | // Overflow/underflow should be avoided externally.
 39 |     | function add(
 40 |     |   X74 value0,
 41 |     |   X74 value1
 42 |     | ) pure returns (
 43 |     |   X74 result
 44 |     | ) {
 45 |     |   assembly {
 46 |     |     result := add(value0, value1)
 47 |     |   }
 48 |     | }
 49 |     | 
 50 |     | // Overflow/underflow should be avoided externally.
 51 |     | function sub(
 52 |     |   X74 value0,
 53 |     |   X74 value1
 54 |     | ) pure returns (
 55 |     |   X74 result
 56 |     | ) {
 57 |     |   assembly {
 58 |     |     result := sub(value0, value1)
 59 |     |   }
 60 |     | }
 61 |     | 
 62 |     | library X74Library {
 63 |     |   // Converts type 'X74' to 'X216'.
 64 |     |   // Overflow should be avoided externally.
 65 |     |   function toX216(
 66 |     |     X74 value
 67 |     |   ) internal pure returns (
 68 |     |     X216 result
 69 |     |   ) {
 70 |     |     assembly {
 71 |     |       // Multiplication is safe because overflow is avoided externally.
 72 |     |       result := mul(shl(142, 1), value)
 73 |     |     }
 74 |     |   }
 75 |     | }

/home/training/echidna/FuzzUtilities.sol
    1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
    2 |     | pragma solidity ^0.8.28;
    3 |     | 
    4 |     | import {
    5 |     |   _begin_,
    6 |     |   _target_,
    7 |     |   _total0_,
    8 |     |   _total1_,
    9 |     |   _currentToTarget_,
   10 |     |   _incomingCurrentToTarget_,
   11 |     |   _overshoot_,
   12 |     |   _end_,
   13 |     |   _forward1_,
   14 |     |   _current_,
   15 |     |   _currentToOvershoot_,
   16 |     |   _endOfStaticParams_,
   17 |     |   _pointers_,
   18 |     |   setIntegral0,
   19 |     |   setIntegral1,
   20 |     |   getZeroForOne,
   21 |     |   getIntegralLimit,
   22 |     |   setZeroForOne,
   23 |     |   setIntegralLimit,
   24 |     |   getCurve,
   25 |     |   getCurveLength,
   26 |     |   setCurve,
   27 |     |   setCurveLength,
   28 |     |   getKernel,
   29 |     |   getKernelLength,
   30 |     |   setKernel,
   31 |     |   setKernelLength,
   32 |     |   setFreeMemoryPointer,
   33 |     |   getLogPriceLimitOffsetted,
   34 |     |   setLogPriceLimitOffsetted,
   35 |     |   getLogPriceLimitOffsettedWithinInterval
   36 |     | } from "../contracts/utilities/Memory.sol";
   37 |     | import {X15, zeroX15, oneX15} from "../contracts/utilities/X15.sol";
   38 |     | import {
   39 |     |   X59,
   40 |     |   epsilonX59,
   41 |     |   twoX59,
   42 |     |   thirtyTwoX59,
   43 |     |   min,
   44 |     |   max,
   45 |     |   minLogStep,
   46 |     |   minLogSpacing
   47 |     | } from "../contracts/utilities/X59.sol";
   48 |     | import {
   49 |     |   X216,
   50 |     |   zeroX216,
   51 |     |   epsilonX216,
   52 |     |   oneX216,
   53 |     |   expInverse8X216,
   54 |     |   min,
   55 |     |   max
   56 |     | } from "../contracts/utilities/X216.sol";
   57 |     | import {
   58 |     |   IntegralLibrary,
   59 |     |   EXP_INV_8_X240
   60 |     | } from "../contracts/utilities/Integral.sol";
   61 |     | import {FullMathLibrary} from "../contracts/utilities/FullMath.sol";
   62 |     | import {PriceLibrary} from "../contracts/utilities/Price.sol";
   63 |     | import {
   64 |     |   initiateInterval,
   65 |     |   searchOutgoingTarget,
   66 |     |   searchIncomingTarget,
   67 |     |   moveOvershootByEpsilon,
   68 |     |   newIntegrals,
   69 |     |   searchOvershoot,
   70 |     |   moveTarget,
   71 |     |   moveOvershoot
   72 |     | } from "../contracts/utilities/Interval.sol";
   73 |     | import {
   74 |     |   Index,
   75 |     |   zeroIndex,
   76 |     |   oneIndex,
   77 |     |   twoIndex
   78 |     | } from "../contracts/utilities/Index.sol";
   79 |     | import {Curve} from "../contracts/utilities/Curve.sol";
   80 |     | import {Kernel} from "../contracts/utilities/Kernel.sol";
   81 |     | 
   82 |     | using PriceLibrary for uint256;
   83 |     | 
   84 |     | /// @notice Reserves 27 bytes in memory for an integral and returns the
   85 |     | /// corresponding memory pointer.
   86 | *   | function get_an_integral_pointer() pure returns (uint256 pointer) {
   87 |     |   assembly {
   88 | *   |     pointer := mload(0x40)
   89 | *   |     mstore(0x40, add(pointer, 27))
   90 |     |   }
   91 |     | }
   92 |     | 
   93 |     | /// @notice Reserves 64 bytes in memory for a price as outlined in 'price.sol'
   94 |     | /// and returns the corresponding memory pointer.
   95 |     | ///
   96 |     | ///   pointer
   97 |     | ///      |
   98 |     | ///   +--+--------+---------------------------+---------------------------+
   99 |     | ///   |  | 8 byte |          27 byte          |          27 byte          |
  100 |     | ///   +--+--------+---------------------------+---------------------------+
  101 |     | ///   |  |        |                           |
  102 |     | ///   |  |        |                            \
  103 |     | ///   |  |        |                             sqrtInversePrice
  104 |     | ///   |  |         \
  105 |     | ///   |  |          sqrtPrice
  106 |     | ///   |   \
  107 |     | ///   |    logPrice
  108 |     | ///    \
  109 |     | ///     heightPrice
  110 |     | ///
  111 | *   | function get_a_price_pointer() pure returns (uint256 pointer) {
  112 |     |   assembly {
  113 | *   |     pointer := add(mload(0x40), 2)
  114 | *   |     mstore(0x40, add(pointer, 62))
  115 |     |   }
  116 |     | }
  117 |     | 
  118 |     | /// @notice Reserves 128 bytes in memory for two consecutive prices as outlined
  119 |     | /// in 'price.sol' and returns the memory pointer associated with the first
  120 |     | /// one.
  121 | *   | function get_a_segment_pointer() pure returns (uint256 pointer) {
  122 |     |   assembly {
  123 | *   |     pointer := add(mload(0x40), 2)
  124 | *   |     mstore(0x40, add(pointer, 126))
  125 |     |   }
  126 |     | }
  127 |     | 
  128 |     | /// @notice Transforms the given random 'seed' into an integral of type 'X216'.
  129 | *   | function get_an_integral(uint216 seed) pure returns (X216) {
  130 | *   |   return X216.wrap(int256(uint256(seed)));
  131 |     | }
  132 |     | 
  133 |     | /// @notice Transforms the given random 'seed' into an 'X15' value which may
  134 |     | /// not exceed 'oneX15'.
  135 | *   | function get_a_height(uint16 seed) pure returns (X15) {
  136 | *   |   return X15.wrap(seed % ((2 ** 15) + 1));
  137 |     | }
  138 |     | 
  139 |     | /// @notice Transforms the given random 'seed' into an 'X15' value which
  140 |     | /// satisfies:
  141 |     | ///
  142 |     | ///   'min(height0, height1) <= value <= min(height0, height1)'
  143 |     | ///
  144 |     | function get_a_height_in_between(
  145 |     |   uint16 seed,
  146 |     |   X15 height0,
  147 |     |   X15 height1
  148 |     | ) pure returns (X15) {
  149 |     |   X15 _min = height0 < height1 ? height0 : height1;
  150 |     |   X15 _max = height0 < height1 ? height1 : height0;
  151 |     |   return _min + X15.wrap(seed % (X15.unwrap(_max - _min) + 1));
  152 |     | }
  153 |     | 
  154 |     | /// @notice Transforms the given random 'seed' into an 'X59' value which may
  155 |     | /// not exceed 'thirtyTwoX59 - epsilonX59'.
  156 |     | function get_a_logPrice(uint64 seed) pure returns (X59) {
  157 |     |   return X59.wrap(int256(uint256(1 + (seed % ((2 ** 64) - 1)))));
  158 |     | }
  159 |     | 
  160 |     | /// @notice Transforms the given random 'seed' into an 'X59' value which
  161 |     | /// satisfies:
  162 |     | ///
  163 |     | ///   'min(logPrice0, logPrice1) <= value <= min(logPrice0, logPrice1)'
  164 |     | ///
  165 | *   | function get_a_logPrice_in_between(
  166 |     |   uint64 seed,
  167 |     |   X59 logPrice0,
  168 |     |   X59 logPrice1
  169 | *   | ) pure returns (X59) {
  170 | *   |   X59 _min = min(logPrice0, logPrice1);
  171 | *   |   X59 _max = max(logPrice0, logPrice1);
  172 | *   |   return _min + X59.wrap(
  173 | *   |     int256(uint256(seed) % uint256(X59.unwrap(_max - _min + epsilonX59)))
  174 |     |   );
  175 |     | }
  176 |     | 
  177 |     | /// @notice A reference for the function 'evaluate' in 'Integral.sol'.
  178 |     | /// Calculates:
  179 |     | ///
  180 |     | ///                                      c1 - c0
  181 |     | ///  (2 ** 201) * (exp(-8) / 2) * (c0 + --------- (q - b0))
  182 |     | ///                                      b1 - b0
  183 |     | ///
  184 | *   | function evaluate_reference(
  185 |     |   X15 c0,
  186 |     |   X15 c1,
  187 |     |   X59 b0,
  188 |     |   X59 b1,
  189 |     |   X59 q
  190 | *   | ) pure returns (X216) {
  191 | *   |   if (b0 < b1) {
  192 | *   |     return X216.wrap(
  193 | *   |       int256(
  194 | *   |         FullMathLibrary.mulDiv(
  195 |     |           EXP_INV_8_X240,
  196 | *   |           X15.unwrap(c0) * uint256(X59.unwrap(b1 - b0)) + 
  197 | *   |             X15.unwrap(c1 - c0) * uint256(X59.unwrap(q - b0)),
  198 | *   |           uint256(X59.unwrap(b1 - b0))
  199 |     |         )
  200 | *   |       ) >> 40
  201 |     |     );
  202 |     |   } else {
  203 | *   |     return X216.wrap(
  204 | *   |       int256(
  205 | *   |         FullMathLibrary.mulDiv(
  206 |     |           EXP_INV_8_X240,
  207 | *   |           X15.unwrap(c0) * uint256(X59.unwrap(b0 - b1)) + 
  208 | *   |             X15.unwrap(c1 - c0) * uint256(X59.unwrap(b0 - q)),
  209 | *   |           uint256(X59.unwrap(b0 - b1))
  210 |     |         )
  211 | *   |       ) >> 40
  212 |     |     );
  213 |     |   }
  214 |     | }
  215 |     | 
  216 |     | /// @notice A reference for the function 'outgoing' in 'Integral.sol'.
  217 |     | /// Define:
  218 |     | ///
  219 |     | ///               from.log()                          to.log()
  220 |     | ///  f := - 16 + ------------    and    t := - 16 + ------------
  221 |     | ///                2 ** 59                            2 ** 59
  222 |     | ///
  223 |     | /// If 'f < t' this function calculates:
  224 |     | ///
  225 |     | ///                                / t
  226 |     | ///                               |     -h/2         c1 - c0
  227 |     | ///  (2 ** 201) * (exp(-8) / 2) * |    e      (c0 + --------- (h - b0)) dh
  228 |     | ///                               |                  b1 - b0
  229 |     | ///                              / f
  230 |     | ///
  231 |     | /// If 't < f' this function calculates:
  232 |     | ///
  233 |     | ///                                / f
  234 |     | ///                               |     +h/2         c1 - c0
  235 |     | ///  (2 ** 201) * (exp(-8) / 2) * |    e      (c0 + --------- (b0 - h)) dh
  236 |     | ///                               |                  b0 - b1
  237 |     | ///                              / t
  238 |     | ///
  239 | *   | function outgoing_reference(
  240 |     |   X15 c0,
  241 |     |   X15 c1,
  242 |     |   X59 b0,
  243 |     |   X59 b1,
  244 |     |   X59 logFrom,
  245 |     |   X59 logTo
  246 | *   | ) pure returns (X216) {
  247 | *   |   uint256 result;
  248 | *   |   if (b0 != b1) {
  249 |     |     unchecked {
  250 | *   |       if (logFrom < logTo) {
  251 | *   |         (X216 sqrtFrom, ) = logFrom.exp();
  252 | *   |         (X216 sqrtTo, ) = logTo.exp();
  253 | *   |         result = X15.unwrap(c0) * uint256(X216.unwrap(sqrtFrom - sqrtTo));
  254 | *   |         result += FullMathLibrary.mulDiv(
  255 | *   |           uint256(X216.unwrap(sqrtFrom)),
  256 | *   |           X15.unwrap(c1 - c0) * uint256(X59.unwrap(logFrom - b0 + twoX59)),
  257 | *   |           uint256(X59.unwrap(b1 - b0))
  258 |     |         );
  259 | *   |         result -= FullMathLibrary.mulDiv(
  260 | *   |           uint256(X216.unwrap(sqrtTo)),
  261 | *   |           X15.unwrap(c1 - c0) * uint256(X59.unwrap(logTo - b0 + twoX59)),
  262 | *   |           uint256(X59.unwrap(b1 - b0))
  263 |     |         );
  264 | *   |       } else {
  265 | *   |         (, X216 sqrtInverseFrom) = logFrom.exp();
  266 | *   |         (, X216 sqrtInverseTo) = logTo.exp();
  267 | *   |         result = X15.unwrap(c0) * uint256(
  268 | *   |           X216.unwrap(sqrtInverseFrom - sqrtInverseTo)
  269 |     |         );
  270 | *   |         result += FullMathLibrary.mulDiv(
  271 | *   |           uint256(X216.unwrap(sqrtInverseFrom)),
  272 | *   |           X15.unwrap(c1 - c0) * uint256(X59.unwrap(b0 - logFrom + twoX59)),
  273 | *   |           uint256(X59.unwrap(b0 - b1))
  274 |     |         );
  275 | *   |         result -= FullMathLibrary.mulDiv(
  276 | *   |           uint256(X216.unwrap(sqrtInverseTo)),
  277 | *   |           X15.unwrap(c1 - c0) * uint256(X59.unwrap(b0 - logTo + twoX59)),
  278 | *   |           uint256(X59.unwrap(b0 - b1))
  279 |     |         );
  280 |     |       }
  281 |     |     }
  282 |     |   }
  283 | *   |   return X216.wrap(int256(result >> 15));
  284 |     | }
  285 |     | 
  286 |     | /// @notice A reference for the function 'incoming' in 'Integral.sol'.
  287 |     | /// Define:
  288 |     | ///
  289 |     | ///               from.log()                          to.log()
  290 |     | ///  f := - 16 + ------------    and    t := - 16 + ------------
  291 |     | ///                2 ** 59                            2 ** 59
  292 |     | ///
  293 |     | /// If 'f < t' this function calculates:
  294 |     | ///
  295 |     | ///                                / t
  296 |     | ///                               |     +h/2         c1 - c0
  297 |     | ///  (2 ** 201) * (exp(-8) / 2) * |    e      (c0 + --------- (h - b0)) dh
  298 |     | ///                               |                  b1 - b0
  299 |     | ///                              / f
  300 |     | ///
  301 |     | /// If 't < f' this function calculates:
  302 |     | ///
  303 |     | ///                                / f
  304 |     | ///                               |     -h/2         c1 - c0
  305 |     | ///  (2 ** 201) * (exp(-8) / 2) * |    e      (c0 + --------- (b0 - h)) dh
  306 |     | ///                               |                  b0 - b1
  307 |     | ///                              / t
  308 |     | ///
  309 | *   | function incoming_reference(
  310 |     |   X15 c0,
  311 |     |   X15 c1,
  312 |     |   X59 b0,
  313 |     |   X59 b1,
  314 |     |   X59 logFrom,
  315 |     |   X59 logTo
  316 | *   | ) pure returns (X216) {
  317 | *   |   uint256 result;
  318 | *   |   if (b0 != b1) {
  319 |     |     unchecked {
  320 | *   |       if (logFrom < logTo) {
  321 | *   |         (, X216 sqrtInverseFrom) = logFrom.exp();
  322 | *   |         (, X216 sqrtInverseTo) = logTo.exp();
  323 | *   |         result = X15.unwrap(c1) * uint256(
  324 | *   |           X216.unwrap(sqrtInverseTo - sqrtInverseFrom)
  325 |     |         );
  326 | *   |         result += FullMathLibrary.mulDiv(
  327 | *   |           uint256(X216.unwrap(sqrtInverseFrom)),
  328 | *   |           X15.unwrap(c1 - c0) * uint256(X59.unwrap(b1 - logFrom + twoX59)),
  329 | *   |           uint256(X59.unwrap(b1 - b0))
  330 |     |         );
  331 | *   |         result -= FullMathLibrary.mulDiv(
  332 | *   |           uint256(X216.unwrap(sqrtInverseTo)),
  333 | *   |           X15.unwrap(c1 - c0) * uint256(X59.unwrap(b1 - logTo + twoX59)),
  334 | *   |           uint256(X59.unwrap(b1 - b0))
  335 |     |         );
  336 | *   |       } else {
  337 | *   |         (X216 sqrtFrom, ) = logFrom.exp();
  338 | *   |         (X216 sqrtTo, ) = logTo.exp();
  339 | *   |         result = X15.unwrap(c1) * uint256(X216.unwrap(sqrtTo - sqrtFrom));
  340 | *   |         result += FullMathLibrary.mulDiv(
  341 | *   |           uint256(X216.unwrap(sqrtFrom)),
  342 | *   |           X15.unwrap(c1 - c0) * uint256(X59.unwrap(logFrom - b1 + twoX59)),
  343 | *   |           uint256(X59.unwrap(b0 - b1))
  344 |     |         );
  345 | *   |         result -= FullMathLibrary.mulDiv(
  346 | *   |           uint256(X216.unwrap(sqrtTo)),
  347 | *   |           X15.unwrap(c1 - c0) * uint256(X59.unwrap(logTo - b1 + twoX59)),
  348 | *   |           uint256(X59.unwrap(b0 - b1))
  349 |     |         );
  350 |     |       }
  351 |     |     }
  352 |     |   }
  353 | *   |   return X216.wrap(int256(result >> 15));
  354 |     | }
  355 |     | 
  356 |     | /// @notice A reference for the function 'shift' in 'Integral.sol'.
  357 |     | /// Calculates:
  358 |     | ///
  359 |     | ///  sqrt0 * sqrt1 * integral
  360 |     | /// --------------------------
  361 |     | ///   (2 ** 432) * exp(-16)
  362 |     | ///
  363 | *   | function shift_reference(
  364 |     |   X216 integral,
  365 |     |   X216 sqrt0,
  366 |     |   X216 sqrt1
  367 | *   | ) pure returns (X216) {
  368 | *   |   return X216.wrap(
  369 | *   |     int256(FullMathLibrary.mulDiv(
  370 | *   |       uint256(X216.unwrap(integral)),
  371 | *   |       FullMathLibrary.mulDiv(
  372 | *   |         uint256(X216.unwrap(sqrt0)) << 20,
  373 | *   |         uint256(X216.unwrap(sqrt1)) << 20,
  374 | *   |         2 ** 216
  375 |     |       ),
  376 | *   |       0x1e355bbaee85cada65f73f32e88fb3cc629b709109f57564d7e0b35f378
  377 |     |     ))
  378 |     |   );
  379 |     | }
  380 |     | 
  381 |     | /// @notice Returns true if and only if:
  382 |     | ///
  383 |     | ///   |a - b| <= err
  384 |     | ///
  385 | *   | function approximatelyEqual(
  386 |     |   X216 a,
  387 |     |   X216 b,
  388 |     |   uint256 err
  389 | *   | ) pure returns (bool) {
  390 | *   |   (a, b) = (a > b) ? (a, b) : (b, a);
  391 | *   |   return uint256(X216.unwrap(a - b)) <= err;
  392 |     | }
  393 |     | 
  394 |     | /// @notice Produces a pseudorandom transient slot by hashing the content of
  395 |     | /// slot0. The resulting transient slot is then returned and also stored on
  396 |     | /// slot0 to be used as a future seed. 
  397 |     | function get_a_transient_pointer() returns (
  398 |     |   uint256 pointer
  399 |     | ) {
  400 |     |   assembly {
  401 |     |     mstore(0, tload(0))
  402 |     |     pointer := keccak256(0, 32)
  403 |     |     tstore(0, pointer)
  404 |     |   }
  405 |     | }
  406 |     | 
  407 |     | /// @notice Writes an X59 value on transient.
  408 |     | function store_logPrice(uint256 pointer, X59 logPrice) {
  409 |     |   assembly {
  410 |     |     tstore(pointer, logPrice)
  411 |     |   }
  412 |     | }
  413 |     | 
  414 |     | /// @notice Writes an X59 value on transient.
  415 |     | function load_logPrice(
  416 |     |   uint256 pointer
  417 |     | ) view returns (X59 logPrice) {
  418 |     |   assembly {
  419 |     |     logPrice := tload(pointer)
  420 |     |   }
  421 |     | }
  422 |     | 
  423 |     | /// @notice Writes an X15 value on transient.
  424 |     | function store_height(uint256 pointer, X15 height) {
  425 |     |   assembly {
  426 |     |     tstore(pointer, height)
  427 |     |   }
  428 |     | }
  429 |     | 
  430 |     | /// @notice Reads an X15 value on transient.
  431 |     | function load_height(
  432 |     |   uint256 pointer
  433 |     | ) view returns (X15 height) {
  434 |     |   assembly {
  435 |     |     height := tload(pointer)
  436 |     |   }
  437 |     | }
  438 |     | 
  439 |     | /// @notice These two functions will be used to created a sorted sequence of
  440 |     | /// values. A value is stored at 'pointer' and 'pointer + 1' points to the next
  441 |     | /// value.
  442 |     | function store_next(
  443 |     |   uint256 pointer,
  444 |     |   uint256 nextPointer
  445 |     | ) {
  446 |     |   assembly {
  447 |     |     sstore(add(pointer, 1), nextPointer)
  448 |     |   }
  449 |     | }
  450 |     | function load_next(
  451 |     |   uint256 pointer
  452 |     | ) view returns (
  453 |     |   uint256 nextPointer
  454 |     | ) {
  455 |     |   assembly {
  456 |     |     nextPointer := sload(add(pointer, 1))
  457 |     |   }
  458 |     | }
  459 |     | 
  460 |     | /// @notice Sets a new memeber for the current kernel set in memory.
  461 |     | function set_breakPoint(
  462 |     |   Index ii,
  463 |     |   X59 iLog,
  464 |     |   X15 iHeight
  465 |     | ) pure {
  466 |     |   uint256 pointer;
  467 |     |   Kernel kernel = getKernel();
  468 |     |   assembly {
  469 |     |     pointer := add(sub(kernel, 62), mul(ii, 64))
  470 |     |   }
  471 |     |   (X216 iSqrt, X216 iSqrtInverse) = iLog.exp();
  472 |     |   pointer.storePrice(iHeight, iLog, iSqrt, iSqrtInverse);
  473 |     | }
  474 |     | 
  475 |     | /// @notice This contract generates a random curve and a random kernel given
  476 |     | /// the given seeds and sets them in memory.
  477 |     | contract KernelAndCurveFactory {
  478 |     |   uint256 immutable kernelLimit;
  479 |     |   uint256 immutable curveLimit;
  480 |     | 
  481 |     |   constructor(uint256 _kernelLimit, uint256 _curveLimit) {
  482 |     |     kernelLimit = _kernelLimit;
  483 |     |     curveLimit = _curveLimit;
  484 |     |   }
  485 |     | 
  486 |     |   function kernelLengthLimit(
  487 |     |     uint256 length
  488 |     |   ) private returns (
  489 |     |     uint256 limitedLength
  490 |     |   ) {
  491 |     |     if (length > kernelLimit) {
  492 |     |       limitedLength = kernelLimit;
  493 |     |     } else {
  494 |     |       limitedLength = length;
  495 |     |     }
  496 |     |   }
  497 |     | 
  498 |     |   function curveLengthLimit(
  499 |     |     uint256 length
  500 |     |   ) private returns (
  501 |     |     uint256 limitedLength
  502 |     |   ) {
  503 |     |     if (length > curveLimit) {
  504 |     |       limitedLength = curveLimit;
  505 |     |     } else {
  506 |     |       limitedLength = length;
  507 |     |     }
  508 |     |   }
  509 |     | 
  510 |     |   /// @notice Generates a random curve and a random kernel based on the given
  511 |     |   /// seeds and gives them as returndata.
  512 |     |   function buildAndIntegrate(
  513 |     |     bool[3] calldata seed_base,
  514 |     |     uint64[3] calldata seed_boundaries,
  515 |     |     uint88[] calldata seed_kernel,
  516 |     |     uint64[] calldata seed_curve
  517 |     |   ) external {
  518 |     |     // In this case, the spacing is determined based on the given seeds.
  519 |     |     _build(
  520 |     |       get_a_logPrice_in_between(
  521 |     |         seed_boundaries[0],
  522 |     |         minLogSpacing,
  523 |     |         X59.wrap(6148914691236517204)
  524 |     |       ),
  525 |     |       seed_base,
  526 |     |       seed_boundaries,
  527 |     |       seed_kernel,
  528 |     |       seed_curve
  529 |     |     );
  530 |     |   }
  531 |     | 
  532 |     |   /// @notice Generates a random spacing, curve and kernel based on the given
  533 |     |   /// seeds and gives them as returndata.
  534 |     |   function buildWithSpacingAndIntegrate(
  535 |     |     X59 qSpacing,
  536 |     |     bool[3] calldata seed_base,
  537 |     |     uint64[3] calldata seed_boundaries,
  538 |     |     uint88[] calldata seed_kernel,
  539 |     |     uint64[] calldata seed_curve
  540 |     |   ) external {
  541 |     |     // In this case, the spacing is read from the storage contract.
  542 |     |     _build(qSpacing, seed_base, seed_boundaries, seed_kernel, seed_curve);
  543 |     |   }
  544 |     | 
  545 |     |   /// @notice This function creates a sorted chain of X59 values between
  546 |     |   /// 'zeroX59' and 'spacing' in storage. It is going to look like this:
  547 |     |   ///
  548 |     |   ///    +-----------------+--------------------------------+
  549 |     |   ///    |   logPrice[0]   | Storage pointer to logPrice[1] |
  550 |     |   ///    +-----------------+--------------------------------+
  551 |     |   ///
  552 |     |   ///    +-----------------+--------------------------------+
  553 |     |   ///    |   logPrice[1]   | Storage pointer to logPrice[2] |
  554 |     |   ///    +-----------------+--------------------------------+
  555 |     |   ///
  556 |     |   ///    +-----------------+--------------------------------+
  557 |     |   ///    |   logPrice[2]   | Storage pointer to logPrice[3] |
  558 |     |   ///    +-----------------+--------------------------------+
  559 |     |   ///    
  560 |     |   ///      .
  561 |     |   ///      .
  562 |     |   ///      .
  563 |     |   ///
  564 |     |   ///    +-----------------+--------------------------------+
  565 |     |   ///    | logPrice[n - 1] | Storage pointer to logPrice[n] |
  566 |     |   ///    +-----------------+--------------------------------+
  567 |     |   ///
  568 |     |   ///    +-----------------+
  569 |     |   ///    |   logPrice[n]   |
  570 |     |   ///    +-----------------+
  571 |     |   ///
  572 |     |   function _sortedX59(
  573 |     |     uint88[] calldata seed_kernel,
  574 |     |     uint64 seed,
  575 |     |     X59 qSpacing
  576 |     |   ) private returns (
  577 |     |     uint256 smallestPointer
  578 |     |   ) {
  579 |     |     smallestPointer = get_a_transient_pointer();
  580 |     |     store_logPrice(
  581 |     |       smallestPointer,
  582 |     |       get_a_logPrice_in_between(
  583 |     |         seed,
  584 |     |         epsilonX59,
  585 |     |         qSpacing - epsilonX59
  586 |     |       )
  587 |     |     );
  588 |     |     uint256 largestPointer = smallestPointer;
  589 |     | 
  590 |     |     for (uint256 ii = 0; ii < kernelLengthLimit(seed_kernel.length); ++ii) {
  591 |     |       X59 logPrice = get_a_logPrice_in_between(
  592 |     |         uint64(seed_kernel[ii]),
  593 |     |         epsilonX59,
  594 |     |         qSpacing - epsilonX59
  595 |     |       );
  596 |     |       uint256 pointer = get_a_transient_pointer();
  597 |     |       store_logPrice(pointer, logPrice);
  598 |     | 
  599 |     |       if (logPrice <= load_logPrice(smallestPointer)) {
  600 |     |         store_next(pointer, smallestPointer);
  601 |     |         smallestPointer = pointer;
  602 |     |       } else if (load_logPrice(largestPointer) < logPrice) {
  603 |     |         store_next(largestPointer, pointer);
  604 |     |         largestPointer = pointer;
  605 |     |       } else {
  606 |     |         uint256 pointer0 = smallestPointer;
  607 |     |         uint256 pointer1 = load_next(smallestPointer);
  608 |     |         while (
  609 |     |           logPrice < load_logPrice(pointer0)
  610 |     |            || 
  611 |     |           load_logPrice(pointer1) < logPrice
  612 |     |         ) {
  613 |     |           pointer0 = pointer1;
  614 |     |           pointer1 = load_next(pointer0);
  615 |     |         }
  616 |     |         store_next(pointer0, pointer);
  617 |     |         store_next(pointer, pointer1);
  618 |     |       }
  619 |     |     }
  620 |     |   }
  621 |     | 
  622 |     |   /// @notice This function creates a sorted chain of X15 values within
  623 |     |   /// '[zeroX15, oneX15 - 1]' in storage. It is going to look like this:
  624 |     |   ///
  625 |     |   ///    +-----------------+------------------------------+
  626 |     |   ///    |    height[0]    | Storage pointer to height[1] |
  627 |     |   ///    +-----------------+------------------------------+
  628 |     |   ///
  629 |     |   ///    +-----------------+------------------------------+
  630 |     |   ///    |    height[1]    | Storage pointer to height[2] |
  631 |     |   ///    +-----------------+------------------------------+
  632 |     |   ///
  633 |     |   ///    +-----------------+------------------------------+
  634 |     |   ///    |    height[2]    | Storage pointer to height[3] |
  635 |     |   ///    +-----------------+------------------------------+
  636 |     |   ///    
  637 |     |   ///      .
  638 |     |   ///      .
  639 |     |   ///      .
  640 |     |   ///
  641 |     |   ///    +-----------------+------------------------------+
  642 |     |   ///    |  height[n - 1]  | Storage pointer to height[n] |
  643 |     |   ///    +-----------------+------------------------------+
  644 |     |   ///
  645 |     |   ///    +-----------------+
  646 |     |   ///    |    height[n]    |
  647 |     |   ///    +-----------------+
  648 |     |   ///
  649 |     |   function _sortedX15(
  650 |     |     uint88[] calldata seed_kernel
  651 |     |   ) private returns (
  652 |     |     uint256 smallestPointer
  653 |     |   ) {
  654 |     |     smallestPointer = get_a_transient_pointer();
  655 |     |     store_height(smallestPointer, zeroX15);
  656 |     |     uint256 largestPointer = smallestPointer;
  657 |     | 
  658 |     |     for (uint256 ii = 0; ii < kernelLengthLimit(seed_kernel.length); ++ii) {
  659 |     |       X15 height = get_a_height_in_between(
  660 |     |         uint16(seed_kernel[ii] >> 64),
  661 |     |         X15.wrap(1),
  662 |     |         oneX15 - X15.wrap(1)
  663 |     |       );
  664 |     |       uint256 pointer = get_a_transient_pointer();
  665 |     |       store_height(pointer, height);
  666 |     | 
  667 |     |       if (height <= load_height(smallestPointer)) {
  668 |     |         store_next(pointer, smallestPointer);
  669 |     |         smallestPointer = pointer;
  670 |     |       } else if (load_height(largestPointer) < height) {
  671 |     |         store_next(largestPointer, pointer);
  672 |     |         largestPointer = pointer;
  673 |     |       } else {
  674 |     |         uint256 pointer0 = smallestPointer;
  675 |     |         uint256 pointer1 = load_next(smallestPointer);
  676 |     |         while (
  677 |     |           height < load_height(pointer0)
  678 |     |            || 
  679 |     |           load_height(pointer1) < height
  680 |     |         ) {
  681 |     |           pointer0 = pointer1;
  682 |     |           pointer1 = load_next(pointer0);
  683 |     |         }
  684 |     |         store_next(pointer0, pointer);
  685 |     |         store_next(pointer, pointer1);
  686 |     |       }
  687 |     |     }
  688 |     |   }
  689 |     | 
  690 |     |   /// @notice This function remove repetitions in the chain of breakpoints.
  691 |     |   function _pruneRepetition(
  692 |     |     uint256 initialLength,
  693 |     |     uint256 smallestPointerX59,
  694 |     |     uint256 smallestPointerX15
  695 |     |   ) private returns (
  696 |     |     uint256 length
  697 |     |   ) {
  698 |     |     length = initialLength;
  699 |     |     for (uint256 ii = 0; ii < initialLength; ++ii) {
  700 |     |       if (
  701 |     |         (
  702 |     |           load_logPrice(smallestPointerX59)
  703 |     |            == 
  704 |     |           load_logPrice(load_next(smallestPointerX59))
  705 |     |         ) || (
  706 |     |           load_height(smallestPointerX15)
  707 |     |            == 
  708 |     |           load_height(load_next(smallestPointerX15))
  709 |     |         )
  710 |     |       ) {
  711 |     |         store_next(
  712 |     |           smallestPointerX59,
  713 |     |           load_next(load_next(smallestPointerX59))
  714 |     |         );
  715 |     |         store_next(
  716 |     |           smallestPointerX15,
  717 |     |           load_next(load_next(smallestPointerX15))
  718 |     |         );
  719 |     |         --length;
  720 |     |       } else {
  721 |     |         smallestPointerX59 = load_next(smallestPointerX59);
  722 |     |         smallestPointerX15 = load_next(smallestPointerX15);
  723 |     |       }
  724 |     |     }
  725 |     |   }
  726 |     | 
  727 |     |   /// @notice This function builds a kernel and places it in memory.
  728 |     |   function _buildKernel(
  729 |     |     uint88[] calldata seed_kernel,
  730 |     |     X59 qSpacing,
  731 |     |     bool notSkip0,
  732 |     |     bool notSkip1,
  733 |     |     uint256 length,
  734 |     |     uint256 smallestPointerX59,
  735 |     |     uint256 smallestPointerX15
  736 |     |   ) private {
  737 |     |     // Repetitions are removed.
  738 |     |     length = _pruneRepetition(
  739 |     |       length,
  740 |     |       smallestPointerX59,
  741 |     |       smallestPointerX15
  742 |     |     );
  743 |     | 
  744 |     |     Kernel kernel;
  745 |     |     assembly {
  746 |     |       kernel := _endOfStaticParams_
  747 |     |     }
  748 |     |     setKernel(kernel);
  749 |     | 
  750 |     |     Index index = oneIndex;
  751 |     | 
  752 |     |     // In this case, we first add a breakpoint corresponding to the first X59
  753 |     |     // and X15.
  754 |     |     if (notSkip0 || load_logPrice(smallestPointerX59) <= minLogStep) {
  755 |     |       set_breakPoint(
  756 |     |         index,
  757 |     |         load_logPrice(smallestPointerX59),
  758 |     |         load_height(smallestPointerX15)
  759 |     |       );
  760 |     |       index = index + oneIndex;
  761 |     |     }
  762 |     | 
  763 |     |     if (length >= 1) {
  764 |     |       for (uint256 ii = 0; ii < length - 1; ++ii) {
  765 |     |         // The X15 is updated while the X59 remains the same.
  766 |     |         smallestPointerX15 = load_next(smallestPointerX15);
  767 |     | 
  768 |     |         // In this case, we add a vertical breakpoint.
  769 |     |         if (
  770 |     |           (
  771 |     |             (seed_kernel[ii] >> 80) % 2 == 0
  772 |     |           ) || (
  773 |     |             load_logPrice(load_next(smallestPointerX59))
  774 |     |              - 
  775 |     |             load_logPrice(smallestPointerX59) <= minLogStep
  776 |     |           )
  777 |     |         ) {
  778 |     |           set_breakPoint(
  779 |     |             index,
  780 |     |             load_logPrice(smallestPointerX59),
  781 |     |             load_height(smallestPointerX15)
  782 |     |           );
  783 |     |           index = index + oneIndex;
  784 |     |         }
  785 |     | 
  786 |     |         // In this case, if the previous 'if' condition is met, we add a
  787 |     |         // horizontal breakpoint. Otherwise, we add a ramp.
  788 |     |         if (
  789 |     |           (
  790 |     |             (seed_kernel[ii] >> 84) % 2 == 0
  791 |     |           ) || (
  792 |     |             load_logPrice(load_next(smallestPointerX59))
  793 |     |              - 
  794 |     |             load_logPrice(smallestPointerX59) <= minLogStep
  795 |     |           )
  796 |     |         ) {
  797 |     |           set_breakPoint(
  798 |     |             index,
  799 |     |             load_logPrice(load_next(smallestPointerX59)),
  800 |     |             load_height(smallestPointerX15)
  801 |     |           );
  802 |     |           index = index + oneIndex;
  803 |     |         }
  804 |     | 
  805 |     |         smallestPointerX59 = load_next(smallestPointerX59);
  806 |     |       }
  807 |     |     }
  808 |     | 
  809 |     |     if (
  810 |     |       notSkip1
  811 |     |        || 
  812 |     |       qSpacing - load_logPrice(smallestPointerX59) <= minLogStep
  813 |     |     ) {
  814 |     |       set_breakPoint(
  815 |     |         index,
  816 |     |         load_logPrice(smallestPointerX59),
  817 |     |         oneX15
  818 |     |       );
  819 |     |       index = index + oneIndex;
  820 |     |     }
  821 |     | 
  822 |     |     set_breakPoint(index, qSpacing, oneX15);
  823 |     |     index = index + oneIndex;
  824 |     | 
  825 |     |     setKernelLength(index);
  826 |     |   }
  827 |     | 
  828 |     |   /// @notice This function builds a curve and places it in memory.
  829 |     |   function _buildCurve(
  830 |     |     uint64[] calldata seed_curve,
  831 |     |     bool seed,
  832 |     |     X59 qLower,
  833 |     |     X59 qUpper
  834 |     |   ) private {
  835 |     |     uint256 pointer;
  836 |     |     {
  837 |     |       Curve curve;
  838 |     |       Kernel kernel = getKernel();
  839 |     |       Index length = getKernelLength() - oneIndex;
  840 |     |       assembly {
  841 |     |         pointer := add(kernel, shl(6, length))
  842 |     |         curve := pointer
  843 |     |       }
  844 |     |       setCurve(curve);
  845 |     |     }
  846 |     | 
  847 |     |     (
  848 |     |       X59 logPrice0,
  849 |     |       X59 logPrice1
  850 |     |     ) = seed ? (qLower, qUpper) : (qUpper, qLower);
  851 |     | 
  852 |     |     assembly {
  853 |     |       mstore(pointer, shl(192, logPrice0))
  854 |     |     }
  855 |     |     pointer += 8;
  856 |     | 
  857 |     |     uint256 k = 0;
  858 |     |     while (true) {
  859 |     |       assembly {
  860 |     |         mstore(pointer, shl(192, logPrice1))
  861 |     |       }
  862 |     |       pointer += 8;
  863 |     | 
  864 |     |       if (k == curveLengthLimit(seed_curve.length)) break;
  865 |     | 
  866 |     |       if (
  867 |     |         min(logPrice0, logPrice1) == max(logPrice0, logPrice1) - epsilonX59
  868 |     |       ) break;
  869 |     | 
  870 |     |       (logPrice0, logPrice1) = (
  871 |     |         logPrice1,
  872 |     |         get_a_logPrice_in_between(
  873 |     |           seed_curve[k],
  874 |     |           min(logPrice0, logPrice1) + epsilonX59,
  875 |     |           max(logPrice0, logPrice1) - epsilonX59
  876 |     |         )
  877 |     |       );
  878 |     | 
  879 |     |       ++k;
  880 |     |     }
  881 |     |     
  882 |     |     {
  883 |     |       Index length;
  884 |     |       assembly {
  885 |     |         length := k
  886 |     |       }
  887 |     |       setCurveLength(length + twoIndex);
  888 |     |     }
  889 |     | 
  890 |     |     setFreeMemoryPointer(pointer + 64);
  891 |     |   }
  892 |     | 
  893 |     |   /// @notice This function calculates 'originToOvershoot' for a swap from
  894 |     |   /// 'getCurve().member(getKernelLength() - oneIndex)' to
  895 |     |   /// 'getCurve().member(zeroIndex)'.
  896 |     |   X216 public originToOvershoot_reference;
  897 |     |   function _originToOvershoot() private {
  898 |     |     originToOvershoot_reference = zeroX216;
  899 |     |     for (
  900 |     |       Index index = zeroIndex;
  901 |     |       index < getKernelLength() - oneIndex;
  902 |     |       index = index + oneIndex
  903 |     |     ) {
  904 |     |       (X15 c0, X59 b0, , ) = getKernel().member(index);
  905 |     |       (X15 c1, X59 b1, , ) = getKernel().member(index + oneIndex);
  906 |     |       if (
  907 |     |         getCurve().member(zeroIndex) <= getCurve().member(oneIndex)
  908 |     |       ) {
  909 |     |         b0 = getCurve().member(oneIndex) - b0;
  910 |     |         b1 = getCurve().member(oneIndex) - b1;
  911 |     |       } else {
  912 |     |         b0 = b0 + getCurve().member(oneIndex);
  913 |     |         b1 = b1 + getCurve().member(oneIndex);
  914 |     |       }
  915 |     |       originToOvershoot_reference = originToOvershoot_reference + 
  916 |     |         outgoing_reference(c0, c1, b0, b1, b0, b1);
  917 |     |     }
  918 |     |   }
  919 |     | 
  920 |     |   /// @notice This function calculates 'incomingCurrentToTarget',
  921 |     |   /// 'currentToOrigin', and 'currentToTarget' for a swap from
  922 |     |   /// 'getCurve().member(getKernelLength() - oneIndex)' to
  923 |     |   /// 'getCurve().member(zeroIndex)'.
  924 |     |   X216 public incomingCurrentToTarget_reference;
  925 |     |   X216 public currentToOrigin_reference;
  926 |     |   X216 public currentToTarget_reference;
  927 |     |   function _integrals() private {
  928 |     |     incomingCurrentToTarget_reference = zeroX216;
  929 |     |     currentToOrigin_reference = zeroX216;
  930 |     |     currentToTarget_reference = zeroX216;
  931 |     | 
  932 |     |     Index iIndex = getCurveLength() - oneIndex;
  933 |     |     X59 begin = getCurve().member(iIndex);
  934 |     |     X59 origin = getCurve().member(iIndex);
  935 |     |     X59 end = getCurve().member(iIndex);
  936 |     |     while(iIndex >= oneIndex) {
  937 |     |       iIndex = iIndex - oneIndex;
  938 |     |       begin = origin;
  939 |     |       origin = end;
  940 |     |       end = getCurve().member(iIndex);
  941 |     |       for (
  942 |     |         Index jIndex = zeroIndex;
  943 |     |         jIndex < getKernelLength() - oneIndex;
  944 |     |         jIndex = jIndex + oneIndex
  945 |     |       ) {
  946 |     |         (X15 c0, X59 b0, , ) = getKernel().member(jIndex);
  947 |     |         (X15 c1, X59 b1, , ) = getKernel().member(jIndex + oneIndex);
  948 |     |         X59 from;
  949 |     |         X59 to;
  950 |     |         if (end < begin) {
  951 |     |           b0 = origin - b0;
  952 |     |           b1 = origin - b1;
  953 |     |           from = min(begin, b0);
  954 |     |           to = max(end, b1);
  955 |     |           if (from < to) continue;
  956 |     |         } else {
  957 |     |           b0 = origin + b0;
  958 |     |           b1 = origin + b1;
  959 |     |           from = max(begin, b0);
  960 |     |           to = min(end, b1);
  961 |     |           if (to < from) continue;
  962 |     |         }
  963 |     |         if (
  964 |     |           (getCurve().member(zeroIndex) <= getCurve().member(oneIndex))
  965 |     |            == 
  966 |     |           (end < begin)
  967 |     |         ) {
  968 |     |           incomingCurrentToTarget_reference = 
  969 |     |             incomingCurrentToTarget_reference + 
  970 |     |             incoming_reference(c0, c1, b0, b1, from, to);
  971 |     |           currentToTarget_reference = 
  972 |     |             currentToTarget_reference + 
  973 |     |             outgoing_reference(c0, c1, b0, b1, from, to);
  974 |     |         } else {
  975 |     |           currentToOrigin_reference = 
  976 |     |             currentToOrigin_reference + 
  977 |     |             outgoing_reference(c0, c1, b0, b1, from, to);
  978 |     |         }
  979 |     |       }
  980 |     |     }
  981 |     |   }
  982 |     | 
  983 |     |   // This function builds a random curve and a random kernel and returns them
  984 |     |   // as returndata.
  985 |     |   function _build(
  986 |     |     X59 qSpacing,
  987 |     |     bool[3] calldata seed_base,
  988 |     |     uint64[3] calldata seed_boundaries,
  989 |     |     uint88[] calldata seed_kernel,
  990 |     |     uint64[] calldata seed_curve
  991 |     |   ) private {
  992 |     |     // The lower boundary of active interval is chosen between 'qSpacing' and
  993 |     |     // 'thirtyTwoX59 - qSpacing - qSpacing'.
  994 |     |     X59 qLower = get_a_logPrice_in_between(
  995 |     |       seed_boundaries[1],
  996 |     |       qSpacing + epsilonX59,
  997 |     |       thirtyTwoX59 - epsilonX59 - qSpacing - qSpacing
  998 |     |     );
  999 |     | 
 1000 |     |     // We build a kernel and places it in memory.
 1001 |     |     uint256 smallestPointer = _sortedX59(
 1002 |     |       seed_kernel,
 1003 |     |       seed_boundaries[2],
 1004 |     |       qSpacing
 1005 |     |     );
 1006 |     |     _buildKernel(
 1007 |     |       seed_kernel,
 1008 |     |       qSpacing,
 1009 |     |       seed_base[0],
 1010 |     |       seed_base[1],
 1011 |     |       kernelLengthLimit(seed_kernel.length),
 1012 |     |       smallestPointer,
 1013 |     |       _sortedX15(seed_kernel)
 1014 |     |     );
 1015 |     | 
 1016 |     |     // We build a curve and places it in memory.
 1017 |     |     _buildCurve(seed_curve, seed_base[2], qLower, qLower + qSpacing);
 1018 |     | 
 1019 |     |     // calculates 'originToOvershoot' for a swap from
 1020 |     |     // 'getCurve().member(getKernelLength() - oneIndex)' to
 1021 |     |     // 'getCurve().member(zeroIndex)'.
 1022 |     |     _originToOvershoot();
 1023 |     | 
 1024 |     |     // calculates 'incomingCurrentToTarget',
 1025 |     |     // 'currentToOrigin', and 'currentToTarget' for a swap from
 1026 |     |     // 'getCurve().member(getKernelLength() - oneIndex)' to
 1027 |     |     // 'getCurve().member(zeroIndex)'.
 1028 |     |     _integrals();
 1029 |     | 
 1030 |     |     // Returns the generated curve and kernel as returndata.
 1031 |     |     {
 1032 |     |       Curve curve = getCurve();
 1033 |     |       Index length = getCurveLength();
 1034 |     |       assembly {
 1035 |     |         return(_pointers_, sub(add(curve, shl(3, length)), _pointers_))
 1036 |     |       }
 1037 |     |     }
 1038 |     |   }
 1039 |     | }

/home/training/echidna/IntegralTest.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import "./FuzzUtilities.sol";
   5 |     | 
   6 |     | using PriceLibrary for uint256;
   7 |     | using IntegralLibrary for uint256;
   8 |     | using IntegralLibrary for X216;
   9 |     | 
  10 | *r  | contract IntegralTest {
  11 | *   |   function integral_setter_getter_test(uint216 seed) public pure {
  12 | *   |     X216 value = get_an_integral(seed);
  13 | *   |     uint256 pointer = get_an_integral_pointer();
  14 | *   |     pointer.setIntegral(value);
  15 | *   |     assert(value == pointer.integral());
  16 |     |   }
  17 |     | 
  18 | *   |   function integral_increment_decrement_test(
  19 |     |     uint216 seed0,
  20 |     |     uint216 seed1
  21 | *   |   ) public pure {
  22 | *   |     X216 value0 = get_an_integral(seed0);
  23 | *   |     X216 value1 = get_an_integral(seed1);
  24 | *   |     (value0, value1) = (value0 <= value1) ? (value0, value1) : (value1, value0);
  25 |     | 
  26 | *   |     uint256 pointer = get_an_integral_pointer();
  27 | *   |     pointer.setIntegral(value1);
  28 |     | 
  29 | *   |     pointer.decrementIntegral(value0);
  30 | *   |     assert(value1 - value0 == pointer.integral());
  31 |     | 
  32 | *   |     pointer.incrementIntegral(value0);
  33 | *   |     assert(value1 == pointer.integral());
  34 |     |   }
  35 |     | 
  36 | *   |   function evaluate_test(
  37 |     |     uint16 seed_c0,
  38 |     |     uint16 seed_c1,
  39 |     |     uint64 seed_b0,
  40 |     |     uint64 seed_b1,
  41 |     |     bool left,
  42 |     |     uint64 seed_q
  43 | *   |   ) public pure {
  44 | *   |     X15 c0 = get_a_height(seed_c0);
  45 | *   |     X15 c1 = get_a_height(seed_c1);
  46 | *   |     (c0, c1) = (c0 < c1) ? (c0, c1) : (c1, c0);
  47 | *   |     X59 b0 = get_a_logPrice_in_between(
  48 | *   |       seed_b0,
  49 |     |       epsilonX59,
  50 | *   |       thirtyTwoX59 - epsilonX59 - epsilonX59
  51 |     |     );
  52 | *   |     X59 b1 = get_a_logPrice_in_between(
  53 | *   |       seed_b1, b0 + epsilonX59,
  54 | *   |       thirtyTwoX59 - epsilonX59
  55 |     |     );
  56 | *   |     (b0, b1) = left ? (b0, b1) : (b1, b0);
  57 | *   |     X59 q = get_a_logPrice_in_between(seed_q, b0, b1);
  58 |     | 
  59 | *   |     (X216 sqrt0, X216 sqrtInverse0) = b0.exp();
  60 | *   |     (X216 sqrt1, X216 sqrtInverse1) = b1.exp();
  61 | *   |     uint256 segmentCoordinates = get_a_segment_pointer();
  62 | *   |     segmentCoordinates.storePrice(c0, b0, sqrt0, sqrtInverse0);
  63 | *   |     (segmentCoordinates + 64).storePrice(c1, b1, sqrt1, sqrtInverse1);
  64 |     | 
  65 | *   |     (X216 sqrt, X216 sqrtInverse) = q.exp();
  66 | *   |     uint256 targetPrice = get_a_price_pointer();
  67 | *   |     targetPrice.storePrice(q, sqrt, sqrtInverse);
  68 |     | 
  69 | *   |     assert(
  70 | *   |       segmentCoordinates.evaluate(targetPrice) == 
  71 | *   |         evaluate_reference(c0, c1, b0, b1, q)
  72 |     |     );
  73 |     |   }
  74 |     | 
  75 | *   |   function outgoing_incoming_test(
  76 |     |     uint16 seed_c0,
  77 |     |     uint16 seed_c1,
  78 |     |     uint64 seed_b0,
  79 |     |     uint64 seed_b1,
  80 |     |     bool direction,
  81 |     |     uint64 seed_from,
  82 |     |     uint64 seed_to
  83 | *   |   ) public pure {
  84 | *   |     X59 b0 = get_a_logPrice_in_between(
  85 | *   |       seed_b0,
  86 |     |       epsilonX59,
  87 | *   |       thirtyTwoX59 - epsilonX59 - epsilonX59
  88 |     |     );
  89 | *   |     X59 b1 = get_a_logPrice_in_between(
  90 | *   |       seed_b1,
  91 | *   |       b0 + epsilonX59,
  92 | *   |       thirtyTwoX59 - epsilonX59
  93 |     |     );
  94 | *   |     (b0, b1) = direction ? (b0, b1) : (b1, b0);
  95 | *   |     X15 c0 = get_a_height(seed_c0);
  96 | *   |     X15 c1 = get_a_height(seed_c1);
  97 | *   |     uint256 segmentCoordinates = get_a_segment_pointer();
  98 | *   |     uint256 fromPrice = get_a_price_pointer();
  99 | *   |     uint256 toPrice = get_a_price_pointer();
 100 | *   |     X59 from = get_a_logPrice_in_between(seed_from, b0, b1);
 101 | *   |     X59 to = get_a_logPrice_in_between(seed_to, b0, b1);
 102 | *   |     {
 103 | *   |       (c0, c1) = (c0 < c1) ? (c0, c1) : (c1, c0);
 104 | *   |       (from, to) = (from < to) ? (from, to) : (to, from);
 105 | *   |       (from, to) = direction ? (from, to) : (to, from);
 106 |     | 
 107 | *   |       (X216 sqrt0, X216 sqrtInverse0) = b0.exp();
 108 | *   |       (X216 sqrt1, X216 sqrtInverse1) = b1.exp();
 109 | *   |       segmentCoordinates.storePrice(c0, b0, sqrt0, sqrtInverse0);
 110 | *   |       (segmentCoordinates + 64).storePrice(c1, b1, sqrt1, sqrtInverse1);
 111 |     | 
 112 | *   |       (X216 sqrt, X216 sqrtInverse) = from.exp();
 113 | *   |       fromPrice.storePrice(from, sqrt, sqrtInverse);
 114 |     | 
 115 | *   |       (sqrt, sqrtInverse) = to.exp();
 116 | *   |       toPrice.storePrice(to, sqrt, sqrtInverse);
 117 |     |     }
 118 |     | 
 119 | *   |     assert(
 120 | *   |       approximatelyEqual(
 121 | *   |         segmentCoordinates.outgoing(fromPrice, toPrice),
 122 | *   |         outgoing_reference(c0, c1, b0, b1, from, to),
 123 | *   |         16
 124 |     |       )
 125 |     |     );
 126 |     | 
 127 | *   |     assert(
 128 | *   |       approximatelyEqual(
 129 | *   |         segmentCoordinates.incoming(fromPrice, toPrice),
 130 | *   |         incoming_reference(c0, c1, b0, b1, from, to),
 131 | *   |         16
 132 |     |       )
 133 |     |     );
 134 |     |   }
 135 |     | 
 136 | *   |   function shift_test(
 137 |     |     uint256 seed_integral,
 138 |     |     uint64 seed_price0,
 139 |     |     uint64 seed_price1
 140 | *   |   ) public pure {
 141 | *   |     X216 integralValue = X216.wrap(int256(
 142 | *   |       seed_integral % uint256(X216.unwrap(expInverse8X216 * expInverse8X216))
 143 |     |     ));
 144 |     | 
 145 | *   |     X59 price0 = get_a_logPrice_in_between(
 146 | *   |       seed_price0,
 147 |     |       epsilonX59,
 148 | *   |       thirtyTwoX59 - epsilonX59
 149 |     |     );
 150 | *   |     (X216 sqrt0, X216 sqrtInverse0) = price0.exp();
 151 | *   |     uint256 pointer0 = get_a_price_pointer();
 152 | *   |     pointer0.storePrice(price0, sqrt0, sqrtInverse0);
 153 |     | 
 154 | *   |     X59 price1 = get_a_logPrice_in_between(
 155 | *   |       seed_price1,
 156 |     |       epsilonX59,
 157 | *   |       thirtyTwoX59 - epsilonX59
 158 |     |     );
 159 | *   |     (X216 sqrt1, X216 sqrtInverse1) = price1.exp();
 160 | *   |     uint256 pointer1 = get_a_price_pointer();
 161 | *   |     pointer1.storePrice(price1, sqrt1, sqrtInverse1);
 162 |     | 
 163 | *   |     assert(
 164 | *   |       approximatelyEqual(
 165 | *   |         integralValue.shift(pointer0, pointer1, false),
 166 | *   |         shift_reference(
 167 | *   |           integralValue,
 168 | *   |           sqrtInverse0,
 169 | *   |           sqrtInverse1
 170 |     |         ),
 171 | *   |         2 ** 32
 172 |     |       )
 173 |     |     );
 174 |     | 
 175 | *   |     assert(
 176 | *   |       approximatelyEqual(
 177 | *   |         integralValue.shift(pointer0, pointer1, true),
 178 | *   |         shift_reference(
 179 | *   |           integralValue,
 180 | *   |           sqrt0,
 181 | *   |           sqrt1
 182 |     |         ),
 183 | *   |         2 ** 32
 184 |     |       )
 185 |     |     );
 186 |     |   }
 187 |     | }


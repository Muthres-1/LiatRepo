<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/home/training/contracts/helpers/CalldataWrapper.sol</b>
<code>
  1 |     | <span class='unexecuted'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../utilities/Calldata.sol&quot;;</span>
  5 |     | <span class='neutral'>import {</span>
  6 |     | <span class='neutral'>  getFreeMemoryPointer,</span>
  7 |     | <span class='neutral'>  getHookInputByteCount,</span>
  8 |     | <span class='neutral'>  _hookInputByteCount_ </span>
  9 |     | <span class='neutral'>} from &quot;../utilities/Memory.sol&quot;;</span>
 10 |     | <span class='neutral'>import {writeStorage} from &quot;../utilities/Storage.sol&quot;;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>/// @title This contract exposes the internal functions of &#39;Calldata.sol&#39; for </span>
 14 |     | <span class='neutral'>/// testing purposes.</span>
 15 | *   | <span class='executed'>contract CalldataWrapper {</span>
 16 |     | <span class='unexecuted'>  function _readInitializeInput() public returns (</span>
 17 |     | <span class='unexecuted'>    KernelCompact kernelCompact</span>
 18 |     | <span class='neutral'>  ) {</span>
 19 |     | <span class='unexecuted'>    kernelCompact = readInitializeInput();</span>
 20 |     | <span class='unexecuted'>    uint256 freeMemoryPointer = getFreeMemoryPointer();</span>
 21 |     | <span class='unexecuted'>    assembly {</span>
 22 |     | <span class='neutral'>      log1(0, freeMemoryPointer, 0)</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'>  }</span>
 25 |     | <span class='neutral'>// log1(memory_start, memory_size, topic1) :- log1 is an EVM assembly opcode used to emit an event with 1 topic.</span>
 26 |     | <span class='neutral'>// 0x00 ------------------- used memory ------------------- freeMemoryPointer ---- free memory ,freeMemoryPointer = memory size for here because memory starts at 0x00, so the size of used memory is equal to the pointer to the start of free memory. So we log from 0x00 to freeMemoryPointer.</span>
 27 |     | <span class='neutral'>// emit meaning → write an event log into the transaction receipt or Store this information in transaction receipt(not storage of the contract).</span>
 28 |     | <span class='neutral'>// topic means  → searchable label of the log</span>
 29 |     | <span class='neutral'>// topic1       → value of that label</span>
 30 |     | <span class='neutral'>// log1         → emit event with 1 topic or It stores memory[memory_start : memory_start + memory_size] into the blockchain logs with 1 topic. It Store this information in transaction receipt(not storage of the contract) so that it can be accessed by off-chain applications or other contracts. The log will contain the data from memory[0 : freeMemoryPointer] and will be indexed by topic1 (which is 0 in this case).</span>
 31 |     | <span class='unexecuted'>  function _readModifyPositionInput() public {</span>
 32 |     | <span class='neutral'>    readModifyPositionInput();</span>
 33 |     | <span class='unexecuted'>    uint256 freeMemoryPointer = getFreeMemoryPointer();</span>
 34 |     | <span class='unexecuted'>    assembly {</span>
 35 |     | <span class='neutral'>      log1(0, freeMemoryPointer, 0)</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'>  }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>  function _readDonateInput() public {</span>
 40 |     | <span class='neutral'>    readDonateInput();</span>
 41 |     | <span class='unexecuted'>    uint256 freeMemoryPointer = getFreeMemoryPointer();</span>
 42 |     | <span class='unexecuted'>    assembly {</span>
 43 |     | <span class='neutral'>      log1(0, freeMemoryPointer, 0)</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'>  }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>  function _readModifyKernelInput() public returns (</span>
 48 |     | <span class='unexecuted'>    KernelCompact kernelCompact</span>
 49 |     | <span class='neutral'>  ) {</span>
 50 |     | <span class='unexecuted'>    kernelCompact = readModifyKernelInput();</span>
 51 |     | <span class='unexecuted'>    uint256 freeMemoryPointer = getFreeMemoryPointer();</span>
 52 |     | <span class='unexecuted'>    assembly {</span>
 53 |     | <span class='neutral'>      log1(0, freeMemoryPointer, 0)</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'>  }</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='unexecuted'>  function _readModifyPoolGrowthPortionInput() public {</span>
 58 |     | <span class='neutral'>    readModifyPoolGrowthPortionInput();</span>
 59 |     | <span class='unexecuted'>    uint256 freeMemoryPointer = getFreeMemoryPointer();</span>
 60 |     | <span class='unexecuted'>    assembly {</span>
 61 |     | <span class='neutral'>      log1(0, freeMemoryPointer, 0)</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'>  }</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='unexecuted'>  function _readUpdateGrowthPortionsInput() public {</span>
 66 |     | <span class='neutral'>    readUpdateGrowthPortionsInput();</span>
 67 |     | <span class='unexecuted'>    uint256 freeMemoryPointer = getFreeMemoryPointer();</span>
 68 |     | <span class='unexecuted'>    assembly {</span>
 69 |     | <span class='neutral'>      log1(0, freeMemoryPointer, 0)</span>
 70 |     | <span class='neutral'>    }</span>
 71 |     | <span class='neutral'>  }</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='unexecuted'>  function _readSwapInput() public {</span>
 74 |     | <span class='neutral'>    readSwapInput();</span>
 75 |     | <span class='unexecuted'>    uint256 hookInputByteCount = getHookInputByteCount();</span>
 76 |     | <span class='unexecuted'>    assembly {</span>
 77 |     | <span class='neutral'>      log1(</span>
 78 |     | <span class='neutral'>        0,</span>
 79 |     | <span class='neutral'>        add(add(_hookInputByteCount_, hookInputByteCount), 32),</span>
 80 |     | <span class='neutral'>        0</span>
 81 |     | <span class='neutral'>      )</span>
 82 |     | <span class='neutral'>    }</span>
 83 |     | <span class='neutral'>  }</span>
 84 |     | <span class='neutral'> </span>
 85 |     | <span class='unexecuted'>  function _readCollectInput() public {</span>
 86 |     | <span class='neutral'>    readCollectInput();</span>
 87 |     | <span class='unexecuted'>    uint256 freeMemoryPointer = getFreeMemoryPointer();</span>
 88 |     | <span class='unexecuted'>    assembly {</span>
 89 |     | <span class='neutral'>      log1(0, freeMemoryPointer, 0)</span>
 90 |     | <span class='neutral'>    }</span>
 91 |     | <span class='neutral'>  }</span>
 92 |     | <span class='neutral'>}</span>
 93 |     | <span class='neutral'></span>
 94 |     | <span class='neutral'></span>
 95 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/training/contracts/interfaces/INofeeswap.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ISentinel} from &quot;./ISentinel.sol&quot;;</span>
   5 |     | <span class='neutral'>import {Tag} from &quot;../utilities/Tag.sol&quot;;</span>
   6 |     | <span class='neutral'>import {X59} from &quot;../utilities/X59.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IStorageAccess} from &quot;./IStorageAccess.sol&quot;;</span>
   8 |     | <span class='neutral'>import {ITransientAccess} from &quot;./ITransientAccess.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/// @notice Interface for the Nofeeswap contract.</span>
  11 |     | <span class='neutral'>interface INofeeswap is IStorageAccess, ITransientAccess {</span>
  12 |     | <span class='neutral'>  /// @notice See ERC6909 specifications.</span>
  13 |     | <span class='neutral'>  function supportsInterface(</span>
  14 |     | <span class='neutral'>    bytes4 interfaceId</span>
  15 |     | <span class='neutral'>  ) external pure returns (bool);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>  /// @notice See ERC6909 specifications.</span>
  18 |     | <span class='neutral'>  function balanceOf(</span>
  19 |     | <span class='neutral'>    address owner,</span>
  20 |     | <span class='neutral'>    Tag tag</span>
  21 |     | <span class='neutral'>  ) external view returns (</span>
  22 |     | <span class='neutral'>    uint256 amount</span>
  23 |     | <span class='neutral'>  );</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>  /// @notice See ERC6909 specifications.</span>
  26 |     | <span class='neutral'>  function allowance(</span>
  27 |     | <span class='neutral'>    address owner,</span>
  28 |     | <span class='neutral'>    address spender,</span>
  29 |     | <span class='neutral'>    Tag tag</span>
  30 |     | <span class='neutral'>  ) external view returns (</span>
  31 |     | <span class='neutral'>    uint256 amount</span>
  32 |     | <span class='neutral'>  );</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>  /// @notice See ERC6909 specifications.</span>
  35 |     | <span class='neutral'>  function isOperator(</span>
  36 |     | <span class='neutral'>    address owner,</span>
  37 |     | <span class='neutral'>    address spender</span>
  38 |     | <span class='neutral'>  ) external view returns (</span>
  39 |     | <span class='neutral'>    bool status</span>
  40 |     | <span class='neutral'>  );</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>  /// @notice See ERC6909 specifications.</span>
  43 |     | <span class='neutral'>  function transfer(</span>
  44 |     | <span class='neutral'>    address receiver,</span>
  45 |     | <span class='neutral'>    Tag tag,</span>
  46 |     | <span class='neutral'>    uint256 amount</span>
  47 |     | <span class='neutral'>  ) external returns (</span>
  48 |     | <span class='neutral'>    bool success</span>
  49 |     | <span class='neutral'>  );</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>  /// @notice See ERC6909 specifications.</span>
  52 |     | <span class='neutral'>  function transferFrom(</span>
  53 |     | <span class='neutral'>    address sender,</span>
  54 |     | <span class='neutral'>    address receiver,</span>
  55 |     | <span class='neutral'>    Tag tag,</span>
  56 |     | <span class='neutral'>    uint256 amount</span>
  57 |     | <span class='neutral'>  ) external returns (</span>
  58 |     | <span class='neutral'>    bool success</span>
  59 |     | <span class='neutral'>  );</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>  /// @notice See ERC6909 specifications.</span>
  62 |     | <span class='neutral'>  function approve(</span>
  63 |     | <span class='neutral'>    address spender,</span>
  64 |     | <span class='neutral'>    Tag tag,</span>
  65 |     | <span class='neutral'>    uint256 amount</span>
  66 |     | <span class='neutral'>  ) external returns (</span>
  67 |     | <span class='neutral'>    bool success</span>
  68 |     | <span class='neutral'>  );</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>  /// @notice See ERC6909 specifications.</span>
  71 |     | <span class='neutral'>  function setOperator(</span>
  72 |     | <span class='neutral'>    address spender,</span>
  73 |     | <span class='neutral'>    bool approved</span>
  74 |     | <span class='neutral'>  ) external returns (</span>
  75 |     | <span class='neutral'>    bool success</span>
  76 |     | <span class='neutral'>  );</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>  /// @notice Mints/burns singleton balance. This results in a transient</span>
  79 |     | <span class='neutral'>  /// storage balance which must be settled.</span>
  80 |     | <span class='neutral'>  ///</span>
  81 |     | <span class='neutral'>  /// transient balance &lt;-&gt; singleton balance</span>
  82 |     | <span class='neutral'>  ///</span>
  83 |     | <span class='neutral'>  /// @param owner Balance owner.</span>
  84 |     | <span class='neutral'>  /// @param tag The tag whose balance to be modified.</span>
  85 |     | <span class='neutral'>  /// @param amount The amount to be added (positive) or removed (negative)</span>
  86 |     | <span class='neutral'>  /// to/from the owner&#39;s singleton balance.</span>
  87 |     | <span class='neutral'>  function modifyBalance(</span>
  88 |     | <span class='neutral'>    address owner,</span>
  89 |     | <span class='neutral'>    Tag tag,</span>
  90 |     | <span class='neutral'>    int256 amount</span>
  91 |     | <span class='neutral'>  ) external;</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>  /// @notice Mints/burns singleton double balance of tags 0 and 1. Can be used</span>
  94 |     | <span class='neutral'>  /// for gas efficient transactions by eliminating the need to update two </span>
  95 |     | <span class='neutral'>  /// storage slots. This results in transient storage balances which must be </span>
  96 |     | <span class='neutral'>  /// settled.</span>
  97 |     | <span class='neutral'>  ///</span>
  98 |     | <span class='neutral'>  /// transient balance of tags 0 and 1 &lt;-&gt; singleton double balance</span>
  99 |     | <span class='neutral'>  ///</span>
 100 |     | <span class='neutral'>  /// @param owner Balance owner.</span>
 101 |     | <span class='neutral'>  /// @param tag0 The arithmetically smaller tag.</span>
 102 |     | <span class='neutral'>  /// @param tag1 The arithmetically larger tag.</span>
 103 |     | <span class='neutral'>  /// @param amount0 The amount of tag0 to be added (positive) or removed </span>
 104 |     | <span class='neutral'>  /// (negative) to/from the owner&#39;s singleton balance.</span>
 105 |     | <span class='neutral'>  /// @param amount1 The amount of tag1 to be added (positive) or removed </span>
 106 |     | <span class='neutral'>  /// (negative) to/from the owner&#39;s singleton balance.</span>
 107 |     | <span class='neutral'>  function modifyBalance(</span>
 108 |     | <span class='neutral'>    address owner,</span>
 109 |     | <span class='neutral'>    Tag tag0,</span>
 110 |     | <span class='neutral'>    Tag tag1,</span>
 111 |     | <span class='neutral'>    int256 amount0,</span>
 112 |     | <span class='neutral'>    int256 amount1</span>
 113 |     | <span class='neutral'>  ) external;</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>  /// @notice This function gives access to the following protocol methods that</span>
 116 |     | <span class='neutral'>  /// are safeguarded against reentrancy:</span>
 117 |     | <span class='neutral'>  ///</span>
 118 |     | <span class='neutral'>  ///   &#39;INofeeswap.clear(Tag,uint256)&#39;</span>
 119 |     | <span class='neutral'>  ///   &#39;INofeeswap.take(address,address,uint256)&#39;</span>
 120 |     | <span class='neutral'>  ///   &#39;INofeeswap.take(address,uint256,address,uint256)&#39;</span>
 121 |     | <span class='neutral'>  ///   &#39;INofeeswap.take(address,uint256,address,uint256,bytes)&#39;</span>
 122 |     | <span class='neutral'>  ///   &#39;INofeeswap.settle(address)&#39;</span>
 123 |     | <span class='neutral'>  ///   &#39;INofeeswap.transferTransientBalanceFrom(address,address,Tag,uint256)&#39;</span>
 124 |     | <span class='neutral'>  ///   &#39;INofeeswap.modifyBalance(address,Tag,int256)&#39;</span>
 125 |     | <span class='neutral'>  ///   &#39;INofeeswap.modifyBalance(address,Tag,Tag,int256,int256)&#39;</span>
 126 |     | <span class='neutral'>  ///   &#39;INofeeswap.swap(uint256,int256,X59,uint256,bytes)&#39;</span>
 127 |     | <span class='neutral'>  ///   &#39;INofeeswapDelegatee.modifyPosition(uint256,X59,X59,int256,bytes)&#39;</span>
 128 |     | <span class='neutral'>  ///   &#39;INofeeswapDelegatee.donate(uint256,uint256,bytes)&#39;</span>
 129 |     | <span class='neutral'>  ///</span>
 130 |     | <span class='neutral'>  /// @param unlockTarget The target contract address which must implement </span>
 131 |     | <span class='neutral'>  /// &#39;IUnlockCallback.sol&#39;.</span>
 132 |     | <span class='neutral'>  /// @param data The data/instructions to be passed to the target contract.</span>
 133 |     | <span class='neutral'>  /// @return result The output from the target contract.</span>
 134 |     | <span class='neutral'>  function unlock(</span>
 135 |     | <span class='neutral'>    address unlockTarget,</span>
 136 |     | <span class='neutral'>    bytes calldata data</span>
 137 |     | <span class='neutral'>  ) external payable returns (</span>
 138 |     | <span class='neutral'>    bytes memory result</span>
 139 |     | <span class='neutral'>  );</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>  /// @notice WARNING - Once a balance is cleared, the corresponding funds</span>
 142 |     | <span class='neutral'>  /// become permanently inaccessible and remain locked within the contract.</span>
 143 |     | <span class='neutral'>  /// Executing a clear call will erase the entire balance owed to the caller</span>
 144 |     | <span class='neutral'>  /// without initiating any outbound transfer.</span>
 145 |     | <span class='neutral'>  /// @notice Clears transient balance owed to &#39;msg.sender&#39;.</span>
 146 |     | <span class='neutral'>  /// @param tag The tag whose transient balance to be cleared.</span>
 147 |     | <span class='neutral'>  /// @param amount The amount to be cleared which must be equal to the current</span>
 148 |     | <span class='neutral'>  /// transient balance of the caller.</span>
 149 |     | <span class='neutral'>  function clear(</span>
 150 |     | <span class='neutral'>    Tag tag,</span>
 151 |     | <span class='neutral'>    uint256 amount</span>
 152 |     | <span class='neutral'>  ) external;</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>  /// @notice Pays native or ERC-20 assets from the protocol to &#39;to&#39;. This</span>
 155 |     | <span class='neutral'>  /// results in a transient storage balance which must be settled.</span>
 156 |     | <span class='neutral'>  ///</span>
 157 |     | <span class='neutral'>  /// transient balance -&gt; &#39;to&#39; wallet</span>
 158 |     | <span class='neutral'>  ///</span>
 159 |     | <span class='neutral'>  /// @param token ERC-20 or native tokens to be taken from the protocol&#39;s</span>
 160 |     | <span class='neutral'>  /// wallet.</span>
 161 |     | <span class='neutral'>  /// @param to The target address.</span>
 162 |     | <span class='neutral'>  /// @param amount The amount of tokens to be taken from the protocol.</span>
 163 |     | <span class='neutral'>  function take(</span>
 164 |     | <span class='neutral'>    address token,</span>
 165 |     | <span class='neutral'>    address to,</span>
 166 |     | <span class='neutral'>    uint256 amount</span>
 167 |     | <span class='neutral'>  ) external;</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>  /// @notice Pays ERC-6909 assets from the protocol to &#39;to&#39;. This results in a</span>
 170 |     | <span class='neutral'>  /// transient storage balance which must be settled.</span>
 171 |     | <span class='neutral'>  ///</span>
 172 |     | <span class='neutral'>  /// transient balance -&gt; &#39;to&#39; wallet</span>
 173 |     | <span class='neutral'>  ///</span>
 174 |     | <span class='neutral'>  /// @param token ERC-6909 address.</span>
 175 |     | <span class='neutral'>  /// @param tokenId Multi-token id to be taken from the protocol&#39;s wallet.</span>
 176 |     | <span class='neutral'>  /// @param to The target address.</span>
 177 |     | <span class='neutral'>  /// @param amount The amount of tokens to be taken from the protocol.</span>
 178 |     | <span class='neutral'>  function take(</span>
 179 |     | <span class='neutral'>    address token,</span>
 180 |     | <span class='neutral'>    uint256 tokenId,</span>
 181 |     | <span class='neutral'>    address to,</span>
 182 |     | <span class='neutral'>    uint256 amount</span>
 183 |     | <span class='neutral'>  ) external;</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>  /// @notice Pays ERC-1155 assets from the protocol to &#39;to&#39;. This results in a</span>
 186 |     | <span class='neutral'>  /// transient storage balance which must be settled.</span>
 187 |     | <span class='neutral'>  ///</span>
 188 |     | <span class='neutral'>  /// transient balance -&gt; &#39;to&#39; wallet</span>
 189 |     | <span class='neutral'>  ///</span>
 190 |     | <span class='neutral'>  /// @param token ERC-1155 address.</span>
 191 |     | <span class='neutral'>  /// @param tokenId Multi-token id to be taken from the protocol&#39;s wallet.</span>
 192 |     | <span class='neutral'>  /// @param to The target address.</span>
 193 |     | <span class='neutral'>  /// @param amount The amount of tokens to be taken from the protocol.</span>
 194 |     | <span class='neutral'>  /// @param transferData Data to be used from &#39;IERC1155.safeTransferFrom&#39;.</span>
 195 |     | <span class='neutral'>  function take(</span>
 196 |     | <span class='neutral'>    address token,</span>
 197 |     | <span class='neutral'>    uint256 tokenId,</span>
 198 |     | <span class='neutral'>    address to,</span>
 199 |     | <span class='neutral'>    uint256 amount,</span>
 200 |     | <span class='neutral'>    bytes calldata transferData</span>
 201 |     | <span class='neutral'>  ) external;</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>  /// @notice Synchronizes the protocol ERC-20 balance. Should be called prior</span>
 204 |     | <span class='neutral'>  /// to ERC-20 transfers to the protocol.</span>
 205 |     | <span class='neutral'>  /// @param token ERC-20 address to be synced.</span>
 206 |     | <span class='neutral'>  function sync(</span>
 207 |     | <span class='neutral'>    address token</span>
 208 |     | <span class='neutral'>  ) external;</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>  /// @notice Synchronizes the protocol ERC-1155 or ERC-6909 balance. Should be </span>
 211 |     | <span class='neutral'>  /// called prior to ERC-1155 or ERC-6909 transfers to the protocol.</span>
 212 |     | <span class='neutral'>  /// @param token ERC-1155 or ERC-6909 address to be synced.</span>
 213 |     | <span class='neutral'>  /// @param tokenId Multi-token id to be synced.</span>
 214 |     | <span class='neutral'>  function sync(</span>
 215 |     | <span class='neutral'>    address token,</span>
 216 |     | <span class='neutral'>    uint256 tokenId</span>
 217 |     | <span class='neutral'>  ) external;</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>  /// @notice Should be called after ERC-20, ERC6909, or ERC1155 transfers to</span>
 220 |     | <span class='neutral'>  /// the protocol to update transient balances. Can be used to send native</span>
 221 |     | <span class='neutral'>  /// tokens to the protocol to settle native transient balance of </span>
 222 |     | <span class='neutral'>  /// &#39;msg.sender&#39;.</span>
 223 |     | <span class='neutral'>  /// @return paid The amount paid.</span>
 224 |     | <span class='neutral'>  function settle() external payable returns (</span>
 225 |     | <span class='neutral'>    uint256 paid</span>
 226 |     | <span class='neutral'>  );</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>  /// @notice Transfers transient balance from &#39;sender&#39; to &#39;receiver&#39;. Can be</span>
 229 |     | <span class='neutral'>  /// used to settle on behalf of other accounts.</span>
 230 |     | <span class='neutral'>  /// @param sender The sender&#39;s address.</span>
 231 |     | <span class='neutral'>  /// @param receiver The recipient&#39;s address.</span>
 232 |     | <span class='neutral'>  /// @param tag The tag whose balance to be transferred.</span>
 233 |     | <span class='neutral'>  /// @param amount The amount to be transferred.</span>
 234 |     | <span class='neutral'>  function transferTransientBalanceFrom(</span>
 235 |     | <span class='neutral'>    address sender,</span>
 236 |     | <span class='neutral'>    address receiver,</span>
 237 |     | <span class='neutral'>    Tag tag,</span>
 238 |     | <span class='neutral'>    uint256 amount</span>
 239 |     | <span class='neutral'>  ) external;</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='neutral'>  /// @notice Gives access to &#39;NofeeswapDelegatee.sol&#39; functionalities.</span>
 242 |     | <span class='neutral'>  /// @param input Encoded input via &#39;abi.encodeWithSelector&#39; to be passed as </span>
 243 |     | <span class='neutral'>  /// delegate call to &#39;NofeeswapDelegatee.sol&#39;.</span>
 244 |     | <span class='neutral'>  /// @return output0 The first output slot.</span>
 245 |     | <span class='neutral'>  /// @return output1 The second output slot.</span>
 246 |     | <span class='neutral'>  function dispatch(</span>
 247 |     | <span class='neutral'>    bytes calldata input</span>
 248 |     | <span class='neutral'>  ) external returns (</span>
 249 |     | <span class='neutral'>    int256 output0,</span>
 250 |     | <span class='neutral'>    int256 output1</span>
 251 |     | <span class='neutral'>  );</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='neutral'>  /// @notice Performs a swap.</span>
 254 |     | <span class='neutral'>  /// @param poolId The target pool identifier.</span>
 255 |     | <span class='neutral'>  /// @param amountSpecified The amount to be given to (positive) or taken </span>
 256 |     | <span class='neutral'>  /// from (negative) the pool.</span>
 257 |     | <span class='neutral'>  /// @param logPriceLimit The limit logPrice constraint. This value is equal</span>
 258 |     | <span class='neutral'>  /// to &#39;(2 ** 59) * log(p)&#39; where &#39;p&#39; is the intended price limit and &#39;log&#39;</span>
 259 |     | <span class='neutral'>  /// denotes the natural logarithm operator.</span>
 260 |     | <span class='neutral'>  /// @param zeroForOne If ‘zeroForOne &amp; ((1 &lt;&lt; 128) - 1) == 0&#39; then tag0 is</span>
 261 |     | <span class='neutral'>  /// taken from and tag1 is given to the pool. If </span>
 262 |     | <span class='neutral'>  /// ‘zeroForOne &amp; ((1 &lt;&lt; 128) - 1) == 1&#39; then tag1 is taken from and tag0 is</span>
 263 |     | <span class='neutral'>  /// given to the pool. If ‘zeroForOne &amp; ((1 &lt;&lt; 128) - 1)’ is greater than 1,</span>
 264 |     | <span class='neutral'>  /// then the direction of the swap is towards &#39;logPriceLimit&#39;.</span>
 265 |     | <span class='neutral'>  /// ‘(zeroForOne &gt;&gt; 128)’ is a threshold on the number of shares that should</span>
 266 |     | <span class='neutral'>  /// be available in any interval for the swap function to transact in that </span>
 267 |     | <span class='neutral'>  /// interval. For example, if (zeroForOne &gt;&gt; 128 == 0), which is the default,</span>
 268 |     | <span class='neutral'>  /// no minimum number of shares is imposed.</span>
 269 |     | <span class='neutral'>  /// @param hookData The data to be passed to the hook.</span>
 270 |     | <span class='neutral'>  /// @return amount0 The amount of tag0 swapped. Positive values are incoming</span>
 271 |     | <span class='neutral'>  /// to the pool and negative values are outgoing from the pool.</span>
 272 |     | <span class='neutral'>  /// @return amount1 The amount of tag1 swapped. Positive values are incoming</span>
 273 |     | <span class='neutral'>  /// to the pool and negative values are outgoing from the pool.</span>
 274 |     | <span class='neutral'>  function swap(</span>
 275 |     | <span class='neutral'>    uint256 poolId,</span>
 276 |     | <span class='neutral'>    int256 amountSpecified,</span>
 277 |     | <span class='neutral'>    X59 logPriceLimit,</span>
 278 |     | <span class='neutral'>    uint256 zeroForOne,</span>
 279 |     | <span class='neutral'>    bytes calldata hookData</span>
 280 |     | <span class='neutral'>  ) external returns (</span>
 281 |     | <span class='neutral'>    int256 amount0,</span>
 282 |     | <span class='neutral'>    int256 amount1</span>
 283 |     | <span class='neutral'>  );</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>  /// @notice Emitted when a tag is transferred.</span>
 286 |     | <span class='neutral'>  /// @notice See ERC6909 specifications.</span>
 287 |     | <span class='neutral'>  event Transfer(</span>
 288 |     | <span class='neutral'>    address caller,</span>
 289 |     | <span class='neutral'>    address indexed from,</span>
 290 |     | <span class='neutral'>    address indexed to,</span>
 291 |     | <span class='neutral'>    Tag indexed tag,</span>
 292 |     | <span class='neutral'>    uint256 amount</span>
 293 |     | <span class='neutral'>  );</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>  /// @notice Emitted when an operator is assigned/absolved by the owner.</span>
 296 |     | <span class='neutral'>  /// @notice See ERC6909 specifications.</span>
 297 |     | <span class='neutral'>  event OperatorSet(</span>
 298 |     | <span class='neutral'>    address indexed owner,</span>
 299 |     | <span class='neutral'>    address indexed operator,</span>
 300 |     | <span class='neutral'>    bool approved</span>
 301 |     | <span class='neutral'>  );</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>  /// @notice Emitted when a spender&#39;s permission is updated by the owner.</span>
 304 |     | <span class='neutral'>  /// @notice See ERC6909 specifications.</span>
 305 |     | <span class='neutral'>  event Approval(</span>
 306 |     | <span class='neutral'>    address indexed owner,</span>
 307 |     | <span class='neutral'>    address indexed spender,</span>
 308 |     | <span class='neutral'>    Tag indexed tag,</span>
 309 |     | <span class='neutral'>    uint256 amount</span>
 310 |     | <span class='neutral'>  );</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='neutral'>  /// @notice Emitted when owner&#39;s double balance is modified.</span>
 313 |     | <span class='neutral'>  /// @param caller The caller of &#39;INofeeswap.modifyBalance&#39;.</span>
 314 |     | <span class='neutral'>  /// @param owner The double balance owner.</span>
 315 |     | <span class='neutral'>  /// @param tag The corresponding tag.</span>
 316 |     | <span class='neutral'>  /// @param increment The amount being incremented/decremented.</span>
 317 |     | <span class='neutral'>  /// @param balance The resulting balance.</span>
 318 |     | <span class='neutral'>  event ModifyDoubleBalanceEvent(</span>
 319 |     | <span class='neutral'>    address indexed caller,</span>
 320 |     | <span class='neutral'>    address indexed owner,</span>
 321 |     | <span class='neutral'>    Tag indexed tag,</span>
 322 |     | <span class='neutral'>    int256 increment,</span>
 323 |     | <span class='neutral'>    uint256 balance</span>
 324 |     | <span class='neutral'>  );</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='neutral'>  /// @notice Emitted when the pool owner&#39;s accrued growth portions are</span>
 327 |     | <span class='neutral'>  /// collected.</span>
 328 |     | <span class='neutral'>  /// @param poolId The target pool identifier.</span>
 329 |     | <span class='neutral'>  /// @param owner Current owner of the target pool.</span>
 330 |     | <span class='neutral'>  /// @param amount0 The total amount of tag0 collected.</span>
 331 |     | <span class='neutral'>  /// @param amount1 The total amount of tag1 collected.</span>
 332 |     | <span class='neutral'>  event PoolCollection(</span>
 333 |     | <span class='neutral'>    uint256 indexed poolId,</span>
 334 |     | <span class='neutral'>    address indexed owner,</span>
 335 |     | <span class='neutral'>    uint256 amount0,</span>
 336 |     | <span class='neutral'>    uint256 amount1</span>
 337 |     | <span class='neutral'>  );</span>
 338 |     | <span class='neutral'></span>
 339 |     | <span class='neutral'>  /// @notice Emitted when the protocol owner&#39;s accrued growth portions are</span>
 340 |     | <span class='neutral'>  /// collected.</span>
 341 |     | <span class='neutral'>  /// @param poolId The target pool identifier.</span>
 342 |     | <span class='neutral'>  /// @param amount0 The total amount of tag0 collected.</span>
 343 |     | <span class='neutral'>  /// @param amount1 The total amount of tag1 collected.</span>
 344 |     | <span class='neutral'>  event ProtocolCollection(</span>
 345 |     | <span class='neutral'>    uint256 indexed poolId,</span>
 346 |     | <span class='neutral'>    uint256 amount0,</span>
 347 |     | <span class='neutral'>    uint256 amount1</span>
 348 |     | <span class='neutral'>  );</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='neutral'>  /// @notice Emitted when protocol slot is updated.</span>
 351 |     | <span class='neutral'>  /// @param newOwner The new protocol owner.</span>
 352 |     | <span class='neutral'>  /// @param newProtocol The new protocol slot.</span>
 353 |     | <span class='neutral'>  event ModifyProtocol(</span>
 354 |     | <span class='neutral'>    address indexed newOwner,</span>
 355 |     | <span class='neutral'>    uint256 newProtocol</span>
 356 |     | <span class='neutral'>  );</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='neutral'>  /// @notice Emitted when the sentinel contract is updated.</span>
 359 |     | <span class='neutral'>  /// @param oldSentinel The old sentinel contract.</span>
 360 |     | <span class='neutral'>  /// @param newSentinel The new sentinel contract.</span>
 361 |     | <span class='neutral'>  event ModifySentinel(</span>
 362 |     | <span class='neutral'>    ISentinel oldSentinel,</span>
 363 |     | <span class='neutral'>    ISentinel newSentinel</span>
 364 |     | <span class='neutral'>  );</span>
 365 |     | <span class='neutral'></span>
 366 |     | <span class='neutral'>  /// @notice Emitted when a pool owner is updated.</span>
 367 |     | <span class='neutral'>  /// @param poolId The target pool identifier.</span>
 368 |     | <span class='neutral'>  /// @param oldOwner The old owner of the target pool.</span>
 369 |     | <span class='neutral'>  /// @param newOwner The new owner of the target pool.</span>
 370 |     | <span class='neutral'>  event ModifyPoolOwner(</span>
 371 |     | <span class='neutral'>    uint256 indexed poolId,</span>
 372 |     | <span class='neutral'>    address indexed oldOwner,</span>
 373 |     | <span class='neutral'>    address indexed newOwner</span>
 374 |     | <span class='neutral'>  );</span>
 375 |     | <span class='neutral'></span>
 376 |     | <span class='neutral'>  /// @notice Emitted when a nofeeswap pool is initialized.</span>
 377 |     | <span class='neutral'>  /// @param poolId The target pool identifier.</span>
 378 |     | <span class='neutral'>  /// @param tag0 The arithmetically smaller tag.</span>
 379 |     | <span class='neutral'>  /// @param tag1 The arithmetically larger tag.</span>
 380 |     | <span class='neutral'>  /// @param data A snapshot of memory which includes &#39;staticParams&#39;, &#39;kernel&#39;,</span>
 381 |     | <span class='neutral'>  /// &#39;kernelCompact&#39;, and &#39;curve&#39;.</span>
 382 |     | <span class='neutral'>  event Initialize(</span>
 383 |     | <span class='neutral'>    uint256 indexed poolId,</span>
 384 |     | <span class='neutral'>    Tag indexed tag0,</span>
 385 |     | <span class='neutral'>    Tag indexed tag1,</span>
 386 |     | <span class='neutral'>    bytes data</span>
 387 |     | <span class='neutral'>  );</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>  /// @notice Emitted when a nofeeswap position is created, burned or modified.</span>
 390 |     | <span class='neutral'>  /// @param poolId The target pool identifier.</span>
 391 |     | <span class='neutral'>  /// @param caller Caller of the external &#39;modifyPosition&#39; function.</span>
 392 |     | <span class='neutral'>  /// @param data A snapshot of memory which includes the following parameters</span>
 393 |     | <span class='neutral'>  /// (as defined in &#39;Memory.sol&#39;) that are tightly packed together:</span>
 394 |     | <span class='neutral'>  ///  - &#39;logPriceMinOffsetted&#39; in &#39;X59&#39; representation (8 bytes)</span>
 395 |     | <span class='neutral'>  ///  - &#39;logPriceMaxOffsetted&#39; in &#39;X59&#39; representation (8 bytes)</span>
 396 |     | <span class='neutral'>  ///  - &#39;shares&#39; in &#39;int256&#39; representation (32 bytes)</span>
 397 |     | <span class='neutral'>  ///  - &#39;logPriceMin&#39; in &#39;X59&#39; representation (32 bytes)</span>
 398 |     | <span class='neutral'>  ///  - &#39;logPriceMax&#39; in &#39;X59&#39; representation (32 bytes)</span>
 399 |     | <span class='neutral'>  ///  - &#39;positionAmount0&#39; in &#39;X127&#39; representation (32 bytes)</span>
 400 |     | <span class='neutral'>  ///  - &#39;positionAmount1&#39; in &#39;X127&#39; representation (32 bytes)</span>
 401 |     | <span class='neutral'>  event ModifyPosition(</span>
 402 |     | <span class='neutral'>    uint256 indexed poolId,</span>
 403 |     | <span class='neutral'>    address indexed caller,</span>
 404 |     | <span class='neutral'>    bytes32[6] data</span>
 405 |     | <span class='neutral'>  );</span>
 406 |     | <span class='neutral'></span>
 407 |     | <span class='neutral'>  /// @notice Emitted with donates.</span>
 408 |     | <span class='neutral'>  /// @param poolId The target pool identifier.</span>
 409 |     | <span class='neutral'>  /// @param caller Caller of the external &#39;donate&#39; function.</span>
 410 |     | <span class='neutral'>  /// @param data A snapshot of memory which contains the new value for</span>
 411 |     | <span class='neutral'>  /// &#39;growth&#39;.</span>
 412 |     | <span class='neutral'>  /// This is sufficient to determine all of the donate parameters.</span>
 413 |     | <span class='neutral'>  event Donate(</span>
 414 |     | <span class='neutral'>    uint256 indexed poolId,</span>
 415 |     | <span class='neutral'>    address indexed caller,</span>
 416 |     | <span class='neutral'>    bytes32 data</span>
 417 |     | <span class='neutral'>  );</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='neutral'>  /// @notice Emitted when a swap is performed. The last two members of the</span>
 420 |     | <span class='neutral'>  /// curve are logged which are sufficient to uniquely characterize the state.</span>
 421 |     | <span class='neutral'>  /// In other words, if we know both &#39;qTarget&#39; and &#39;qOvershoot&#39; that appear at</span>
 422 |     | <span class='neutral'>  /// the end of the amended curve, then we can deterministically track the</span>
 423 |     | <span class='neutral'>  /// state of each pool without having to perform any numerical search.</span>
 424 |     | <span class='neutral'>  /// @param poolId The target pool identifier.</span>
 425 |     | <span class='neutral'>  /// @param caller Caller of the external &#39;swap&#39; function.</span>
 426 |     | <span class='neutral'>  /// @param data A snapshot of memory which includes the last two members of</span>
 427 |     | <span class='neutral'>  /// the amended curve (i.e., &#39;qOvershoot&#39; and &#39;qTarget&#39;). This is sufficient</span>
 428 |     | <span class='neutral'>  /// to reproduce the swap.</span>
 429 |     | <span class='neutral'>  event Swap(</span>
 430 |     | <span class='neutral'>    uint256 indexed poolId,</span>
 431 |     | <span class='neutral'>    address indexed caller,</span>
 432 |     | <span class='neutral'>    bytes32 data</span>
 433 |     | <span class='neutral'>  );</span>
 434 |     | <span class='neutral'></span>
 435 |     | <span class='neutral'>  /// @notice Emitted when a pending kernel is introduced for a nofeeswap pool.</span>
 436 |     | <span class='neutral'>  /// @param poolId The target pool identifier.</span>
 437 |     | <span class='neutral'>  /// @param caller Current owner of the target pool.</span>
 438 |     | <span class='neutral'>  /// @param data A snapshot of memory which includes &#39;staticParams&#39;, &#39;kernel&#39;,</span>
 439 |     | <span class='neutral'>  /// and &#39;kernelCompact&#39;.</span>
 440 |     | <span class='neutral'>  event ModifyKernel(</span>
 441 |     | <span class='neutral'>    uint256 indexed poolId,</span>
 442 |     | <span class='neutral'>    address indexed caller,</span>
 443 |     | <span class='neutral'>    bytes data</span>
 444 |     | <span class='neutral'>  );</span>
 445 |     | <span class='neutral'></span>
 446 |     | <span class='neutral'>  /// @notice Emitted when a nofeeswap pool growth portion is modified.</span>
 447 |     | <span class='neutral'>  /// @param poolId The target pool identifier.</span>
 448 |     | <span class='neutral'>  /// @param caller Current owner of the target pool.</span>
 449 |     | <span class='neutral'>  /// @param data A snapshot of memory which contains the new value for </span>
 450 |     | <span class='neutral'>  /// &#39;poolGrowthPortion&#39;.</span>
 451 |     | <span class='neutral'>  event ModifyPoolGrowthPortion(</span>
 452 |     | <span class='neutral'>    uint256 indexed poolId,</span>
 453 |     | <span class='neutral'>    address indexed caller,</span>
 454 |     | <span class='neutral'>    bytes32 data</span>
 455 |     | <span class='neutral'>  );</span>
 456 |     | <span class='neutral'></span>
 457 |     | <span class='neutral'>  /// @notice Emitted when the growth portions for a nofeeswap pool are synced</span>
 458 |     | <span class='neutral'>  /// with the protocol or sentinel contract.</span>
 459 |     | <span class='neutral'>  /// @param poolId The target pool identifier.</span>
 460 |     | <span class='neutral'>  /// @param caller Current owner of the target pool.</span>
 461 |     | <span class='neutral'>  /// @param data A snapshot of memory which contains the new values for </span>
 462 |     | <span class='neutral'>  /// &#39;maxPoolGrowthPortion&#39; and &#39;protocolGrowthPortion&#39;.</span>
 463 |     | <span class='neutral'>  event UpdateGrowthPortions(</span>
 464 |     | <span class='neutral'>    uint256 indexed poolId,</span>
 465 |     | <span class='neutral'>    address indexed caller,</span>
 466 |     | <span class='neutral'>    bytes32 data</span>
 467 |     | <span class='neutral'>  );</span>
 468 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/interfaces/ISentinel.sol</b>
<code>
  1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {X47} from &quot;../utilities/X47.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @notice Interface for the Sentinel contract.</span>
  7 |     | <span class='neutral'>interface ISentinel {</span>
  8 |     | <span class='neutral'>  /// @notice Gives the values of &#39;maxPoolGrowthPortion&#39; and</span>
  9 |     | <span class='neutral'>  /// &#39;protocolGrowthPortion&#39; when called by the protocol.</span>
 10 |     | <span class='neutral'>  /// @param sentinelInput Data passed to sentinel contract.</span>
 11 |     | <span class='neutral'>  /// @return maxPoolGrowthPortion The value for &#39;maxPoolGrowthPortion&#39;. If </span>
 12 |     | <span class='neutral'>  /// returns any value greater than &#39;oneX47&#39; then protocol slot&#39;s default</span>
 13 |     | <span class='neutral'>  /// values are used.</span>
 14 |     | <span class='neutral'>  /// @return protocolGrowthPortion The value for &#39;protocolGrowthPortion&#39;. If</span>
 15 |     | <span class='neutral'>  /// returns any value greater than &#39;oneX47&#39; then protocol slot&#39;s default</span>
 16 |     | <span class='neutral'>  /// values are used.</span>
 17 |     | <span class='neutral'>  function getGrowthPortions(</span>
 18 |     | <span class='neutral'>    bytes calldata sentinelInput</span>
 19 |     | <span class='neutral'>  ) external returns (</span>
 20 |     | <span class='neutral'>    X47 maxPoolGrowthPortion,</span>
 21 |     | <span class='neutral'>    X47 protocolGrowthPortion</span>
 22 |     | <span class='neutral'>  );</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>  /// @notice Called by nofeeswap to get authorization for a pool </span>
 25 |     | <span class='neutral'>  /// initialization.</span>
 26 |     | <span class='neutral'>  /// @param sentinelInput Data passed to sentinel contract which is a snapshot</span>
 27 |     | <span class='neutral'>  /// of nofeeswap&#39;s memory post initialization.</span>
 28 |     | <span class='neutral'>  function authorizeInitialization(</span>
 29 |     | <span class='neutral'>    bytes calldata sentinelInput</span>
 30 |     | <span class='neutral'>  ) external returns (bytes4 selector);</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>  /// @notice Called by nofeeswap to get authorization for modification of a </span>
 33 |     | <span class='neutral'>  /// pool growth portion.</span>
 34 |     | <span class='neutral'>  /// @param sentinelInput Data passed to sentinel contract which is a snapshot</span>
 35 |     | <span class='neutral'>  /// of nofeeswap&#39;s memory.</span>
 36 |     | <span class='neutral'>  function authorizeModificationOfPoolGrowthPortion(</span>
 37 |     | <span class='neutral'>    bytes calldata sentinelInput</span>
 38 |     | <span class='neutral'>  ) external returns (bytes4 selector);</span>
 39 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/interfaces/IStorageAccess.sol</b>
<code>
  1 |     | <span class='neutral'>// Credit to: https://github.com/Uniswap/v4-core/blob/</span>
  2 |     | <span class='neutral'>// 80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/IExtsload.sol</span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>/// @notice Interface to access any storage slot of Nofeeswap.</span>
  6 |     | <span class='neutral'>interface IStorageAccess {</span>
  7 |     | <span class='neutral'>  /// @notice Provides access to a single Nofeeswap storage slot.</span>
  8 |     | <span class='neutral'>  /// @param slot Key of slot to sload.</span>
  9 |     | <span class='neutral'>  /// @return value The value of the slot as bytes32</span>
 10 |     | <span class='neutral'>  function storageAccess(bytes32 slot) external view returns (bytes32 value);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>  /// @notice Provides access to consecutive Nofeeswap storage slots.</span>
 13 |     | <span class='neutral'>  /// @param startSlot Starting slot to be read.</span>
 14 |     | <span class='neutral'>  /// @param nSlots Number of slots to be read.</span>
 15 |     | <span class='neutral'>  /// @return values List of loaded values.</span>
 16 |     | <span class='neutral'>  function storageAccess(</span>
 17 |     | <span class='neutral'>    bytes32 startSlot,</span>
 18 |     | <span class='neutral'>    uint256 nSlots</span>
 19 |     | <span class='neutral'>  ) external view returns (bytes32[] memory values);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>  /// @notice Provides access to a given list of Nofeeswap storage slots.</span>
 22 |     | <span class='neutral'>  /// @param slots List of slots to sload from.</span>
 23 |     | <span class='neutral'>  /// @return values List of loaded values.</span>
 24 |     | <span class='neutral'>  function storageAccess(</span>
 25 |     | <span class='neutral'>    bytes32[] calldata slots</span>
 26 |     | <span class='neutral'>  ) external view returns (bytes32[] memory values);</span>
 27 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/interfaces/ITransientAccess.sol</b>
<code>
  1 |     | <span class='neutral'>// Credit to: https://github.com/Uniswap/v4-core/blob/</span>
  2 |     | <span class='neutral'>// 80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/IExttload.sol</span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>/// @notice Interface to access any transient storage slot of Nofeeswap.</span>
  6 |     | <span class='neutral'>interface ITransientAccess {</span>
  7 |     | <span class='neutral'>  /// @notice Provides access to a single Nofeeswap transient storage slot.</span>
  8 |     | <span class='neutral'>  /// @param slot Key of slot to tload.</span>
  9 |     | <span class='neutral'>  /// @return value The value of the slot as bytes32</span>
 10 |     | <span class='neutral'>  function transientAccess(bytes32 slot) external view returns (bytes32 value);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>  /// @notice Provides access to consecutive Nofeeswap transient storage slots.</span>
 13 |     | <span class='neutral'>  /// @param startSlot Starting slot to be read.</span>
 14 |     | <span class='neutral'>  /// @param nSlots Number of slots to be read.</span>
 15 |     | <span class='neutral'>  /// @return values List of loaded values.</span>
 16 |     | <span class='neutral'>  function transientAccess(</span>
 17 |     | <span class='neutral'>    bytes32 startSlot,</span>
 18 |     | <span class='neutral'>    uint256 nSlots</span>
 19 |     | <span class='neutral'>  ) external view returns (bytes32[] memory values);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>  /// @notice Provides access to a given list of Nofeeswap transient storage</span>
 22 |     | <span class='neutral'>  /// slots.</span>
 23 |     | <span class='neutral'>  /// @param slots List of slots to tload from.</span>
 24 |     | <span class='neutral'>  /// @return values List of loaded values.</span>
 25 |     | <span class='neutral'>  function transientAccess(</span>
 26 |     | <span class='neutral'>    bytes32[] calldata slots</span>
 27 |     | <span class='neutral'>  ) external view returns (bytes32[] memory values);</span>
 28 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/Calldata.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {</span>
   5 |     | <span class='neutral'>  _swapInput_,</span>
   6 |     | <span class='neutral'>  _endOfStaticParams_,</span>
   7 |     | <span class='neutral'>  _hookInputByteCount_,</span>
   8 |     | <span class='neutral'>  _zeroForOne_,</span>
   9 |     | <span class='neutral'>  setMsgSender,</span>
  10 |     | <span class='neutral'>  setPoolId,</span>
  11 |     | <span class='neutral'>  setSqrtOffset, </span>
  12 |     | <span class='neutral'>  setSqrtInverseOffset,</span>
  13 |     | <span class='neutral'>  setTag0,</span>
  14 |     | <span class='neutral'>  setTag1,</span>
  15 |     | <span class='neutral'>  setPoolGrowthPortion,</span>
  16 |     | <span class='neutral'>  setCurve,</span>
  17 |     | <span class='neutral'>  setHookData,</span>
  18 |     | <span class='neutral'>  setHookDataByteCount,</span>
  19 |     | <span class='neutral'>  setFreeMemoryPointer,</span>
  20 |     | <span class='neutral'>  setHookInputByteCount,</span>
  21 |     | <span class='neutral'>  setKernel,</span>
  22 |     | <span class='neutral'>  setLogPriceMin,</span>
  23 |     | <span class='neutral'>  setLogPriceMax,</span>
  24 |     | <span class='neutral'>  setLogPriceMinOffsetted,</span>
  25 |     | <span class='neutral'>  setLogPriceMaxOffsetted,</span>
  26 |     | <span class='neutral'>  setShares,</span>
  27 |     | <span class='neutral'>  setAmountSpecified,</span>
  28 |     | <span class='neutral'>  setLogPriceLimit,</span>
  29 |     | <span class='neutral'>  setCrossThreshold</span>
  30 |     | <span class='neutral'>} from &quot;./Memory.sol&quot;;</span>
  31 |     | <span class='neutral'>import {getLogOffsetFromPoolId, derivePoolId} from &quot;./PoolId.sol&quot;;</span>
  32 |     | <span class='neutral'>import {Index} from &quot;./Index.sol&quot;;</span>
  33 |     | <span class='neutral'>import {X47, oneX47} from &quot;./X47.sol&quot;;</span>
  34 |     | <span class='neutral'>import {</span>
  35 |     | <span class='neutral'>  X59,</span>
  36 |     | <span class='neutral'>  zeroX59,</span>
  37 |     | <span class='neutral'>  minLogOffset,</span>
  38 |     | <span class='neutral'>  maxLogOffset,</span>
  39 |     | <span class='neutral'>  sixteenX59,</span>
  40 |     | <span class='neutral'>  thirtyTwoX59</span>
  41 |     | <span class='neutral'>} from &quot;./X59.sol&quot;;</span>
  42 |     | <span class='neutral'>import {X127} from &quot;./X127.sol&quot;;</span>
  43 |     | <span class='neutral'>import {Tag} from &quot;./Tag.sol&quot;;</span>
  44 |     | <span class='neutral'>import {Curve} from &quot;./Curve.sol&quot;;</span>
  45 |     | <span class='neutral'>import {Kernel} from &quot;./Kernel.sol&quot;;</span>
  46 |     | <span class='neutral'>import {KernelCompact} from &quot;./KernelCompact.sol&quot;;</span>
  47 |     | <span class='neutral'>import {readStorage, getDynamicParamsSlot} from &quot;./Storage.sol&quot;;</span>
  48 |     | <span class='neutral'>import {</span>
  49 |     | <span class='neutral'>  PoolExists,</span>
  50 |     | <span class='neutral'>  LogOffsetOutOfRange,</span>
  51 |     | <span class='neutral'>  TagsOutOfOrder,</span>
  52 |     | <span class='neutral'>  InvalidGrowthPortion,</span>
  53 |     | <span class='neutral'>  LogPriceOutOfRange,</span>
  54 |     | <span class='neutral'>  InvalidNumberOfShares,</span>
  55 |     | <span class='neutral'>  CurveLengthIsZero,</span>
  56 |     | <span class='neutral'>  PoolIdCannotBeZero,</span>
  57 |     | <span class='neutral'>  HookDataTooLong</span>
  58 |     | <span class='neutral'>} from &quot;./Errors.sol&quot;;</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>/// @notice Reads the inputs of the external function &#39;initialize&#39; and places</span>
  61 |     | <span class='neutral'>/// each in the appropriate memory location. Then, the free memory pointer is</span>
  62 |     | <span class='neutral'>/// set.</span>
  63 |     | <span class='neutral'>/// @return kernelCompact The memory pointer for the given &#39;kernelCompact&#39;.</span>
  64 |     | <span class='neutral'>/// Observe that &#39;kernel&#39;, &#39;kernelCompact&#39;, &#39;curve&#39;, and &#39;hookData&#39; are loaded</span>
  65 |     | <span class='neutral'>/// in memory in this order. Hence, the place of &#39;kernelCompact&#39; is not</span>
  66 |     | <span class='neutral'>/// constant and depends on the size of &#39;kernel&#39;.</span>
  67 |     | <span class='unexecuted'>function readInitializeInput() view returns (KernelCompact kernelCompact) {</span>
  68 |     | <span class='neutral'>  // Calldata layout for &#39;initialize&#39; is as follows:</span>
  69 |     | <span class='neutral'>  //</span>
  70 |     | <span class='neutral'>  // &#39;0x00&#39;: &#39;INofeeswapDelegatee.initialize.selector&#39;</span>
  71 |     | <span class='neutral'>  // &#39;0x04&#39;: &#39;unsaltedPoolId&#39;</span>
  72 |     | <span class='neutral'>  // &#39;0x24&#39;: &#39;tag0&#39;</span>
  73 |     | <span class='neutral'>  // &#39;0x44&#39;: &#39;tag1&#39;</span>
  74 |     | <span class='neutral'>  // &#39;0x64&#39;: &#39;poolGrowthPortion&#39;</span>
  75 |     | <span class='neutral'>  // &#39;0x84&#39;: &#39;calldata pointer to the beginning of kernelCompactArray - 0x04&#39;</span>
  76 |     | <span class='neutral'>  // &#39;0xA4&#39;: &#39;calldata pointer to the beginning of curveArray - 0x04&#39;</span>
  77 |     | <span class='neutral'>  // &#39;0xC4&#39;: &#39;calldata pointer to the beginning of hookData - 0x04&#39;</span>
  78 |     | <span class='neutral'>  // &#39;0x04 + calldataload(0x84)&#39;: &#39;kernelCompactArray&#39;</span>
  79 |     | <span class='neutral'>  // &#39;0x04 + calldataload(0xA4)&#39;: &#39;curveArray&#39;</span>
  80 |     | <span class='neutral'>  // &#39;0x04 + calldataload(0xC4)&#39;: &#39;hookData&#39;</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>  // &#39;msg.sender&#39; is placed in memory to be passed to hook via calldata.</span>
  83 |     | <span class='unexecuted'>  setMsgSender(msg.sender);</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>  {</span>
  86 |     | <span class='neutral'>    // &#39;unsaltedPoolId&#39; is read from calldata and used to derive poolId which</span>
  87 |     | <span class='neutral'>    // will be placed in memory.</span>
  88 |     | <span class='unexecuted'>    uint256 poolId;</span>
  89 |     | <span class='neutral'>    {</span>
  90 |     | <span class='unexecuted'>      uint256 unsaltedPoolId;</span>
  91 |     | <span class='unexecuted'>      assembly {</span>
  92 |     | <span class='neutral'>        unsaltedPoolId := calldataload(4)</span>
  93 |     | <span class='neutral'>      }</span>
  94 |     | <span class='unexecuted'>      poolId = derivePoolId(unsaltedPoolId);</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='unexecuted'>    setPoolId(poolId);</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    // Check &#39;poolId != 0&#39;.</span>
  99 |     | <span class='unexecuted'>    require(poolId != 0, PoolIdCannotBeZero());</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    // Verifies whether the pool already exists or not.</span>
 102 |     | <span class='unexecuted'>    require(</span>
 103 |     | <span class='neutral'>      // The first slot of dynamic parameters contains the &#39;logPriceCurrent&#39;</span>
 104 |     | <span class='neutral'>      // which is always nonzero after initialization.</span>
 105 |     | <span class='unexecuted'>      readStorage(getDynamicParamsSlot(poolId)) == 0,</span>
 106 |     | <span class='unexecuted'>      PoolExists(poolId)</span>
 107 |     | <span class='neutral'>    );</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    // Throws if &#39;qOffset&#39; is out of range.</span>
 110 |     | <span class='unexecuted'>    X59 qOffset = getLogOffsetFromPoolId(poolId);</span>
 111 |     | <span class='unexecuted'>    require(qOffset &gt; minLogOffset, LogOffsetOutOfRange(qOffset));</span>
 112 |     | <span class='unexecuted'>    require(qOffset &lt; maxLogOffset, LogOffsetOutOfRange(qOffset));</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    // &#39;sqrtOffset&#39; and &#39;sqrtInverseOffset&#39; are calculated and stored in</span>
 115 |     | <span class='neutral'>    // memory.</span>
 116 |     | <span class='unexecuted'>    setSqrtOffset(qOffset.logToSqrtOffset());</span>
 117 |     | <span class='neutral'>    // The subtraction is safe due to the prior check.</span>
 118 |     | <span class='unexecuted'>    setSqrtInverseOffset((zeroX59 - qOffset).logToSqrtOffset());</span>
 119 |     | <span class='neutral'>  }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>  {</span>
 122 |     | <span class='neutral'>    // &#39;tag0&#39; is read from calldata and placed in memory.</span>
 123 |     | <span class='unexecuted'>    Tag tag0;</span>
 124 |     | <span class='unexecuted'>    assembly {</span>
 125 |     | <span class='neutral'>      tag0 := calldataload(36)</span>
 126 |     | <span class='neutral'>    }</span>
 127 |     | <span class='unexecuted'>    setTag0(tag0);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    // &#39;tag1&#39; is read from calldata and placed in memory.</span>
 130 |     | <span class='unexecuted'>    Tag tag1;</span>
 131 |     | <span class='unexecuted'>    assembly {</span>
 132 |     | <span class='neutral'>      tag1 := calldataload(68)</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='unexecuted'>    setTag1(tag1);</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    // Throws if the two tags are out of order.</span>
 137 |     | <span class='unexecuted'>    require(tag1 &gt; tag0, TagsOutOfOrder(tag0, tag1));</span>
 138 |     | <span class='neutral'>  }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>  {</span>
 141 |     | <span class='neutral'>    // &#39;poolGrowthPortion&#39; is read from calldata and placed in memory.</span>
 142 |     | <span class='unexecuted'>    X47 poolGrowthPortion;</span>
 143 |     | <span class='unexecuted'>    assembly {</span>
 144 |     | <span class='neutral'>      poolGrowthPortion := calldataload(100)</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'>    // Throws if &#39;poolGrowthPortion&#39; is greater than &#39;oneX47&#39;.</span>
 147 |     | <span class='unexecuted'>    require(</span>
 148 |     | <span class='unexecuted'>      poolGrowthPortion &lt;= oneX47,</span>
 149 |     | <span class='unexecuted'>      InvalidGrowthPortion(poolGrowthPortion)</span>
 150 |     | <span class='neutral'>    );</span>
 151 |     | <span class='unexecuted'>    setPoolGrowthPortion(poolGrowthPortion);</span>
 152 |     | <span class='neutral'>  }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>// Here we are reading &#39;kernelCompact&#39;, &#39;curve&#39;, and &#39;hookData&#39; from calldata and placing each in the appropriate memory location. The layout of these three inputs in calldata is dynamic and determined by the byte count of &#39;kernelCompact&#39; which is given in calldata. After placing these three inputs in memory, the free memory pointer is set accordingly to point to the end of the memory occupied by these three inputs.</span>
 155 |     | <span class='neutral'>  {</span>
 156 |     | <span class='neutral'>    // This is the pointer referring to the start of the kernel in memory.</span>
 157 |     | <span class='unexecuted'>    Kernel kernel;</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    // This value refers to the start of &#39;kernelCompactArray&#39; in calldata.</span>
 160 |     | <span class='unexecuted'>    uint256 kernelCompactStart;</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    // The byte count of &#39;kernelCompact&#39;.</span>
 163 |     | <span class='unexecuted'>    uint256 kernelCompactByteCount;</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='unexecuted'>    assembly {</span>
 166 |     | <span class='neutral'>      kernelCompactStart := add(0x04, calldataload(0x84))</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>      // kernel starts immediately after static parameters in memory.</span>
 169 |     | <span class='neutral'>      kernel := _endOfStaticParams_</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>      // The number of bytes to be occupied by &#39;kernelCompact&#39; in memory.</span>
 172 |     | <span class='neutral'>      kernelCompactByteCount := shl(5, calldataload(kernelCompactStart))</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>      // Each breakpoint occupies 80-bits in &#39;kernelCompact&#39;.</span>
 175 |     | <span class='neutral'>      // Each breakpoint occupies 512-bits in &#39;kernel&#39;.</span>
 176 |     | <span class='neutral'>      // Hence, &#39;512 * calldataload(kernelCompactStart) / 80&#39; is an upper </span>
 177 |     | <span class='neutral'>      // bound on the number of slots to be occupied by &#39;kernel&#39;.</span>
 178 |     | <span class='neutral'>      // And, &#39;32 * (512 * calldataload(kernelCompactStart) / 80)&#39; is an upper</span>
 179 |     | <span class='neutral'>      // bound on the number of bytes to be occupied by &#39;kernel&#39;.</span>
 180 |     | <span class='neutral'>      // Since &#39;kernelCompact&#39; comes immediately after &#39;kernel&#39; in memory, we</span>
 181 |     | <span class='neutral'>      // need to set its memory pointer accordingly.</span>
 182 |     | <span class='neutral'>      kernelCompact := add(kernel, shl(5, div(kernelCompactByteCount, 5))) // A memory pointer (address) where the compact kernel data will be stored in memory while kernalCompactStart is a calldata pointer (offset) where the compact kernel data starts in calldata. </span>
 183 |     | <span class='neutral'>//       Memory example:</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>// | kernel | kernelCompact | curve |</span>
 186 |     | <span class='neutral'>//             ^</span>
 187 |     | <span class='neutral'>//             pointer stored in kernelCompact</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='unexecuted'>    setKernel(kernel);</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>    {</span>
 193 |     | <span class='neutral'>      // This is the pointer referring to the start of the curve sequence in memory.</span>
 194 |     | <span class='unexecuted'>      Curve curve;</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>      // This value refers to the start of &#39;curveArray&#39; in calldata.</span>
 197 |     | <span class='unexecuted'>      uint256 curveStart;</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>      // The byte count of the curve sequence.</span>
 200 |     | <span class='unexecuted'>      uint256 curveByteCount;</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='unexecuted'>      assembly {</span>
 203 |     | <span class='neutral'>        curveStart := add(0x04, calldataload(0xA4))</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>        // &#39;curve&#39; appears after &#39;kernelCompact&#39; in memory.</span>
 206 |     | <span class='neutral'>        curve := add(kernelCompact, kernelCompactByteCount)</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>        // The number of bytes to be occupied by &#39;curve&#39;.</span>
 209 |     | <span class='neutral'>        curveByteCount := shl(5, calldataload(curveStart))</span>
 210 |     | <span class='neutral'>      }</span>
 211 |     | <span class='unexecuted'>      require(curveByteCount &gt;= 32, CurveLengthIsZero());</span>
 212 |     | <span class='unexecuted'>      setCurve(curve);</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>      {</span>
 215 |     | <span class='neutral'>        // This is the pointer referring to the start of hookData in memory.</span>
 216 |     | <span class='unexecuted'>        uint256 hookData;</span>
 217 |     | <span class='neutral'>        </span>
 218 |     | <span class='neutral'>        // The byte count of &#39;hookData&#39;.</span>
 219 |     | <span class='unexecuted'>        uint256 hookDataByteCount;</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>        // The total number of bytes of the memory snapshot to be used as</span>
 222 |     | <span class='neutral'>        // input for the hook contract.</span>
 223 |     | <span class='unexecuted'>        uint256 hookInputByteCount;</span>
 224 |     | <span class='neutral'>        </span>
 225 |     | <span class='neutral'>        // The free memory pointer which is set at the end.</span>
 226 |     | <span class='unexecuted'>        uint256 freeMemoryPointer;</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='unexecuted'>        assembly {</span>
 229 |     | <span class='neutral'>          // This value refers to the start of &#39;hookData&#39; in calldata (the</span>
 230 |     | <span class='neutral'>          // length slot).</span>
 231 |     | <span class='neutral'>          let hookDataStart := add(0x04, calldataload(0xC4))</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>          // &#39;hookData&#39; appears after &#39;curve&#39; in memory.</span>
 234 |     | <span class='neutral'>          // 8 bytes are added to seperate the curve sequence from hook data.</span>
 235 |     | <span class='neutral'>          hookData := add(add(curve, curveByteCount), 8)</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>          // The number of bytes to be occupied by &#39;hookData&#39;.</span>
 238 |     | <span class='neutral'>          hookDataByteCount := calldataload(hookDataStart)</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>          // &#39;freeMemoryPointer&#39; appears after &#39;hookData&#39; in memory.</span>
 241 |     | <span class='neutral'>          freeMemoryPointer := add(hookData, hookDataByteCount)</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>          // The total number of bytes to be given to the hook as input.</span>
 244 |     | <span class='neutral'>          // 32 is subtracted to exclude the &#39;_hookInputByteCount_&#39; slot.</span>
 245 |     | <span class='neutral'>          hookInputByteCount := sub(sub(freeMemoryPointer, _hookInputByteCount_), 32) </span>
 246 |     | <span class='neutral'>          // So the result is:</span>
 247 |     | <span class='neutral'>          // hookInputByteCount = actual number of bytes of input that the hook will receive</span>
 248 |     | <span class='neutral'>          // _hookInputByteCount_ = → starting memory location where hook-input snapshot begins</span>
 249 |     | <span class='neutral'>          // Simple mental picture</span>
 250 |     | <span class='neutral'>          // Memory:</span>
 251 |     | <span class='neutral'>          // [_hookInputByteCount_]   -&gt; slot storing length</span>
 252 |     | <span class='neutral'>          // [data_for_hook ..........]</span>
 253 |     | <span class='neutral'>          //                          ^</span>
 254 |     | <span class='neutral'>          //                          freeMemoryPointer</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>          // So calculation is basically:</span>
 258 |     | <span class='neutral'>          // payload_size = end_of_memory − start_of_payload − 32</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='neutral'>          // calldatacopy(source, destination, length)</span>
 262 |     | <span class='neutral'>          // Data is copied from calldata to memory.</span>
 263 |     | <span class='neutral'>          calldatacopy(</span>
 264 |     | <span class='neutral'>            kernelCompact,</span>
 265 |     | <span class='neutral'>            // The length slot of &#39;kernelCompactArray&#39; is excluded.</span>
 266 |     | <span class='neutral'>            add(kernelCompactStart, 32),</span>
 267 |     | <span class='neutral'>            kernelCompactByteCount</span>
 268 |     | <span class='neutral'>          )</span>
 269 |     | <span class='neutral'>          calldatacopy(</span>
 270 |     | <span class='neutral'>            curve,</span>
 271 |     | <span class='neutral'>            // The length slot of &#39;curveArray&#39; is excluded.</span>
 272 |     | <span class='neutral'>            add(curveStart, 32),</span>
 273 |     | <span class='neutral'>            curveByteCount</span>
 274 |     | <span class='neutral'>          )</span>
 275 |     | <span class='neutral'>          calldatacopy(</span>
 276 |     | <span class='neutral'>            hookData,</span>
 277 |     | <span class='neutral'>            // The length slot of &#39;hookData&#39; is excluded.</span>
 278 |     | <span class='neutral'>            add(hookDataStart, 32),</span>
 279 |     | <span class='neutral'>            hookDataByteCount</span>
 280 |     | <span class='neutral'>          )</span>
 281 |     | <span class='neutral'>        }</span>
 282 |     | <span class='unexecuted'>        setHookData(hookData);</span>
 283 |     | <span class='unexecuted'>        require(</span>
 284 |     | <span class='unexecuted'>          hookDataByteCount &lt;= type(uint16).max,</span>
 285 |     | <span class='unexecuted'>          HookDataTooLong(hookDataByteCount)</span>
 286 |     | <span class='neutral'>        );</span>
 287 |     | <span class='unexecuted'>        setHookDataByteCount(uint16(hookDataByteCount));</span>
 288 |     | <span class='unexecuted'>        setHookInputByteCount(hookInputByteCount);</span>
 289 |     | <span class='unexecuted'>        setFreeMemoryPointer(freeMemoryPointer);</span>
 290 |     | <span class='neutral'>      }</span>
 291 |     | <span class='neutral'>    }</span>
 292 |     | <span class='neutral'>  }</span>
 293 |     | <span class='neutral'>}</span>
 294 |     | <span class='neutral'>// for above Key points on why curve pointer can be set early while hook data pointers cannot:</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='neutral'>// setCurve(curve) is not writing the curve data,</span>
 297 |     | <span class='neutral'>// it is only storing the pointer (address) where the curve will exist in memory.</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>// So the sequence is:</span>
 300 |     | <span class='neutral'>// Calculate where curve WILL be stored </span>
 301 |     | <span class='neutral'>// Save that address using setCurve(curve)</span>
 302 |     | <span class='neutral'>// Later copy actual bytes into that address using calldatacopy</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='neutral'>// This is valid because the address is already correct even if the bytes are not yet copied.</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='neutral'>// Why hookData setters cannot always be moved</span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='neutral'>// Some setters depend on values that are only finalized after memory building, such as:</span>
 309 |     | <span class='neutral'>// hookInputByteCount</span>
 310 |     | <span class='neutral'>// freeMemoryPointer</span>
 311 |     | <span class='neutral'>// offsets computed after full layout</span>
 312 |     | <span class='neutral'></span>
 313 |     | <span class='neutral'>// Those may change during layout construction, so writing them early can produce wrong metadata.</span>
 314 |     | <span class='neutral'>// But curve pointer is deterministic immediately:</span>
 315 |     | <span class='neutral'>// curve = kernelCompact + kernelCompactByteCount</span>
 316 |     | <span class='neutral'></span>
 317 |     | <span class='neutral'>// This address does not change later → safe to store early.</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='neutral'>/// @notice Reads inputs of the external function &#39;modifyPosition&#39; and places</span>
 322 |     | <span class='neutral'>/// each in the appropriate memory location.</span>
 323 |     | <span class='unexecuted'>function readModifyPositionInput() view {</span>
 324 |     | <span class='neutral'>  // Calldata layout for &#39;modifyPosition&#39; is as follows:</span>
 325 |     | <span class='neutral'>  //</span>
 326 |     | <span class='neutral'>  // &#39;0x00&#39;: &#39;INofeeswapDelegatee.modifyPosition.selector&#39;</span>
 327 |     | <span class='neutral'>  // &#39;0x04&#39;: &#39;poolId&#39;</span>
 328 |     | <span class='neutral'>  // &#39;0x24&#39;: &#39;logPriceMin&#39;</span>
 329 |     | <span class='neutral'>  // &#39;0x44&#39;: &#39;logPriceMax&#39;</span>
 330 |     | <span class='neutral'>  // &#39;0x64&#39;: &#39;shares&#39;</span>
 331 |     | <span class='neutral'>  // &#39;0x84&#39;: &#39;calldata pointer to the beginning of hookData - 0x04&#39;</span>
 332 |     | <span class='neutral'>  // &#39;0x04 + calldataload(0x84)&#39;: &#39;hookData&#39;</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>  // &#39;msg.sender&#39; is placed in memory to be passed to hook as calldata.</span>
 335 |     | <span class='unexecuted'>  setMsgSender(msg.sender);</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='neutral'>  {</span>
 338 |     | <span class='neutral'>    // &#39;poolId&#39; is read from calldata and placed in memory.</span>
 339 |     | <span class='unexecuted'>    uint256 poolId;</span>
 340 |     | <span class='unexecuted'>    assembly {</span>
 341 |     | <span class='neutral'>      poolId := calldataload(4)</span>
 342 |     | <span class='neutral'>    }</span>
 343 |     | <span class='unexecuted'>    setPoolId(poolId);</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>    // Normalized log price values are calculated next.</span>
 346 |     | <span class='unexecuted'>    X59 shift = getLogOffsetFromPoolId(poolId) - sixteenX59;</span>
 347 |     | <span class='neutral'></span>
 348 |     | <span class='neutral'>    // &#39;logPriceMin&#39; is read from calldata and placed in memory.</span>
 349 |     | <span class='unexecuted'>    X59 logPriceMin;</span>
 350 |     | <span class='unexecuted'>    assembly {</span>
 351 |     | <span class='neutral'>      logPriceMin := calldataload(36)</span>
 352 |     | <span class='neutral'>    }</span>
 353 |     | <span class='unexecuted'>    setLogPriceMin(logPriceMin);</span>
 354 |     | <span class='unexecuted'>    X59 qMin = logPriceMin - shift;</span>
 355 |     | <span class='unexecuted'>    require(qMin &gt; zeroX59, LogPriceOutOfRange(logPriceMin));</span>
 356 |     | <span class='unexecuted'>    require(qMin &lt; thirtyTwoX59, LogPriceOutOfRange(logPriceMin));</span>
 357 |     | <span class='unexecuted'>    setLogPriceMinOffsetted(qMin);</span>
 358 |     | <span class='neutral'></span>
 359 |     | <span class='neutral'>    // &#39;logPriceMax&#39; is read from calldata and placed in memory.</span>
 360 |     | <span class='unexecuted'>    X59 logPriceMax;</span>
 361 |     | <span class='unexecuted'>    assembly {</span>
 362 |     | <span class='neutral'>      logPriceMax := calldataload(68)</span>
 363 |     | <span class='neutral'>    }</span>
 364 |     | <span class='unexecuted'>    setLogPriceMax(logPriceMax);</span>
 365 |     | <span class='unexecuted'>    X59 qMax = logPriceMax - shift;</span>
 366 |     | <span class='unexecuted'>    require(qMax &gt; zeroX59, LogPriceOutOfRange(logPriceMax));</span>
 367 |     | <span class='unexecuted'>    require(qMax &lt; thirtyTwoX59, LogPriceOutOfRange(logPriceMax));</span>
 368 |     | <span class='unexecuted'>    setLogPriceMaxOffsetted(qMax);</span>
 369 |     | <span class='neutral'>  }</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>  {</span>
 372 |     | <span class='neutral'>    // The number of shares to be minted/burned is read from calldata capped by</span>
 373 |     | <span class='neutral'>    // &#39;-type(int128).max&#39; and &#39;+type(int128).max&#39;, and placed in memory.</span>
 374 |     | <span class='unexecuted'>    int256 shares;</span>
 375 |     | <span class='unexecuted'>    assembly {</span>
 376 |     | <span class='neutral'>      shares := calldataload(100)</span>
 377 |     | <span class='neutral'>    }</span>
 378 |     | <span class='neutral'>    // Checks the number of shares.</span>
 379 |     | <span class='unexecuted'>    require(shares &lt;= type(int128).max, InvalidNumberOfShares(shares));</span>
 380 |     | <span class='unexecuted'>    require(shares &gt;= 0 - type(int128).max, InvalidNumberOfShares(shares));</span>
 381 |     | <span class='unexecuted'>    require(shares != 0, InvalidNumberOfShares(shares));</span>
 382 |     | <span class='unexecuted'>    setShares(shares);</span>
 383 |     | <span class='neutral'>  }</span>
 384 |     | <span class='neutral'></span>
 385 |     | <span class='neutral'>  {</span>
 386 |     | <span class='neutral'>    // This is the pointer referring to the start of the curve sequence in</span>
 387 |     | <span class='neutral'>    // memory.</span>
 388 |     | <span class='unexecuted'>    Curve curve;</span>
 389 |     | <span class='neutral'></span>
 390 |     | <span class='neutral'>    // This is the pointer referring to the start of hookData in memory.</span>
 391 |     | <span class='unexecuted'>    uint256 hookData;</span>
 392 |     | <span class='neutral'></span>
 393 |     | <span class='neutral'>    // The byte count of &#39;hookData&#39;.</span>
 394 |     | <span class='unexecuted'>    uint256 hookDataByteCount;</span>
 395 |     | <span class='neutral'></span>
 396 |     | <span class='neutral'>    // The total number of bytes of the memory snapshot to be used as input for</span>
 397 |     | <span class='neutral'>    // the hook contract.</span>
 398 |     | <span class='unexecuted'>    uint256 hookInputByteCount;</span>
 399 |     | <span class='neutral'></span>
 400 |     | <span class='neutral'>    // The free memory pointer which is set at the end.</span>
 401 |     | <span class='unexecuted'>    uint256 freeMemoryPointer;</span>
 402 |     | <span class='neutral'></span>
 403 |     | <span class='unexecuted'>    assembly {</span>
 404 |     | <span class='neutral'>      // This value refers to the start of &#39;hookData&#39; in calldata (the length</span>
 405 |     | <span class='neutral'>      // slot).</span>
 406 |     | <span class='neutral'>      let hookDataStart := add(0x04, calldataload(0x84))</span>
 407 |     | <span class='neutral'></span>
 408 |     | <span class='neutral'>      // 32 bytes are reserved for the first slot of the curve sequence and no</span>
 409 |     | <span class='neutral'>      // member of kernel is loaded.</span>
 410 |     | <span class='neutral'>      curve := _endOfStaticParams_</span>
 411 |     | <span class='neutral'></span>
 412 |     | <span class='neutral'>      // &#39;hookData&#39; appears immediately after.</span>
 413 |     | <span class='neutral'>      hookData := add(_endOfStaticParams_, 32)</span>
 414 |     | <span class='neutral'></span>
 415 |     | <span class='neutral'>      // The number of bytes to be occupied by &#39;hookData&#39;.</span>
 416 |     | <span class='neutral'>      hookDataByteCount := calldataload(hookDataStart)</span>
 417 |     | <span class='neutral'></span>
 418 |     | <span class='neutral'>      // &#39;freeMemoryPointer&#39; appears after &#39;hookData&#39; in memory.</span>
 419 |     | <span class='neutral'>      freeMemoryPointer := add(hookData, hookDataByteCount)</span>
 420 |     | <span class='neutral'></span>
 421 |     | <span class='neutral'>      // The total number of bytes to be given to the hook as input.</span>
 422 |     | <span class='neutral'>      hookInputByteCount := sub(sub(freeMemoryPointer, _hookInputByteCount_), 32)</span>
 423 |     | <span class='neutral'></span>
 424 |     | <span class='neutral'>      // Data is copied from calldata to memory.</span>
 425 |     | <span class='neutral'>      calldatacopy(</span>
 426 |     | <span class='neutral'>        hookData,</span>
 427 |     | <span class='neutral'>        // The length slot of &#39;hookData&#39; is excluded.</span>
 428 |     | <span class='neutral'>        add(hookDataStart, 32),</span>
 429 |     | <span class='neutral'>        hookDataByteCount</span>
 430 |     | <span class='neutral'>      )</span>
 431 |     | <span class='neutral'>    }</span>
 432 |     | <span class='unexecuted'>    setCurve(curve);</span>
 433 |     | <span class='unexecuted'>    setHookData(hookData);</span>
 434 |     | <span class='unexecuted'>    require(</span>
 435 |     | <span class='unexecuted'>      hookDataByteCount &lt;= type(uint16).max,</span>
 436 |     | <span class='unexecuted'>      HookDataTooLong(hookDataByteCount)</span>
 437 |     | <span class='neutral'>    );</span>
 438 |     | <span class='unexecuted'>    setHookDataByteCount(uint16(hookDataByteCount));</span>
 439 |     | <span class='unexecuted'>    setHookInputByteCount(hookInputByteCount);</span>
 440 |     | <span class='unexecuted'>    setFreeMemoryPointer(freeMemoryPointer);</span>
 441 |     | <span class='neutral'>  }</span>
 442 |     | <span class='neutral'>}</span>
 443 |     | <span class='neutral'></span>
 444 |     | <span class='neutral'>/// @notice Reads inputs of the external function &#39;donate&#39; and places each in</span>
 445 |     | <span class='neutral'>/// the appropriate memory location.</span>
 446 |     | <span class='unexecuted'>function readDonateInput() view {</span>
 447 |     | <span class='neutral'>  // Calldata layout for &#39;donate&#39; is as follows:</span>
 448 |     | <span class='neutral'>  //</span>
 449 |     | <span class='neutral'>  // &#39;0x00&#39;: &#39;INofeeswapDelegatee.donate.selector&#39;</span>
 450 |     | <span class='neutral'>  // &#39;0x04&#39;: &#39;poolId&#39;</span>
 451 |     | <span class='neutral'>  // &#39;0x24&#39;: &#39;shares&#39;</span>
 452 |     | <span class='neutral'>  // &#39;0x44&#39;: &#39;calldata pointer to the beginning of hookData - 0x04&#39;</span>
 453 |     | <span class='neutral'>  // &#39;0x04 + calldataload(0x44)&#39;: &#39;hookData&#39;</span>
 454 |     | <span class='neutral'></span>
 455 |     | <span class='neutral'>  // &#39;msg.sender&#39; is placed in memory to be passed to hook as calldata.</span>
 456 |     | <span class='unexecuted'>  setMsgSender(msg.sender);</span>
 457 |     | <span class='neutral'></span>
 458 |     | <span class='neutral'>  {</span>
 459 |     | <span class='neutral'>    // &#39;poolId&#39; is read from calldata and placed in memory.</span>
 460 |     | <span class='unexecuted'>    uint256 poolId;</span>
 461 |     | <span class='unexecuted'>    assembly {</span>
 462 |     | <span class='neutral'>      poolId := calldataload(4)</span>
 463 |     | <span class='neutral'>    }</span>
 464 |     | <span class='unexecuted'>    setPoolId(poolId);</span>
 465 |     | <span class='neutral'>  }</span>
 466 |     | <span class='neutral'></span>
 467 |     | <span class='neutral'>  {</span>
 468 |     | <span class='neutral'>    // The number of shares to be minted/burned is read from calldata capped by</span>
 469 |     | <span class='neutral'>    // &#39;+type(int128).max&#39;, and placed in memory.</span>
 470 |     | <span class='unexecuted'>    int256 shares;</span>
 471 |     | <span class='unexecuted'>    assembly {</span>
 472 |     | <span class='neutral'>      shares := calldataload(36)</span>
 473 |     | <span class='neutral'>    }</span>
 474 |     | <span class='unexecuted'>    require(shares &lt;= type(int128).max, InvalidNumberOfShares(shares));</span>
 475 |     | <span class='unexecuted'>    require(shares &gt; 0, InvalidNumberOfShares(shares));</span>
 476 |     | <span class='unexecuted'>    setShares(shares);</span>
 477 |     | <span class='neutral'>  }</span>
 478 |     | <span class='neutral'></span>
 479 |     | <span class='neutral'>  {</span>
 480 |     | <span class='neutral'>    // This is the pointer referring to the start of the curve sequence in</span>
 481 |     | <span class='neutral'>    // memory.</span>
 482 |     | <span class='unexecuted'>    Curve curve;</span>
 483 |     | <span class='neutral'></span>
 484 |     | <span class='neutral'>    // This is the pointer referring to the start of hookData in memory.</span>
 485 |     | <span class='unexecuted'>    uint256 hookData;</span>
 486 |     | <span class='neutral'></span>
 487 |     | <span class='neutral'>    // The byte count of &#39;hookData&#39;.</span>
 488 |     | <span class='unexecuted'>    uint256 hookDataByteCount;</span>
 489 |     | <span class='neutral'></span>
 490 |     | <span class='neutral'>    // The total number of bytes of the memory snapshot to be used as input for</span>
 491 |     | <span class='neutral'>    // the hook contract.</span>
 492 |     | <span class='unexecuted'>    uint256 hookInputByteCount;</span>
 493 |     | <span class='neutral'></span>
 494 |     | <span class='neutral'>    // The free memory pointer which is set at the end.</span>
 495 |     | <span class='unexecuted'>    uint256 freeMemoryPointer;</span>
 496 |     | <span class='neutral'></span>
 497 |     | <span class='unexecuted'>    assembly {</span>
 498 |     | <span class='neutral'>      // This value refers to the start of &#39;hookData&#39; in calldata (the length</span>
 499 |     | <span class='neutral'>      // slot).</span>
 500 |     | <span class='neutral'>      let hookDataStart := add(0x04, calldataload(0x44))</span>
 501 |     | <span class='neutral'></span>
 502 |     | <span class='neutral'>      // 32 bytes are reserved for the first slot of the curve sequence and no</span>
 503 |     | <span class='neutral'>      // member of kernel is loaded.</span>
 504 |     | <span class='neutral'>      curve := _endOfStaticParams_</span>
 505 |     | <span class='neutral'></span>
 506 |     | <span class='neutral'>      // &#39;hookData&#39; appears immediately after.</span>
 507 |     | <span class='neutral'>      hookData := add(_endOfStaticParams_, 32)</span>
 508 |     | <span class='neutral'></span>
 509 |     | <span class='neutral'>      // The number of bytes to be occupied by &#39;hookData&#39;.</span>
 510 |     | <span class='neutral'>      hookDataByteCount := calldataload(hookDataStart)</span>
 511 |     | <span class='neutral'></span>
 512 |     | <span class='neutral'>      // &#39;freeMemoryPointer&#39; appears after &#39;hookData&#39; in memory.</span>
 513 |     | <span class='neutral'>      freeMemoryPointer := add(hookData, hookDataByteCount)</span>
 514 |     | <span class='neutral'></span>
 515 |     | <span class='neutral'>      // The total number of bytes to be given to the hook as input.</span>
 516 |     | <span class='neutral'>      hookInputByteCount := </span>
 517 |     | <span class='neutral'>        sub(sub(freeMemoryPointer, _hookInputByteCount_), 32)</span>
 518 |     | <span class='neutral'></span>
 519 |     | <span class='neutral'>      // Data is copied from calldata to memory.</span>
 520 |     | <span class='neutral'>      calldatacopy(</span>
 521 |     | <span class='neutral'>        hookData,</span>
 522 |     | <span class='neutral'>        // The length slot of &#39;hookData&#39; is excluded.</span>
 523 |     | <span class='neutral'>        add(hookDataStart, 32),</span>
 524 |     | <span class='neutral'>        hookDataByteCount</span>
 525 |     | <span class='neutral'>      )</span>
 526 |     | <span class='neutral'>    }</span>
 527 |     | <span class='unexecuted'>    setCurve(curve);</span>
 528 |     | <span class='unexecuted'>    setHookData(hookData);</span>
 529 |     | <span class='unexecuted'>    require(</span>
 530 |     | <span class='unexecuted'>      hookDataByteCount &lt;= type(uint16).max,</span>
 531 |     | <span class='unexecuted'>      HookDataTooLong(hookDataByteCount)</span>
 532 |     | <span class='neutral'>    );</span>
 533 |     | <span class='unexecuted'>    setHookDataByteCount(uint16(hookDataByteCount));</span>
 534 |     | <span class='unexecuted'>    setHookInputByteCount(hookInputByteCount);</span>
 535 |     | <span class='unexecuted'>    setFreeMemoryPointer(freeMemoryPointer);</span>
 536 |     | <span class='neutral'>  }</span>
 537 |     | <span class='neutral'>}</span>
 538 |     | <span class='neutral'></span>
 539 |     | <span class='neutral'>/// @notice Reads the inputs of the external function &#39;modifyKernel&#39; and</span>
 540 |     | <span class='neutral'>/// places each in the appropriate memory location.</span>
 541 |     | <span class='neutral'>/// @return kernelCompact The memory pointer for the given &#39;kernelCompact&#39;.</span>
 542 |     | <span class='neutral'>/// Observe that &#39;kernel&#39;, &#39;kernelCompact&#39;, &#39;curve&#39;, and &#39;hookData&#39; are loaded</span>
 543 |     | <span class='neutral'>/// in memory in this order. Hence, the place of &#39;kernelCompact&#39; is not</span>
 544 |     | <span class='neutral'>/// constant and depends on the size of &#39;kernel&#39;.</span>
 545 |     | <span class='unexecuted'>function readModifyKernelInput() view returns (KernelCompact kernelCompact) {</span>
 546 |     | <span class='neutral'>  // Calldata layout for &#39;modifyKernel&#39; is as follows:</span>
 547 |     | <span class='neutral'>  //</span>
 548 |     | <span class='neutral'>  // &#39;0x00&#39;: &#39;INofeeswapDelegatee.modifyKernel.selector&#39;</span>
 549 |     | <span class='neutral'>  // &#39;0x04&#39;: &#39;poolId&#39;</span>
 550 |     | <span class='neutral'>  // &#39;0x24&#39;: &#39;calldata pointer to the beginning of kernelCompactArray - 0x04&#39;</span>
 551 |     | <span class='neutral'>  // &#39;0x44&#39;: &#39;calldata pointer to the beginning of hookData - 0x04&#39;</span>
 552 |     | <span class='neutral'>  // &#39;0x04 + calldataload(0x24)&#39;: &#39;kernelCompactArray&#39;</span>
 553 |     | <span class='neutral'>  // &#39;0x04 + calldataload(0x44)&#39;: &#39;hookData&#39;</span>
 554 |     | <span class='neutral'></span>
 555 |     | <span class='neutral'>  // &#39;msg.sender&#39; is placed in memory to be passed to hook as calldata.</span>
 556 |     | <span class='unexecuted'>  setMsgSender(msg.sender);</span>
 557 |     | <span class='neutral'></span>
 558 |     | <span class='neutral'>  // &#39;poolId&#39; is read from calldata and placed in memory.</span>
 559 |     | <span class='unexecuted'>  uint256 poolId;</span>
 560 |     | <span class='unexecuted'>  assembly {</span>
 561 |     | <span class='neutral'>    poolId := calldataload(4)</span>
 562 |     | <span class='neutral'>  }</span>
 563 |     | <span class='unexecuted'>  setPoolId(poolId);</span>
 564 |     | <span class='neutral'></span>
 565 |     | <span class='neutral'>  // This is the pointer referring to the start of the kernel in memory.</span>
 566 |     | <span class='unexecuted'>  Kernel kernel;</span>
 567 |     | <span class='neutral'></span>
 568 |     | <span class='neutral'>  // This value refers to the start of &#39;kernelCompactArray&#39; in calldata.</span>
 569 |     | <span class='unexecuted'>  uint256 kernelCompactStart;</span>
 570 |     | <span class='neutral'></span>
 571 |     | <span class='neutral'>  // The byte count of &#39;kernelCompact&#39;.</span>
 572 |     | <span class='unexecuted'>  uint256 kernelCompactByteCount;</span>
 573 |     | <span class='neutral'></span>
 574 |     | <span class='unexecuted'>  assembly {</span>
 575 |     | <span class='neutral'>    kernelCompactStart := add(0x04, calldataload(0x24))</span>
 576 |     | <span class='neutral'></span>
 577 |     | <span class='neutral'>    // kernel starts immediately after static parameters in memory.</span>
 578 |     | <span class='neutral'>    kernel := _endOfStaticParams_</span>
 579 |     | <span class='neutral'></span>
 580 |     | <span class='neutral'>    // The number of bytes to be occupied by &#39;kernelCompact&#39;.</span>
 581 |     | <span class='neutral'>    kernelCompactByteCount := shl(5, calldataload(kernelCompactStart))</span>
 582 |     | <span class='neutral'></span>
 583 |     | <span class='neutral'>    // Each breakpoint occupies 80-bits in kernelCompact.</span>
 584 |     | <span class='neutral'>    // Each breakpoint occupies 512-bits in kernel.</span>
 585 |     | <span class='neutral'>    // Hence, &#39;512 * calldataload(kernelCompactStart) / 80&#39; is an upper </span>
 586 |     | <span class='neutral'>    // bound for the number of slots to be occupied by &#39;kernel&#39;.</span>
 587 |     | <span class='neutral'>    // And, &#39;32 * (512 * calldataload(kernelCompactStart) / 80)&#39; is an upper</span>
 588 |     | <span class='neutral'>    // bound for the number of bytes to be occupied by &#39;kernel&#39;.</span>
 589 |     | <span class='neutral'>    // Since &#39;kernelCompact&#39; comes immediately after &#39;kernel&#39; in memory, we</span>
 590 |     | <span class='neutral'>    // need to set its memory pointer accordingly:</span>
 591 |     | <span class='neutral'>    kernelCompact := add(kernel, shl(5, div(kernelCompactByteCount, 5)))</span>
 592 |     | <span class='neutral'>  }</span>
 593 |     | <span class='unexecuted'>  setKernel(kernel);</span>
 594 |     | <span class='neutral'></span>
 595 |     | <span class='neutral'>  // This is the pointer referring to the start of hookData in memory.</span>
 596 |     | <span class='unexecuted'>  uint256 hookData;</span>
 597 |     | <span class='neutral'>  </span>
 598 |     | <span class='neutral'>  // The byte count of &#39;hookData&#39;.</span>
 599 |     | <span class='unexecuted'>  uint256 hookDataByteCount;</span>
 600 |     | <span class='neutral'></span>
 601 |     | <span class='neutral'>  // The total number of bytes of the memory snapshot to be used as input for</span>
 602 |     | <span class='neutral'>  // the hook contract.</span>
 603 |     | <span class='unexecuted'>  uint256 hookInputByteCount;</span>
 604 |     | <span class='neutral'>  </span>
 605 |     | <span class='neutral'>  // The free memory pointer which is set at the end.</span>
 606 |     | <span class='unexecuted'>  uint256 freeMemoryPointer;</span>
 607 |     | <span class='neutral'></span>
 608 |     | <span class='unexecuted'>  assembly {</span>
 609 |     | <span class='neutral'>    // This value refers to the start of &#39;hookData&#39; in calldata (the length</span>
 610 |     | <span class='neutral'>    // slot).</span>
 611 |     | <span class='neutral'>    let hookDataStart := add(0x04, calldataload(0x44))</span>
 612 |     | <span class='neutral'></span>
 613 |     | <span class='neutral'>    // &#39;hookData&#39; appears after &#39;kernelCompact&#39; in memory.</span>
 614 |     | <span class='neutral'>    hookData := add(kernelCompact, kernelCompactByteCount)</span>
 615 |     | <span class='neutral'></span>
 616 |     | <span class='neutral'>    // The number of bytes to be occupied by &#39;hookData&#39;.</span>
 617 |     | <span class='neutral'>    hookDataByteCount := calldataload(hookDataStart)</span>
 618 |     | <span class='neutral'></span>
 619 |     | <span class='neutral'>    // &#39;freeMemoryPointer&#39; appears after &#39;hookData&#39; in memory.</span>
 620 |     | <span class='neutral'>    freeMemoryPointer := add(hookData, hookDataByteCount)</span>
 621 |     | <span class='neutral'></span>
 622 |     | <span class='neutral'>    // The total number of bytes to be given to the hook as input.</span>
 623 |     | <span class='neutral'>    // 32 is subtracted to exclude the &#39;_hookInputByteCount_&#39; slot.</span>
 624 |     | <span class='neutral'>    hookInputByteCount := </span>
 625 |     | <span class='neutral'>      sub(sub(freeMemoryPointer, _hookInputByteCount_), 32)</span>
 626 |     | <span class='neutral'></span>
 627 |     | <span class='neutral'>    // Data is copied from calldata to memory.</span>
 628 |     | <span class='neutral'>    calldatacopy(</span>
 629 |     | <span class='neutral'>      kernelCompact,</span>
 630 |     | <span class='neutral'>      // The length slot of &#39;kernelCompactArray&#39; is excluded.</span>
 631 |     | <span class='neutral'>      add(kernelCompactStart, 32),</span>
 632 |     | <span class='neutral'>      kernelCompactByteCount</span>
 633 |     | <span class='neutral'>    )</span>
 634 |     | <span class='neutral'>    calldatacopy(</span>
 635 |     | <span class='neutral'>      hookData,</span>
 636 |     | <span class='neutral'>      // The length slot of &#39;hookData&#39; is excluded.</span>
 637 |     | <span class='neutral'>      add(hookDataStart, 32),</span>
 638 |     | <span class='neutral'>      hookDataByteCount</span>
 639 |     | <span class='neutral'>    )</span>
 640 |     | <span class='neutral'>  }</span>
 641 |     | <span class='unexecuted'>  setHookData(hookData);</span>
 642 |     | <span class='unexecuted'>  require(</span>
 643 |     | <span class='unexecuted'>    hookDataByteCount &lt;= type(uint16).max,</span>
 644 |     | <span class='unexecuted'>    HookDataTooLong(hookDataByteCount)</span>
 645 |     | <span class='neutral'>  );</span>
 646 |     | <span class='unexecuted'>  setHookDataByteCount(uint16(hookDataByteCount));</span>
 647 |     | <span class='unexecuted'>  setHookInputByteCount(hookInputByteCount);</span>
 648 |     | <span class='unexecuted'>  setFreeMemoryPointer(freeMemoryPointer);</span>
 649 |     | <span class='neutral'>}</span>
 650 |     | <span class='neutral'></span>
 651 |     | <span class='neutral'>/// @notice Reads inputs of the external function &#39;modifyPoolGrowthPortion&#39; and</span>
 652 |     | <span class='neutral'>/// places each in the appropriate memory location.</span>
 653 |     | <span class='unexecuted'>function readModifyPoolGrowthPortionInput() view {</span>
 654 |     | <span class='neutral'>  // Calldata layout for &#39;modifyKernel&#39; is as follows:</span>
 655 |     | <span class='neutral'>  //</span>
 656 |     | <span class='neutral'>  // &#39;0x00&#39;: &#39;INofeeswapDelegatee.modifyPoolGrowthPortion.selector&#39;</span>
 657 |     | <span class='neutral'>  // &#39;0x04&#39;: &#39;poolId&#39;</span>
 658 |     | <span class='neutral'>  // &#39;0x24&#39;: &#39;poolGrowthPortion&#39;</span>
 659 |     | <span class='neutral'></span>
 660 |     | <span class='neutral'>  // &#39;msg.sender&#39; is placed in memory to be passed to sentinel as calldata.</span>
 661 |     | <span class='unexecuted'>  setMsgSender(msg.sender);</span>
 662 |     | <span class='neutral'></span>
 663 |     | <span class='neutral'>  // &#39;poolId&#39; is read from calldata and placed in memory.</span>
 664 |     | <span class='unexecuted'>  uint256 poolId;</span>
 665 |     | <span class='unexecuted'>  assembly {</span>
 666 |     | <span class='neutral'>    poolId := calldataload(4)</span>
 667 |     | <span class='neutral'>  }</span>
 668 |     | <span class='unexecuted'>  setPoolId(poolId);</span>
 669 |     | <span class='neutral'></span>
 670 |     | <span class='neutral'>  {</span>
 671 |     | <span class='neutral'>    // &#39;poolGrowthPortion&#39; is read from calldata and placed in memory.</span>
 672 |     | <span class='unexecuted'>    X47 poolGrowthPortion;</span>
 673 |     | <span class='unexecuted'>    assembly {</span>
 674 |     | <span class='neutral'>      poolGrowthPortion := calldataload(36)</span>
 675 |     | <span class='neutral'>    }</span>
 676 |     | <span class='unexecuted'>    require(</span>
 677 |     | <span class='unexecuted'>      poolGrowthPortion &lt;= oneX47,</span>
 678 |     | <span class='unexecuted'>      InvalidGrowthPortion(poolGrowthPortion)</span>
 679 |     | <span class='neutral'>    );</span>
 680 |     | <span class='unexecuted'>    setPoolGrowthPortion(poolGrowthPortion);</span>
 681 |     | <span class='neutral'>  }</span>
 682 |     | <span class='neutral'></span>
 683 |     | <span class='neutral'>  // The total number of bytes of the memory snapshot to be used as input for</span>
 684 |     | <span class='neutral'>  // the sentinel contract.</span>
 685 |     | <span class='unexecuted'>  uint256 hookInputByteCount;</span>
 686 |     | <span class='unexecuted'>  assembly {</span>
 687 |     | <span class='neutral'>    // The total number of bytes to be given to the sentinel as input.</span>
 688 |     | <span class='neutral'>    hookInputByteCount := </span>
 689 |     | <span class='neutral'>      sub(sub(_endOfStaticParams_, _hookInputByteCount_), 32)</span>
 690 |     | <span class='neutral'>  }</span>
 691 |     | <span class='unexecuted'>  setHookInputByteCount(hookInputByteCount);</span>
 692 |     | <span class='neutral'></span>
 693 |     | <span class='neutral'>  // Free memory appears immediately after staticParams.</span>
 694 |     | <span class='unexecuted'>  setFreeMemoryPointer(_endOfStaticParams_);</span>
 695 |     | <span class='neutral'>}</span>
 696 |     | <span class='neutral'></span>
 697 |     | <span class='neutral'>/// @notice Reads inputs of the external function &#39;updateGrowthPortions&#39; and</span>
 698 |     | <span class='neutral'>/// places each in the appropriate memory location.</span>
 699 |     | <span class='unexecuted'>function readUpdateGrowthPortionsInput() pure {</span>
 700 |     | <span class='neutral'>  // Calldata layout for &#39;updateGrowthPortions&#39; is as follows:</span>
 701 |     | <span class='neutral'>  //</span>
 702 |     | <span class='neutral'>  // &#39;0x00&#39;: &#39;INofeeswapDelegatee.updateGrowthPortions.selector&#39;</span>
 703 |     | <span class='neutral'>  // &#39;0x04&#39;: &#39;poolId&#39;</span>
 704 |     | <span class='neutral'></span>
 705 |     | <span class='neutral'>  // &#39;poolId&#39; is read from calldata and placed in memory.</span>
 706 |     | <span class='unexecuted'>  uint256 poolId;</span>
 707 |     | <span class='unexecuted'>  assembly {</span>
 708 |     | <span class='neutral'>    poolId := calldataload(4)</span>
 709 |     | <span class='neutral'>  }</span>
 710 |     | <span class='unexecuted'>  setPoolId(poolId);</span>
 711 |     | <span class='neutral'></span>
 712 |     | <span class='neutral'>  // The total number of bytes of the memory snapshot to be used as input for</span>
 713 |     | <span class='neutral'>  // the sentinel contract.</span>
 714 |     | <span class='unexecuted'>  uint256 hookInputByteCount;</span>
 715 |     | <span class='unexecuted'>  assembly {</span>
 716 |     | <span class='neutral'>    // The total number of bytes to be given to the sentinel as input.</span>
 717 |     | <span class='neutral'>    hookInputByteCount := </span>
 718 |     | <span class='neutral'>      sub(sub(_endOfStaticParams_, _hookInputByteCount_), 32)</span>
 719 |     | <span class='neutral'>  }</span>
 720 |     | <span class='unexecuted'>  setHookInputByteCount(hookInputByteCount);</span>
 721 |     | <span class='neutral'></span>
 722 |     | <span class='neutral'>  // Free memory appears immediately after staticParams.</span>
 723 |     | <span class='unexecuted'>  setFreeMemoryPointer(_endOfStaticParams_);</span>
 724 |     | <span class='neutral'>}</span>
 725 |     | <span class='neutral'></span>
 726 |     | <span class='neutral'>/// @notice Reads the inputs of the external function &#39;swap&#39; and places each in</span>
 727 |     | <span class='neutral'>/// the appropriate memory location.</span>
 728 |     | <span class='unexecuted'>function readSwapInput() view {</span>
 729 |     | <span class='neutral'>  // Calldata layout for &#39;swap&#39; is as follows:</span>
 730 |     | <span class='neutral'>  //</span>
 731 |     | <span class='neutral'>  // &#39;0x00&#39;: &#39;INofeeswap.swap.selector&#39;</span>
 732 |     | <span class='neutral'>  // &#39;0x04&#39;: &#39;poolId&#39;</span>
 733 |     | <span class='neutral'>  // &#39;0x24&#39;: &#39;amountSpecified&#39;</span>
 734 |     | <span class='neutral'>  // &#39;0x44&#39;: &#39;logPriceLimit&#39;</span>
 735 |     | <span class='neutral'>  // &#39;0x64&#39;: &#39;zeroForOne&#39;</span>
 736 |     | <span class='neutral'>  // &#39;0x84&#39;: &#39;calldata pointer to the beginning of hookData - 0x04&#39;</span>
 737 |     | <span class='neutral'>  // &#39;0x04 + calldataload(0x84)&#39;: &#39;hookData&#39;</span>
 738 |     | <span class='neutral'></span>
 739 |     | <span class='neutral'>  // &#39;msg.sender&#39; is placed in memory to be passed to hook as calldata.</span>
 740 |     | <span class='unexecuted'>  setMsgSender(msg.sender);</span>
 741 |     | <span class='neutral'></span>
 742 |     | <span class='neutral'>  // &#39;poolId&#39; is read from calldata and placed in memory.</span>
 743 |     | <span class='unexecuted'>  uint256 poolId;</span>
 744 |     | <span class='unexecuted'>  assembly {</span>
 745 |     | <span class='neutral'>    poolId := calldataload(4)</span>
 746 |     | <span class='neutral'>  }</span>
 747 |     | <span class='unexecuted'>  setPoolId(poolId);</span>
 748 |     | <span class='neutral'></span>
 749 |     | <span class='neutral'>  // &#39;amountSpecified&#39; is read from calldata, capped by &#39;-type(int128).max&#39; and </span>
 750 |     | <span class='neutral'>  // &#39;+type(int128).max&#39;, transformed to X127, and placed in memory.</span>
 751 |     | <span class='unexecuted'>  X127 amountSpecified;</span>
 752 |     | <span class='unexecuted'>  assembly {</span>
 753 |     | <span class='neutral'>    amountSpecified := calldataload(36)</span>
 754 |     | <span class='neutral'>    // slt and sgt are EVM assembly (Yul) comparison opcodes:</span>
 755 |     | <span class='neutral'>    // slt(a, b) → signed less than → returns 1 if a &lt; b (signed), else 0, signed less than = slt</span>
 756 |     | <span class='neutral'>    // sgt(a, b) → signed greater than → returns 1 if a &gt; b (signed), else 0 , signed greater than = sgt</span>
 757 |     | <span class='neutral'>  </span>
 758 |     | <span class='neutral'>    if slt(amountSpecified, sub(0, 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) { // MAX_INT128 = 0x7FFF...FFF</span>
 759 |     | <span class='neutral'>      amountSpecified := sub(0, 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)</span>
 760 |     | <span class='neutral'>    }</span>
 761 |     | <span class='neutral'>    if sgt(amountSpecified, 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) { // MAX_INT128 = 0x7FFF...FFF</span>
 762 |     | <span class='neutral'>      amountSpecified := 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span>
 763 |     | <span class='neutral'>    }</span>
 764 |     | <span class='neutral'>    amountSpecified := mul(amountSpecified, shl(127, 1))</span>
 765 |     | <span class='neutral'>    // shl(127, 1) = 2^127</span>
 766 |     | <span class='neutral'>    // So:</span>
 767 |     | <span class='neutral'>    // amountSpecified = amountSpecified × 2^127</span>
 768 |     | <span class='neutral'>    // This converts the integer into Q127 fixed-point representation (X127) used internally for precise AMM math. This multiplication increase precision, AMM math needs fractional precision.</span>
 769 |     | <span class='neutral'></span>
 770 |     | <span class='neutral'>  }</span>
 771 |     | <span class='neutral'></span>
 772 |     | <span class='unexecuted'>  setAmountSpecified(amountSpecified);</span>
 773 |     | <span class='neutral'></span>
 774 |     | <span class='neutral'>  // &#39;logPriceLimit&#39; is read from calldata and placed in memory.</span>
 775 |     | <span class='unexecuted'>  X59 logPriceLimit;</span>
 776 |     | <span class='unexecuted'>  assembly {</span>
 777 |     | <span class='neutral'>    logPriceLimit := calldataload(68)</span>
 778 |     | <span class='neutral'>  }</span>
 779 |     | <span class='unexecuted'>  setLogPriceLimit(logPriceLimit);</span>
 780 |     | <span class='neutral'></span>
 781 |     | <span class='neutral'>  // 1. logPriceLimit: Defines the maximum price boundary the swap is allowed to reach.</span>
 782 |     | <span class='neutral'>  // Meaning: &quot;Do the swap, but stop if price reaches this limit.&quot;</span>
 783 |     | <span class='neutral'></span>
 784 |     | <span class='neutral'>  // 2. crossThreshold: Controls how many ticks / price ranges the swap engine is allowed to cross in one execution (performance / safety limiter).</span>
 785 |     | <span class='neutral'>  // Meaning: &quot;Swap can move price, but don&#39;t cross too many ranges at once.&quot;</span>
 786 |     | <span class='neutral'></span>
 787 |     | <span class='neutral'>  // 3. zeroForOne: Direction of the swap. If true (1), swap token0 for token1; if false (0), swap token1 for token0.</span>
 788 |     | <span class='neutral'>  // 4. amountSpecified: The exact amount of tokens to swap. Positive values indicate the amount input to the pool, negative values indicate the amount output from the pool.</span>
 789 |     | <span class='neutral'>  // 5. poolId: Identifies the specific liquidity pool where the swap will occur.</span>
 790 |     | <span class='neutral'>  // 6. msg.sender: The address initiating the swap, used for authorization and tracking.</span>
 791 |     | <span class='neutral'>  // 7. hookData: Additional data passed to custom logic hooks during the swap process.</span>
 792 |     | <span class='neutral'></span>
 793 |     | <span class='neutral'>  // &#39;crossThreshold&#39; is read from calldata and placed in memory.</span>
 794 |     | <span class='unexecuted'>  uint256 crossThreshold;</span>
 795 |     | <span class='unexecuted'>  assembly {</span>
 796 |     | <span class='neutral'>    // → removes lower 16 bytes</span>
 797 |     | <span class='neutral'>    // → keeps upper 16 bytes (128 bits)</span>
 798 |     | <span class='neutral'>    crossThreshold := shr(128, calldataload(100)) // second argument of shr is the number of bits to shift right, so this is dividing by 2^128 while in normal cpp second argument is the number of bits to shift right, so this is dividing by 2^128</span>
 799 |     | <span class='neutral'>    // gt(a,b) = (unsigned) greater than → returns 1 if a &gt; b, shr = shift right</span>
 800 |     | <span class='neutral'>    if gt(crossThreshold, 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {</span>
 801 |     | <span class='neutral'>      crossThreshold := 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span>
 802 |     | <span class='neutral'>    }</span>
 803 |     | <span class='neutral'>  }</span>
 804 |     | <span class='unexecuted'>  setCrossThreshold(crossThreshold);</span>
 805 |     | <span class='neutral'></span>
 806 |     | <span class='neutral'>  // &#39;zeroForOne&#39; is read from calldata, capped by &#39;2&#39; and placed in memory.</span>
 807 |     | <span class='neutral'>  // Step-by-step explanation of the assembly code for reading &#39;zeroForOne&#39;:</span>
 808 |     | <span class='neutral'>// Read calldata at position 116</span>
 809 |     | <span class='neutral'>// Extract upper 128 bits</span>
 810 |     | <span class='neutral'>// Ensure:</span>
 811 |     | <span class='neutral'>// zeroForOne &lt;= 2</span>
 812 |     | <span class='neutral'>// Store 1 byte in memory</span>
 813 |     | <span class='neutral'>// mstore8(_zeroForOne_, zeroForOne)</span>
 814 |     | <span class='neutral'>// so memory variable _zeroForOne_ now holds 0,1,2 only.</span>
 815 |     | <span class='neutral'>// This prevents invalid values like 200.</span>
 816 |     | <span class='unexecuted'>  assembly {</span>
 817 |     | <span class='neutral'>    let zeroForOne := shr(128, calldataload(116))</span>
 818 |     | <span class='neutral'>    if gt(zeroForOne, 2) {</span>
 819 |     | <span class='neutral'>      zeroForOne := 2</span>
 820 |     | <span class='neutral'>    }</span>
 821 |     | <span class='neutral'>    mstore8(_zeroForOne_, zeroForOne)</span>
 822 |     | <span class='neutral'>  }</span>
 823 |     | <span class='neutral'></span>
 824 |     | <span class='neutral'>  {</span>
 825 |     | <span class='neutral'>    // This is the pointer referring to the start of the kernel in memory.</span>
 826 |     | <span class='unexecuted'>    Kernel kernel;</span>
 827 |     | <span class='neutral'></span>
 828 |     | <span class='neutral'>    // This is the pointer referring to the start of hookData in memory.</span>
 829 |     | <span class='unexecuted'>    uint256 hookData;</span>
 830 |     | <span class='neutral'></span>
 831 |     | <span class='neutral'>    // The byte count of &#39;hookData&#39;.</span>
 832 |     | <span class='unexecuted'>    uint256 hookDataByteCount;</span>
 833 |     | <span class='neutral'></span>
 834 |     | <span class='neutral'>    // The total number of bytes of the memory snapshot to be used as input for</span>
 835 |     | <span class='neutral'>    // the hook contract.</span>
 836 |     | <span class='unexecuted'>    uint256 hookInputByteCount;</span>
 837 |     | <span class='neutral'></span>
 838 |     | <span class='unexecuted'>    assembly {</span>
 839 |     | <span class='neutral'>      // This value refers to the start of &#39;hookData&#39; in calldata (the length</span>
 840 |     | <span class='neutral'>      // slot).</span>
 841 |     | <span class='neutral'>      let hookDataStart := add(0x04, calldataload(0x84))</span>
 842 |     | <span class='neutral'></span>
 843 |     | <span class='neutral'>      // &#39;hookData&#39; appears immediately after static parameters.</span>
 844 |     | <span class='neutral'>      hookData := _endOfStaticParams_</span>
 845 |     | <span class='neutral'></span>
 846 |     | <span class='neutral'>      // The number of bytes to be occupied by &#39;hookData&#39;.</span>
 847 |     | <span class='neutral'>      hookDataByteCount := calldataload(hookDataStart)</span>
 848 |     | <span class='neutral'></span>
 849 |     | <span class='neutral'>      // &#39;kernel&#39; appears immediately after &#39;hookData&#39;.</span>
 850 |     | <span class='neutral'>      kernel := add(hookData, hookDataByteCount)</span>
 851 |     | <span class='neutral'></span>
 852 |     | <span class='neutral'>      // The total number of bytes to be given to the &#39;preSwap&#39; hook as input.</span>
 853 |     | <span class='neutral'>      // 32 is subtracted to exclude the &#39;_hookInputByteCount_&#39; slot.</span>
 854 |     | <span class='neutral'>      hookInputByteCount := sub(sub(kernel, _hookInputByteCount_), 32)</span>
 855 |     | <span class='neutral'></span>
 856 |     | <span class='neutral'>      // Data is copied from calldata to memory.</span>
 857 |     | <span class='neutral'>      calldatacopy(</span>
 858 |     | <span class='neutral'>        hookData,</span>
 859 |     | <span class='neutral'>        // The length slot of &#39;hookData&#39; is excluded.</span>
 860 |     | <span class='neutral'>        add(hookDataStart, 32),</span>
 861 |     | <span class='neutral'>        hookDataByteCount</span>
 862 |     | <span class='neutral'>      )</span>
 863 |     | <span class='neutral'>    }</span>
 864 |     | <span class='unexecuted'>    setHookData(hookData);</span>
 865 |     | <span class='unexecuted'>    require(</span>
 866 |     | <span class='unexecuted'>      hookDataByteCount &lt;= type(uint16).max,</span>
 867 |     | <span class='unexecuted'>      HookDataTooLong(hookDataByteCount)</span>
 868 |     | <span class='neutral'>    );</span>
 869 |     | <span class='unexecuted'>    setHookDataByteCount(uint16(hookDataByteCount));</span>
 870 |     | <span class='unexecuted'>    setHookInputByteCount(hookInputByteCount);</span>
 871 |     | <span class='unexecuted'>    setKernel(kernel);</span>
 872 |     | <span class='neutral'>  }</span>
 873 |     | <span class='neutral'>}</span>
 874 |     | <span class='neutral'></span>
 875 |     | <span class='neutral'>/// @notice Reads input of the external functions &#39;collectPool&#39; and </span>
 876 |     | <span class='neutral'>/// &#39;collectProtocol&#39;.</span>
 877 |     | <span class='unexecuted'>function readCollectInput() pure {</span>
 878 |     | <span class='neutral'>  // Calldata layout is as follows:</span>
 879 |     | <span class='neutral'>  //</span>
 880 |     | <span class='neutral'>  // &#39;0x00&#39;: function selector</span>
 881 |     | <span class='neutral'>  // &#39;0x04&#39;: &#39;poolId&#39;</span>
 882 |     | <span class='neutral'></span>
 883 |     | <span class='neutral'>  // &#39;poolId&#39; is read from calldata and placed in memory.</span>
 884 |     | <span class='unexecuted'>  uint256 poolId;</span>
 885 |     | <span class='unexecuted'>  assembly {</span>
 886 |     | <span class='neutral'>    poolId := calldataload(4)</span>
 887 |     | <span class='neutral'>  }</span>
 888 |     | <span class='unexecuted'>  setPoolId(poolId);</span>
 889 |     | <span class='neutral'></span>
 890 |     | <span class='neutral'>  // Determines the largest used memory slot.</span>
 891 |     | <span class='unexecuted'>  setFreeMemoryPointer(_swapInput_);</span>
 892 |     | <span class='neutral'>}</span>
 893 |     | <span class='neutral'></span>
 894 |     | <span class='neutral'></span>
 895 |     | <span class='neutral'>// Calldata reader usage map</span>
 896 |     | <span class='neutral'>// Reader function	                Called by external function                     	When used	                             What it loads into memory</span>
 897 |     | <span class='neutral'>// readInitializeInput()	              initialize()	                    When a new pool is created	                    poolId, tags, growth portion, kernel, kernelCompact, curve, hookData</span>
 898 |     | <span class='neutral'>// readModifyPositionInput()	          modifyPosition()	                When liquidity is added/removed	                poolId, logPriceMin/Max, shares, curve pointer, hookData</span>
 899 |     | <span class='neutral'>// readDonateInput()	                  donate()	                        When liquidity is donated to pool	              poolId, shares, curve pointer, hookData</span>
 900 |     | <span class='neutral'>// readModifyKernelInput()	            modifyKernel()	                  When kernel configuration is updated	          poolId, kernel, kernelCompact, hookData</span>
 901 |     | <span class='neutral'>// readModifyPoolGrowthPortionInput()	modifyPoolGrowthPortion()	        When pool fee/growth portion is changed	          poolId, poolGrowthPortion</span>
 902 |     | <span class='neutral'>// readUpdateGrowthPortionsInput()	    updateGrowthPortions()	          When growth portions are refreshed	            poolId only</span>
 903 |     | <span class='neutral'>// readSwapInput()	                    swap()	                          During token swap execution	                    poolId, amountSpecified, logPriceLimit, crossThreshold, zeroForOne, hookData, kernel</span>
 904 |     | <span class='neutral'>// readCollectInput()	                collectPool() / collectProtocol()	When fees are collected	                          poolId only</span>
 905 |     | <span class='neutral'></span>
 906 |     | <span class='neutral'>// One-line core idea</span>
 907 |     | <span class='neutral'>// All readXInput() functions decode calldata and construct the exact memory layout required by that specific action (swap, initialize, modify position, etc.).</span>
 908 |     | <span class='neutral'>// You never choose them manually — each external function internally calls its corresponding reader.</span>
 909 |     | <span class='neutral'></span>
 910 |     | <span class='neutral'>// Very important mental shortcut (senior-level understanding)</span>
 911 |     | <span class='neutral'></span>
 912 |     | <span class='neutral'>// Think of these readers as:</span>
 913 |     | <span class='neutral'>// initialize()        → build FULL pool setup memory</span>
 914 |     | <span class='neutral'>// swap()              → build swap execution memory</span>
 915 |     | <span class='neutral'>// modifyPosition()    → build LP position memory</span>
 916 |     | <span class='neutral'>// modifyKernel()      → build kernel update memory</span>
 917 |     | <span class='neutral'>// collect()           → build minimal memory (poolId only)</span>
 918 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/training/contracts/utilities/Curve.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {</span>
   5 |     | <span class='neutral'>  _spacing_,</span>
   6 |     | <span class='neutral'>  getCurveLength,</span>
   7 |     | <span class='neutral'>  setLogPriceCurrent,</span>
   8 |     | <span class='neutral'>  setCurveLength</span>
   9 |     | <span class='neutral'>} from &quot;./Memory.sol&quot;;</span>
  10 |     | <span class='neutral'>import {</span>
  11 |     | <span class='neutral'>  Index,</span>
  12 |     | <span class='neutral'>  zeroIndex,</span>
  13 |     | <span class='neutral'>  oneIndex,</span>
  14 |     | <span class='neutral'>  twoIndex,</span>
  15 |     | <span class='neutral'>  maxCurveIndex</span>
  16 |     | <span class='neutral'>} from &quot;./Index.sol&quot;;</span>
  17 |     | <span class='neutral'>import {PriceLibrary} from &quot;./Price.sol&quot;;</span>
  18 |     | <span class='neutral'>import {</span>
  19 |     | <span class='neutral'>  X59,</span>
  20 |     | <span class='neutral'>  min,</span>
  21 |     | <span class='neutral'>  max,</span>
  22 |     | <span class='neutral'>  zeroX59,</span>
  23 |     | <span class='neutral'>  thirtyTwoX59,</span>
  24 |     | <span class='neutral'>  minLogSpacing</span>
  25 |     | <span class='neutral'>} from &quot;./X59.sol&quot;;</span>
  26 |     | <span class='neutral'>import {</span>
  27 |     | <span class='neutral'>  LogSpacingIsTooSmall,</span>
  28 |     | <span class='neutral'>  BlankIntervalsShouldBeAvoided,</span>
  29 |     | <span class='neutral'>  InvalidCurveArrangement,</span>
  30 |     | <span class='neutral'>  CurveIndexOutOfRange</span>
  31 |     | <span class='neutral'>} from &quot;./Errors.sol&quot;;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>// The curve sequence comprises 64 bit logarithmic prices in the form of</span>
  34 |     | <span class='neutral'>//</span>
  35 |     | <span class='neutral'>//  &#39;(2 ** 59) * (16 + qHistorical)&#39;</span>
  36 |     | <span class='neutral'>//</span>
  37 |     | <span class='neutral'>// where</span>
  38 |     | <span class='neutral'>//</span>
  39 |     | <span class='neutral'>//  &#39;qHistorical := log(pHistorical / pOffset)&#39;.</span>
  40 |     | <span class='neutral'>//</span>
  41 |     | <span class='neutral'>// Hence, each slot of the curve sequence consists of up to four members. The</span>
  42 |     | <span class='neutral'>// curve sequence should have at least two members. The first and the second</span>
  43 |     | <span class='neutral'>// members are &#39;qLower&#39; and &#39;qUpper&#39; (i.e., boundaries of the active liquidity</span>
  44 |     | <span class='neutral'>// interval) with the order depending on the pool&#39;s history. The last member is</span>
  45 |     | <span class='neutral'>// always &#39;qCurrent&#39;. Consider the following curve sequence:</span>
  46 |     | <span class='neutral'>// </span>
  47 |     | <span class='neutral'>//  &#39;q[0], q[1], q[2], ..., q[l - 1]&#39;</span>
  48 |     | <span class='neutral'>//</span>
  49 |     | <span class='neutral'>// where &#39;l&#39; is the number of members. In order for the above sequence to be</span>
  50 |     | <span class='neutral'>// considered valid, we should have:</span>
  51 |     | <span class='neutral'>//</span>
  52 |     | <span class='neutral'>//  &#39;min(q[i - 1], q[i - 2]) &lt; q[i] &lt; max(q[i - 1], q[i - 2])&#39;.</span>
  53 |     | <span class='neutral'>//</span>
  54 |     | <span class='neutral'>// This ordering rule is verified upon initialization of any pool and it is</span>
  55 |     | <span class='neutral'>// preserved by each amendment to the curve sequence.</span>
  56 |     | <span class='neutral'>type Curve is uint256;</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>using PriceLibrary for uint16;</span>
  59 |     | <span class='neutral'>using CurveLibrary for Curve global;</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>library CurveLibrary {</span>
  62 |     | <span class='neutral'>  /// @notice Returns the member of the curve sequence corresponding to the</span>
  63 |     | <span class='neutral'>  /// given index.</span>
  64 |     | <span class='neutral'>  ///</span>
  65 |     | <span class='neutral'>  /// Index out-of-range should be avoided externally.</span>
  66 |     | <span class='neutral'>  function member(</span>
  67 |     | <span class='neutral'>    Curve curve,</span>
  68 |     | <span class='neutral'>    Index index</span>
  69 |     | <span class='neutral'>  ) internal pure returns (</span>
  70 |     | <span class='neutral'>    X59 q</span>
  71 |     | <span class='neutral'>  ) {</span>
  72 |     | <span class='neutral'>    assembly {</span>
  73 |     | <span class='neutral'>      // Each member of the curve sequence is &#39;64 bits == 8 bytes&#39; which is why</span>
  74 |     | <span class='neutral'>      // we are shifting index by &#39;3&#39; bits (i.e., we are multiplying index by</span>
  75 |     | <span class='neutral'>      // &#39;8 == 2 ** 3&#39;). We load the memory slot whose most significant 64 bits</span>
  76 |     | <span class='neutral'>      // host the member that we are interested in. Then, we shift the content</span>
  77 |     | <span class='neutral'>      // by 192 bits to the right in order to discard the remaining bits.</span>
  78 |     | <span class='neutral'>      //</span>
  79 |     | <span class='neutral'>      //       ----------------------------------------------------</span>
  80 |     | <span class='neutral'>      //       | 64 bit member to be loaded | 192 additional bits |</span>
  81 |     | <span class='neutral'>      //       +---------------------------------------------------</span>
  82 |     | <span class='neutral'>      //       |</span>
  83 |     | <span class='neutral'>      //    pointer == curve + (index &lt;&lt; 3)</span>
  84 |     | <span class='neutral'>      //</span>
  85 |     | <span class='neutral'>      // The addition is safe because index out-of-range is avoided externally.</span>
  86 |     | <span class='neutral'>      q := shr(192, mload(add(curve, shl(3, index))))</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'>  }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>  /// @notice Returns the leftmost and rightmost members of the curve sequence.</span>
  91 |     | <span class='neutral'>  function boundaries(</span>
  92 |     | <span class='neutral'>    Curve curve</span>
  93 |     | <span class='neutral'>  ) internal pure returns (</span>
  94 |     | <span class='neutral'>    X59 qLower,</span>
  95 |     | <span class='neutral'>    X59 qUpper</span>
  96 |     | <span class='neutral'>  ) {</span>
  97 |     | <span class='neutral'>    // The first and the second members of the curve sequence are loaded.</span>
  98 |     | <span class='neutral'>    // Index-out-of-range is not possible because the curve sequence has at</span>
  99 |     | <span class='neutral'>    // least two members.</span>
 100 |     | <span class='neutral'>    qLower = curve.member(zeroIndex);</span>
 101 |     | <span class='neutral'>    qUpper = curve.member(oneIndex);</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    // The two boundaries are arranged in order.</span>
 104 |     | <span class='neutral'>    //</span>
 105 |     | <span class='neutral'>    // Signed comparison is valid because both values are nonnegative and </span>
 106 |     | <span class='neutral'>    // do not exceed &#39;2 ** 64&#39; since each one is loaded from 64 bits of memory.</span>
 107 |     | <span class='neutral'>    (qLower, qUpper) = (qUpper &lt;= qLower) ? </span>
 108 |     | <span class='neutral'>                       (qUpper, qLower) : </span>
 109 |     | <span class='neutral'>                       (qLower, qUpper);</span>
 110 |     | <span class='neutral'>  }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>  /// @notice Validates an initial curve provided by the pool creator.</span>
 113 |     | <span class='neutral'>  function validate(</span>
 114 |     | <span class='neutral'>    Curve curve</span>
 115 |     | <span class='neutral'>  ) internal pure returns (</span>
 116 |     | <span class='neutral'>    X59 qLower,</span>
 117 |     | <span class='neutral'>    X59 qUpper</span>
 118 |     | <span class='neutral'>  ) {</span>
 119 |     | <span class='neutral'>    // The first and the second members of the curve sequence to be verified</span>
 120 |     | <span class='neutral'>    // are loaded. The curve sequence is read from an &#39;uint256[]&#39; calldata</span>
 121 |     | <span class='neutral'>    // array, whose length is non-zero due to the custom error</span>
 122 |     | <span class='neutral'>    // &#39;CurveLengthIsZero()&#39;. Hence, index out of range is not possible at this</span>
 123 |     | <span class='neutral'>    // point.</span>
 124 |     | <span class='neutral'>    X59 q0 = curve.member(zeroIndex);</span>
 125 |     | <span class='neutral'>    X59 q1 = curve.member(oneIndex);</span>
 126 |     | <span class='neutral'>    </span>
 127 |     | <span class='neutral'>    // The output of &#39;member&#39; is always non-negative and never exceeds </span>
 128 |     | <span class='neutral'>    // &#39;2 ** 64&#39; (read from 64 bits of memory). Hence, signed comparison is</span>
 129 |     | <span class='neutral'>    // valid.</span>
 130 |     | <span class='neutral'>    (qLower, qUpper) = (q0 &lt;= q1) ? (q0, q1) : (q1, q0);</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    // Underflow is not possible due to the above rearrangement of &#39;qLower&#39; and</span>
 133 |     | <span class='neutral'>    // &#39;qUpper&#39;.</span>
 134 |     | <span class='neutral'>    X59 qSpacing = qUpper - qLower;</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    // This is a one time calculation of &#39;sqrtSpacing&#39; and </span>
 137 |     | <span class='neutral'>    // &#39;sqrtInverseSpacing&#39;. They will be used later for swaps.</span>
 138 |     | <span class='neutral'>    _spacing_.storePrice(qSpacing);</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    // Since both sides are non-negative and less than &#39;2 ** 64&#39;, all three </span>
 141 |     | <span class='neutral'>    // signed comparisons are valid.</span>
 142 |     | <span class='neutral'>    require(qSpacing &gt;= minLogSpacing, LogSpacingIsTooSmall(qSpacing));</span>
 143 |     | <span class='neutral'>    require(</span>
 144 |     | <span class='neutral'>      qLower &gt; qSpacing,</span>
 145 |     | <span class='neutral'>      BlankIntervalsShouldBeAvoided(qLower, qUpper)</span>
 146 |     | <span class='neutral'>    );</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    // Underflow is not possible because &#39;qSpacing&#39; does not exceed &#39;64&#39; bits.</span>
 149 |     | <span class='neutral'>    // Hence, &#39;qSpacing &lt;= (2 ** 64) - 1 &lt; thirtyTwoX59&#39;.</span>
 150 |     | <span class='neutral'>    require(</span>
 151 |     | <span class='neutral'>      qUpper &lt; thirtyTwoX59 - qSpacing,</span>
 152 |     | <span class='neutral'>      BlankIntervalsShouldBeAvoided(qLower, qUpper)</span>
 153 |     | <span class='neutral'>    );</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    Index length = twoIndex;</span>
 156 |     | <span class='neutral'>    while (true) {</span>
 157 |     | <span class='neutral'>      // This may be an out-of-range access which is intentional, because we</span>
 158 |     | <span class='neutral'>      // break before using &#39;q2&#39; if &#39;length&#39; is out of range.</span>
 159 |     | <span class='neutral'>      X59 q2 = curve.member(length);</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>      // During initialization of a pool, the provided &#39;curve&#39; is always</span>
 162 |     | <span class='neutral'>      // followed by at least &#39;64&#39; bits of &#39;0&#39;. Hence, this indicates that we</span>
 163 |     | <span class='neutral'>      // have reached the end of the curve.</span>
 164 |     | <span class='neutral'>      if (q2 == zeroX59) break;</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>      // Here, we are checking the requirement:</span>
 167 |     | <span class='neutral'>      //</span>
 168 |     | <span class='neutral'>      //  &#39;min(q0, q1) &lt; q2 &lt; max(q0, q1)&#39;</span>
 169 |     | <span class='neutral'>      //</span>
 170 |     | <span class='neutral'>      // The output of &#39;member&#39; is always non-negative and never exceeds 64</span>
 171 |     | <span class='neutral'>      // bits (loaded from 64 bits of memory). Hence signed comparisons are</span>
 172 |     | <span class='neutral'>      // valid.</span>
 173 |     | <span class='neutral'>      if ((q2 &lt;= q0) || (q1 &lt;= q2)) {</span>
 174 |     | <span class='neutral'>        if ((q2 &lt;= q1) || (q0 &lt;= q2)) {</span>
 175 |     | <span class='neutral'>          revert InvalidCurveArrangement(q0, q1, q2);</span>
 176 |     | <span class='neutral'>        }</span>
 177 |     | <span class='neutral'>      }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>      // The two most recent members are shifted so that a new member can be</span>
 180 |     | <span class='neutral'>      // loaded as &#39;q2&#39;.</span>
 181 |     | <span class='neutral'>      q0 = q1;</span>
 182 |     | <span class='neutral'>      q1 = q2;</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>      // This addition is safe and never exceeds the &#39;2 ** 256 - 1&#39; limit.</span>
 185 |     | <span class='neutral'>      length = length + oneIndex;</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    // The length of the given curve should not exceed &#39;maxCurveIndex&#39;.</span>
 189 |     | <span class='neutral'>    require(length &lt;= maxCurveIndex, CurveIndexOutOfRange(length));</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    // &#39;q1&#39; is the last valid member of the curve and therefore, it is set in</span>
 192 |     | <span class='neutral'>    // memory as &#39;qCurrent&#39;.</span>
 193 |     | <span class='neutral'>    setLogPriceCurrent(q1);</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    // The &#39;length&#39; of the curve is stored in its appropriate memory location.</span>
 196 |     | <span class='neutral'>    // Due to the above check, this value is less than &#39;2 ** 16&#39; and can be</span>
 197 |     | <span class='neutral'>    // safely stored in the allocated 2 bytes of memory space.</span>
 198 |     | <span class='neutral'>    setCurveLength(length);</span>
 199 |     | <span class='neutral'>  }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>  /// @notice Generates a new curve with two members and stores its memory</span>
 202 |     | <span class='neutral'>  /// pointer in the appropriate memory location.</span>
 203 |     | <span class='neutral'>  ///</span>
 204 |     | <span class='neutral'>  /// &#39;qCurrent&#39; and &#39;qOther&#39; should be positive and smaller than </span>
 205 |     | <span class='neutral'>  /// &#39;thirtyTwoX59&#39;.</span>
 206 |     | <span class='neutral'>  function newCurve(</span>
 207 |     | <span class='neutral'>    Curve curve,</span>
 208 |     | <span class='neutral'>    X59 qCurrent,</span>
 209 |     | <span class='neutral'>    X59 qOther</span>
 210 |     | <span class='neutral'>  ) internal pure {</span>
 211 |     | <span class='neutral'>    assembly {</span>
 212 |     | <span class='neutral'>      mstore(</span>
 213 |     | <span class='neutral'>        curve,</span>
 214 |     | <span class='neutral'>        or(</span>
 215 |     | <span class='neutral'>          // &#39;qOther&#39; is written in the first place.</span>
 216 |     | <span class='neutral'>          shl(192, qOther),</span>
 217 |     | <span class='neutral'>          // &#39;qCurrent&#39; is written in the second place.</span>
 218 |     | <span class='neutral'>          shl(128, qCurrent)</span>
 219 |     | <span class='neutral'>        )</span>
 220 |     | <span class='neutral'>      )</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    // The new length is stored in the allocated memory location.</span>
 224 |     | <span class='neutral'>    setCurveLength(twoIndex);</span>
 225 |     | <span class='neutral'>  }</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='neutral'>  /// @notice Amends the curve by adding a new member.</span>
 228 |     | <span class='neutral'>  /// @param q is the given logarithmic price to be added to the curve</span>
 229 |     | <span class='neutral'>  /// sequence.</span>
 230 |     | <span class='neutral'>  /// &#39;q&#39; must be positive and less than &#39;2 ** 64&#39;.</span>
 231 |     | <span class='neutral'>  function amend(</span>
 232 |     | <span class='neutral'>    Curve curve,</span>
 233 |     | <span class='neutral'>    X59 q</span>
 234 |     | <span class='neutral'>  ) internal pure {</span>
 235 |     | <span class='neutral'>    // The first and second members of the curve are loaded.</span>
 236 |     | <span class='neutral'>    // Index out of range is not possible because the curve has at least two </span>
 237 |     | <span class='neutral'>    // members.</span>
 238 |     | <span class='neutral'>    X59 q0 = curve.member(zeroIndex);</span>
 239 |     | <span class='neutral'>    X59 q1 = curve.member(oneIndex);</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='neutral'>    // If &#39;q&#39; is not within the current active interval, then a new curve</span>
 242 |     | <span class='neutral'>    // sequence is constructed. Signed comparison is valid because &#39;q0&#39;, &#39;q1&#39;,</span>
 243 |     | <span class='neutral'>    // and &#39;q&#39; are nonnegative and do not exceed 64 bits.</span>
 244 |     | <span class='neutral'>    if (q &lt;= min(q0, q1)) {</span>
 245 |     | <span class='neutral'>      newCurve(curve, min(q0, q1), max(q0, q1));</span>
 246 |     | <span class='neutral'>      return;</span>
 247 |     | <span class='neutral'>    }</span>
 248 |     | <span class='neutral'>    if (max(q0, q1) &lt;= q) {</span>
 249 |     | <span class='neutral'>      newCurve(curve, max(q0, q1), min(q0, q1));</span>
 250 |     | <span class='neutral'>      return;</span>
 251 |     | <span class='neutral'>    }</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='neutral'>    // The length of the curve is loaded from the memory.</span>
 254 |     | <span class='neutral'>    Index length = getCurveLength();</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>    // Every member of the curve is exhausted until either the following rule</span>
 257 |     | <span class='neutral'>    // is violated or runs out of members:</span>
 258 |     | <span class='neutral'>    //</span>
 259 |     | <span class='neutral'>    // &#39;min(q[k - 1], q[k - 2]) &lt; q[k] &lt; max(q[k - 1], q[k - 2])&#39;.</span>
 260 |     | <span class='neutral'>    //</span>
 261 |     | <span class='neutral'>    // Then, &#39;q&#39; is written in the corresponding place and the rest of that</span>
 262 |     | <span class='neutral'>    // slot is cleared.</span>
 263 |     | <span class='neutral'>    Index index = oneIndex;</span>
 264 |     | <span class='neutral'>    while (true) {</span>
 265 |     | <span class='neutral'>      // Is &#39;q&#39; between &#39;q0&#39; and &#39;q1&#39;? If so, we proceed forward, otherwise,</span>
 266 |     | <span class='neutral'>      // &#39;q&#39; is written in place of &#39;q1&#39; and the rest of that slot is cleared.</span>
 267 |     | <span class='neutral'>      // Signed comparisons are valid because &#39;q0&#39;, &#39;q1&#39;, and &#39;q&#39; are</span>
 268 |     | <span class='neutral'>      // non-negative and do not exceed 64 bits.</span>
 269 |     | <span class='neutral'>      if ((q0 &lt; q1) ? (q &lt; q1) : (q1 &lt; q)) {</span>
 270 |     | <span class='neutral'>        // This addition is safe and never exceeds the &#39;2 ** 256 - 1&#39; limit.</span>
 271 |     | <span class='neutral'>        index = index + oneIndex;</span>
 272 |     | <span class='neutral'>        q0 = q1;</span>
 273 |     | <span class='neutral'>        if (index &lt; length) {</span>
 274 |     | <span class='neutral'>          // Index out-of-range is not possible due to the above check.</span>
 275 |     | <span class='neutral'>          q1 = curve.member(index);</span>
 276 |     | <span class='neutral'>        } else {</span>
 277 |     | <span class='neutral'>          break;</span>
 278 |     | <span class='neutral'>        }</span>
 279 |     | <span class='neutral'>      } else {</span>
 280 |     | <span class='neutral'>        break;</span>
 281 |     | <span class='neutral'>      }</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>    // &#39;q&#39; is added to the end.</span>
 285 |     | <span class='neutral'>    // This is not an out-of-range addition because one additional slot is</span>
 286 |     | <span class='neutral'>    // always reserved for the amendment of the curve. A maximum of 2</span>
 287 |     | <span class='neutral'>    // amendments occur per swap.</span>
 288 |     | <span class='neutral'>    assembly {</span>
 289 |     | <span class='neutral'>      mstore(add(curve, shl(3, index)), shl(192, q))</span>
 290 |     | <span class='neutral'>    }</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>    // &#39;index + oneIndex&#39; must not exceed &#39;maxIndex&#39;.</span>
 293 |     | <span class='neutral'>    require(index &lt; maxCurveIndex, CurveIndexOutOfRange(index));</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    // Lastly, &#39;curveLength&#39; is updated.</span>
 296 |     | <span class='neutral'>    // Due to the above check, this value is less than &#39;2 ** 16&#39; and can be</span>
 297 |     | <span class='neutral'>    // safely stored in the allocated 2 bytes of memory space.</span>
 298 |     | <span class='neutral'>    setCurveLength(index + oneIndex);</span>
 299 |     | <span class='neutral'>  }</span>
 300 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/Errors.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {Index} from &quot;./Index.sol&quot;;</span>
   5 |     | <span class='neutral'>import {X15} from &quot;./X15.sol&quot;;</span>
   6 |     | <span class='neutral'>import {X47} from &quot;./X47.sol&quot;;</span>
   7 |     | <span class='neutral'>import {X59} from &quot;./X59.sol&quot;;</span>
   8 |     | <span class='neutral'>import {X111} from &quot;./X111.sol&quot;;</span>
   9 |     | <span class='neutral'>import {X127} from &quot;./X127.sol&quot;;</span>
  10 |     | <span class='neutral'>import {X208} from &quot;./X208.sol&quot;;</span>
  11 |     | <span class='neutral'>import {X216} from &quot;./X216.sol&quot;;</span>
  12 |     | <span class='neutral'>import {Tag} from &quot;./Tag.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>/// @notice Thrown in case of overflow when attempting to calculate</span>
  15 |     | <span class='neutral'>/// &#39;(a * b) / denominator&#39;.</span>
  16 |     | <span class='neutral'>error MulDivOverflow(uint256 a, uint256 b, uint256 denominator);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>/// @notice Thrown in case of overflow or underflow when attempting to</span>
  19 |     | <span class='neutral'>/// calculate &#39;a + b&#39;.</span>
  20 |     | <span class='neutral'>error SafeAddFailed(X127 a, X127 b);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>/// @notice Thrown when balance exceeds &#39;type(uint128).max&#39;.</span>
  23 |     | <span class='neutral'>error BalanceOverflow(uint256 balance);</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>/// @notice Thrown when safe cast into an int256 overflows.</span>
  26 |     | <span class='neutral'>error SafeCastOverflow(uint256 value);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>/// @notice Thrown when the given &#39;qSpacing&#39; is less than &#39;minLogSpacing&#39;.</span>
  29 |     | <span class='neutral'>error LogSpacingIsTooSmall(X59 qSpacing);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>/// @notice Thrown when attempting to initialize a curve sequence on blank</span>
  32 |     | <span class='neutral'>/// intervals.</span>
  33 |     | <span class='neutral'>error BlankIntervalsShouldBeAvoided(X59 qLower, X59 qUpper);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>/// @notice Thrown when &#39;curveLength&#39; is zero upon initialization.</span>
  36 |     | <span class='neutral'>error CurveLengthIsZero();</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>/// @notice Each member of the curve sequence should be in-between the</span>
  39 |     | <span class='neutral'>/// preceding two members. Thrown when a given initial curve sequence violates</span>
  40 |     | <span class='neutral'>/// this rule.</span>
  41 |     | <span class='neutral'>error InvalidCurveArrangement(X59 q0, X59 q1, X59 q2);</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>/// @notice Thrown when &#39;curveLength&#39; is out of range.</span>
  44 |     | <span class='neutral'>error CurveIndexOutOfRange(Index length);</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>/// @notice Thrown in case of overflow when attempting to calculate </span>
  47 |     | <span class='neutral'>///</span>
  48 |     | <span class='neutral'>/// &#39;amount := ceiling(</span>
  49 |     | <span class='neutral'>///</span>
  50 |     | <span class='neutral'>///     shares *</span>
  51 |     | <span class='neutral'>///</span>
  52 |     | <span class='neutral'>///     (getZeroForOne() ? sqrtOffset : sqrtInverseOffset) * </span>
  53 |     | <span class='neutral'>///</span>
  54 |     | <span class='neutral'>///      multiplier</span>
  55 |     | <span class='neutral'>///     ------------</span>
  56 |     | <span class='neutral'>///       2 ** 208</span>
  57 |     | <span class='neutral'>///  )&#39;.</span>
  58 |     | <span class='neutral'>error SafeOutOfRangeAmountOverflow(</span>
  59 |     | <span class='neutral'>  X127 sqrtOffsetOrSqrtInverseOffset,</span>
  60 |     | <span class='neutral'>  X208 growthMultiplier,</span>
  61 |     | <span class='neutral'>  int256 shares</span>
  62 |     | <span class='neutral'>);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>/// @notice Thrown in case of overflow when attempting to calculate </span>
  65 |     | <span class='neutral'>///</span>
  66 |     | <span class='neutral'>/// &#39;amount := ceiling(</span>
  67 |     | <span class='neutral'>///</span>
  68 |     | <span class='neutral'>///     (zeroOrOne ? sqrtOffset : sqrtInverseOffset) * </span>
  69 |     | <span class='neutral'>///</span>
  70 |     | <span class='neutral'>///      liquidity      integral</span>
  71 |     | <span class='neutral'>///     ----------- * -------------</span>
  72 |     | <span class='neutral'>///       2 ** 111     outgoingMax</span>
  73 |     | <span class='neutral'>///  )&#39;.</span>
  74 |     | <span class='neutral'>error SafeInRangeAmountOverflow(</span>
  75 |     | <span class='neutral'>  X127 sqrtOffsetOrSqrtInverseOffset,</span>
  76 |     | <span class='neutral'>  X216 integral,</span>
  77 |     | <span class='neutral'>  X111 liquidity,</span>
  78 |     | <span class='neutral'>  X216 outgoingMax,</span>
  79 |     | <span class='neutral'>  uint256 outgoingMaxModularInverse</span>
  80 |     | <span class='neutral'>);</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>/// @notice Thrown when the second horizontal coordinate of a given kernel is</span>
  83 |     | <span class='neutral'>/// &#39;0&#39;. In this case, we have a vertical jump at the origin which limits</span>
  84 |     | <span class='neutral'>/// liquidity growth.</span>
  85 |     | <span class='neutral'>error SecondHorizontalCoordinateIsZero();</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>/// @notice The horizontal coordinates should be monotonically non-decreasing.</span>
  88 |     | <span class='neutral'>error NonMonotonicHorizontalCoordinates(X59 q_i, X59 q_j);</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>/// @notice The vertical coordinates should be monotonically non-decreasing.</span>
  91 |     | <span class='neutral'>error NonMonotonicVerticalCoordinates(X15 c_i, X15 c_j);</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>/// @notice There should not be repetitive points.</span>
  94 |     | <span class='neutral'>error RepetitiveKernelPoints(X15 c_i, X59 q_i);</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>/// @notice Thrown when the horizontal coordinates of a non-vertical and </span>
  97 |     | <span class='neutral'>/// non-horizontal segment are closer than &#39;2 ** 32&#39;.</span>
  98 |     | <span class='neutral'>error SlopeTooHigh(X59 q_i, X59 q_j);</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>/// @notice Thrown when the horizontal coordinates of a given &#39;kernelCompact&#39;</span>
 101 |     | <span class='neutral'>/// exceeds &#39;qSpacing&#39;.</span>
 102 |     | <span class='neutral'>error HorizontalCoordinatesMayNotExceedLogSpacing(X59 q_j, X59 qSpacing);</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>/// @notice There should not be three repetitive horizontal coordinates. A </span>
 105 |     | <span class='neutral'>/// vertical jump (i.e., discontinuity) is permitted and can be constructed</span>
 106 |     | <span class='neutral'>/// via two repetitive horizontal coordinates. However, three repetitive</span>
 107 |     | <span class='neutral'>/// horizontal coordinates are always redundant and should be avoided.</span>
 108 |     | <span class='neutral'>error RepetitiveHorizontalCoordinates(X59 q_i);</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>/// @notice There should not be three repetitive vertical coordinates. A </span>
 111 |     | <span class='neutral'>/// horizontal segment (i.e., constant range) is permitted and can be </span>
 112 |     | <span class='neutral'>/// constructed via two repetitive vertical coordinates. However, three</span>
 113 |     | <span class='neutral'>/// repetitive vertical coordinates are always redundant and should be</span>
 114 |     | <span class='neutral'>/// avoided.</span>
 115 |     | <span class='neutral'>error RepetitiveVerticalCoordinates(X15 c_i);</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>/// @notice Thrown when &#39;kernelLength&#39; is out of range.</span>
 118 |     | <span class='neutral'>error KernelIndexOutOfRange(Index length);</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>/// @notice The last vertical coordinate should be equal to &#39;oneX15&#39;.</span>
 121 |     | <span class='neutral'>error LastVerticalCoordinateMismatch(X15 c_j);</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>/// @notice Thrown when growth exceeds maximum permitted value of &#39;maxGrowth&#39;.</span>
 124 |     | <span class='neutral'>error GrowthOverflow();</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>/// @notice Thrown when accrued growth portion values exceed &#39;2 ** 104 - 1&#39;.</span>
 127 |     | <span class='neutral'>error AccruedGrowthPortionOverflow(X127 accruedValue);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>/// @notice Thrown when given flags are invalid or not consistent with hook.</span>
 130 |     | <span class='neutral'>error InvalidFlags(uint256);</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>/// @notice Thrown when the numerical search for outgoing target fails which </span>
 133 |     | <span class='neutral'>/// should never heappen.</span>
 134 |     | <span class='neutral'>error SearchingForOutgoingTargetFailed();</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>/// @notice Thrown when the numerical search for incoming target fails which</span>
 137 |     | <span class='neutral'>/// should never heappen.</span>
 138 |     | <span class='neutral'>error SearchingForIncomingTargetFailed();</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>/// @notice Thrown when the numerical search for overshoot fails which should</span>
 141 |     | <span class='neutral'>/// never heappen.</span>
 142 |     | <span class='neutral'>error SearchingForOvershootFailed();</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>/// @notice Thrown if attempting to unlock the protocol while already unlocked.</span>
 145 |     | <span class='neutral'>error AlreadyUnlocked(address currentCaller);</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>/// @notice Thrown when any of the following methods are invoked prior to the</span>
 148 |     | <span class='neutral'>/// protocol being unlocked:</span>
 149 |     | <span class='neutral'>///</span>
 150 |     | <span class='neutral'>///   &#39;INofeeswap.clear&#39;</span>
 151 |     | <span class='neutral'>///   &#39;INofeeswap.take&#39;</span>
 152 |     | <span class='neutral'>///   &#39;INofeeswap.settle&#39;</span>
 153 |     | <span class='neutral'>///   &#39;INofeeswap.transferTransientBalanceFrom&#39;</span>
 154 |     | <span class='neutral'>///   &#39;INofeeswap.modifyBalance&#39;</span>
 155 |     | <span class='neutral'>///   &#39;INofeeswap.swap&#39;</span>
 156 |     | <span class='neutral'>///   &#39;INofeeswapDelegatee.modifyPosition&#39;</span>
 157 |     | <span class='neutral'>///   &#39;INofeeswapDelegatee.donate&#39;</span>
 158 |     | <span class='neutral'>///</span>
 159 |     | <span class='neutral'>error ProtocolIsLocked();</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>/// @notice Thrown when attempting to perform the following operations on a </span>
 162 |     | <span class='neutral'>/// pool which is locked:</span>
 163 |     | <span class='neutral'>///</span>
 164 |     | <span class='neutral'>///   &#39;INofeeswap.swap&#39;</span>
 165 |     | <span class='neutral'>///   &#39;INofeeswapDelegatee.modifyPosition&#39;</span>
 166 |     | <span class='neutral'>///   &#39;INofeeswapDelegatee.donate&#39;</span>
 167 |     | <span class='neutral'>///   &#39;INofeeswapDelegatee.modifyKernel&#39;</span>
 168 |     | <span class='neutral'>///   &#39;INofeeswapDelegatee.modifyPoolGrowthPortion&#39;</span>
 169 |     | <span class='neutral'>///   &#39;INofeeswapDelegatee.updateGrowthPortions&#39;</span>
 170 |     | <span class='neutral'>///   &#39;INofeeswapDelegatee.collectPool&#39;</span>
 171 |     | <span class='neutral'>///   &#39;INofeeswapDelegatee.collectProtocol&#39;</span>
 172 |     | <span class='neutral'>///</span>
 173 |     | <span class='neutral'>error PoolIsLocked(uint256 poolId);</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>/// @notice Thrown when the deployment of static parameters fail.</span>
 176 |     | <span class='neutral'>error DeploymentFailed();</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>/// @notice Thrown when the method &#39;redeployStaticParamsAndKernel&#39; is run</span>
 179 |     | <span class='neutral'>/// externally.</span>
 180 |     | <span class='neutral'>error CannotRedeployStaticParamsAndKernelExternally();</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>/// @notice Thrown when attempting to sync protocol&#39;s reserve of native token.</span>
 183 |     | <span class='neutral'>error NativeTokenCannotBeSynced();</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>/// @notice Thrown when the spender allowance for a tag is insufficient.</span>
 186 |     | <span class='neutral'>error InsufficientPermission(address spender, Tag tag);</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>/// @notice Thrown when the total number of shares accross all liquidity</span>
 189 |     | <span class='neutral'>/// intervals exceed &#39;2 ** 127 - 1&#39;.</span>
 190 |     | <span class='neutral'>error SharesGrossOverflow(int256 sharesGross);</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>/// @notice Thrown when attempting to access a pool which does not exist.</span>
 193 |     | <span class='neutral'>error PoolDoesNotExist(uint256 poolId);</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>/// @notice Thrown when the owner balance for a tag is insufficient.</span>
 196 |     | <span class='neutral'>error InsufficientBalance(address owner, Tag tag);</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>/// @notice Throws when Sentinel response is invalid.</span>
 199 |     | <span class='neutral'>error InvalidSentinelResponse(bytes4 response);</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>/// @notice Thrown when the given &#39;zeroForOne&#39; is not in agreement with </span>
 202 |     | <span class='neutral'>/// &#39;logPriceLimitOffsetted&#39;.</span>
 203 |     | <span class='neutral'>error InvalidDirection(X59 current, X59 limit);</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>/// @notice Thrown when attempting to initialize a pool that already exists.</span>
 206 |     | <span class='neutral'>error PoolExists(uint256 poolId);</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>/// @notice Thrown when &#39;log(pOffset)&#39; is not within the range &#39;[-89, +89]&#39;.</span>
 209 |     | <span class='neutral'>error LogOffsetOutOfRange(X59 qOffset);</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>/// @notice Thrown when the given tags are not in the correct order, i.e.,</span>
 212 |     | <span class='neutral'>/// &#39;tag0 &lt; tag1&#39;.</span>
 213 |     | <span class='neutral'>error TagsOutOfOrder(Tag tag0, Tag tag1);</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>/// @notice Thrown when a given growth portion is greater than one.</span>
 216 |     | <span class='neutral'>error InvalidGrowthPortion(X47 poolGrowthPortion);</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>/// @notice Thrown when a given logarithmic price does not belong to the range</span>
 219 |     | <span class='neutral'>/// &#39;[log(pOffset) - 16 + 1 / (2 ** 59), log(pOffset) + 16 - 1 / (2 ** 59)]&#39;.</span>
 220 |     | <span class='neutral'>error LogPriceOutOfRange(X59 logPrice);</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>/// @notice Thrown when attempting to mint/burn a position with zero shares or</span>
 223 |     | <span class='neutral'>/// when the number of shares does not belong to </span>
 224 |     | <span class='neutral'>/// &#39;[- type(int128).max, type(int128).max]&#39;.</span>
 225 |     | <span class='neutral'>error InvalidNumberOfShares(int256 shares);</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='neutral'>/// @notice Thrown when attempting to initialize a pool with &#39;poolId == 0&#39;.</span>
 228 |     | <span class='neutral'>error PoolIdCannotBeZero();</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>/// @notice Thrown when attempting to access protocol operations via an</span>
 231 |     | <span class='neutral'>/// unauthorized address.</span>
 232 |     | <span class='neutral'>error OnlyByProtocol(address attemptingAddress, address protocolAddress);</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>/// @notice Thrown when attempting to access pool operations via an</span>
 235 |     | <span class='neutral'>/// unauthorized address.</span>
 236 |     | <span class='neutral'>error OnlyByPoolOwner(address attemptingAddress, address poolOwnerAddress);</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>/// @notice Thrown when attempting to mint/burn a position with invalid</span>
 239 |     | <span class='neutral'>/// lower bound which is not equal to interval boundaries modulo &#39;qSpacing&#39;.</span>
 240 |     | <span class='neutral'>error LogPriceMinIsNotSpaced(X59 logPriceMin);</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>/// @notice Thrown when attempting to mint/burn a position with invalid</span>
 243 |     | <span class='neutral'>/// upper bound which is not equal to interval boundaries modulo &#39;qSpacing&#39;.</span>
 244 |     | <span class='neutral'>error LogPriceMaxIsNotSpaced(X59 logPriceMax);</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='neutral'>/// @notice Thrown when attempting to mint/burn a position with invalid</span>
 247 |     | <span class='neutral'>/// lower bound which is not greater than &#39;qSpacing&#39;</span>
 248 |     | <span class='neutral'>error LogPriceMinIsInBlankArea(X59 logPriceMin);</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>/// @notice Thrown when attempting to mint/burn a position with invalid</span>
 251 |     | <span class='neutral'>/// lower bound which is not less than &#39;thirtyTwoX59 - qSpacing&#39;.</span>
 252 |     | <span class='neutral'>error LogPriceMaxIsInBlankArea(X59 logPriceMax);</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>/// @notice Thrown when the given logPrices for a position are not in the</span>
 255 |     | <span class='neutral'>/// correct order.</span>
 256 |     | <span class='neutral'>error LogPricesOutOfOrder(X59 logPriceMin, X59 logPriceMax);</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='neutral'>/// @notice Thrown when attempting donate to a pool whose donate flag is not </span>
 259 |     | <span class='neutral'>/// active.</span>
 260 |     | <span class='neutral'>error DonateIsNotAllowed(uint256 poolId);</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>/// @notice Thrown when attempting to perform a donate to an empty interval.</span>
 263 |     | <span class='neutral'>error CannotDonateToEmptyInterval();</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='neutral'>/// @notice Thrown when attempting to change an immutable kernel.</span>
 266 |     | <span class='neutral'>error ImmutableKernel(uint256 poolId);</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>/// @notice Thrown when attempting to change an immutable poolGrowthPortion.</span>
 269 |     | <span class='neutral'>error ImmutablePoolGrowthPortion(uint256 poolId);</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='neutral'>/// @notice Thrown when attempting to make a delegate call to the protocol.</span>
 272 |     | <span class='neutral'>error NoDelegateCall(address context);</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>/// @notice Thrown when transient balances are not cleared.</span>
 275 |     | <span class='neutral'>error OutstandingAmount();</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='neutral'>/// @notice Thrown when attempting to transfer NofeeAssets to address 0.</span>
 278 |     | <span class='neutral'>error CannotTransferToAddressZero();</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>/// @notice Thrown when the amount to be cleared is not equal to the transient</span>
 281 |     | <span class='neutral'>/// balance of &#39;msg.sender&#39;.</span>
 282 |     | <span class='neutral'>error NotEqualToTransientBalance(int256 currentBalance);</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>/// @notice Thrown when the size of &#39;hookData&#39; exceeds &#39;type(uint16).max&#39;.</span>
 285 |     | <span class='neutral'>error HookDataTooLong(uint256 hookDataByteCount);</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='neutral'>/// @notice Thrown when attempting to transfer ownership to address 0.</span>
 288 |     | <span class='neutral'>error AdminCannotBeAddressZero();</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='neutral'>/// @notice Thrown when attempting to settle a tag with nonzero &#39;msg.value&#39;.</span>
 291 |     | <span class='neutral'>error MsgValueIsNonZero(uint256 msgValue);</span>
 292 |     | <span class='neutral'></span>
 293 |     | <span class='neutral'>/// @notice Thrown when attempting to mint a position after burning it in the</span>
 294 |     | <span class='neutral'>/// same transaction.</span>
 295 |     | <span class='neutral'>error CannotMintAfterBurning(uint256 poolId, X59 qMin, X59 qMax);</span>

</code>
<br />

<b>/home/training/contracts/utilities/Events.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ISentinel} from &quot;../interfaces/ISentinel.sol&quot;;</span>
   5 |     | <span class='neutral'>import {INofeeswap} from &quot;../interfaces/INofeeswap.sol&quot;;</span>
   6 |     | <span class='neutral'>import {</span>
   7 |     | <span class='neutral'>  _staticParams_,</span>
   8 |     | <span class='neutral'>  _modifyPositionInput_,</span>
   9 |     | <span class='neutral'>  _endOfModifyPosition_,</span>
  10 |     | <span class='neutral'>  _poolGrowthPortion_,</span>
  11 |     | <span class='neutral'>  _maxPoolGrowthPortion_,</span>
  12 |     | <span class='neutral'>  _growth_,</span>
  13 |     | <span class='neutral'>  getPoolId,</span>
  14 |     | <span class='neutral'>  getTag0,</span>
  15 |     | <span class='neutral'>  getTag1,</span>
  16 |     | <span class='neutral'>  getHookData,</span>
  17 |     | <span class='neutral'>  getCurve,</span>
  18 |     | <span class='neutral'>  getCurveLength</span>
  19 |     | <span class='neutral'>} from &quot;./Memory.sol&quot;;</span>
  20 |     | <span class='neutral'>import {getProtocolOwner} from &quot;./Storage.sol&quot;;</span>
  21 |     | <span class='neutral'>import {KernelCompact} from &quot;./KernelCompact.sol&quot;;</span>
  22 |     | <span class='neutral'>import {Tag} from &quot;./Tag.sol&quot;;</span>
  23 |     | <span class='neutral'>import {Curve} from &quot;./Curve.sol&quot;;</span>
  24 |     | <span class='neutral'>import {Index} from &quot;./Index.sol&quot;;</span>
  25 |     | <span class='neutral'>import {X47} from &quot;./X47.sol&quot;;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>function emitTransferEvent(</span>
  28 |     | <span class='neutral'>  address caller,</span>
  29 |     | <span class='neutral'>  address from,</span>
  30 |     | <span class='neutral'>  address to,</span>
  31 |     | <span class='neutral'>  Tag tag,</span>
  32 |     | <span class='neutral'>  uint256 amount</span>
  33 |     | <span class='neutral'>) {</span>
  34 |     | <span class='neutral'>  emit INofeeswap.Transfer(caller, from, to, tag, amount);</span>
  35 |     | <span class='neutral'>}</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>function emitOperatorSetEvent(</span>
  38 |     | <span class='neutral'>  address owner,</span>
  39 |     | <span class='neutral'>  address operator,</span>
  40 |     | <span class='neutral'>  bool approved</span>
  41 |     | <span class='neutral'>) {</span>
  42 |     | <span class='neutral'>  emit INofeeswap.OperatorSet(owner, operator, approved);</span>
  43 |     | <span class='neutral'>}</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>function emitApprovalEvent(</span>
  46 |     | <span class='neutral'>  address owner,</span>
  47 |     | <span class='neutral'>  address spender,</span>
  48 |     | <span class='neutral'>  Tag tag,</span>
  49 |     | <span class='neutral'>  uint256 amount</span>
  50 |     | <span class='neutral'>) {</span>
  51 |     | <span class='neutral'>  emit INofeeswap.Approval(owner, spender, tag, amount);</span>
  52 |     | <span class='neutral'>}</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>function emitModifyDoubleBalanceEvent(</span>
  55 |     | <span class='neutral'>  address caller,</span>
  56 |     | <span class='neutral'>  address owner,</span>
  57 |     | <span class='neutral'>  Tag tag,</span>
  58 |     | <span class='neutral'>  int256 increment,</span>
  59 |     | <span class='neutral'>  uint256 balance</span>
  60 |     | <span class='neutral'>) {</span>
  61 |     | <span class='neutral'>  emit INofeeswap.ModifyDoubleBalanceEvent(</span>
  62 |     | <span class='neutral'>    caller,</span>
  63 |     | <span class='neutral'>    owner,</span>
  64 |     | <span class='neutral'>    tag,</span>
  65 |     | <span class='neutral'>    increment,</span>
  66 |     | <span class='neutral'>    balance</span>
  67 |     | <span class='neutral'>  );</span>
  68 |     | <span class='neutral'>}</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>function emitPoolCollectionEvent(</span>
  71 |     | <span class='neutral'>  uint256 poolId,</span>
  72 |     | <span class='neutral'>  address owner,</span>
  73 |     | <span class='neutral'>  uint256 amount0,</span>
  74 |     | <span class='neutral'>  uint256 amount1</span>
  75 |     | <span class='neutral'>) {</span>
  76 |     | <span class='neutral'>  emit INofeeswap.PoolCollection(poolId, owner, amount0, amount1);</span>
  77 |     | <span class='neutral'>}</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>function emitProtocolCollectionEvent(</span>
  80 |     | <span class='neutral'>  uint256 poolId,</span>
  81 |     | <span class='neutral'>  uint256 amount0,</span>
  82 |     | <span class='neutral'>  uint256 amount1</span>
  83 |     | <span class='neutral'>) {</span>
  84 |     | <span class='neutral'>  emit INofeeswap.ProtocolCollection(poolId, amount0, amount1);</span>
  85 |     | <span class='neutral'>}</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>function emitModifyProtocolEvent(</span>
  88 |     | <span class='neutral'>  uint256 newProtocol</span>
  89 |     | <span class='neutral'>) {</span>
  90 |     | <span class='neutral'>  emit INofeeswap.ModifyProtocol(getProtocolOwner(newProtocol), newProtocol);</span>
  91 |     | <span class='neutral'>}</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>function emitModifySentinelEvent(</span>
  94 |     | <span class='neutral'>  ISentinel oldSentinel,</span>
  95 |     | <span class='neutral'>  ISentinel newSentinel</span>
  96 |     | <span class='neutral'>) {</span>
  97 |     | <span class='neutral'>  emit INofeeswap.ModifySentinel(oldSentinel, newSentinel);</span>
  98 |     | <span class='neutral'>}</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>function emitModifyPoolOwnerEvent(</span>
 101 |     | <span class='neutral'>  uint256 poolId,</span>
 102 |     | <span class='neutral'>  address oldOwner,</span>
 103 |     | <span class='neutral'>  address newOwner</span>
 104 |     | <span class='neutral'>) {</span>
 105 |     | <span class='neutral'>  emit INofeeswap.ModifyPoolOwner(poolId, oldOwner, newOwner);</span>
 106 |     | <span class='neutral'>}</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>function emitInitializeEvent() {</span>
 109 |     | <span class='neutral'>  uint256 poolId = getPoolId();</span>
 110 |     | <span class='neutral'>  Tag tag0 = getTag0();</span>
 111 |     | <span class='neutral'>  Tag tag1 = getTag1();</span>
 112 |     | <span class='neutral'>  uint256 hookData = getHookData();</span>
 113 |     | <span class='neutral'>  bytes32 selector = INofeeswap.Initialize.selector;</span>
 114 |     | <span class='neutral'>  assembly {</span>
 115 |     | <span class='neutral'>    // The byte count of the data to be emitted which does not include the abi</span>
 116 |     | <span class='neutral'>    // offset and length slot.</span>
 117 |     | <span class='neutral'>    // The subtraction is safe because &#39;hookData&#39; is always ahead of</span>
 118 |     | <span class='neutral'>    // &#39;_staticParams_&#39; per &#39;Calldata.sol&#39;.</span>
 119 |     | <span class='neutral'>    let size := sub(hookData, _staticParams_)</span>
 120 |     | <span class='neutral'>    </span>
 121 |     | <span class='neutral'>    // This slot should be populated with the abi offset. Hence, we cache its</span>
 122 |     | <span class='neutral'>    // current content so that it can be written back. Then we store a &#39;0x20&#39;</span>
 123 |     | <span class='neutral'>    // abi offset for the data to be emitted.</span>
 124 |     | <span class='neutral'>    // The subtractions are safe because both values are constants.</span>
 125 |     | <span class='neutral'>    let content0 := mload(sub(_staticParams_, 64))</span>
 126 |     | <span class='neutral'>    mstore(sub(_staticParams_, 64), 0x20)</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>    // This slot should be populated with &#39;size&#39;. Hence, we cache its current</span>
 129 |     | <span class='neutral'>    // content so that it can be written back. Then we store a &#39;size&#39;.</span>
 130 |     | <span class='neutral'>    // The subtractions are safe because both values are constants.</span>
 131 |     | <span class='neutral'>    let content1 := mload(sub(_staticParams_, 32))</span>
 132 |     | <span class='neutral'>    mstore(sub(_staticParams_, 32), size)</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    // The number of bytes to be emitted should be divisible by &#39;32&#39;. If</span>
 135 |     | <span class='neutral'>    // &#39;32 * ceiling(size / 32)&#39; goes beyond &#39;size&#39;, then the extra bytes</span>
 136 |     | <span class='neutral'>    // should be equal to zero. Hence, we cache the content of this slot, so</span>
 137 |     | <span class='neutral'>    // that it can be restored after being zeroed. We then write zero in this</span>
 138 |     | <span class='neutral'>    // slot.</span>
 139 |     | <span class='neutral'>    let content2 := mload(hookData)</span>
 140 |     | <span class='neutral'>    mstore(hookData, 0)</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    // Here, we calculate &#39;32 * ceiling(size / 32)&#39; which is the actual number</span>
 143 |     | <span class='neutral'>    // of bytes to be given as input to &#39;log4&#39;.</span>
 144 |     | <span class='neutral'>    let module := mod(size, 0x20)</span>
 145 |     | <span class='neutral'>    if gt(module, 0) {</span>
 146 |     | <span class='neutral'>      size := add(sub(size, module), 0x20)</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    log4(</span>
 150 |     | <span class='neutral'>      // During initialization, &#39;staticParams&#39;, &#39;kernel&#39;, &#39;kernelCompact&#39;,</span>
 151 |     | <span class='neutral'>      // &#39;curve&#39;, and &#39;hookData&#39; appear in this order in memory. Hence, the</span>
 152 |     | <span class='neutral'>      // beginning of event data is &#39;_staticParams_&#39; which points to the start</span>
 153 |     | <span class='neutral'>      // of &#39;staticParams&#39; and the end of event data is &#39;hookData&#39; which points</span>
 154 |     | <span class='neutral'>      // to the end of &#39;curve&#39;. &#39;64&#39; is subtracted in order to include the abi</span>
 155 |     | <span class='neutral'>      // offset and &#39;size&#39; slots.</span>
 156 |     | <span class='neutral'>      sub(_staticParams_, 64),</span>
 157 |     | <span class='neutral'>      // As argued above, &#39;hookData - _staticParams_&#39; is the number of bytes to</span>
 158 |     | <span class='neutral'>      // be emitted. &#39;64&#39; is added in order to include the abi offset and</span>
 159 |     | <span class='neutral'>      // &#39;size&#39; slots.</span>
 160 |     | <span class='neutral'>      add(size, 64),</span>
 161 |     | <span class='neutral'>      selector,</span>
 162 |     | <span class='neutral'>      poolId,</span>
 163 |     | <span class='neutral'>      tag0,</span>
 164 |     | <span class='neutral'>      tag1</span>
 165 |     | <span class='neutral'>    )</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    // Now we restore all of the cached content.</span>
 168 |     | <span class='neutral'>    mstore(sub(_staticParams_, 64), content0)    </span>
 169 |     | <span class='neutral'>    mstore(sub(_staticParams_, 32), content1)</span>
 170 |     | <span class='neutral'>    mstore(hookData, content2)</span>
 171 |     | <span class='neutral'>  }</span>
 172 |     | <span class='neutral'>}</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>function emitModifyPositionEvent() {</span>
 175 |     | <span class='neutral'>  uint256 poolId = getPoolId();</span>
 176 |     | <span class='neutral'>  bytes32 selector = INofeeswap.ModifyPosition.selector;</span>
 177 |     | <span class='neutral'>  assembly {</span>
 178 |     | <span class='neutral'>    // The number of bytes to be emitted should be divisible by &#39;32&#39;. Since</span>
 179 |     | <span class='neutral'>    // &#39;32 * ceiling((_endOfModifyPosition_ - _modifyPositionInput_) / 32)&#39;</span>
 180 |     | <span class='neutral'>    // goes beyond &#39;_endOfModifyPosition_ - _modifyPositionInput_&#39;, the extra</span>
 181 |     | <span class='neutral'>    // bytes should be equal to zero. Hence, we cache the content of this slot,</span>
 182 |     | <span class='neutral'>    // so that it can be restored after being zeroed. We then write zero in</span>
 183 |     | <span class='neutral'>    // this slot.</span>
 184 |     | <span class='neutral'>    let content := mload(_endOfModifyPosition_)</span>
 185 |     | <span class='neutral'>    mstore(_endOfModifyPosition_, 0)</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    log3(</span>
 188 |     | <span class='neutral'>      // As described in &#39;Memory.sol&#39;, in order to include all of the above</span>
 189 |     | <span class='neutral'>      // seven parameters, the beginning of event data should be</span>
 190 |     | <span class='neutral'>      // &#39;_modifyPositionInput_&#39; and the end of event data should be</span>
 191 |     | <span class='neutral'>      // &#39;_endOfModifyPosition_&#39;.</span>
 192 |     | <span class='neutral'>      _modifyPositionInput_,</span>
 193 |     | <span class='neutral'>      // As argued above, &#39;_endOfModifyPosition_ - _modifyPositionInput_&#39; is</span>
 194 |     | <span class='neutral'>      // the number of bytes to be emitted.</span>
 195 |     | <span class='neutral'>      // &#39;16&#39; is added because we want the number of bytes to be emitted to be</span>
 196 |     | <span class='neutral'>      // divisible by &#39;32&#39;.</span>
 197 |     | <span class='neutral'>      add(sub(_endOfModifyPosition_, _modifyPositionInput_), 16),</span>
 198 |     | <span class='neutral'>      selector,</span>
 199 |     | <span class='neutral'>      poolId,</span>
 200 |     | <span class='neutral'>      caller()</span>
 201 |     | <span class='neutral'>    )</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    // Now we restore the cached content.</span>
 204 |     | <span class='neutral'>    mstore(_endOfModifyPosition_, content)</span>
 205 |     | <span class='neutral'>  }</span>
 206 |     | <span class='neutral'>}</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>function emitDonateEvent() {</span>
 209 |     | <span class='neutral'>  uint256 poolId = getPoolId();</span>
 210 |     | <span class='neutral'>  bytes32 selector = INofeeswap.Donate.selector;</span>
 211 |     | <span class='neutral'>  assembly {</span>
 212 |     | <span class='neutral'>    // We copy zeros to the end of &#39;growth&#39; and emit the total &#39;32&#39; bytes.</span>
 213 |     | <span class='neutral'>    let content := mload(add(_growth_, 16))</span>
 214 |     | <span class='neutral'>    mstore(add(_growth_, 16), 0)</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>    // As described in &#39;Memory.sol&#39;, the pointer &#39;_growth_&#39; points to the</span>
 217 |     | <span class='neutral'>    // memory slot whose most significant &#39;128&#39; bits host &#39;growth&#39;. Hence,</span>
 218 |     | <span class='neutral'>    // the beginning of event data should be &#39;_growth_&#39; and the size of event</span>
 219 |     | <span class='neutral'>    // data should be exactly &#39;32&#39; bytes.</span>
 220 |     | <span class='neutral'>    log3(_growth_, 32, selector, poolId, caller())</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    // Now we restore the cached content.</span>
 223 |     | <span class='neutral'>    mstore(add(_growth_, 16), content)</span>
 224 |     | <span class='neutral'>  }</span>
 225 |     | <span class='neutral'>}</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='neutral'>function emitSwapEvent() {</span>
 228 |     | <span class='neutral'>  uint256 poolId = getPoolId();</span>
 229 |     | <span class='neutral'>  Curve curve = getCurve();</span>
 230 |     | <span class='neutral'>  Index curveLength = getCurveLength();</span>
 231 |     | <span class='neutral'>  bytes32 selector = INofeeswap.Swap.selector;</span>
 232 |     | <span class='neutral'>  assembly {</span>
 233 |     | <span class='neutral'>    // The end of the curve sequence is calculated.</span>
 234 |     | <span class='neutral'>    let endOfCurve := add(curve, shl(3, curveLength))</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='neutral'>    // We copy &#39;growth&#39; to the end of &#39;curve&#39; and emit the total &#39;32&#39; bytes.</span>
 237 |     | <span class='neutral'>    let content := mload(endOfCurve)</span>
 238 |     | <span class='neutral'>    mcopy(endOfCurve, _growth_, 16)</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>    log3(</span>
 241 |     | <span class='neutral'>      // The subtraction is safe because the curve sequence has at least &#39;2&#39;</span>
 242 |     | <span class='neutral'>      // members at all times.</span>
 243 |     | <span class='neutral'>      //</span>
 244 |     | <span class='neutral'>      // Each member of the curve sequence is &#39;64 bits == 8 bytes&#39; which is why</span>
 245 |     | <span class='neutral'>      // we shift &#39;curveLength - 2&#39; by &#39;3&#39; bits (i.e., we are multiplying this</span>
 246 |     | <span class='neutral'>      // value by &#39;8 == 2 ** 3&#39;). We load the memory slot whose most</span>
 247 |     | <span class='neutral'>      // significant 128 bits host the last two members of the curve sequence.</span>
 248 |     | <span class='neutral'>      //</span>
 249 |     | <span class='neutral'>      //       ------------------------------------------------------------</span>
 250 |     | <span class='neutral'>      //       | 64 bits overshoot | 64 bits target | 128 additional bits |</span>
 251 |     | <span class='neutral'>      //       +-----------------------------------------------------------</span>
 252 |     | <span class='neutral'>      //       |</span>
 253 |     | <span class='neutral'>      //    pointer == curve + ((curveLength - 2) &lt;&lt; 3)</span>
 254 |     | <span class='neutral'>      //</span>
 255 |     | <span class='neutral'>      // The addition is safe because we do not exceed the length of the curve</span>
 256 |     | <span class='neutral'>      // sequence.</span>
 257 |     | <span class='neutral'>      sub(endOfCurve, 16),</span>
 258 |     | <span class='neutral'>      // 32 bytes is 128 bits which covers exactly two members of the curve</span>
 259 |     | <span class='neutral'>      // sequence and the &#39;growth&#39; that we have just copied.</span>
 260 |     | <span class='neutral'>      32,</span>
 261 |     | <span class='neutral'>      selector,</span>
 262 |     | <span class='neutral'>      poolId,</span>
 263 |     | <span class='neutral'>      caller()</span>
 264 |     | <span class='neutral'>    )</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    // Now we restore the cached content.</span>
 267 |     | <span class='neutral'>    mstore(endOfCurve, content)</span>
 268 |     | <span class='neutral'>  }</span>
 269 |     | <span class='neutral'>}</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='neutral'>function emitModifyKernelEvent() {</span>
 272 |     | <span class='neutral'>  uint256 poolId = getPoolId();</span>
 273 |     | <span class='neutral'>  bytes32 selector = INofeeswap.ModifyKernel.selector;</span>
 274 |     | <span class='neutral'>  uint256 hookData = getHookData();</span>
 275 |     | <span class='neutral'>  assembly {</span>
 276 |     | <span class='neutral'>    // The byte count of the data to be emitted which does not include the abi</span>
 277 |     | <span class='neutral'>    // offset and length slot.</span>
 278 |     | <span class='neutral'>    // The subtraction is safe because &#39;hookData&#39; is always ahead of</span>
 279 |     | <span class='neutral'>    // &#39;_staticParams_&#39; per &#39;Calldata.sol&#39;.</span>
 280 |     | <span class='neutral'>    let size := sub(hookData, _staticParams_)</span>
 281 |     | <span class='neutral'>    </span>
 282 |     | <span class='neutral'>    // This slot should be populated with the abi offset. Hence, we cache its</span>
 283 |     | <span class='neutral'>    // current content so that it can be written back. Then we store a &#39;0x20&#39;</span>
 284 |     | <span class='neutral'>    // abi offset for the data to be emitted.</span>
 285 |     | <span class='neutral'>    // The subtractions are safe because both values are constants.</span>
 286 |     | <span class='neutral'>    let content0 := mload(sub(_staticParams_, 64))</span>
 287 |     | <span class='neutral'>    mstore(sub(_staticParams_, 64), 0x20)</span>
 288 |     | <span class='neutral'></span>
 289 |     | <span class='neutral'>    // This slot should be populated with &#39;size&#39;. Hence, we cache its current</span>
 290 |     | <span class='neutral'>    // content so that it can be written back. Then we store a &#39;size.</span>
 291 |     | <span class='neutral'>    // The subtractions are safe because both values are constants.</span>
 292 |     | <span class='neutral'>    let content1 := mload(sub(_staticParams_, 32))</span>
 293 |     | <span class='neutral'>    mstore(sub(_staticParams_, 32), size)</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    // The number of bytes to be emitted should be divisible by &#39;32&#39;. If</span>
 296 |     | <span class='neutral'>    // &#39;32 * ceiling(size / 32)&#39; goes beyond &#39;size&#39;, then the extra bytes</span>
 297 |     | <span class='neutral'>    // should be equal to zero. Hence, we cache the content of this slot, so</span>
 298 |     | <span class='neutral'>    // that it can be restored after being zeroed. We then write zero in this</span>
 299 |     | <span class='neutral'>    // slot.</span>
 300 |     | <span class='neutral'>    let content2 := mload(hookData)</span>
 301 |     | <span class='neutral'>    mstore(hookData, 0)</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>    // Here, we calculate &#39;32 * ceiling(size / 32)&#39; which is the actual number</span>
 304 |     | <span class='neutral'>    // of bytes to be given as input to &#39;log4&#39;.</span>
 305 |     | <span class='neutral'>    let module := mod(size, 0x20)</span>
 306 |     | <span class='neutral'>    if gt(module, 0) {</span>
 307 |     | <span class='neutral'>      size := add(sub(size, module), 0x20)</span>
 308 |     | <span class='neutral'>    }</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='neutral'>    log3(</span>
 311 |     | <span class='neutral'>      // During modifyKernel, &#39;staticParams&#39;, &#39;kernel&#39;, &#39;kernelCompact&#39;, and</span>
 312 |     | <span class='neutral'>      // &#39;hookData&#39; appear in this order in memory. Hence, the beginning of</span>
 313 |     | <span class='neutral'>      // event data is &#39;_staticParams_&#39; which points to the start of</span>
 314 |     | <span class='neutral'>      // &#39;staticParams&#39; and the end of event data is &#39;hookData&#39; which points</span>
 315 |     | <span class='neutral'>      // to the end of &#39;kernelCompact&#39;. &#39;64&#39; is subtracted in order to include</span>
 316 |     | <span class='neutral'>      // the abi offset and &#39;size&#39; slots.</span>
 317 |     | <span class='neutral'>      sub(_staticParams_, 64),</span>
 318 |     | <span class='neutral'>      // As argued above, &#39;hookData - _staticParams_&#39; is the number of bytes to</span>
 319 |     | <span class='neutral'>      // be emitted. &#39;64&#39; is added in order to include the abi offset and</span>
 320 |     | <span class='neutral'>      // &#39;size&#39; slots.</span>
 321 |     | <span class='neutral'>      add(size, 64),      </span>
 322 |     | <span class='neutral'>      selector,</span>
 323 |     | <span class='neutral'>      poolId,</span>
 324 |     | <span class='neutral'>      caller()</span>
 325 |     | <span class='neutral'>    )</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='neutral'>    // Now we restore all of the cached content.</span>
 328 |     | <span class='neutral'>    mstore(sub(_staticParams_, 64), content0)    </span>
 329 |     | <span class='neutral'>    mstore(sub(_staticParams_, 32), content1)</span>
 330 |     | <span class='neutral'>    mstore(hookData, content2)</span>
 331 |     | <span class='neutral'>  }</span>
 332 |     | <span class='neutral'>}</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>function emitModifyPoolGrowthPortionEvent() {</span>
 335 |     | <span class='neutral'>  uint256 poolId = getPoolId();</span>
 336 |     | <span class='neutral'>  bytes32 selector = INofeeswap.ModifyPoolGrowthPortion.selector;</span>
 337 |     | <span class='neutral'>  assembly {</span>
 338 |     | <span class='neutral'>    // We copy zeros to the end of &#39;poolGrowthPortion&#39; and emit the total &#39;32&#39;</span>
 339 |     | <span class='neutral'>    // bytes.</span>
 340 |     | <span class='neutral'>    let content := mload(add(_poolGrowthPortion_, 6))</span>
 341 |     | <span class='neutral'>    mstore(add(_poolGrowthPortion_, 6), 0)</span>
 342 |     | <span class='neutral'></span>
 343 |     | <span class='neutral'>    // As described in &#39;Memory.sol&#39;, the pointer &#39;_poolGrowthPortion_&#39; points</span>
 344 |     | <span class='neutral'>    // to the memory slot whose most significant &#39;48&#39; bits host</span>
 345 |     | <span class='neutral'>    // &#39;poolGrowthPortion&#39;. Hence, the beginning of event data should be</span>
 346 |     | <span class='neutral'>    // &#39;_poolGrowthPortion_&#39; and the size of event data should be exactly &#39;32&#39;</span>
 347 |     | <span class='neutral'>    // bytes.</span>
 348 |     | <span class='neutral'>    log3(_poolGrowthPortion_, 32, selector, poolId, caller())</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='neutral'>    // Now we restore the cached content.</span>
 351 |     | <span class='neutral'>    mstore(add(_poolGrowthPortion_, 6), content)</span>
 352 |     | <span class='neutral'>  }</span>
 353 |     | <span class='neutral'>}</span>
 354 |     | <span class='neutral'></span>
 355 |     | <span class='neutral'>function emitUpdateGrowthPortionsEvent() {</span>
 356 |     | <span class='neutral'>  uint256 poolId = getPoolId();</span>
 357 |     | <span class='neutral'>  bytes32 selector = INofeeswap.UpdateGrowthPortions.selector;</span>
 358 |     | <span class='neutral'>  assembly {</span>
 359 |     | <span class='neutral'>    // We copy zeros to the end of &#39;protocolGrowthPortion&#39; and emit the total</span>
 360 |     | <span class='neutral'>    // &#39;32&#39; bytes.</span>
 361 |     | <span class='neutral'>    let content := mload(add(_maxPoolGrowthPortion_, 12))</span>
 362 |     | <span class='neutral'>    mstore(add(_maxPoolGrowthPortion_, 12), 0)</span>
 363 |     | <span class='neutral'></span>
 364 |     | <span class='neutral'>    // As described in &#39;Memory.sol&#39;, the pointer &#39;_maxPoolGrowthPortion_&#39;</span>
 365 |     | <span class='neutral'>    // points to the memory slot whose most significant &#39;48&#39; bits host</span>
 366 |     | <span class='neutral'>    // &#39;maxPoolGrowthPortion&#39;. The next &#39;48&#39; bits that appear immediately after</span>
 367 |     | <span class='neutral'>    // &#39;maxPoolGrowthPortion&#39; host &#39;protocolGrowthPortion&#39;. Hence, the</span>
 368 |     | <span class='neutral'>    // beginning of event data should be &#39;_maxPoolGrowthPortion_&#39; and the size</span>
 369 |     | <span class='neutral'>    // of event data should be exactly &#39;32&#39; bytes.</span>
 370 |     | <span class='neutral'>    log3(_maxPoolGrowthPortion_, 32, selector, poolId, caller())</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='neutral'>    // Now we restore the cached content.</span>
 373 |     | <span class='neutral'>    mstore(add(_maxPoolGrowthPortion_, 12), content)</span>
 374 |     | <span class='neutral'>  }</span>
 375 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/FullMath.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {MulDivOverflow} from &quot;./Errors.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @title Contains 512-bit multiplication and division functions</span>
   7 |     | <span class='neutral'>/// Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv</span>
   8 |     | <span class='neutral'>/// for several functions in this library.</span>
   9 |     | <span class='unexecuted'>library FullMathLibrary {</span>
  10 |     | <span class='neutral'>  ///                           _____   _____   _____</span>
  11 |     | <span class='neutral'>  /// @notice 512-bit addition &#39;r1 r0 = a1 a0 + b1 b0&#39;.</span>
  12 |     | <span class='neutral'>  /// Overflow should be avoided externally.</span>
  13 |     | <span class='neutral'>  /// @param a0 Least significant 256 bits of the first number.</span>
  14 |     | <span class='neutral'>  /// @param a1 Most significant 256 bits of the first number.</span>
  15 |     | <span class='neutral'>  /// @param b0 Least significant 256 bits of the second number.</span>
  16 |     | <span class='neutral'>  /// @param b1 Most significant 256 bits of the second number.</span>
  17 |     | <span class='neutral'>  /// @return r0 Least significant 256 bits of the addition.</span>
  18 |     | <span class='neutral'>  /// @return r1 Most significant 256 bits of the addition.</span>
  19 |     | <span class='neutral'>  function add512(</span>
  20 |     | <span class='neutral'>    uint256 a0,</span>
  21 |     | <span class='neutral'>    uint256 a1,</span>
  22 |     | <span class='neutral'>    uint256 b0,</span>
  23 |     | <span class='neutral'>    uint256 b1</span>
  24 |     | <span class='neutral'>  ) internal pure returns (</span>
  25 |     | <span class='neutral'>    uint256 r0,</span>
  26 |     | <span class='neutral'>    uint256 r1</span>
  27 |     | <span class='neutral'>  ) {</span>
  28 |     | <span class='neutral'>    //      s0</span>
  29 |     | <span class='neutral'>    //      a1 a0</span>
  30 |     | <span class='neutral'>    // +    b1 b0</span>
  31 |     | <span class='neutral'>    // -----------</span>
  32 |     | <span class='neutral'>    //      r1 r0</span>
  33 |     | <span class='neutral'>    //</span>
  34 |     | <span class='neutral'>    // where &#39;s0 := lt(r0, a0)&#39;.</span>
  35 |     | <span class='neutral'>    assembly {</span>
  36 |     | <span class='neutral'>      r0 := add(a0, b0)</span>
  37 |     | <span class='neutral'>      r1 := add(</span>
  38 |     | <span class='neutral'>        add(a1, b1),</span>
  39 |     | <span class='neutral'>        // &#39;r0 &lt; a0&#39; indicates that the addition &#39;a0 + b0&#39; has overflowed. In</span>
  40 |     | <span class='neutral'>        // this case &#39;1&#39; needs to be added to the most significant 256 bits of</span>
  41 |     | <span class='neutral'>        // the output.</span>
  42 |     | <span class='neutral'>        lt(r0, a0)</span>
  43 |     | <span class='neutral'>      )</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'>  }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>  ///                              _____   _____   _____</span>
  48 |     | <span class='neutral'>  /// @notice 512-bit subtraction &#39;r1 r0 = a1 a0 - b1 b0&#39;.</span>
  49 |     | <span class='neutral'>  /// Underflow should be avoided externally.</span>
  50 |     | <span class='neutral'>  /// @param a0 Least significant 256 bits of the minuend.</span>
  51 |     | <span class='neutral'>  /// @param a1 Most significant 256 bits of the minuend.</span>
  52 |     | <span class='neutral'>  /// @param b0 Least significant 256 bits of the subtrahend.</span>
  53 |     | <span class='neutral'>  /// @param b1 Most significant 256 bits of the subtrahend.</span>
  54 |     | <span class='neutral'>  /// @return r0 Least significant 256 bits of the subtraction.</span>
  55 |     | <span class='neutral'>  /// @return r1 Most significant 256 bits of the subtraction.</span>
  56 |     | <span class='neutral'>  function sub512(</span>
  57 |     | <span class='neutral'>    uint256 a0,</span>
  58 |     | <span class='neutral'>    uint256 a1,</span>
  59 |     | <span class='neutral'>    uint256 b0,</span>
  60 |     | <span class='neutral'>    uint256 b1</span>
  61 |     | <span class='neutral'>  ) internal pure returns (</span>
  62 |     | <span class='neutral'>    uint256 r0,</span>
  63 |     | <span class='neutral'>    uint256 r1</span>
  64 |     | <span class='neutral'>  ) {</span>
  65 |     | <span class='neutral'>    //      a1 a0</span>
  66 |     | <span class='neutral'>    // -    b1 b0</span>
  67 |     | <span class='neutral'>    // -----------</span>
  68 |     | <span class='neutral'>    //      s1 r0</span>
  69 |     | <span class='neutral'>    // -    s0</span>
  70 |     | <span class='neutral'>    // -----------</span>
  71 |     | <span class='neutral'>    //      r1 r0</span>
  72 |     | <span class='neutral'>    //</span>
  73 |     | <span class='neutral'>    // where &#39;s0 := lt(a0, b0)&#39; and &#39;s1 := (a1 - b1) % (2 ** 256)&#39;.</span>
  74 |     | <span class='neutral'>    assembly {</span>
  75 |     | <span class='neutral'>      r0 := sub(a0, b0)</span>
  76 |     | <span class='neutral'>      r1 := sub(</span>
  77 |     | <span class='neutral'>        sub(a1, b1),</span>
  78 |     | <span class='neutral'>        // &#39;a0 &lt; b0&#39; indicates that the subtraction &#39;a0 - b0&#39; has underflowed.</span>
  79 |     | <span class='neutral'>        // In this case &#39;1&#39; needs to be subtracted from the most significant</span>
  80 |     | <span class='neutral'>        // 256 bits of the output.</span>
  81 |     | <span class='neutral'>        lt(a0, b0)</span>
  82 |     | <span class='neutral'>      )</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'>  }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>  ///                           ___________</span>
  87 |     | <span class='neutral'>  /// @notice 512-bit multiply &#39;prod1 prod0 = a * b&#39;.</span>
  88 |     | <span class='neutral'>  /// @param a The multiplicand.</span>
  89 |     | <span class='neutral'>  /// @param b The multiplier.</span>
  90 |     | <span class='neutral'>  /// @return prod0 Least significant 256 bits of the product.</span>
  91 |     | <span class='neutral'>  /// @return prod1 Most significant 256 bits of the product.</span>
  92 |     | <span class='neutral'>  function mul512(</span>
  93 |     | <span class='neutral'>    uint256 a,</span>
  94 |     | <span class='neutral'>    uint256 b</span>
  95 |     | <span class='neutral'>  ) internal pure returns (</span>
  96 |     | <span class='neutral'>    uint256 prod0, </span>
  97 |     | <span class='neutral'>    uint256 prod1</span>
  98 |     | <span class='neutral'>  ) {</span>
  99 |     | <span class='neutral'>    assembly {</span>
 100 |     | <span class='neutral'>      // &#39;mm := a * b - (2 ** 256 - 1) * q&#39;</span>
 101 |     | <span class='neutral'>      let mm := mulmod(a, b, not(0))</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>      // &#39;prod0 := a * b - (2 ** 256) * p&#39;</span>
 104 |     | <span class='neutral'>      prod0 := mul(a, b)</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>      prod1 := sub(</span>
 107 |     | <span class='neutral'>        // &#39;mm - prod0 == q&#39;.</span>
 108 |     | <span class='neutral'>        sub(mm, prod0),</span>
 109 |     | <span class='neutral'>        //               a * b                 a * b</span>
 110 |     | <span class='neutral'>        // p == floor(----------) &lt;= floor(--------------) == q</span>
 111 |     | <span class='neutral'>        //             2 ** 256             2 ** 256 - 1</span>
 112 |     | <span class='neutral'>        //</span>
 113 |     | <span class='neutral'>        // On the other hand, since</span>
 114 |     | <span class='neutral'>        //</span>
 115 |     | <span class='neutral'>        //      a * b          a * b                  a * b</span>
 116 |     | <span class='neutral'>        // -------------- - ---------- == ----------------------------- &lt; 1</span>
 117 |     | <span class='neutral'>        //  2 ** 256 - 1     2 ** 256      (2 ** 256) * (2 ** 256 - 1)</span>
 118 |     | <span class='neutral'>        //</span>
 119 |     | <span class='neutral'>        // we have &#39;q - p &lt;= 1&#39;.</span>
 120 |     | <span class='neutral'>        //</span>
 121 |     | <span class='neutral'>        // Hence, either &#39;p == q&#39; or &#39;p == q - 1&#39;.</span>
 122 |     | <span class='neutral'>        //</span>
 123 |     | <span class='neutral'>        // If &#39;p == q&#39;, then &#39;mm - prod0 == q &gt;= 0&#39;.</span>
 124 |     | <span class='neutral'>        // If &#39;p == q - 1&#39;, then &#39;prod0 - mm == (2 ** 256) - q &gt; 0&#39;.</span>
 125 |     | <span class='neutral'>        //</span>
 126 |     | <span class='neutral'>        // Since &#39;p == q&#39; and &#39;p == q - 1&#39; are mutually exclusive, we can argue</span>
 127 |     | <span class='neutral'>        // that:</span>
 128 |     | <span class='neutral'>        //</span>
 129 |     | <span class='neutral'>        // &#39;p == q&#39; if and only if &#39;mm &gt;= prod0&#39;.</span>
 130 |     | <span class='neutral'>        // &#39;p == q - 1&#39; if and only if &#39;mm &lt; prod0&#39;.</span>
 131 |     | <span class='neutral'>        //</span>
 132 |     | <span class='neutral'>        // Hence, in the latter case, we should subtract by &#39;1&#39;.</span>
 133 |     | <span class='neutral'>        lt(mm, prod0)</span>
 134 |     | <span class='neutral'>      )</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'>  }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>  /// @notice Calculates (a * b) / denominator when </span>
 139 |     | <span class='neutral'>  /// &#39;a * b &lt; denominator * (denominator - 1)&#39;.</span>
 140 |     | <span class='neutral'>  /// @param a The multiplicand.</span>
 141 |     | <span class='neutral'>  /// @param b The multiplier.</span>
 142 |     | <span class='neutral'>  /// @param denominator The divisor.</span>
 143 |     | <span class='neutral'>  /// @return result &#39;(a * b) / denominator&#39;.</span>
 144 |     | <span class='unexecuted'>  function cheapMulDiv(</span>
 145 |     | <span class='neutral'>    uint256 a,</span>
 146 |     | <span class='neutral'>    uint256 b,</span>
 147 |     | <span class='neutral'>    uint256 denominator</span>
 148 |     | <span class='neutral'>  ) internal pure returns (</span>
 149 |     | <span class='unexecuted'>    uint256 result</span>
 150 |     | <span class='neutral'>  ) {</span>
 151 |     | <span class='unexecuted'>    assembly {</span>
 152 |     | <span class='neutral'>      result := sub(denominator, 1)</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>      // &#39;s := a * b - q * (denominator - 1)&#39;</span>
 155 |     | <span class='neutral'>      // &#39;r := a * b - p * denominator&#39;</span>
 156 |     | <span class='neutral'>      // &#39;s - r == p * denominator == p&#39; [mod (denominator - 1)]</span>
 157 |     | <span class='neutral'>      result := addmod(</span>
 158 |     | <span class='neutral'>        mulmod(a, b, result),</span>
 159 |     | <span class='neutral'>        // This subtraction is safe because </span>
 160 |     | <span class='neutral'>        // &#39;(a * b) % denominator &lt;= denominator - 1&#39;.</span>
 161 |     | <span class='neutral'>        sub(result, mulmod(a, b, denominator)),</span>
 162 |     | <span class='neutral'>        result</span>
 163 |     | <span class='neutral'>      )</span>
 164 |     | <span class='neutral'>      // Notice that &#39;result &lt;= denominator - 1&#39; and because of the input</span>
 165 |     | <span class='neutral'>      // requirement, we have &#39;p = (a * b) / denominator &lt;= denominator - 1&#39;.</span>
 166 |     | <span class='neutral'>      // Hence, &#39;result == s - r == p&#39;.</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'>  }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>  /// @notice Calculates the modular inverse of an odd number modulo &#39;2 ** 256&#39;</span>
 171 |     | <span class='neutral'>  /// Input should be odd.</span>
 172 |     | <span class='neutral'>  /// @param value The number whose modular inverse to be calculated.</span>
 173 |     | <span class='neutral'>  /// @return inverse A 256-bit inverse satisfying</span>
 174 |     | <span class='neutral'>  /// &#39;value * inverse == 1&#39; [mod 2 ** 256].</span>
 175 |     | <span class='neutral'>  function modularInverse(</span>
 176 |     | <span class='neutral'>    uint256 value</span>
 177 |     | <span class='neutral'>  ) internal pure returns (</span>
 178 |     | <span class='neutral'>    uint256 inverse</span>
 179 |     | <span class='neutral'>  ) {</span>
 180 |     | <span class='neutral'>    unchecked {</span>
 181 |     | <span class='neutral'>      // Compute the inverse by starting with a seed that is correct for four</span>
 182 |     | <span class='neutral'>      // bits. That is, &#39;value * inverse = 1&#39; [mod 2 ** 4].</span>
 183 |     | <span class='neutral'>      inverse = 3 * value ^ 2;</span>
 184 |     | <span class='neutral'>      // Now use Newton-Raphson iterations to improve the precision. Thanks to</span>
 185 |     | <span class='neutral'>      // Hensel&#39;s lifting lemma, this also works in modular arithmetic,</span>
 186 |     | <span class='neutral'>      // doubling the correct bits in each step.</span>
 187 |     | <span class='neutral'>      inverse *= 2 - value * inverse;</span>
 188 |     | <span class='neutral'>      inverse *= 2 - value * inverse;</span>
 189 |     | <span class='neutral'>      inverse *= 2 - value * inverse;</span>
 190 |     | <span class='neutral'>      inverse *= 2 - value * inverse;</span>
 191 |     | <span class='neutral'>      inverse *= 2 - value * inverse;</span>
 192 |     | <span class='neutral'>      inverse *= 2 - value * inverse;</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'>  }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>  ///                          ________</span>
 197 |     | <span class='neutral'>  /// @notice 768-bit multiply q2 q1 q0 = a * b * c</span>
 198 |     | <span class='neutral'>  /// @param a The multiplicand.</span>
 199 |     | <span class='neutral'>  /// @param b The first multiplier.</span>
 200 |     | <span class='neutral'>  /// @param c The second multiplier.</span>
 201 |     | <span class='neutral'>  /// @return q0 Least significant 256 bits of the product.</span>
 202 |     | <span class='neutral'>  /// @return q1 Middle 256 bits of the product.</span>
 203 |     | <span class='neutral'>  /// @return q2 Most significant 256 bits of the product.</span>
 204 |     | <span class='neutral'>  function mul768(</span>
 205 |     | <span class='neutral'>    uint256 a,</span>
 206 |     | <span class='neutral'>    uint256 b,</span>
 207 |     | <span class='neutral'>    uint256 c</span>
 208 |     | <span class='neutral'>  ) internal pure returns (</span>
 209 |     | <span class='neutral'>    uint256 q0,</span>
 210 |     | <span class='neutral'>    uint256 q1,</span>
 211 |     | <span class='neutral'>    uint256 q2</span>
 212 |     | <span class='neutral'>  ) {</span>
 213 |     | <span class='neutral'>    //          a</span>
 214 |     | <span class='neutral'>    // x        b</span>
 215 |     | <span class='neutral'>    // -----------</span>
 216 |     | <span class='neutral'>    //      q1 q0</span>
 217 |     | <span class='neutral'>    // x        c</span>
 218 |     | <span class='neutral'>    // -----------</span>
 219 |     | <span class='neutral'>    //   ss </span>
 220 |     | <span class='neutral'>    //      mm q0</span>
 221 |     | <span class='neutral'>    // + q2 q1  0</span>
 222 |     | <span class='neutral'>    // -----------</span>
 223 |     | <span class='neutral'>    //   q2 q1 q0</span>
 224 |     | <span class='neutral'>    //</span>
 225 |     | <span class='neutral'>    uint256 mm;</span>
 226 |     | <span class='neutral'>    (q0, q1) = mul512(a, b);</span>
 227 |     | <span class='neutral'>    (q1, q2) = mul512(q1, c);</span>
 228 |     | <span class='neutral'>    (q0, mm) = mul512(q0, c);</span>
 229 |     | <span class='neutral'>    assembly {</span>
 230 |     | <span class='neutral'>      q1 := add(q1, mm)</span>
 231 |     | <span class='neutral'>      // &#39;q1 &lt; mm&#39; indicates that the above addition has overflowed (i.e.,</span>
 232 |     | <span class='neutral'>      // &#39;ss == 1&#39;) and hence, &#39;1&#39; needs to be added to the most significant</span>
 233 |     | <span class='neutral'>      // 256 bits of the product.</span>
 234 |     | <span class='neutral'>      q2 := add(q2, lt(q1, mm))</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'>  }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>  /// @notice Calculates </span>
 239 |     | <span class='neutral'>  ///</span>
 240 |     | <span class='neutral'>  ///         a * b * c</span>
 241 |     | <span class='neutral'>  /// &#39;min(----------------, 2 ** 216 - 1)&#39;</span>
 242 |     | <span class='neutral'>  ///       d * (2 ** 143)</span>
 243 |     | <span class='neutral'>  ///</span>
 244 |     | <span class='neutral'>  /// with full precision when &#39;a * b * c != 0&#39;.</span>
 245 |     | <span class='neutral'>  /// @param a The multiplicand.</span>
 246 |     | <span class='neutral'>  /// @param b The first multiplier.</span>
 247 |     | <span class='neutral'>  /// @param c The second multiplier.</span>
 248 |     | <span class='neutral'>  /// @param d The denominator.</span>
 249 |     | <span class='neutral'>  /// @param roundUp Whether to round up the result.</span>
 250 |     | <span class='neutral'>  /// @return result The output value &#39;(a * b * c) / (d * (2 ** 143))&#39; which is</span>
 251 |     | <span class='neutral'>  /// capped by &#39;2 ** 216 - 1&#39;.</span>
 252 |     | <span class='neutral'>  function mulDiv(</span>
 253 |     | <span class='neutral'>    uint256 a,</span>
 254 |     | <span class='neutral'>    uint256 b,</span>
 255 |     | <span class='neutral'>    uint256 c,</span>
 256 |     | <span class='neutral'>    uint256 d,</span>
 257 |     | <span class='neutral'>    bool roundUp</span>
 258 |     | <span class='neutral'>  ) internal pure returns (</span>
 259 |     | <span class='neutral'>    uint256 result</span>
 260 |     | <span class='neutral'>  ) {</span>
 261 |     | <span class='neutral'>    unchecked {</span>
 262 |     | <span class='neutral'>      // ________</span>
 263 |     | <span class='neutral'>      // q2 q1 q0 = a * b * c</span>
 264 |     | <span class='neutral'>      (uint256 q0, uint256 q1, uint256 q2) = mul768(a, b, c);</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>      // If &#39;q2 &gt;= (1 &lt;&lt; 103)&#39;, then the output is greater than or equal to</span>
 267 |     | <span class='neutral'>      //</span>
 268 |     | <span class='neutral'>      //  (2 ** 103) * (2 ** 256) * (2 ** 256)</span>
 269 |     | <span class='neutral'>      // -------------------------------------- == 2 ** 216</span>
 270 |     | <span class='neutral'>      //        (2 ** 256) * (2 ** 143)</span>
 271 |     | <span class='neutral'>      //</span>
 272 |     | <span class='neutral'>      // In this case, &#39;2 ** 216 - 1&#39; should be returned.</span>
 273 |     | <span class='neutral'>      if (q2 &gt;= (1 &lt;&lt; 103)) return ((1 &lt;&lt; 216) - 1);</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='neutral'>      // Divide the numerator by &#39;2 ** 143&#39;</span>
 276 |     | <span class='neutral'>      (q2, q1) = (</span>
 277 |     | <span class='neutral'>        (q2 &lt;&lt; 113) | (q1 &gt;&gt; 143),</span>
 278 |     | <span class='neutral'>        (q1 &lt;&lt; 113) | (q0 &gt;&gt; 143)</span>
 279 |     | <span class='neutral'>      );</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='neutral'>      // Calculating the remainder of the numerator modulo &#39;d&#39;.</span>
 282 |     | <span class='neutral'>      uint256 r;</span>
 283 |     | <span class='neutral'>      assembly {</span>
 284 |     | <span class='neutral'>        r := addmod(</span>
 285 |     | <span class='neutral'>          addmod(q1, q2, d), // (q1 + q2) % d</span>
 286 |     | <span class='neutral'>          mulmod(q2, not(0), d), // (q2 * (2 ** 256 - 1)) % d</span>
 287 |     | <span class='neutral'>          d</span>
 288 |     | <span class='neutral'>        ) // (q1 + q2 * (2 ** 256)) % d</span>
 289 |     | <span class='neutral'>      }</span>
 290 |     | <span class='neutral'>      </span>
 291 |     | <span class='neutral'>      //                         _____</span>
 292 |     | <span class='neutral'>      // &#39;r&#39; is subtracted from &#39;q2 q1&#39;.</span>
 293 |     | <span class='neutral'>      assembly {</span>
 294 |     | <span class='neutral'>        // &#39;q1 &lt; r&#39; indicates that the subtraction &#39;q1 - r&#39; underflows.</span>
 295 |     | <span class='neutral'>        // In this case &#39;1&#39; needs to be subtracted from q2.</span>
 296 |     | <span class='neutral'>        q2 := sub(q2, lt(q1, r))</span>
 297 |     | <span class='neutral'>        q1 := sub(q1, r)</span>
 298 |     | <span class='neutral'>      }</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='neutral'>      // Determines whether to return &#39;2 ** 216 - 1&#39;.</span>
 301 |     | <span class='neutral'>      //                _____</span>
 302 |     | <span class='neutral'>      // Check whether &#39;q2 q1 &gt;= (2 ** 256) * d&#39;.</span>
 303 |     | <span class='neutral'>      if (q2 &gt;= d) return ((1 &lt;&lt; 216) - 1);</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>      // &#39;d&#39; is factored into an odd part and a power of two. </span>
 306 |     | <span class='neutral'>      // Then, the numerator is divided by the power of two.</span>
 307 |     | <span class='neutral'>      {</span>
 308 |     | <span class='neutral'>        // This is the largest power of two that &#39;d&#39; is divisible by.</span>
 309 |     | <span class='neutral'>        uint256 twos = (0 - d) &amp; d;</span>
 310 |     | <span class='neutral'>        assembly {</span>
 311 |     | <span class='neutral'>          // Dividing &#39;d&#39; by &#39;twos&#39;.</span>
 312 |     | <span class='neutral'>          d := div(d, twos)</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>          //           _____</span>
 315 |     | <span class='neutral'>          // Dividing &#39;q2 q1&#39; by &#39;twos&#39; and storing the least significant &#39;256&#39;</span>
 316 |     | <span class='neutral'>          // bits in &#39;q1&#39;.</span>
 317 |     | <span class='neutral'>          q1 := or(</span>
 318 |     | <span class='neutral'>            div(q1, twos), // &#39;q1 / (2 ** k)&#39;</span>
 319 |     | <span class='neutral'>            mul(</span>
 320 |     | <span class='neutral'>              q2,</span>
 321 |     | <span class='neutral'>              add(</span>
 322 |     | <span class='neutral'>                div(</span>
 323 |     | <span class='neutral'>                  sub(0, twos), // &#39;2 ** 256 - 2 ** k&#39;</span>
 324 |     | <span class='neutral'>                  twos // &#39;2 ** k&#39;</span>
 325 |     | <span class='neutral'>                ), // &#39;2 ** (256 - k) - 1&#39;</span>
 326 |     | <span class='neutral'>                1</span>
 327 |     | <span class='neutral'>              ) // &#39;(2 ** (256 - k)) % (2 ** 256)&#39;</span>
 328 |     | <span class='neutral'>            ) // &#39;(q2 * (2 ** (256 - k))) % (2 ** 256)&#39;</span>
 329 |     | <span class='neutral'>          ) // &#39;(q2 * (2 ** (256 - k)) + q1 / (2 ** k)) % (2 ** 256)&#39;</span>
 330 |     | <span class='neutral'>        }</span>
 331 |     | <span class='neutral'>      }</span>
 332 |     | <span class='neutral'></span>
 333 |     | <span class='neutral'>      // The result can now be calculated precisely using modular inverse.</span>
 334 |     | <span class='neutral'>      // Let &#39;di := modularInverse(d)&#39;.</span>
 335 |     | <span class='neutral'>      //</span>
 336 |     | <span class='neutral'>      //  _____</span>
 337 |     | <span class='neutral'>      // &#39;q2 q1 == d * result&#39;</span>
 338 |     | <span class='neutral'>      // &#39;(2 ** 256) * q2 + q1 == d * result&#39;</span>
 339 |     | <span class='neutral'>      // &#39;di * (2 ** 256) * q2 + di * q1 == di * d * result&#39;</span>
 340 |     | <span class='neutral'>      // &#39;di * (2 ** 256) * q2 + di * q1 == ((2 ** 256) * k + 1) * result&#39;</span>
 341 |     | <span class='neutral'>      // &#39;di * q1 == result&#39; [mod 2 ** 256]</span>
 342 |     | <span class='neutral'>      result = modularInverse(d) * q1;</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='neutral'>      // If either of the remainders are positive, then the result should be</span>
 345 |     | <span class='neutral'>      // rounded up.</span>
 346 |     | <span class='neutral'>      if (roundUp) {</span>
 347 |     | <span class='neutral'>        if ((q0 &amp; 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) &gt; 0 || r &gt; 0) {</span>
 348 |     | <span class='neutral'>          ++result;</span>
 349 |     | <span class='neutral'>        }</span>
 350 |     | <span class='neutral'>      }</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='neutral'>      // Determines whether to return &#39;2 ** 216 - 1&#39;.</span>
 353 |     | <span class='neutral'>      if (result &gt;= (1 &lt;&lt; 216)) return ((1 &lt;&lt; 216) - 1);</span>
 354 |     | <span class='neutral'>    }</span>
 355 |     | <span class='neutral'>  }</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>  /// @notice Calculates</span>
 358 |     | <span class='neutral'>  ///</span>
 359 |     | <span class='neutral'>  ///      a * b * c</span>
 360 |     | <span class='neutral'>  /// &#39;----------------&#39;</span>
 361 |     | <span class='neutral'>  ///   d * (2 ** 111)</span>
 362 |     | <span class='neutral'>  ///</span>
 363 |     | <span class='neutral'>  /// with full precision. Overflows if the result exceeds &#39;type(int256).max&#39;.</span>
 364 |     | <span class='neutral'>  /// &#39;e&#39; must be the modular inverse of &#39;d / (2 ** k)&#39; where &#39;k&#39; is the</span>
 365 |     | <span class='neutral'>  /// largest power of two within &#39;d&#39;.</span>
 366 |     | <span class='neutral'>  /// We should have &#39;a * b * c != 0&#39; and &#39;d != 0&#39;.</span>
 367 |     | <span class='neutral'>  /// @param a The multiplicand.</span>
 368 |     | <span class='neutral'>  /// @param b The first multiplier.</span>
 369 |     | <span class='neutral'>  /// @param c The second multiplier.</span>
 370 |     | <span class='neutral'>  /// @param d The denominator.</span>
 371 |     | <span class='neutral'>  /// @param e Modular inverse of the odd part of the denominator.</span>
 372 |     | <span class='neutral'>  /// @param roundUp Whether to round up the result.</span>
 373 |     | <span class='neutral'>  /// @return result The output value &#39;(a * b * c) / (d * (2 ** 111))&#39; if there</span>
 374 |     | <span class='neutral'>  /// is no overflow.</span>
 375 |     | <span class='neutral'>  /// @return overflow Whether the result overflows.</span>
 376 |     | <span class='neutral'>  function mulDiv(</span>
 377 |     | <span class='neutral'>    uint256 a,</span>
 378 |     | <span class='neutral'>    uint256 b,</span>
 379 |     | <span class='neutral'>    uint256 c,</span>
 380 |     | <span class='neutral'>    uint256 d,</span>
 381 |     | <span class='neutral'>    uint256 e,</span>
 382 |     | <span class='neutral'>    bool roundUp</span>
 383 |     | <span class='neutral'>  ) internal pure returns (</span>
 384 |     | <span class='neutral'>    uint256 result,</span>
 385 |     | <span class='neutral'>    bool overflow</span>
 386 |     | <span class='neutral'>  ) {</span>
 387 |     | <span class='neutral'>    unchecked {</span>
 388 |     | <span class='neutral'>      // ________</span>
 389 |     | <span class='neutral'>      // q2 q1 q0 = a * b * c</span>
 390 |     | <span class='neutral'>      (uint256 q0, uint256 q1, uint256 q2) = mul768(a, b, c);</span>
 391 |     | <span class='neutral'></span>
 392 |     | <span class='neutral'>      // If &#39;q2 &gt;= (1 &lt;&lt; 111)&#39;, then the output is greater than or equal to</span>
 393 |     | <span class='neutral'>      //</span>
 394 |     | <span class='neutral'>      //  (2 ** 111) * (2 ** 256) * (2 ** 256)</span>
 395 |     | <span class='neutral'>      // -------------------------------------- == 2 ** 256</span>
 396 |     | <span class='neutral'>      //        (2 ** 256) * (2 ** 111)</span>
 397 |     | <span class='neutral'>      //</span>
 398 |     | <span class='neutral'>      // In this case, we return overflow.</span>
 399 |     | <span class='neutral'>      if (q2 &gt;= (1 &lt;&lt; 111)) return (0, true);</span>
 400 |     | <span class='neutral'></span>
 401 |     | <span class='neutral'>      // Divide the numerator by &#39;2 ** 111&#39;</span>
 402 |     | <span class='neutral'>      (q2, q1) = (</span>
 403 |     | <span class='neutral'>        (q2 &lt;&lt; 145) | (q1 &gt;&gt; 111),</span>
 404 |     | <span class='neutral'>        (q1 &lt;&lt; 145) | (q0 &gt;&gt; 111)</span>
 405 |     | <span class='neutral'>      );</span>
 406 |     | <span class='neutral'></span>
 407 |     | <span class='neutral'>      // Calculating the remainder of the numerator modulo &#39;d&#39;.</span>
 408 |     | <span class='neutral'>      uint256 r;</span>
 409 |     | <span class='neutral'>      assembly {</span>
 410 |     | <span class='neutral'>        r := addmod(</span>
 411 |     | <span class='neutral'>          addmod(q1, q2, d), // (q1 + q2) % d</span>
 412 |     | <span class='neutral'>          mulmod(q2, not(0), d), // (q2 * (2 ** 256 - 1)) % d</span>
 413 |     | <span class='neutral'>          d</span>
 414 |     | <span class='neutral'>        ) // (q1 + q2 * (2 ** 256)) % d</span>
 415 |     | <span class='neutral'>      }</span>
 416 |     | <span class='neutral'></span>
 417 |     | <span class='neutral'>      //                         _____</span>
 418 |     | <span class='neutral'>      // &#39;r&#39; is subtracted from &#39;q2 q1&#39;.</span>
 419 |     | <span class='neutral'>      assembly {</span>
 420 |     | <span class='neutral'>        // &#39;q1 &lt; r&#39; indicates that the subtraction &#39;q1 - r&#39; underflowes.</span>
 421 |     | <span class='neutral'>        // In this case &#39;1&#39; needs to be subtracted from q2.</span>
 422 |     | <span class='neutral'>        q2 := sub(q2, lt(q1, r))</span>
 423 |     | <span class='neutral'>        q1 := sub(q1, r)</span>
 424 |     | <span class='neutral'>      }</span>
 425 |     | <span class='neutral'></span>
 426 |     | <span class='neutral'>      // Determines whether to return overflow.</span>
 427 |     | <span class='neutral'>      // The following equality is satisfied if and only if</span>
 428 |     | <span class='neutral'>      //</span>
 429 |     | <span class='neutral'>      //      a * b * c</span>
 430 |     | <span class='neutral'>      // &#39;---------------- &gt;= (2 ** 256)&#39;</span>
 431 |     | <span class='neutral'>      //   d * (2 ** 111)</span>
 432 |     | <span class='neutral'>      //</span>
 433 |     | <span class='neutral'>      if (q2 &gt;= d) return (0, true);</span>
 434 |     | <span class='neutral'></span>
 435 |     | <span class='neutral'>      // &#39;d&#39; is factored into an odd part and a power of two and the numerator</span>
 436 |     | <span class='neutral'>      // is divided by the power of two.</span>
 437 |     | <span class='neutral'>      d = (0 - d) &amp; d;</span>
 438 |     | <span class='neutral'>      assembly {</span>
 439 |     | <span class='neutral'>        q1 := or(</span>
 440 |     | <span class='neutral'>          div(q1, d), // q1 / (2 ** k)</span>
 441 |     | <span class='neutral'>          mul(</span>
 442 |     | <span class='neutral'>            q2,</span>
 443 |     | <span class='neutral'>            add(</span>
 444 |     | <span class='neutral'>              div(</span>
 445 |     | <span class='neutral'>                sub(0, d), // &#39;2 ** 256 - 2 ** k&#39;</span>
 446 |     | <span class='neutral'>                d // &#39;2 ** k&#39;</span>
 447 |     | <span class='neutral'>              ), // &#39;2 ** (256 - k) - 1&#39;</span>
 448 |     | <span class='neutral'>              1</span>
 449 |     | <span class='neutral'>            ) // &#39;(2 ** (256 - k)) % (2 ** 256)&#39;</span>
 450 |     | <span class='neutral'>          ) // &#39;(q2 * (2 ** (256 - k))) % (2 ** 256)&#39;</span>
 451 |     | <span class='neutral'>        ) // &#39;(q2 * (2 ** (256 - k)) + q1 / (2 ** k)) % (2 ** 256)&#39;</span>
 452 |     | <span class='neutral'>      }</span>
 453 |     | <span class='neutral'></span>
 454 |     | <span class='neutral'>      // The result can now be calculated precisely using &#39;e&#39;.</span>
 455 |     | <span class='neutral'>      //  _____</span>
 456 |     | <span class='neutral'>      // &#39;q2 q1 == d * result&#39;</span>
 457 |     | <span class='neutral'>      // &#39;(2 ** 256) * q2 + q1 == d * result&#39;</span>
 458 |     | <span class='neutral'>      // &#39;e * (2 ** 256) * q2 + e * q1 == e * d * result&#39;</span>
 459 |     | <span class='neutral'>      // &#39;e * (2 ** 256) * q2 + e * q1 == ((2 ** 256) * k + 1) * result&#39;</span>
 460 |     | <span class='neutral'>      // &#39;e * q1 == result&#39; [mod 2 ** 256]</span>
 461 |     | <span class='neutral'>      result = e * q1;</span>
 462 |     | <span class='neutral'></span>
 463 |     | <span class='neutral'>      // If either of the remainders are positive, then the result should be</span>
 464 |     | <span class='neutral'>      // rounded up.</span>
 465 |     | <span class='neutral'>      if (roundUp) {</span>
 466 |     | <span class='neutral'>        if ((q0 &amp; 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFF) &gt; 0 || r &gt; 0) {</span>
 467 |     | <span class='neutral'>          ++result;</span>
 468 |     | <span class='neutral'>        }</span>
 469 |     | <span class='neutral'>      }</span>
 470 |     | <span class='neutral'></span>
 471 |     | <span class='neutral'>      // Determines whether to overflow.</span>
 472 |     | <span class='neutral'>      if (result &gt;= (1 &lt;&lt; 255)) return (0, true);</span>
 473 |     | <span class='neutral'>    }</span>
 474 |     | <span class='neutral'>  }</span>
 475 |     | <span class='neutral'></span>
 476 |     | <span class='neutral'>  /// @notice Calculates floor((a * b) / denominator) with full precision.</span>
 477 |     | <span class='neutral'>  /// Overflow should be avoided externally.</span>
 478 |     | <span class='neutral'>  /// @param a The multiplicand</span>
 479 |     | <span class='neutral'>  /// @param b The multiplier</span>
 480 |     | <span class='neutral'>  /// @param denominator The divisor</span>
 481 |     | <span class='neutral'>  /// @return result The 256-bit result</span>
 482 |     | <span class='neutral'>  function mulDiv(</span>
 483 |     | <span class='neutral'>    uint256 a,</span>
 484 |     | <span class='neutral'>    uint256 b,</span>
 485 |     | <span class='neutral'>    uint256 denominator</span>
 486 |     | <span class='neutral'>  ) internal pure returns (</span>
 487 |     | <span class='neutral'>    uint256 result</span>
 488 |     | <span class='neutral'>  ) {</span>
 489 |     | <span class='neutral'>    unchecked {</span>
 490 |     | <span class='neutral'>      //                   ___________</span>
 491 |     | <span class='neutral'>      // 512-bit multiply &#39;prod1 prod0 = a * b&#39;</span>
 492 |     | <span class='neutral'>      // Compute the product mod 2**256 and mod 2 ** 256 - 1</span>
 493 |     | <span class='neutral'>      // then use the Chinese Remainder Theorem to reconstruct</span>
 494 |     | <span class='neutral'>      // the 512 bit result. The result is stored in two 256</span>
 495 |     | <span class='neutral'>      // variables such that product = prod1 * (2 ** 256) + prod0</span>
 496 |     | <span class='neutral'>      (uint256 prod0, uint256 prod1) = mul512(a, b);</span>
 497 |     | <span class='neutral'></span>
 498 |     | <span class='neutral'>      // Short circuit 256 by 256 division</span>
 499 |     | <span class='neutral'>      // This saves gas when a * b is small, at the cost of making the</span>
 500 |     | <span class='neutral'>      // large case a bit more expensive. Depending on your use case you</span>
 501 |     | <span class='neutral'>      // may want to remove this short circuit and always go through the</span>
 502 |     | <span class='neutral'>      // 512 bit path.</span>
 503 |     | <span class='neutral'>      if (prod1 == 0) {</span>
 504 |     | <span class='neutral'>        assembly {</span>
 505 |     | <span class='neutral'>          result := div(prod0, denominator)</span>
 506 |     | <span class='neutral'>        }</span>
 507 |     | <span class='neutral'>        return result;</span>
 508 |     | <span class='neutral'>      }</span>
 509 |     | <span class='neutral'>      </span>
 510 |     | <span class='neutral'>      ///////////////////////////////////////////////</span>
 511 |     | <span class='neutral'>      // 512 by 256 division.</span>
 512 |     | <span class='neutral'>      ///////////////////////////////////////////////</span>
 513 |     | <span class='neutral'></span>
 514 |     | <span class='neutral'>      //                                                        ___________</span>
 515 |     | <span class='neutral'>      // Make division exact by subtracting the remainder from &#39;prod1 prod0&#39;</span>
 516 |     | <span class='neutral'>      // Compute remainder using mulmod</span>
 517 |     | <span class='neutral'>      // Note mulmod(_, _, 0) == 0</span>
 518 |     | <span class='neutral'>      uint256 remainder;</span>
 519 |     | <span class='neutral'>      assembly {</span>
 520 |     | <span class='neutral'>        remainder := mulmod(a, b, denominator)</span>
 521 |     | <span class='neutral'>      }</span>
 522 |     | <span class='neutral'></span>
 523 |     | <span class='neutral'>      // Subtract 256 bit number from 512 bit number</span>
 524 |     | <span class='neutral'>      assembly {</span>
 525 |     | <span class='neutral'>        prod1 := sub(prod1, gt(remainder, prod0))</span>
 526 |     | <span class='neutral'>        prod0 := sub(prod0, remainder)</span>
 527 |     | <span class='neutral'>      }</span>
 528 |     | <span class='neutral'>      </span>
 529 |     | <span class='neutral'>      // Factor powers of two out of denominator</span>
 530 |     | <span class='neutral'>      // Compute largest power of two-divisor of denominator.</span>
 531 |     | <span class='neutral'>      // Always &gt;= 1 unless the denominator is zero, then twos is zero.</span>
 532 |     | <span class='neutral'>      uint256 twos = (0 - denominator) &amp; denominator;</span>
 533 |     | <span class='neutral'>      // Divide denominator by power of two</span>
 534 |     | <span class='neutral'>      assembly {</span>
 535 |     | <span class='neutral'>        denominator := div(denominator, twos)</span>
 536 |     | <span class='neutral'>      }</span>
 537 |     | <span class='neutral'>      </span>
 538 |     | <span class='neutral'>      //         ___________</span>
 539 |     | <span class='neutral'>      // Divide &#39;prod1 prod0&#39; by the factors of two</span>
 540 |     | <span class='neutral'>      assembly {</span>
 541 |     | <span class='neutral'>        prod0 := div(prod0, twos)</span>
 542 |     | <span class='neutral'>      }</span>
 543 |     | <span class='neutral'>      // Shift in bits from prod1 into prod0. For this we need</span>
 544 |     | <span class='neutral'>      // to flip `twos` such that it is 2**256 / twos.</span>
 545 |     | <span class='neutral'>      // If twos is zero, then it becomes one</span>
 546 |     | <span class='neutral'>      assembly {</span>
 547 |     | <span class='neutral'>        twos := add(div(sub(0, twos), twos), 1)</span>
 548 |     | <span class='neutral'>      }</span>
 549 |     | <span class='neutral'>      prod0 |= prod1 * twos;</span>
 550 |     | <span class='neutral'>      </span>
 551 |     | <span class='neutral'>      // Invert denominator mod 2**256</span>
 552 |     | <span class='neutral'>      // Now that denominator is an odd number, it has an inverse</span>
 553 |     | <span class='neutral'>      // modulo 2**256 such that denominator * inv = 1 mod 2**256.</span>
 554 |     | <span class='neutral'>      // Compute the inverse by starting with a seed that is correct</span>
 555 |     | <span class='neutral'>      // correct for four bits. That is, denominator * inv = 1 mod 2**4</span>
 556 |     | <span class='neutral'>      // If denominator is zero the inverse starts with 2</span>
 557 |     | <span class='neutral'>      // Now use Newton-Raphson iteration to improve the precision.</span>
 558 |     | <span class='neutral'>      // Thanks to Hensel&#39;s lifting lemma, this also works in modular</span>
 559 |     | <span class='neutral'>      // arithmetic, doubling the correct bits in each step.</span>
 560 |     | <span class='neutral'>      uint256 inv = modularInverse(denominator);</span>
 561 |     | <span class='neutral'>      // If denominator is zero, inv is now 128</span>
 562 |     | <span class='neutral'>      </span>
 563 |     | <span class='neutral'>      // Because the division is now exact we can divide by multiplying</span>
 564 |     | <span class='neutral'>      // with the modular inverse of the denominator. This will give us the</span>
 565 |     | <span class='neutral'>      // correct result modulo 2**256. Since the preconditions guarantee</span>
 566 |     | <span class='neutral'>      // that the outcome is less than 2**256, this is the final result.</span>
 567 |     | <span class='neutral'>      // We don&#39;t need to compute the high bits of the result and prod1</span>
 568 |     | <span class='neutral'>      // is no longer required.</span>
 569 |     | <span class='neutral'>      result = prod0 * inv;</span>
 570 |     | <span class='neutral'>      return result;</span>
 571 |     | <span class='neutral'>    }</span>
 572 |     | <span class='neutral'>  }</span>
 573 |     | <span class='neutral'></span>
 574 |     | <span class='neutral'>  /// @notice Calculates ceiling((a * b) / denominator) with full precision.</span>
 575 |     | <span class='neutral'>  /// Overflow should be avoided externally.</span>
 576 |     | <span class='neutral'>  /// @param a The multiplicand</span>
 577 |     | <span class='neutral'>  /// @param b The multiplier</span>
 578 |     | <span class='neutral'>  /// @param denominator The divisor</span>
 579 |     | <span class='neutral'>  /// @return result The 256-bit result</span>
 580 |     | <span class='neutral'>  function mulDivRoundUp(</span>
 581 |     | <span class='neutral'>    uint256 a,</span>
 582 |     | <span class='neutral'>    uint256 b,</span>
 583 |     | <span class='neutral'>    uint256 denominator</span>
 584 |     | <span class='neutral'>  ) internal pure returns (uint256 result) {</span>
 585 |     | <span class='neutral'>    result = mulDiv(a, b, denominator);</span>
 586 |     | <span class='neutral'>    // The result is incremented if &#39;a * b&#39; is not divisible by &#39;denominator&#39;.</span>
 587 |     | <span class='neutral'>    assembly {</span>
 588 |     | <span class='neutral'>      result := add(result, gt(mulmod(a, b, denominator), 0))</span>
 589 |     | <span class='neutral'>    }</span>
 590 |     | <span class='neutral'>  }</span>
 591 |     | <span class='neutral'></span>
 592 |     | <span class='neutral'>  /// @notice Calculates floor((a * b) / denominator) with full precision.</span>
 593 |     | <span class='neutral'>  /// Throws in case of overflow.</span>
 594 |     | <span class='neutral'>  /// @param a The multiplicand</span>
 595 |     | <span class='neutral'>  /// @param b The multiplier</span>
 596 |     | <span class='neutral'>  /// @param denominator The divisor</span>
 597 |     | <span class='neutral'>  /// @return result The 256-bit result</span>
 598 |     | <span class='neutral'>  function safeMulDiv(</span>
 599 |     | <span class='neutral'>    uint256 a,</span>
 600 |     | <span class='neutral'>    uint256 b,</span>
 601 |     | <span class='neutral'>    uint256 denominator</span>
 602 |     | <span class='neutral'>  ) internal pure returns (uint256 result) {</span>
 603 |     | <span class='neutral'>    (, uint256 prod1) = mul512(a, b);</span>
 604 |     | <span class='neutral'>    require(prod1 &lt; denominator, MulDivOverflow(a, b, denominator));</span>
 605 |     | <span class='neutral'>    result = mulDiv(a, b, denominator);</span>
 606 |     | <span class='neutral'>  }</span>
 607 |     | <span class='neutral'></span>
 608 |     | <span class='neutral'>  /// @notice Calculates ceiling((a * b) / denominator) with full precision.</span>
 609 |     | <span class='neutral'>  /// Throws in case of overflow.</span>
 610 |     | <span class='neutral'>  /// @param a The multiplicand</span>
 611 |     | <span class='neutral'>  /// @param b The multiplier</span>
 612 |     | <span class='neutral'>  /// @param denominator The divisor</span>
 613 |     | <span class='neutral'>  /// @return result The 256-bit result</span>
 614 |     | <span class='neutral'>  function safeMulDivRoundUp(</span>
 615 |     | <span class='neutral'>    uint256 a,</span>
 616 |     | <span class='neutral'>    uint256 b,</span>
 617 |     | <span class='neutral'>    uint256 denominator</span>
 618 |     | <span class='neutral'>  ) internal pure returns (uint256 result) {</span>
 619 |     | <span class='neutral'>    // The result is incremented if &#39;a * b&#39; is not divisible by &#39;denominator&#39;.</span>
 620 |     | <span class='neutral'>    assembly {</span>
 621 |     | <span class='neutral'>      result := gt(mulmod(a, b, denominator), 0)</span>
 622 |     | <span class='neutral'>    }</span>
 623 |     | <span class='neutral'>    result += safeMulDiv(a, b, denominator);</span>
 624 |     | <span class='neutral'>  }</span>
 625 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/Index.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// Type index is used to enumerate members of the curve and kernel.</span>
   5 |     | <span class='neutral'>type Index is uint256;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>Index constant zeroIndex = Index.wrap(0);</span>
   8 |     | <span class='neutral'>Index constant oneIndex = Index.wrap(1);</span>
   9 |     | <span class='neutral'>Index constant twoIndex = Index.wrap(2);</span>
  10 |     | <span class='neutral'>Index constant threeIndex = Index.wrap(3);</span>
  11 |     | <span class='neutral'>Index constant maxCurveIndex = Index.wrap(type(uint16).max);</span>
  12 |     | <span class='neutral'>Index constant maxKernelIndex = Index.wrap(1020);</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>using {equals as ==, notEquals as !=} for Index global;</span>
  15 |     | <span class='neutral'>using {lessThan as &lt;, greaterThan as &gt;} for Index global;</span>
  16 |     | <span class='neutral'>using {lessThanOrEqualTo as &lt;=, greaterThanOrEqualTo as &gt;=} for Index global;</span>
  17 |     | <span class='neutral'>using {add as +, sub as -} for Index global;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>function equals(</span>
  20 |     | <span class='neutral'>  Index value0,</span>
  21 |     | <span class='neutral'>  Index value1</span>
  22 |     | <span class='neutral'>) pure returns (</span>
  23 |     | <span class='neutral'>  bool result</span>
  24 |     | <span class='neutral'>) {</span>
  25 |     | <span class='neutral'>  assembly {</span>
  26 |     | <span class='neutral'>    result := eq(value0, value1)</span>
  27 |     | <span class='neutral'>  }</span>
  28 |     | <span class='neutral'>}</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>function notEquals(</span>
  31 |     | <span class='neutral'>  Index value0,</span>
  32 |     | <span class='neutral'>  Index value1</span>
  33 |     | <span class='neutral'>) pure returns (</span>
  34 |     | <span class='neutral'>  bool result</span>
  35 |     | <span class='neutral'>) {</span>
  36 |     | <span class='neutral'>  return !(value0 == value1);</span>
  37 |     | <span class='neutral'>}</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>function lessThan(</span>
  40 |     | <span class='neutral'>  Index value0,</span>
  41 |     | <span class='neutral'>  Index value1</span>
  42 |     | <span class='neutral'>) pure returns (</span>
  43 |     | <span class='neutral'>  bool result</span>
  44 |     | <span class='neutral'>) {</span>
  45 |     | <span class='neutral'>  assembly {</span>
  46 |     | <span class='neutral'>    result := lt(value0, value1)</span>
  47 |     | <span class='neutral'>  }</span>
  48 |     | <span class='neutral'>}</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>function greaterThan(</span>
  51 |     | <span class='neutral'>  Index value0,</span>
  52 |     | <span class='neutral'>  Index value1</span>
  53 |     | <span class='neutral'>) pure returns (</span>
  54 |     | <span class='neutral'>  bool result</span>
  55 |     | <span class='neutral'>) {</span>
  56 |     | <span class='neutral'>  assembly {</span>
  57 |     | <span class='neutral'>    result := gt(value0, value1)</span>
  58 |     | <span class='neutral'>  }</span>
  59 |     | <span class='neutral'>}</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>function lessThanOrEqualTo(</span>
  62 |     | <span class='neutral'>  Index value0,</span>
  63 |     | <span class='neutral'>  Index value1</span>
  64 |     | <span class='neutral'>) pure returns (</span>
  65 |     | <span class='neutral'>  bool result</span>
  66 |     | <span class='neutral'>) {</span>
  67 |     | <span class='neutral'>  return !(value0 &gt; value1);</span>
  68 |     | <span class='neutral'>}</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>function greaterThanOrEqualTo(</span>
  71 |     | <span class='neutral'>  Index value0,</span>
  72 |     | <span class='neutral'>  Index value1</span>
  73 |     | <span class='neutral'>) pure returns (</span>
  74 |     | <span class='neutral'>  bool result</span>
  75 |     | <span class='neutral'>) {</span>
  76 |     | <span class='neutral'>  return !(value0 &lt; value1);</span>
  77 |     | <span class='neutral'>}</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>// Overflow should be avoided externally.</span>
  80 |     | <span class='neutral'>function add(</span>
  81 |     | <span class='neutral'>  Index value0,</span>
  82 |     | <span class='neutral'>  Index value1</span>
  83 |     | <span class='neutral'>) pure returns (</span>
  84 |     | <span class='neutral'>  Index result</span>
  85 |     | <span class='neutral'>) {</span>
  86 |     | <span class='neutral'>  assembly {</span>
  87 |     | <span class='neutral'>    result := add(value0, value1)</span>
  88 |     | <span class='neutral'>  }</span>
  89 |     | <span class='neutral'>}</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>// Underflow should be avoided externally.</span>
  92 |     | <span class='neutral'>function sub(</span>
  93 |     | <span class='neutral'>  Index value0,</span>
  94 |     | <span class='neutral'>  Index value1</span>
  95 |     | <span class='neutral'>) pure returns (</span>
  96 |     | <span class='neutral'>  Index result</span>
  97 |     | <span class='neutral'>) {</span>
  98 |     | <span class='neutral'>  assembly {</span>
  99 |     | <span class='neutral'>    result := sub(value0, value1)</span>
 100 |     | <span class='neutral'>  }</span>
 101 |     | <span class='neutral'>}</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>function min(</span>
 104 |     | <span class='neutral'>  Index value0,</span>
 105 |     | <span class='neutral'>  Index value1</span>
 106 |     | <span class='neutral'>) pure returns (</span>
 107 |     | <span class='neutral'>  Index result</span>
 108 |     | <span class='neutral'>) {</span>
 109 |     | <span class='neutral'>  return (value0 &lt; value1) ? value0 : value1;</span>
 110 |     | <span class='neutral'>}</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>function max(</span>
 113 |     | <span class='neutral'>  Index value0,</span>
 114 |     | <span class='neutral'>  Index value1</span>
 115 |     | <span class='neutral'>) pure returns (</span>
 116 |     | <span class='neutral'>  Index result</span>
 117 |     | <span class='neutral'>) {</span>
 118 |     | <span class='neutral'>  return (value0 &lt; value1) ? value1 : value0;</span>
 119 |     | <span class='neutral'>}</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>library IndexLibrary {</span>
 122 |     | <span class='neutral'>  /// @notice Returns the current 16-bit index of the curve or kernel under </span>
 123 |     | <span class='neutral'>  /// exploration given the corresponding pointer.</span>
 124 |     | <span class='neutral'>  ///</span>
 125 |     | <span class='neutral'>  /// &#39;pointer&#39; should be a constant value.</span>
 126 |     | <span class='neutral'>  function getIndex(</span>
 127 |     | <span class='neutral'>    uint256 pointer</span>
 128 |     | <span class='neutral'>  ) internal pure returns (</span>
 129 |     | <span class='neutral'>    Index value</span>
 130 |     | <span class='neutral'>  ) {</span>
 131 |     | <span class='neutral'>    assembly {</span>
 132 |     | <span class='neutral'>      // First, the memory slot whose most significant 16 bits host the index</span>
 133 |     | <span class='neutral'>      // is loaded and then the least significant 240 bits are discarded.</span>
 134 |     | <span class='neutral'>      value := shr(240, mload(pointer))</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'>  }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>  /// @notice Increases a 16-bit index stored in memory by one, given a </span>
 139 |     | <span class='neutral'>  /// pointer. The new value for the index is then returned.</span>
 140 |     | <span class='neutral'>  /// Overflow should be avoided externally.</span>
 141 |     | <span class='neutral'>  ///</span>
 142 |     | <span class='neutral'>  /// &#39;pointer&#39; should be a constant value.</span>
 143 |     | <span class='neutral'>  function incrementIndex(</span>
 144 |     | <span class='neutral'>    uint256 pointer</span>
 145 |     | <span class='neutral'>  ) internal pure returns (</span>
 146 |     | <span class='neutral'>    Index value</span>
 147 |     | <span class='neutral'>  ) {</span>
 148 |     | <span class='neutral'>    assembly {</span>
 149 |     | <span class='neutral'>      // Index is the most significant 16 bit. Hence, to increment it we need</span>
 150 |     | <span class='neutral'>      // to add the slot by &#39;2 ** 240&#39;.</span>
 151 |     | <span class='neutral'>      value := add(mload(pointer), shl(240, 1))</span>
 152 |     | <span class='neutral'>      mstore(pointer, value)</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>      // Then, the least significant 240 bits are discarded and the resulting</span>
 155 |     | <span class='neutral'>      // value is returned.</span>
 156 |     | <span class='neutral'>      value := shr(240, value)</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'>  }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>  /// @notice Decreases a 16-bit index stored in memory by one, given a </span>
 161 |     | <span class='neutral'>  /// pointer. The new value for the index is then returned.</span>
 162 |     | <span class='neutral'>  /// Underflow should be avoided externally.</span>
 163 |     | <span class='neutral'>  ///</span>
 164 |     | <span class='neutral'>  /// &#39;pointer&#39; should be a constant value.</span>
 165 |     | <span class='neutral'>  function decrementIndex(</span>
 166 |     | <span class='neutral'>    uint256 pointer</span>
 167 |     | <span class='neutral'>  ) internal pure returns (</span>
 168 |     | <span class='neutral'>    Index value</span>
 169 |     | <span class='neutral'>  ) {</span>
 170 |     | <span class='neutral'>    assembly {</span>
 171 |     | <span class='neutral'>      // Index is the most significant 16 bit. Hence, to decrement it we need</span>
 172 |     | <span class='neutral'>      // to subtract the slot by &#39;2 ** 240&#39;.</span>
 173 |     | <span class='neutral'>      value := sub(mload(pointer), shl(240, 1))</span>
 174 |     | <span class='neutral'>      mstore(pointer, value)</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>      // Then, the least significant 240 bits are discarded and the resulting</span>
 177 |     | <span class='neutral'>      // value is returned.</span>
 178 |     | <span class='neutral'>      value := shr(240, value)</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'>  }</span>
 181 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/Kernel.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {Index, zeroIndex} from &quot;./Index.sol&quot;;</span>
   5 |     | <span class='neutral'>import {X15} from &quot;./X15.sol&quot;;</span>
   6 |     | <span class='neutral'>import {X59} from &quot;./X59.sol&quot;;</span>
   7 |     | <span class='neutral'>import {X216, oneX216} from &quot;./X216.sol&quot;;</span>
   8 |     | <span class='neutral'>import {PriceLibrary} from &quot;./Price.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>using PriceLibrary for uint16;</span>
  11 |     | <span class='neutral'>using PriceLibrary for uint256;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>// For every pool, the kernel function &#39;k : [0, qSpacing] -&gt; [0, 1]&#39; represents</span>
  14 |     | <span class='neutral'>// a monotonically non-decreasing piece-wise linear function whose breakpoints</span>
  15 |     | <span class='neutral'>// are listed in the storage smart contract. Let &#39;m + 1&#39; denote the number</span>
  16 |     | <span class='neutral'>// of these breakpoints. For every integer &#39;0 &lt;= i &lt;= m&#39; the i-th breakpoint of</span>
  17 |     | <span class='neutral'>// the kernel represents the pair &#39;(b[i], c[i])&#39; where</span>
  18 |     | <span class='neutral'>//</span>
  19 |     | <span class='neutral'>//  &#39;0 == b[0] &lt;  b[1] &lt;= b[2] &lt;= ... &lt;= b[m - 1] &lt;  b[m] == qSpacing&#39;,</span>
  20 |     | <span class='neutral'>//  &#39;0 == c[0] &lt;= c[1] &lt;= c[2] &lt;= ... &lt;= c[m - 1] &lt;= c[m] == 1&#39;.</span>
  21 |     | <span class='neutral'>// </span>
  22 |     | <span class='neutral'>// Each breakpoint occupies 64 bytes, in which:</span>
  23 |     | <span class='neutral'>//</span>
  24 |     | <span class='neutral'>//  - the &#39;X15&#39; representation of &#39;(2 ** 15) * c[i]&#39; occupies 2 bytes,</span>
  25 |     | <span class='neutral'>//</span>
  26 |     | <span class='neutral'>//  - the &#39;X59&#39; representation of &#39;(2 ** 59) * b[i]&#39; occupies 8 bytes,</span>
  27 |     | <span class='neutral'>//</span>
  28 |     | <span class='neutral'>//  - the &#39;X216&#39; representation of &#39;(2 ** 216) * exp(- b[i] / 2)&#39; occupies 27</span>
  29 |     | <span class='neutral'>//    bytes,</span>
  30 |     | <span class='neutral'>//</span>
  31 |     | <span class='neutral'>//  - the &#39;X216&#39; representation of &#39;(2 ** 216) * exp(- 16 + b[i] / 2)&#39; occupies</span>
  32 |     | <span class='neutral'>//    27 bytes.</span>
  33 |     | <span class='neutral'>//</span>
  34 |     | <span class='neutral'>// The above-mentioned layout is illustrated as follows:</span>
  35 |     | <span class='neutral'>//</span>
  36 |     | <span class='neutral'>//                      A 512 bit kernel breakpoint</span>
  37 |     | <span class='neutral'>//  +--+--------+---------------------------+---------------------------+</span>
  38 |     | <span class='neutral'>//  |  | 8 byte |          27 byte          |          27 byte          |</span>
  39 |     | <span class='neutral'>//  +--+--------+---------------------------+---------------------------+</span>
  40 |     | <span class='neutral'>//  |  |        |                           |</span>
  41 |     | <span class='neutral'>//  |  |        |                            \</span>
  42 |     | <span class='neutral'>//  |  |        |                             (2 ** 216) * exp(- 16 + b[i] / 2)</span>
  43 |     | <span class='neutral'>//  |  |         \</span>
  44 |     | <span class='neutral'>//  |  |          (2 ** 216) * exp(- b[i] / 2)</span>
  45 |     | <span class='neutral'>//  |   \</span>
  46 |     | <span class='neutral'>//  |    (2 ** 59) * b[i]</span>
  47 |     | <span class='neutral'>//   \</span>
  48 |     | <span class='neutral'>//    (2 ** 15) * c[i]</span>
  49 |     | <span class='neutral'>//</span>
  50 |     | <span class='neutral'>// Consider the following list of kernel breakpoints:</span>
  51 |     | <span class='neutral'>//</span>
  52 |     | <span class='neutral'>//  &#39;(b[0], c[0]), (b[1], c[1]), (b[2], c[2]), ..., (b[m], c[m])&#39;</span>
  53 |     | <span class='neutral'>//</span>
  54 |     | <span class='neutral'>// and for every integer &#39;0 &lt; i &lt;= m&#39;, define</span>
  55 |     | <span class='neutral'>//</span>
  56 |     | <span class='neutral'>//  &#39;k_i : [0, qSpacing] -&gt; [0, 1]&#39;</span>
  57 |     | <span class='neutral'>//</span>
  58 |     | <span class='neutral'>// as</span>
  59 |     | <span class='neutral'>//</span>
  60 |     | <span class='neutral'>//  &#39;k_i(q) :=</span>
  61 |     | <span class='neutral'>//</span>
  62 |     | <span class='neutral'>//    /            c[i] - c[i - 1]</span>
  63 |     | <span class='neutral'>//   | c[i - 1] + ----------------- * (q - b[i - 1])  if  b[i - 1] &lt; q &lt; b[i]</span>
  64 |     | <span class='neutral'>//   |             b[i] - b[i - 1]                                           &#39;,</span>
  65 |     | <span class='neutral'>//   | 0                                              otherwise</span>
  66 |     | <span class='neutral'>//    \</span>
  67 |     | <span class='neutral'>//</span>
  68 |     | <span class='neutral'>// which means that if &#39;b[i - 1] == b[i]&#39;, then &#39;k_i(q) := 0&#39;. Now, the kernel</span>
  69 |     | <span class='neutral'>// function</span>
  70 |     | <span class='neutral'>// </span>
  71 |     | <span class='neutral'>//  &#39;k : [0, qSpacing] -&gt; [0, 1]&#39;</span>
  72 |     | <span class='neutral'>//</span>
  73 |     | <span class='neutral'>// is defined as</span>
  74 |     | <span class='neutral'>//</span>
  75 |     | <span class='neutral'>//             m</span>
  76 |     | <span class='neutral'>//           -----</span>
  77 |     | <span class='neutral'>//           \</span>
  78 |     | <span class='neutral'>//  &#39;k(q) := /     k_i(q)&#39;.</span>
  79 |     | <span class='neutral'>//           -----</span>
  80 |     | <span class='neutral'>//           i = 1</span>
  81 |     | <span class='neutral'>//</span>
  82 |     | <span class='neutral'>type Kernel is uint256;</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>using KernelLibrary for Kernel global;</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>library KernelLibrary {</span>
  87 |     | <span class='neutral'>  /// @notice Returns the components of the kernel breakpoint which corresponds</span>
  88 |     | <span class='neutral'>  /// to the given index.</span>
  89 |     | <span class='neutral'>  ///</span>
  90 |     | <span class='neutral'>  /// Index out of range should be avoided externally.</span>
  91 |     | <span class='neutral'>  function member(</span>
  92 |     | <span class='neutral'>    Kernel kernel,</span>
  93 |     | <span class='neutral'>    Index index</span>
  94 |     | <span class='neutral'>  ) internal pure returns (</span>
  95 |     | <span class='neutral'>    X15 height,</span>
  96 |     | <span class='neutral'>    X59 logShift,</span>
  97 |     | <span class='neutral'>    X216 sqrtShift,</span>
  98 |     | <span class='neutral'>    X216 sqrtInverseShift</span>
  99 |     | <span class='neutral'>  ) {</span>
 100 |     | <span class='neutral'>    // If &#39;index&#39; is equal to 0, then this function should return </span>
 101 |     | <span class='neutral'>    // &#39;(zeroX15, zeroX59, oneX216, floor((2 ** 216) * exp(-16)))&#39;. Because the</span>
 102 |     | <span class='neutral'>    // first member of kernelCompact is always &#39;(zeroX15, zeroX59)&#39;.</span>
 103 |     | <span class='neutral'>    if (index &gt; zeroIndex) {</span>
 104 |     | <span class='neutral'>      uint256 pointer;</span>
 105 |     | <span class='neutral'>      assembly {</span>
 106 |     | <span class='neutral'>        // Each member of Kernel is &#39;64 == 2 ** 6&#39; bytes. Hence we shift</span>
 107 |     | <span class='neutral'>        // &#39;index&#39; by &#39;6&#39; digits which is equivalent to multiplying by &#39;64&#39;.</span>
 108 |     | <span class='neutral'>        // The origin is omitted and handled separately. We subtract by</span>
 109 |     | <span class='neutral'>        // &#39;62 = 8 + 27 + 27&#39; so that the pointer corresponding to </span>
 110 |     | <span class='neutral'>        // &#39;index == oneIndex&#39; follows this layout:</span>
 111 |     | <span class='neutral'>        //</span>
 112 |     | <span class='neutral'>        //        pointer</span>
 113 |     | <span class='neutral'>        //      /</span>
 114 |     | <span class='neutral'>        //     |        A 512 bit kernel breakpoint</span>
 115 |     | <span class='neutral'>        //  +--+--------+-----------------+-----------------+</span>
 116 |     | <span class='neutral'>        //  |  | 8 byte |     27 byte     |     27 byte     |</span>
 117 |     | <span class='neutral'>        //  +--+--------+-----------------+-----------------+</span>
 118 |     | <span class='neutral'>        //  |  |        |                 |</span>
 119 |     | <span class='neutral'>        //  |  |        |                  \</span>
 120 |     | <span class='neutral'>        //  |  |        |                   (2 ** 216) * exp(- 16 + b[i] / 2)</span>
 121 |     | <span class='neutral'>        //  |  |         \</span>
 122 |     | <span class='neutral'>        //  |  |          (2 ** 216) * exp(- b[i] / 2)</span>
 123 |     | <span class='neutral'>        //  |   \</span>
 124 |     | <span class='neutral'>        //  |    (2 ** 59) * b[i]</span>
 125 |     | <span class='neutral'>        //   \</span>
 126 |     | <span class='neutral'>        //    (2 ** 15) * c[i]</span>
 127 |     | <span class='neutral'>        //</span>
 128 |     | <span class='neutral'>        pointer := add(kernel, sub(shl(6, index), 62))</span>
 129 |     | <span class='neutral'>      }</span>
 130 |     | <span class='neutral'>      // Now that &#39;pointer&#39; points to a price with height according to the</span>
 131 |     | <span class='neutral'>      // above layout, all four values are loaded from memory using</span>
 132 |     | <span class='neutral'>      // &#39;PriceLibrary&#39;.</span>
 133 |     | <span class='neutral'>      height = pointer.height();</span>
 134 |     | <span class='neutral'>      logShift = pointer.log();</span>
 135 |     | <span class='neutral'>      sqrtShift = pointer.sqrt(false);</span>
 136 |     | <span class='neutral'>      sqrtInverseShift = pointer.sqrt(true);</span>
 137 |     | <span class='neutral'>    } else {</span>
 138 |     | <span class='neutral'>      // &#39;height&#39; and &#39;logShift&#39; are zero by default.</span>
 139 |     | <span class='neutral'>      sqrtShift = oneX216;</span>
 140 |     | <span class='neutral'>      sqrtInverseShift = X216.wrap(</span>
 141 |     | <span class='neutral'>        0x0000000000000001E355BBAEE85CADA65F73F32E88FB3CC629B709109F57564D</span>
 142 |     | <span class='neutral'>      ); // floor((2 ** 216) * exp(-16))</span>
 143 |     | <span class='neutral'>    }</span>
 144 |     | <span class='neutral'>  }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>  /// @notice This function calculates the resultant of the logarithmic price</span>
 147 |     | <span class='neutral'>  /// &#39;q&#39; which is stored in &#39;basePrice&#39; and the &#39;index&#39; breakpoint of</span>
 148 |     | <span class='neutral'>  /// &#39;kernel&#39;. The resultant is then stored in memory.</span>
 149 |     | <span class='neutral'>  ///</span>
 150 |     | <span class='neutral'>  /// If &#39;left == false&#39;, the resulting log price is equal to </span>
 151 |     | <span class='neutral'>  ///</span>
 152 |     | <span class='neutral'>  ///  &#39;qResultant := q + b[index]&#39;.</span>
 153 |     | <span class='neutral'>  ///</span>
 154 |     | <span class='neutral'>  /// In this case we should have: &#39;0 &lt; q + b[index] &lt; 2 ** 64&#39;.</span>
 155 |     | <span class='neutral'>  ///</span>
 156 |     | <span class='neutral'>  /// If &#39;left == true&#39;, the resulting log price is equal to </span>
 157 |     | <span class='neutral'>  ///</span>
 158 |     | <span class='neutral'>  ///  &#39;qResultant := q - b[index]&#39;.</span>
 159 |     | <span class='neutral'>  ///</span>
 160 |     | <span class='neutral'>  /// In this case we should have: &#39;0 &lt; q - b[index] &lt; 2 ** 64&#39;.</span>
 161 |     | <span class='neutral'>  ///</span>
 162 |     | <span class='neutral'>  /// Index out of range should be avoided externally.</span>
 163 |     | <span class='neutral'>  /// &#39;resultant&#39; should not be less than &#39;34&#39;.</span>
 164 |     | <span class='neutral'>  function impose(</span>
 165 |     | <span class='neutral'>    Kernel kernel,</span>
 166 |     | <span class='neutral'>    uint256 resultant,</span>
 167 |     | <span class='neutral'>    uint256 basePrice,</span>
 168 |     | <span class='neutral'>    Index index,</span>
 169 |     | <span class='neutral'>    bool left</span>
 170 |     | <span class='neutral'>  ) internal pure {</span>
 171 |     | <span class='neutral'>    // These four values correspond to the kernel&#39;s member.</span>
 172 |     | <span class='neutral'>    (X15 height, X59 logShift, X216 sqrtShift, X216 sqrtInverseShift) = </span>
 173 |     | <span class='neutral'>      kernel.member(index);</span>
 174 |     | <span class='neutral'>    </span>
 175 |     | <span class='neutral'>    // Addition or subtraction is safe due to the above requirements.</span>
 176 |     | <span class='neutral'>    // The multiplication does not overflow because both values are loaded from</span>
 177 |     | <span class='neutral'>    // 216 bits of memory. Hence, they are non-negative and are less than</span>
 178 |     | <span class='neutral'>    // oneX216.</span>
 179 |     | <span class='neutral'>    // The requirements of &#39;mulDivByExpInv16&#39; are met because both values are </span>
 180 |     | <span class='neutral'>    // loaded from 216 bits of memory. Hence, they are non-negative and are </span>
 181 |     | <span class='neutral'>    // less than oneX216. Additionally, &#39;mulDivByExpInv16&#39; does not overflow</span>
 182 |     | <span class='neutral'>    // and fits within 216 bits, because if &#39;left == false&#39;:</span>
 183 |     | <span class='neutral'>    //</span>
 184 |     | <span class='neutral'>    // &#39;(basePrice.sqrt(true) ^ sqrtInverseShift) / (2 ** 216) == </span>
 185 |     | <span class='neutral'>    //  exp(- 16 - 16 + (basePrice.log() + logShift) / (2 ** 60)) / exp(-16)</span>
 186 |     | <span class='neutral'>    //  == exp(- 16 + (basePrice.log() + logShift) / (2 ** 60)) &lt;</span>
 187 |     | <span class='neutral'>    //  == exp(- 16 + (2 ** 64) / (2 ** 60)) &lt;= 1&#39;</span>
 188 |     | <span class='neutral'>    //</span>
 189 |     | <span class='neutral'>    // and if &#39;left == true&#39;:</span>
 190 |     | <span class='neutral'>    //</span>
 191 |     | <span class='neutral'>    // &#39;(basePrice.sqrt(false) ^ sqrtInverseShift) / (2 ** 216) == </span>
 192 |     | <span class='neutral'>    //  exp(-16 - (basePrice.log() - logShift) / (2 ** 60)) / exp(-16) == </span>
 193 |     | <span class='neutral'>    //  exp(- (basePrice.log() - logShift) / (2 ** 60)) &lt; exp(0) &lt;= 1&#39;</span>
 194 |     | <span class='neutral'>    //</span>
 195 |     | <span class='neutral'>    // Hence, the outcome of the multiplication and &#39;mulDivByExpInv16&#39; do not</span>
 196 |     | <span class='neutral'>    // exceed 216 bits.</span>
 197 |     | <span class='neutral'>    (X59 logPrice, X216 sqrtPrice, X216 sqrtInversePrice) = left ? (</span>
 198 |     | <span class='neutral'>      basePrice.log() - logShift,</span>
 199 |     | <span class='neutral'>      basePrice.sqrt(false) ^ sqrtInverseShift,</span>
 200 |     | <span class='neutral'>      basePrice.sqrt(true) * sqrtShift</span>
 201 |     | <span class='neutral'>    ) : (</span>
 202 |     | <span class='neutral'>      basePrice.log() + logShift,</span>
 203 |     | <span class='neutral'>      basePrice.sqrt(false) * sqrtShift,</span>
 204 |     | <span class='neutral'>      basePrice.sqrt(true) ^ sqrtInverseShift</span>
 205 |     | <span class='neutral'>    );</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>    // The requirements of &#39;storePrice&#39; are satisfied due to the above</span>
 208 |     | <span class='neutral'>    // arguments and the input requirements.</span>
 209 |     | <span class='neutral'>    resultant.storePrice(height, logPrice, sqrtPrice, sqrtInversePrice);</span>
 210 |     | <span class='neutral'>  }</span>
 211 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/KernelCompact.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {</span>
   5 |     | <span class='neutral'>  _spacing_,</span>
   6 |     | <span class='neutral'>  getKernel,</span>
   7 |     | <span class='neutral'>  getKernelLength,</span>
   8 |     | <span class='neutral'>  setKernelLength</span>
   9 |     | <span class='neutral'>} from &quot;./Memory.sol&quot;;</span>
  10 |     | <span class='neutral'>import {</span>
  11 |     | <span class='neutral'>  Index,</span>
  12 |     | <span class='neutral'>  zeroIndex,</span>
  13 |     | <span class='neutral'>  oneIndex,</span>
  14 |     | <span class='neutral'>  twoIndex,</span>
  15 |     | <span class='neutral'>  maxKernelIndex</span>
  16 |     | <span class='neutral'>} from &quot;./Index.sol&quot;;</span>
  17 |     | <span class='neutral'>import {X15, oneX15} from &quot;./X15.sol&quot;;</span>
  18 |     | <span class='neutral'>import {X59, zeroX59, minLogStep} from &quot;./X59.sol&quot;;</span>
  19 |     | <span class='neutral'>import {X216} from &quot;./X216.sol&quot;;</span>
  20 |     | <span class='neutral'>import {PriceLibrary} from &quot;./Price.sol&quot;;</span>
  21 |     | <span class='neutral'>import {Kernel} from &quot;./Kernel.sol&quot;;</span>
  22 |     | <span class='neutral'>import {</span>
  23 |     | <span class='neutral'>  SecondHorizontalCoordinateIsZero,</span>
  24 |     | <span class='neutral'>  NonMonotonicHorizontalCoordinates,</span>
  25 |     | <span class='neutral'>  NonMonotonicVerticalCoordinates,</span>
  26 |     | <span class='neutral'>  RepetitiveKernelPoints,</span>
  27 |     | <span class='neutral'>  SlopeTooHigh,</span>
  28 |     | <span class='neutral'>  HorizontalCoordinatesMayNotExceedLogSpacing,</span>
  29 |     | <span class='neutral'>  RepetitiveHorizontalCoordinates,</span>
  30 |     | <span class='neutral'>  RepetitiveVerticalCoordinates,</span>
  31 |     | <span class='neutral'>  KernelIndexOutOfRange,</span>
  32 |     | <span class='neutral'>  LastVerticalCoordinateMismatch</span>
  33 |     | <span class='neutral'>} from &quot;./Errors.sol&quot;;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>using PriceLibrary for uint16;</span>
  36 |     | <span class='neutral'>using PriceLibrary for uint256;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>// For every pool, the kernel function &#39;k : [0, qSpacing] -&gt; [0, 1]&#39; represents</span>
  39 |     | <span class='neutral'>// a monotonically non-decreasing piece-wise linear function. Let &#39;m + 1&#39;</span>
  40 |     | <span class='neutral'>// denote the number of these breakpoints. For every integer &#39;0 &lt;= i &lt;= m&#39; the</span>
  41 |     | <span class='neutral'>// i-th breakpoint of the kernel represents the pair &#39;(b[i], c[i])&#39; where</span>
  42 |     | <span class='neutral'>//</span>
  43 |     | <span class='neutral'>//  &#39;0 == b[0] &lt;  b[1] &lt;= b[2] &lt;= ... &lt;= b[m - 1] &lt;  b[m] == qSpacing&#39;,</span>
  44 |     | <span class='neutral'>//  &#39;0 == c[0] &lt;= c[1] &lt;= c[2] &lt;= ... &lt;= c[m - 1] &lt;= c[m] == 1&#39;.</span>
  45 |     | <span class='neutral'>// </span>
  46 |     | <span class='neutral'>// In its compact form, each breakpoint occupies 10 bytes, in which:</span>
  47 |     | <span class='neutral'>//</span>
  48 |     | <span class='neutral'>//  - the &#39;X15&#39; representation of &#39;(2 ** 15) * c[i]&#39; occupies 2 bytes,</span>
  49 |     | <span class='neutral'>//</span>
  50 |     | <span class='neutral'>//  - the &#39;X59&#39; representation of &#39;(2 ** 59) * b[i]&#39; occupies 8 bytes,</span>
  51 |     | <span class='neutral'>//</span>
  52 |     | <span class='neutral'>// The above-mentioned layout is illustrated as follows:</span>
  53 |     | <span class='neutral'>//</span>
  54 |     | <span class='neutral'>//          A 80 bit kernel breakpoint</span>
  55 |     | <span class='neutral'>//  +--------+--------------------------------+</span>
  56 |     | <span class='neutral'>//  | 2 byte |             8 byte             |</span>
  57 |     | <span class='neutral'>//  +--------+--------------------------------+</span>
  58 |     | <span class='neutral'>//  |        |</span>
  59 |     | <span class='neutral'>//  |         \</span>
  60 |     | <span class='neutral'>//  |          (2 ** 59) * b[i]</span>
  61 |     | <span class='neutral'>//   \</span>
  62 |     | <span class='neutral'>//    (2 ** 15) * c[i]</span>
  63 |     | <span class='neutral'>//</span>
  64 |     | <span class='neutral'>// These 80 bit breakpoints are compactly encoded in a &#39;uint256[]&#39; array and</span>
  65 |     | <span class='neutral'>// given as input to &#39;initialize&#39; or &#39;modifyKernel&#39; methods.</span>
  66 |     | <span class='neutral'>//</span>
  67 |     | <span class='neutral'>// The expanded form of kernel is calculated based on the given compact form</span>
  68 |     | <span class='neutral'>// and stored on the storage smart contract.</span>
  69 |     | <span class='neutral'>type KernelCompact is uint256;</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>using KernelCompactLibrary for KernelCompact global;</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>library KernelCompactLibrary {</span>
  74 |     | <span class='neutral'>  /// @notice Returns the breakpoint components corresponding to the given</span>
  75 |     | <span class='neutral'>  /// index of a compact kernel.</span>
  76 |     | <span class='neutral'>  ///</span>
  77 |     | <span class='neutral'>  /// Index out of range should be avoided externally.</span>
  78 |     | <span class='neutral'>  function member(</span>
  79 |     | <span class='neutral'>    KernelCompact kernelCompact,</span>
  80 |     | <span class='neutral'>    Index index</span>
  81 |     | <span class='neutral'>  ) internal pure returns (</span>
  82 |     | <span class='neutral'>    X15 height,</span>
  83 |     | <span class='neutral'>    X59 logShift</span>
  84 |     | <span class='neutral'>  ) {</span>
  85 |     | <span class='neutral'>    // If &#39;index&#39; is equal to 0, then this function should return </span>
  86 |     | <span class='neutral'>    // &#39;(zeroX15, zeroX59)&#39;, because the first member of &#39;kernelCompact&#39; is</span>
  87 |     | <span class='neutral'>    // always &#39;(zeroX15, zeroX59)&#39;.</span>
  88 |     | <span class='neutral'>    if (index &gt; zeroIndex) {</span>
  89 |     | <span class='neutral'>      uint256 pointer;</span>
  90 |     | <span class='neutral'>      assembly {</span>
  91 |     | <span class='neutral'>        // Each member of &#39;kernelCompact&#39; is 10 bytes. 2 bytes for the &#39;height&#39;</span>
  92 |     | <span class='neutral'>        // and 8 bytes for the &#39;logShift&#39;.</span>
  93 |     | <span class='neutral'>        // &#39;8 == 10 - 2&#39;. We move 2 bytes forward because &#39;priceLibrary&#39; uses</span>
  94 |     | <span class='neutral'>        // the following layout to read prices from the memory:</span>
  95 |     | <span class='neutral'>        //</span>
  96 |     | <span class='neutral'>        //          A 80 bit kernel breakpoint</span>
  97 |     | <span class='neutral'>        //</span>
  98 |     | <span class='neutral'>        //              pointer</span>
  99 |     | <span class='neutral'>        //            /</span>
 100 |     | <span class='neutral'>        //  +--------+--------------------------------+</span>
 101 |     | <span class='neutral'>        //  | 2 byte |             8 byte             |</span>
 102 |     | <span class='neutral'>        //  +--------+--------------------------------+</span>
 103 |     | <span class='neutral'>        //  |        |</span>
 104 |     | <span class='neutral'>        //  |         \</span>
 105 |     | <span class='neutral'>        //  |          (2 ** 59) * b[i]</span>
 106 |     | <span class='neutral'>        //   \</span>
 107 |     | <span class='neutral'>        //    (2 ** 15) * c[i]</span>
 108 |     | <span class='neutral'>        //</span>
 109 |     | <span class='neutral'>        // In other words, the pointer to be used to access the &#39;height&#39; and </span>
 110 |     | <span class='neutral'>        // &#39;logShift&#39; should point to the end of &#39;height&#39; and the beginning of</span>
 111 |     | <span class='neutral'>        // &#39;logShift&#39;. Since &#39;height&#39; occupies 2 bytes, we move 2 bytes forward</span>
 112 |     | <span class='neutral'>        // to point to the end of it. We move 10 bytes backward because the</span>
 113 |     | <span class='neutral'>        // first breakpoint which is supposed to be &#39;(zeroX15, zeroX59)&#39; is </span>
 114 |     | <span class='neutral'>        // always omitted.</span>
 115 |     | <span class='neutral'>        // The addition and multiplication are safe because index out-of-range</span>
 116 |     | <span class='neutral'>        // is handled externally.</span>
 117 |     | <span class='neutral'>        pointer := add(kernelCompact, sub(mul(10, index), 8))</span>
 118 |     | <span class='neutral'>      }</span>
 119 |     | <span class='neutral'>      // Now that we have the pointer, we can load both the &#39;height&#39; and</span>
 120 |     | <span class='neutral'>      // &#39;logShift&#39; from the memory.</span>
 121 |     | <span class='neutral'>      height = pointer.height();</span>
 122 |     | <span class='neutral'>      logShift = pointer.log();</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'>  }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>  /// @notice Sqrt values are calculated and the kernel array is constructed.</span>
 127 |     | <span class='neutral'>  function expand(</span>
 128 |     | <span class='neutral'>    KernelCompact kernelCompact</span>
 129 |     | <span class='neutral'>  ) internal pure {</span>
 130 |     | <span class='neutral'>    Index i = oneIndex;</span>
 131 |     | <span class='neutral'>    uint256 pointer;</span>
 132 |     | <span class='neutral'>    // This is the place in memory where the expanded kernel is stored.</span>
 133 |     | <span class='neutral'>    Kernel kernel = getKernel();</span>
 134 |     | <span class='neutral'>    assembly {</span>
 135 |     | <span class='neutral'>      // We move &#39;62 = 8 + 27 + 27&#39; bytes backward. When we later move 64 bytes</span>
 136 |     | <span class='neutral'>      // forward, the pointer would point to &#39;kernel + 2&#39; which follows this</span>
 137 |     | <span class='neutral'>      // layout:</span>
 138 |     | <span class='neutral'>      //</span>
 139 |     | <span class='neutral'>      //        pointer to the first price</span>
 140 |     | <span class='neutral'>      //      /</span>
 141 |     | <span class='neutral'>      //     |        A 512 bit kernel breakpoint</span>
 142 |     | <span class='neutral'>      //  +--+--------+-----------------+-----------------+</span>
 143 |     | <span class='neutral'>      //  |  | 8 byte |     27 byte     |     27 byte     |</span>
 144 |     | <span class='neutral'>      //  +--+--------+-----------------+-----------------+</span>
 145 |     | <span class='neutral'>      //  |  |        |                 |</span>
 146 |     | <span class='neutral'>      //  |  |        |                  \</span>
 147 |     | <span class='neutral'>      //  |  |        |                   (2 ** 216) * exp(- 16 + b[i] / 2)</span>
 148 |     | <span class='neutral'>      //  |  |         \</span>
 149 |     | <span class='neutral'>      //  |  |          (2 ** 216) * exp(- b[i] / 2)</span>
 150 |     | <span class='neutral'>      //  |   \</span>
 151 |     | <span class='neutral'>      //  |    (2 ** 59) * b[i]</span>
 152 |     | <span class='neutral'>      //   \</span>
 153 |     | <span class='neutral'>      //    (2 ** 15) * c[i]</span>
 154 |     | <span class='neutral'>      //</span>
 155 |     | <span class='neutral'>      pointer := sub(kernel, 62)</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'>    Index length = getKernelLength();</span>
 158 |     | <span class='neutral'>    while (i &lt; length) {</span>
 159 |     | <span class='neutral'>      // We move 64 bytes forward because each member of kernel occupies </span>
 160 |     | <span class='neutral'>      // exactly 64 bytes.</span>
 161 |     | <span class='neutral'>      // The addition is safe because we do not go beyond the length of the</span>
 162 |     | <span class='neutral'>      // kernel which is calculated prior to calling this method by the</span>
 163 |     | <span class='neutral'>      // function &#39;validate&#39;.</span>
 164 |     | <span class='neutral'>      unchecked {</span>
 165 |     | <span class='neutral'>        pointer = pointer + 64;</span>
 166 |     | <span class='neutral'>      }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>      // &#39;height&#39; and &#39;logShift&#39; are loaded first.</span>
 169 |     | <span class='neutral'>      // Index-out-of-range is not possible, because we do not go beyond the </span>
 170 |     | <span class='neutral'>      // length of the kernel which is calculated prior to calling this method</span>
 171 |     | <span class='neutral'>      // by the function &#39;validate&#39;.</span>
 172 |     | <span class='neutral'>      (X15 c_i, X59 b_i) = kernelCompact.member(i);</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>      // The requirements of &#39;exp&#39; are met because &#39;kernelCompact&#39; is validated</span>
 175 |     | <span class='neutral'>      // prior to calling this function. The custom errors</span>
 176 |     | <span class='neutral'>      // &#39;SecondHorizontalCoordinateIsZero&#39; and </span>
 177 |     | <span class='neutral'>      // &#39;NonMonotonicHorizontalCoordinates&#39; safeguard against any horizontal</span>
 178 |     | <span class='neutral'>      // coordinate being zero.</span>
 179 |     | <span class='neutral'>      // On the other hand, the custom errors &#39;BlankIntervalsShouldBeAvoided&#39;</span>
 180 |     | <span class='neutral'>      // and &#39;HorizontalCoordinatesMayNotExceedLogSpacing&#39; safeguard against</span>
 181 |     | <span class='neutral'>      // any horizontal coordinate exceeding &#39;2 ** 64 - 1&#39;.</span>
 182 |     | <span class='neutral'>      (X216 iSqrt, X216 iSqrtInverse) = b_i.exp();</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>      // The requirements of &#39;storePrice&#39; are met because the custom errors</span>
 185 |     | <span class='neutral'>      // &#39;LastVerticalCoordinateMismatch&#39; and &#39;NonMonotonicVerticalCoordinates&#39;</span>
 186 |     | <span class='neutral'>      // safeguard against any vertical coordinate exceeding &#39;oneX15&#39;. As </span>
 187 |     | <span class='neutral'>      // discussed above, all horizontal coordinates are between &#39;0&#39; and </span>
 188 |     | <span class='neutral'>      // &#39;2 ** 64&#39;. The outputs of the function &#39;exp()&#39; never exceed &#39;oneX216&#39;</span>
 189 |     | <span class='neutral'>      // because both &#39;exp(- x / (2 ** 60))&#39; and  &#39;exp(-16 + x / (2 ** 60))&#39;</span>
 190 |     | <span class='neutral'>      // are positive and smaller than &#39;1&#39;. Lastly, since &#39;kernel&#39; always</span>
 191 |     | <span class='neutral'>      // appears after the end of static parameters, (i.e., </span>
 192 |     | <span class='neutral'>      // &#39;kernel &gt;= _endOfStaticParams_&#39;) the value of &#39;pointer&#39; is not less</span>
 193 |     | <span class='neutral'>      // than 32.</span>
 194 |     | <span class='neutral'>      pointer.storePrice(c_i, b_i, iSqrt, iSqrtInverse);</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>      // The addition is safe because we do not go beyond the length of the</span>
 197 |     | <span class='neutral'>      // kernel which is calculated prior to calling this method by the</span>
 198 |     | <span class='neutral'>      // function &#39;validate&#39;.</span>
 199 |     | <span class='neutral'>      i = i + oneIndex;</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'>  }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>  /// @notice Validates a given kernel for compliance.</span>
 204 |     | <span class='neutral'>  function validate(</span>
 205 |     | <span class='neutral'>    KernelCompact kernelCompact</span>
 206 |     | <span class='neutral'>  ) internal pure {</span>
 207 |     | <span class='neutral'>    X59 qSpacing = _spacing_.log();</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>    // The length of any given &#39;kernelCompact&#39; is at least 2. The first member</span>
 210 |     | <span class='neutral'>    // is &#39;(zeroX15, zeroX59)&#39; which is omitted. The last member is</span>
 211 |     | <span class='neutral'>    // &#39;(oneX15, qSpacing)&#39;.</span>
 212 |     | <span class='neutral'>    Index length = twoIndex;</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>    // &#39;i&#39;, &#39;j&#39;, and &#39;k&#39; are indices representing consecutive members of</span>
 215 |     | <span class='neutral'>    // the given &#39;kernelCompact&#39;, respectively.</span>
 216 |     | <span class='neutral'>    Index i = zeroIndex;</span>
 217 |     | <span class='neutral'>    Index j = oneIndex;</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>    // The following two coordinates are zero by default to represent the first</span>
 220 |     | <span class='neutral'>    // member &#39;(zeroX15, zeroX59)&#39;.</span>
 221 |     | <span class='neutral'>    X15 c_i;</span>
 222 |     | <span class='neutral'>    X59 b_i;</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>    // The second member of &#39;kernelCompact&#39; is loaded next. </span>
 225 |     | <span class='neutral'>    (X15 c_j, X59 b_j) = kernelCompact.member(j);</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='neutral'>    // The third member of &#39;kernelCompact&#39; is loaded next. &#39;k&#39; may be an out of</span>
 228 |     | <span class='neutral'>    // range index in which case its values will not be used. This is</span>
 229 |     | <span class='neutral'>    // intentional, because the line &#39;if (b_j == qSpacing) break;&#39; appears</span>
 230 |     | <span class='neutral'>    // prior to using &#39;k&#39;.</span>
 231 |     | <span class='neutral'>    (X15 c_k, X59 b_k) = kernelCompact.member(length);</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>    // The second horizontal coordinate may not be zero. Remember that the</span>
 234 |     | <span class='neutral'>    // first member of the kernel is &#39;(zeroX15, zeroX59)&#39;. If the second</span>
 235 |     | <span class='neutral'>    // horizontal coordinate is &#39;zeroX59&#39;, it means that we have a vertical</span>
 236 |     | <span class='neutral'>    // jump at the origin. This is not permitted because it would limit</span>
 237 |     | <span class='neutral'>    // liquidity growth.</span>
 238 |     | <span class='neutral'>    require(b_j != zeroX59, SecondHorizontalCoordinateIsZero());</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>    // A loop over every member of &#39;kernelCompact&#39;.</span>
 241 |     | <span class='neutral'>    while (true) {</span>
 242 |     | <span class='neutral'>      // The horizontal coordinates should be monotonically nondecreasing. This</span>
 243 |     | <span class='neutral'>      // is because we are inputting breakpoints from the left to the right and</span>
 244 |     | <span class='neutral'>      // from the bottom to the top.</span>
 245 |     | <span class='neutral'>      require(b_i &lt;= b_j, NonMonotonicHorizontalCoordinates(b_i, b_j));</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>      // The vertical coordinates should be monotonically nondecreasing. This</span>
 248 |     | <span class='neutral'>      // is because we are inputting breakpoints from the left to the right and</span>
 249 |     | <span class='neutral'>      // from the bottom to the top.</span>
 250 |     | <span class='neutral'>      require(</span>
 251 |     | <span class='neutral'>        c_i &lt;= c_j,</span>
 252 |     | <span class='neutral'>        NonMonotonicVerticalCoordinates(c_i, c_j)</span>
 253 |     | <span class='neutral'>      );</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='neutral'>      // Repetitive breakpoints should be avoided.</span>
 256 |     | <span class='neutral'>      require(</span>
 257 |     | <span class='neutral'>        (b_i != b_j) || (c_i != c_j),</span>
 258 |     | <span class='neutral'>        RepetitiveKernelPoints(c_i, b_i)</span>
 259 |     | <span class='neutral'>      );</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='neutral'>      // If &#39;b_i == b_j&#39;, we have a vertical jump (discontinuity) which is</span>
 262 |     | <span class='neutral'>      // permitted. If &#39;c_i == c_j&#39;, we have a flat segment which is</span>
 263 |     | <span class='neutral'>      // also permitted. However, in case of a sloped segment, &#39;b_j - b_i&#39;</span>
 264 |     | <span class='neutral'>      // may not be less than &#39;minLogStep&#39; which corresponds to a price</span>
 265 |     | <span class='neutral'>      // movement by a factor of approximately &#39;1.0000000075&#39;.</span>
 266 |     | <span class='neutral'>      require(</span>
 267 |     | <span class='neutral'>        (b_i == b_j) || (c_i == c_j) || (b_j - b_i &gt;= minLogStep),</span>
 268 |     | <span class='neutral'>        SlopeTooHigh(b_i, b_j)</span>
 269 |     | <span class='neutral'>      );</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='neutral'>      // The kernel is characterized via a sequence of monotonically </span>
 272 |     | <span class='neutral'>      // non-decreasing horizontal coordinates from &#39;zeroX59&#39; to &#39;qSpacing&#39;</span>
 273 |     | <span class='neutral'>      // and a sequence of monotonically non-decreasing vertical coordinates</span>
 274 |     | <span class='neutral'>      // from &#39;zeroX15&#39; to &#39;oneX15&#39;. Hence, no horizontal coordinate may exceed</span>
 275 |     | <span class='neutral'>      // &#39;qSpacing&#39;.</span>
 276 |     | <span class='neutral'>      require(</span>
 277 |     | <span class='neutral'>        b_j &lt;= qSpacing,</span>
 278 |     | <span class='neutral'>        HorizontalCoordinatesMayNotExceedLogSpacing(b_j, qSpacing)</span>
 279 |     | <span class='neutral'>      );</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='neutral'>      // &#39;b_j == qSpacing&#39; indicates that we have reached the end of</span>
 282 |     | <span class='neutral'>      // &#39;kernelCompact&#39;. This is because the last member is supposed to be</span>
 283 |     | <span class='neutral'>      // &#39;(oneX15, qSpacing)&#39; and the horizontal coordinates for all other</span>
 284 |     | <span class='neutral'>      // members should be less than &#39;qSpacing&#39;.</span>
 285 |     | <span class='neutral'>      if (b_j == qSpacing) break;</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='neutral'>      // A horizontal coordinate cannot be repeated twice. It may be repeated</span>
 288 |     | <span class='neutral'>      // once, which would indicate a vertical jump (kernel discontinuity).</span>
 289 |     | <span class='neutral'>      require(</span>
 290 |     | <span class='neutral'>        (b_i != b_j) || (b_j != b_k),</span>
 291 |     | <span class='neutral'>        RepetitiveHorizontalCoordinates(b_i)</span>
 292 |     | <span class='neutral'>      );</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>      // A vertical coordinate cannot be repeated twice. It may be repeated</span>
 295 |     | <span class='neutral'>      // once, which would indicate a flat segment.</span>
 296 |     | <span class='neutral'>      require(</span>
 297 |     | <span class='neutral'>        (c_i != c_j) || (c_j != c_k),</span>
 298 |     | <span class='neutral'>        RepetitiveVerticalCoordinates(c_i)</span>
 299 |     | <span class='neutral'>      );</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='neutral'>      // We substitute &#39;i&#39; with &#39;j&#39; to move one step forward.</span>
 302 |     | <span class='neutral'>      i = j;</span>
 303 |     | <span class='neutral'>      c_i = c_j;</span>
 304 |     | <span class='neutral'>      b_i = b_j;</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='neutral'>      // We substitute &#39;j&#39; with &#39;k&#39; to move one step forward.</span>
 307 |     | <span class='neutral'>      j = length;</span>
 308 |     | <span class='neutral'>      c_j = c_k;</span>
 309 |     | <span class='neutral'>      b_j = b_k;</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>      // &#39;length&#39; is incremented. The addition is safe because of the following</span>
 312 |     | <span class='neutral'>      // check.</span>
 313 |     | <span class='neutral'>      length = length + oneIndex;</span>
 314 |     | <span class='neutral'></span>
 315 |     | <span class='neutral'>      // The deployment code for static parameters and kernel reserves 2 bytes</span>
 316 |     | <span class='neutral'>      // for the byte count of the content to be deployed. Because of this</span>
 317 |     | <span class='neutral'>      // limit, we should have:</span>
 318 |     | <span class='neutral'>      //</span>
 319 |     | <span class='neutral'>      // &#39;_endOfStaticParams_ - _staticParams_ + 64*(length - 1) + 1 &lt; 2 ** 16&#39;</span>
 320 |     | <span class='neutral'>      //</span>
 321 |     | <span class='neutral'>      // where</span>
 322 |     | <span class='neutral'>      //</span>
 323 |     | <span class='neutral'>      // - &#39;64&#39; accounts for the number of bytes that each member of kernel</span>
 324 |     | <span class='neutral'>      // occupies.</span>
 325 |     | <span class='neutral'>      // - &#39;-1&#39; accounts for the omitted origin point.</span>
 326 |     | <span class='neutral'>      // - &#39;+1&#39; accounts for a &#39;00&#39; padding byte.</span>
 327 |     | <span class='neutral'>      //</span>
 328 |     | <span class='neutral'>      // Hence:</span>
 329 |     | <span class='neutral'>      //</span>
 330 |     | <span class='neutral'>      // &#39;length &lt;= 1 + (</span>
 331 |     | <span class='neutral'>      //    ((2 ** 16 - 1) - 1 - _endOfStaticParams_ + _staticParams_) / 64</span>
 332 |     | <span class='neutral'>      // ) == 1020&#39;</span>
 333 |     | <span class='neutral'>      //</span>
 334 |     | <span class='neutral'>      require(length &lt;= maxKernelIndex, KernelIndexOutOfRange(length));</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='neutral'>      // &#39;k&#39; may be an out of range index in which case its values will not be </span>
 337 |     | <span class='neutral'>      // used. This is intentional, because the line</span>
 338 |     | <span class='neutral'>      // &#39;if (b_j == qSpacing) break;&#39; appears prior to using &#39;k&#39;.</span>
 339 |     | <span class='neutral'>      (c_k, b_k) = kernelCompact.member(length);</span>
 340 |     | <span class='neutral'>    }</span>
 341 |     | <span class='neutral'></span>
 342 |     | <span class='neutral'>    // The last member of &#39;kernelCompact&#39; should be &#39;(oneX15, qSpacing)&#39;.</span>
 343 |     | <span class='neutral'>    // The loop is already broken at &#39;b_j == qSpacing&#39; and now we check the</span>
 344 |     | <span class='neutral'>    // vertical coordinate.</span>
 345 |     | <span class='neutral'>    require(c_j == oneX15, LastVerticalCoordinateMismatch(c_j));</span>
 346 |     | <span class='neutral'></span>
 347 |     | <span class='neutral'>    // The length for &#39;kernel&#39; is set in memory. Due to the above check, this</span>
 348 |     | <span class='neutral'>    // value does not exceed &#39;maxKernelIndex&#39; and can be safely stored in the</span>
 349 |     | <span class='neutral'>    // allocated 2 bytes of memory.</span>
 350 |     | <span class='neutral'>    setKernelLength(length);</span>
 351 |     | <span class='neutral'>  }</span>
 352 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/Memory.sol</b>
<code>
    1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
    2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>/// @dev Nofeeswap&#39;s memory layout.</span>
    5 |     | <span class='neutral'>/// @notice Each &#39;uint16&#39; value is a memory pointer referring to the</span>
    6 |     | <span class='neutral'>/// corresponding value in memory. This file is generated using &#39;Memory.py&#39;.</span>
    7 |     | <span class='neutral'></span>
    8 |     | <span class='neutral'>import {Tag} from &quot;./Tag.sol&quot;;</span>
    9 |     | <span class='neutral'>import {Index} from &quot;./Index.sol&quot;;</span>
   10 |     | <span class='neutral'>import {X15} from &quot;./X15.sol&quot;;</span>
   11 |     | <span class='neutral'>import {X23} from &quot;./X23.sol&quot;;</span>
   12 |     | <span class='neutral'>import {X47} from &quot;./X47.sol&quot;;</span>
   13 |     | <span class='neutral'>import {X59} from &quot;./X59.sol&quot;;</span>
   14 |     | <span class='neutral'>import {X111} from &quot;./X111.sol&quot;;</span>
   15 |     | <span class='neutral'>import {X127} from &quot;./X127.sol&quot;;</span>
   16 |     | <span class='neutral'>import {X208} from &quot;./X208.sol&quot;;</span>
   17 |     | <span class='neutral'>import {X216} from &quot;./X216.sol&quot;;</span>
   18 |     | <span class='neutral'>import {Curve} from &quot;./Curve.sol&quot;;</span>
   19 |     | <span class='neutral'>import {Kernel} from &quot;./Kernel.sol&quot;;</span>
   20 |     | <span class='neutral'></span>
   21 |     | <span class='neutral'>// Refers to the third slot of the memory which contains the free memory</span>
   22 |     | <span class='neutral'>// pointer.</span>
   23 |     | <span class='neutral'>uint16 constant _freeMemoryPointer_ = 64;</span>
   24 |     | <span class='neutral'></span>
   25 |     | <span class='neutral'>// Refers to the fourth slot of the memory which remains blank.</span>
   26 |     | <span class='neutral'>uint16 constant _blank_ = 96;</span>
   27 |     | <span class='neutral'></span>
   28 |     | <span class='neutral'>// When the protocol calls a hook or the sentinel contract, a snapshot of the</span>
   29 |     | <span class='neutral'>// memory (with &#39;_hookSelector_&#39; as the starting point) is sent to the target</span>
   30 |     | <span class='neutral'>// contract as calldata. Before calling the target contract, this 4 byte space</span>
   31 |     | <span class='neutral'>// is populated with the intended function selector of the target contract.</span>
   32 |     | <span class='neutral'>uint16 constant _hookSelector_ = 128;</span>
   33 |     | <span class='neutral'></span>
   34 |     | <span class='neutral'>// This space is populated with the abi offset &#39;0x20&#39; so that the hook or the</span>
   35 |     | <span class='neutral'>// sentinel contract can decode the given calldata. This offset value points to</span>
   36 |     | <span class='neutral'>// the slot that contains the byte count of the snapshot given to the hook or</span>
   37 |     | <span class='neutral'>// the sentinel contract</span>
   38 |     | <span class='neutral'>uint16 constant _hookInputHeader_ = 132;</span>
   39 |     | <span class='neutral'></span>
   40 |     | <span class='neutral'>// This space is populated with the byte count of &#39;bytes calldata hookInput&#39;</span>
   41 |     | <span class='neutral'>// which is passed as input to the hook or the sentinel contract.</span>
   42 |     | <span class='neutral'>uint16 constant _hookInputByteCount_ = 164;</span>
   43 |     | <span class='neutral'></span>
   44 |     | <span class='neutral'>// &#39;msg.sender&#39; in the current execution context is placed in this space to be</span>
   45 |     | <span class='neutral'>// passed to the hook or the sentinel contract. This way, the hook or the</span>
   46 |     | <span class='neutral'>// sentinel contract have access to &#39;msg.sender&#39; in the prior execution</span>
   47 |     | <span class='neutral'>// context (i.e., in the context where the protocol is called).</span>
   48 |     | <span class='neutral'>uint16 constant _msgSender_ = 196;</span>
   49 |     | <span class='neutral'></span>
   50 |     | <span class='neutral'>// This space is dedicated to the identifier of the intended pool. The least</span>
   51 |     | <span class='neutral'>// significant 160 bits of this memory space refer to the hook address. The</span>
   52 |     | <span class='neutral'>// next 20 bits are referred to as flags that are used by the protocol to know</span>
   53 |     | <span class='neutral'>// which methods from &#39;IHook.sol&#39; should be invoked and what permissions are</span>
   54 |     | <span class='neutral'>// activated. Flags are further explained in &#39;IHook.sol&#39;. The next 8 bits</span>
   55 |     | <span class='neutral'>// represent the natural logarithm of &#39;pOffset&#39; which must be greater than or</span>
   56 |     | <span class='neutral'>// equal to &#39;-89&#39; and less than or equal to &#39;89&#39; in &#39;int8&#39; representation</span>
   57 |     | <span class='neutral'>// (two&#39;s complement). Hence, &#39;pOffset&#39; is greater than or equal to &#39;exp(-89)&#39;</span>
   58 |     | <span class='neutral'>// and less than or equal to &#39;exp(+89)&#39;. As will be discussed later, the price</span>
   59 |     | <span class='neutral'>// of the pool is always greater than or equal to</span>
   60 |     | <span class='neutral'>//</span>
   61 |     | <span class='neutral'>//  &#39;pOffset * exp(- 16 + 1 / (2 ** 59))&#39;</span>
   62 |     | <span class='neutral'>//</span>
   63 |     | <span class='neutral'>// and less than or equal to</span>
   64 |     | <span class='neutral'>//</span>
   65 |     | <span class='neutral'>//  &#39;pOffset * exp(+ 16 - 1 / (2 ** 59))&#39;.</span>
   66 |     | <span class='neutral'>uint16 constant _poolId_ = 216;</span>
   67 |     | <span class='neutral'></span>
   68 |     | <span class='neutral'>// How does a swap work?</span>
   69 |     | <span class='neutral'>// ----------------------------------------------------------------------------</span>
   70 |     | <span class='neutral'>// A swap in a pool can be interpreted as a change in that pool&#39;s price. There</span>
   71 |     | <span class='neutral'>// are two types of swaps:</span>
   72 |     | <span class='neutral'>//</span>
   73 |     | <span class='neutral'>//  - If &#39;tag0&#39; is outgoing from the pool and &#39;tag1&#39; is incoming to the pool as</span>
   74 |     | <span class='neutral'>//    a result of a swap, then the swap is price increasing, i.e., the price</span>
   75 |     | <span class='neutral'>//    prior to the execution of the swap is lower than the price after the</span>
   76 |     | <span class='neutral'>//    execution of the swap.</span>
   77 |     | <span class='neutral'>//</span>
   78 |     | <span class='neutral'>//  - If &#39;tag0&#39; is incoming to the pool and &#39;tag1&#39; is outgoing from the pool as</span>
   79 |     | <span class='neutral'>//    a result of a swap, then the swap is price decreasing, i.e., the price</span>
   80 |     | <span class='neutral'>//    prior to the execution of the swap is higher than the price after the</span>
   81 |     | <span class='neutral'>//    execution of the swap.</span>
   82 |     | <span class='neutral'>//</span>
   83 |     | <span class='neutral'>// Let &#39;pOffset&#39; represent the offset price whose natural logarithm is encoded</span>
   84 |     | <span class='neutral'>// in &#39;poolId&#39; as described above (in the definition of &#39;poolId&#39;). The protocol</span>
   85 |     | <span class='neutral'>// offers liquidity providers (LPs) the flexibility to deposit their liquidity</span>
   86 |     | <span class='neutral'>// in a range of their choosing. To this end, the price horizon is partitioned</span>
   87 |     | <span class='neutral'>// into a number of liquidity intervals with equal length in the natural</span>
   88 |     | <span class='neutral'>// logarithmic scale. An LP may choose any consecutive range of liquidity</span>
   89 |     | <span class='neutral'>// intervals to deposit their liquidity. By doing so, the LP acquires a number</span>
   90 |     | <span class='neutral'>// of shares in every liquidity interval that belongs to the given range. The</span>
   91 |     | <span class='neutral'>// shares can be used later to withdraw liquidity along with any accumulated</span>
   92 |     | <span class='neutral'>// growth which is accrued as a result of swap and donate actions.</span>
   93 |     | <span class='neutral'>//</span>
   94 |     | <span class='neutral'>// At each moment, a single one of the above-mentioned intervals is active to</span>
   95 |     | <span class='neutral'>// which the current price of the pool belongs. Let &#39;pLower&#39; and &#39;pUpper&#39;,</span>
   96 |     | <span class='neutral'>// respectively, denote the minimum and maximum price in the current active</span>
   97 |     | <span class='neutral'>// liquidity interval and define</span>
   98 |     | <span class='neutral'>//</span>
   99 |     | <span class='neutral'>//  &#39;qLower := log(pLower / pOffset)&#39;</span>
  100 |     | <span class='neutral'>//  &#39;qUpper := log(pUpper / pOffset)&#39;</span>
  101 |     | <span class='neutral'>//  &#39;qSpacing := log(pUpper / pLower)&#39;.</span>
  102 |     | <span class='neutral'>//</span>
  103 |     | <span class='neutral'>// Then, for every integer &#39;j&#39;, the interval</span>
  104 |     | <span class='neutral'>//</span>
  105 |     | <span class='neutral'>//  &#39;[qLower + j * qSpacing, qUpper + j * qSpacing]&#39;</span>
  106 |     | <span class='neutral'>//</span>
  107 |     | <span class='neutral'>// is a valid liquidity interval if and only if:</span>
  108 |     | <span class='neutral'>//</span>
  109 |     | <span class='neutral'>//  &#39;- 16 + 1 / (2 ** 59) + qSpacing &lt; qLower + j * qSpacing&#39;</span>
  110 |     | <span class='neutral'>//</span>
  111 |     | <span class='neutral'>// and</span>
  112 |     | <span class='neutral'>//</span>
  113 |     | <span class='neutral'>//  &#39;qUpper + j * qSpacing &lt;= + 16 - 1 / (2 ** 59) - qSpacing&#39;.</span>
  114 |     | <span class='neutral'>//</span>
  115 |     | <span class='neutral'>// This includes the current active liquidity interval &#39;[qLower, qUpper]&#39;</span>
  116 |     | <span class='neutral'>// which corresponds to &#39;j == 0&#39;.</span>
  117 |     | <span class='neutral'>//</span>
  118 |     | <span class='neutral'>// Every swap has the following input parameters:</span>
  119 |     | <span class='neutral'>//</span>
  120 |     | <span class='neutral'>//  - &#39;logPriceLimit&#39;: This value is the natural logarithm of a price limit in</span>
  121 |     | <span class='neutral'>//    &#39;X59&#39; representation. It imposes a constraint on the price of the pool</span>
  122 |     | <span class='neutral'>//    post execution of the swap. For price increasing swaps, &#39;logPriceLimit&#39;</span>
  123 |     | <span class='neutral'>//    serves as an upper bound, in which case the price of the pool must not</span>
  124 |     | <span class='neutral'>//    exceed &#39;exp(logPriceLimit / (2 ** 59))&#39;. For price decreasing swaps,</span>
  125 |     | <span class='neutral'>//    &#39;logPriceLimit&#39; serves as a lower bound, in which case the price of the</span>
  126 |     | <span class='neutral'>//    pool must not subceed &#39;exp(logPriceLimit / (2 ** 59))&#39;. In both cases,</span>
  127 |     | <span class='neutral'>//    once the price of the pool reaches &#39;exp(logPriceLimit / (2 ** 59))&#39;, the</span>
  128 |     | <span class='neutral'>//    execution of the swap is halted. Put simply, no amount of tags are traded</span>
  129 |     | <span class='neutral'>//    with any price worst than &#39;exp(logPriceLimit / (2 ** 59))&#39; for the</span>
  130 |     | <span class='neutral'>//    swapper.</span>
  131 |     | <span class='neutral'>//</span>
  132 |     | <span class='neutral'>//  - &#39;zeroForOne&#39;: If &#39;zeroForOne == 0&#39;, then the swap is price increasing in</span>
  133 |     | <span class='neutral'>//    which case &#39;tag0&#39; is outgoing from the pool and &#39;tag1&#39; is incoming to the</span>
  134 |     | <span class='neutral'>//    pool. If &#39;zeroForOne == 1&#39;, then the swap is price decreasing in which</span>
  135 |     | <span class='neutral'>//    case &#39;tag0&#39; is incoming to the pool and &#39;tag1&#39; is outgoing from the pool.</span>
  136 |     | <span class='neutral'>//    Given any other value, the movement of the price is towards</span>
  137 |     | <span class='neutral'>//    &#39;logPriceLimit&#39;, i.e., the swap is price increasing if</span>
  138 |     | <span class='neutral'>//</span>
  139 |     | <span class='neutral'>//      &#39;pCurrent &lt; exp(logPriceLimit / (2 ** 59))&#39;</span>
  140 |     | <span class='neutral'>//</span>
  141 |     | <span class='neutral'>//    and the swap is price decreasing if</span>
  142 |     | <span class='neutral'>//</span>
  143 |     | <span class='neutral'>//      &#39;exp(logPriceLimit / (2 ** 59)) &lt; pCurrent&#39;</span>
  144 |     | <span class='neutral'>//</span>
  145 |     | <span class='neutral'>//    where &#39;pCurrent&#39; represents the current price of the pool.</span>
  146 |     | <span class='neutral'>//</span>
  147 |     | <span class='neutral'>//  - &#39;amountSpecified&#39;: If &#39;amountSpecified &gt; 0&#39; then &#39;amountSpecified&#39;</span>
  148 |     | <span class='neutral'>//    represents the amount of &#39;tag0&#39; (if the swap is price decreasing) or the</span>
  149 |     | <span class='neutral'>//    amount of &#39;tag1&#39; (if the swap is price increasing) to be given to the</span>
  150 |     | <span class='neutral'>//    pool subject to the constraint imposed by &#39;logPriceLimit&#39;. If</span>
  151 |     | <span class='neutral'>//    &#39;amountSpecified &lt; 0&#39; then &#39;0 - amountSpecified&#39; represents the amount of</span>
  152 |     | <span class='neutral'>//    &#39;tag0&#39; (if the swap is price increasing) or the amount of &#39;tag1&#39; (if the</span>
  153 |     | <span class='neutral'>//    swap is price decreasing) to be taken from the pool. Define</span>
  154 |     | <span class='neutral'>//</span>
  155 |     | <span class='neutral'>//      &#39;exactInput := amountSpecified &gt; 0&#39;</span>
  156 |     | <span class='neutral'>//</span>
  157 |     | <span class='neutral'>//    which determines whether &#39;amountSpecified&#39; is incoming to the pool or</span>
  158 |     | <span class='neutral'>//    outgoing from the pool. Additionally, if &#39;zeroForOne == exactInput&#39;, then</span>
  159 |     | <span class='neutral'>//    &#39;amountSpecified&#39; is with respect to &#39;tag0&#39; and if</span>
  160 |     | <span class='neutral'>//    &#39;zeroForOne != exactInput&#39; then &#39;amountSpecified&#39; is with respect to</span>
  161 |     | <span class='neutral'>//    &#39;tag1&#39;.</span>
  162 |     | <span class='neutral'>//</span>
  163 |     | <span class='neutral'>//  - &#39;crossThreshold&#39;: If large enough, a swap may involve transitioning from</span>
  164 |     | <span class='neutral'>//    the active liquidity interval to other intervals. &#39;crossThreshold&#39;</span>
  165 |     | <span class='neutral'>//    imposes a lower bound on the total number of shares that should be</span>
  166 |     | <span class='neutral'>//    available in any interval for the swapper to transact in that interval.</span>
  167 |     | <span class='neutral'>//    For example, if &#39;crossThreshold == 0&#39;, which is the default, no minimum</span>
  168 |     | <span class='neutral'>//    number of shares is imposed. If &#39;crossThreshold == 100&#39;, there has to be</span>
  169 |     | <span class='neutral'>//    at least 100 shares in the interval for the swap function to either swap</span>
  170 |     | <span class='neutral'>//    within or enter that interval.</span>
  171 |     | <span class='neutral'>//</span>
  172 |     | <span class='neutral'>// Consider a hypothetical pool that satisfies</span>
  173 |     | <span class='neutral'>//</span>
  174 |     | <span class='neutral'>//  &#39;qLower &lt; qCurrent &lt; qUpper&#39;,</span>
  175 |     | <span class='neutral'>//</span>
  176 |     | <span class='neutral'>// where</span>
  177 |     | <span class='neutral'>//</span>
  178 |     | <span class='neutral'>//  &#39;qCurrent := log(pCurrent / pOffset)&#39;</span>
  179 |     | <span class='neutral'>//</span>
  180 |     | <span class='neutral'>// and &#39;pCurrent&#39; is the current price of the pool.</span>
  181 |     | <span class='neutral'>//</span>
  182 |     | <span class='neutral'>// Consider a swap in this pool with the following parameters:</span>
  183 |     | <span class='neutral'>//</span>
  184 |     | <span class='neutral'>//  &#39;logPriceLimit := (2 ** 59) * log(pLimit)&#39;</span>
  185 |     | <span class='neutral'>//  &#39;zeroForOne := 1&#39;</span>
  186 |     | <span class='neutral'>//  &#39;amountSpecified := +oo&#39;</span>
  187 |     | <span class='neutral'>//  &#39;crossThreshold := 0&#39;</span>
  188 |     | <span class='neutral'>//</span>
  189 |     | <span class='neutral'>// where</span>
  190 |     | <span class='neutral'>//</span>
  191 |     | <span class='neutral'>//  &#39;pLimit := exp(- 3 * qSpacing) * pCurrent&#39;</span>
  192 |     | <span class='neutral'>//</span>
  193 |     | <span class='neutral'>// and</span>
  194 |     | <span class='neutral'>//</span>
  195 |     | <span class='neutral'>//  &#39;qLimit := log(pLimit / pOffset)&#39;.</span>
  196 |     | <span class='neutral'>//</span>
  197 |     | <span class='neutral'>// As explained later in this script, each of the above input parameters are</span>
  198 |     | <span class='neutral'>// loaded from calldata, transformed to appropriate formats and then stored in</span>
  199 |     | <span class='neutral'>// dedicated spaces in memory that are pointed to by the constant values</span>
  200 |     | <span class='neutral'>// &#39;_logPriceLimit_&#39;, &#39;_zeroForOne_&#39;, &#39;_amountSpecified_&#39;, and</span>
  201 |     | <span class='neutral'>// &#39;_crossThreshold_&#39;, respectively. Additionally, prior to the execution</span>
  202 |     | <span class='neutral'>// of the swap, &#39;qLimit&#39; is calculated and stored in the memory space which</span>
  203 |     | <span class='neutral'>// is pointed to by &#39;_logPriceLimitOffsetted_&#39;.</span>
  204 |     | <span class='neutral'>//</span>
  205 |     | <span class='neutral'>// In this example, we have:</span>
  206 |     | <span class='neutral'>//</span>
  207 |     | <span class='neutral'>//  &#39;qLower - 3 * qSpacing &lt; qLimit &lt; qUpper - 3 * qSpacing&#39;,</span>
  208 |     | <span class='neutral'>//</span>
  209 |     | <span class='neutral'>// which is illustrated as follows:</span>
  210 |     | <span class='neutral'>//</span>
  211 |     | <span class='neutral'>//             qLimit                                  qCurrent</span>
  212 |     | <span class='neutral'>//               |                                         |</span>
  213 |     | <span class='neutral'>//  ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
  214 |     | <span class='neutral'>//</span>
  215 |     | <span class='neutral'>// In the presence of liquidity, the further away &#39;qLimit&#39; is from &#39;qCurrent&#39;</span>
  216 |     | <span class='neutral'>// the larger the outgoing amount from the pool and the incoming amount to the</span>
  217 |     | <span class='neutral'>// pool are.</span>
  218 |     | <span class='neutral'>//</span>
  219 |     | <span class='neutral'>// In the above example, the swap is price decreasing which means that &#39;tag0&#39;</span>
  220 |     | <span class='neutral'>// is incoming to the pool and &#39;tag1&#39; is outgoing from the pool as a result of</span>
  221 |     | <span class='neutral'>// the swap.</span>
  222 |     | <span class='neutral'>//</span>
  223 |     | <span class='neutral'>// Observe that &#39;qLimit&#39; is three intervals away from &#39;qCurrent&#39;. Hence, in</span>
  224 |     | <span class='neutral'>// order to go from &#39;qCurrent&#39; to &#39;qLimit&#39; we need to transact in the following</span>
  225 |     | <span class='neutral'>// four intervals:</span>
  226 |     | <span class='neutral'>//</span>
  227 |     | <span class='neutral'>//  &#39;[qLower - 0 * qSpacing, qUpper - 0 * qSpacing]&#39;,</span>
  228 |     | <span class='neutral'>//  &#39;[qLower - 1 * qSpacing, qUpper - 1 * qSpacing]&#39;,</span>
  229 |     | <span class='neutral'>//  &#39;[qLower - 2 * qSpacing, qUpper - 2 * qSpacing]&#39;,</span>
  230 |     | <span class='neutral'>//  &#39;[qLower - 3 * qSpacing, qUpper - 3 * qSpacing]&#39;.</span>
  231 |     | <span class='neutral'>//</span>
  232 |     | <span class='neutral'>// At each point throughout the execution of the swap, as we transition from</span>
  233 |     | <span class='neutral'>// each interval to the next one, the memory pointers &#39;_back_&#39; and &#39;_next_&#39; are</span>
  234 |     | <span class='neutral'>// used in order to keep track of the boundaries for the current active</span>
  235 |     | <span class='neutral'>// interval. Each of these pointers refer to a memory space in which the</span>
  236 |     | <span class='neutral'>// following two values are enclosed:</span>
  237 |     | <span class='neutral'>//</span>
  238 |     | <span class='neutral'>//  &#39;qBack := log(pBack / pOffset)&#39;</span>
  239 |     | <span class='neutral'>//  &#39;qNext := log(pNext / pOffset)&#39;</span>
  240 |     | <span class='neutral'>//</span>
  241 |     | <span class='neutral'>// (among other values) where &#39;pBack&#39; is the boundary of the current active</span>
  242 |     | <span class='neutral'>// liquidity interval in the opposite direction of the swap and &#39;pNext&#39; is the</span>
  243 |     | <span class='neutral'>// other boundary in the direction of the swap.</span>
  244 |     | <span class='neutral'>//</span>
  245 |     | <span class='neutral'>// For price increasing swaps, the initial values for &#39;qBack&#39; and &#39;qNext&#39; are</span>
  246 |     | <span class='neutral'>// as follows</span>
  247 |     | <span class='neutral'>//</span>
  248 |     | <span class='neutral'>//  &#39;qBack := qLower&#39;</span>
  249 |     | <span class='neutral'>//  &#39;qNext := qUpper&#39;.</span>
  250 |     | <span class='neutral'>//</span>
  251 |     | <span class='neutral'>// However, in the present example, since the swap is price decreasing, these</span>
  252 |     | <span class='neutral'>// initial values are:</span>
  253 |     | <span class='neutral'>//</span>
  254 |     | <span class='neutral'>//  &#39;qBack := qUpper&#39;</span>
  255 |     | <span class='neutral'>//  &#39;qNext := qLower&#39;.</span>
  256 |     | <span class='neutral'>//</span>
  257 |     | <span class='neutral'>// as illustrated here:</span>
  258 |     | <span class='neutral'>//</span>
  259 |     | <span class='neutral'>//             qLimit                                   qCurrent</span>
  260 |     | <span class='neutral'>//               |                                         |</span>
  261 |     | <span class='neutral'>//  ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
  262 |     | <span class='neutral'>//                                                   |             |</span>
  263 |     | <span class='neutral'>//                                                 qNext         qBack</span>
  264 |     | <span class='neutral'>//</span>
  265 |     | <span class='neutral'>// As the price transitions to a new liquidity interval, the content of the</span>
  266 |     | <span class='neutral'>// memory spaces that are pointed to by &#39;_back_&#39; and &#39;_next_&#39; are updated</span>
  267 |     | <span class='neutral'>// accordingly.</span>
  268 |     | <span class='neutral'>//</span>
  269 |     | <span class='neutral'>// Now, in order to perform this swap, we need to proceed as follows:</span>
  270 |     | <span class='neutral'>//</span>
  271 |     | <span class='neutral'>//  - The dynamic parameters of the pool are read from the protocol&#39;s storage</span>
  272 |     | <span class='neutral'>//    which include the followings:</span>
  273 |     | <span class='neutral'>//</span>
  274 |     | <span class='neutral'>//    - &#39;sharesTotal&#39;: This is the total number of shares that are deposited in</span>
  275 |     | <span class='neutral'>//      the current active liquidity interval &#39;[qLower, qUpper]&#39; across all</span>
  276 |     | <span class='neutral'>//      LPs. Consider an example where we have only two LP positions such that</span>
  277 |     | <span class='neutral'>//      </span>
  278 |     | <span class='neutral'>//      - The first position has 2 shares in every interval from &#39;qLower&#39; to</span>
  279 |     | <span class='neutral'>//        &#39;qUpper + 2 * qSpacing&#39;, i.e., 2 shares in each of the intervals</span>
  280 |     | <span class='neutral'>//        &#39;[qLower, qUpper]&#39;, &#39;[qLower + qSpacing, qUpper + qSpacing]&#39;, and</span>
  281 |     | <span class='neutral'>//        &#39;[qSpacing + 2 * qSpacing, qUpper + 2 * qSpacing]&#39;.</span>
  282 |     | <span class='neutral'>//      </span>
  283 |     | <span class='neutral'>//      - The second position has 5 shares in every interval from</span>
  284 |     | <span class='neutral'>//        &#39;qLower - qSpacing&#39; to &#39;qUpper + qSpacing&#39;, i.e., 5 shares in each of</span>
  285 |     | <span class='neutral'>//        the intervals &#39;[qLower - qSpacing, qUpper - qSpacing]&#39;,</span>
  286 |     | <span class='neutral'>//        &#39;[qLower, qUpper]&#39;, and &#39;[qLower + qSpacing, qUpper + qSpacing]&#39;.</span>
  287 |     | <span class='neutral'>//</span>
  288 |     | <span class='neutral'>//      In this case, both LP positions include the active liquidity interval</span>
  289 |     | <span class='neutral'>//      &#39;[qLower, qUpper]&#39; which means that &#39;sharesTotal == 2 + 5 == 7&#39;.</span>
  290 |     | <span class='neutral'>//</span>
  291 |     | <span class='neutral'>//    - &#39;growth&#39;: The amount of liquidity which is allocated to a single LP</span>
  292 |     | <span class='neutral'>//      share in the active interval increases as a result of a swap or a</span>
  293 |     | <span class='neutral'>//      donation. We use this parameter to keep track of the amount of</span>
  294 |     | <span class='neutral'>//      liquidity for each share. &#39;growth&#39; is stored in &#39;X111&#39; format and we</span>
  295 |     | <span class='neutral'>//      always have &#39;growth &gt;= oneX111&#39;.</span>
  296 |     | <span class='neutral'>//</span>
  297 |     | <span class='neutral'>//    - &#39;qCurrent&#39;: This is equal to &#39;log(pCurrent / pOffset)&#39; where &#39;pCurrent&#39;</span>
  298 |     | <span class='neutral'>//      is the current price of the pool prior to the execution of the swap.</span>
  299 |     | <span class='neutral'>//</span>
  300 |     | <span class='neutral'>//    - &#39;staticParamsStoragePointer&#39;: Certain information about the pool that</span>
  301 |     | <span class='neutral'>//      never change (e.g., &#39;tag0&#39; and &#39;tag1&#39;) or do not change frequently are</span>
  302 |     | <span class='neutral'>//      encoded in an external smart contract&#39;s bytecode. We refer to this</span>
  303 |     | <span class='neutral'>//      external smart contract as the storage smart contract of the pool. This</span>
  304 |     | <span class='neutral'>//      way, the encoded parameters can be accessed by reading the storage</span>
  305 |     | <span class='neutral'>//      smart contract&#39;s bytecode which is more gas efficient than accessing</span>
  306 |     | <span class='neutral'>//      protocol&#39;s storage via &#39;sload&#39;. However, if we ever need to make any</span>
  307 |     | <span class='neutral'>//      modification, a new storage smart contract should be deployed with an</span>
  308 |     | <span class='neutral'>//      updated bytecode. Hence, the protocol needs to keep track of the</span>
  309 |     | <span class='neutral'>//      address for the storage smart contract associated with each pool.</span>
  310 |     | <span class='neutral'>//      Instead of storing a 20-byte address for each pool, we calculate it</span>
  311 |     | <span class='neutral'>//      from &#39;staticParamsStoragePointer&#39; as further explained in</span>
  312 |     | <span class='neutral'>//      &#39;Storage.sol&#39;. Hence, &#39;staticParamsStoragePointer&#39; is a 16-bit pointer</span>
  313 |     | <span class='neutral'>//      which is used to derive the address of the storage smart contract from</span>
  314 |     | <span class='neutral'>//      which additional information about the pool is read.</span>
  315 |     | <span class='neutral'>//</span>
  316 |     | <span class='neutral'>//  - The curve sequence is read from the protocol&#39;s storage. The &#39;curve&#39; is a</span>
  317 |     | <span class='neutral'>//    sequence containing historical prices in &#39;X59&#39; representation. It should</span>
  318 |     | <span class='neutral'>//    have at least two members. In other words, every  member of the curve</span>
  319 |     | <span class='neutral'>//    sequence represents a historical price &#39;pHistorical&#39; which is stored in</span>
  320 |     | <span class='neutral'>//    the form:</span>
  321 |     | <span class='neutral'>//</span>
  322 |     | <span class='neutral'>//      &#39;(2 ** 59) * (16 + qHistorical)&#39;</span>
  323 |     | <span class='neutral'>//</span>
  324 |     | <span class='neutral'>//    where</span>
  325 |     | <span class='neutral'>//</span>
  326 |     | <span class='neutral'>//      &#39;qHistorical := log(pHistorical / pOffset)&#39;.</span>
  327 |     | <span class='neutral'>//</span>
  328 |     | <span class='neutral'>//    Hence, each member of the curve occupies exactly &#39;64&#39; bits as explained</span>
  329 |     | <span class='neutral'>//    in &#39;Curve.sol&#39;. This is because &#39;pHistorical&#39; satisfies</span>
  330 |     | <span class='neutral'>//</span>
  331 |     | <span class='neutral'>//      &#39;pOffset * exp(- 16 + 1 / (2 ** 59)) &lt;= pHistorical&#39;</span>
  332 |     | <span class='neutral'>//</span>
  333 |     | <span class='neutral'>//    and</span>
  334 |     | <span class='neutral'>//</span>
  335 |     | <span class='neutral'>//      &#39;pHistorical &lt;= pOffset * exp(+ 16 - 1 / (2 ** 59))&#39;.</span>
  336 |     | <span class='neutral'>//</span>
  337 |     | <span class='neutral'>//    which conclude that</span>
  338 |     | <span class='neutral'>//</span>
  339 |     | <span class='neutral'>//      &#39;1 &lt;= (2 ** 59) * (16 + qHistorical) &lt;= 2 ** 64 - 1&#39;.</span>
  340 |     | <span class='neutral'>//</span>
  341 |     | <span class='neutral'>//    The first and the second members of the curve sequence correspond to the</span>
  342 |     | <span class='neutral'>//    boundaries of the current active liquidity interval (i.e., &#39;qLower&#39; and</span>
  343 |     | <span class='neutral'>//    &#39;qUpper&#39;) with the order depending on the pool&#39;s history. The last member</span>
  344 |     | <span class='neutral'>//    of the curve represents the current price of the pool, i.e., &#39;qCurrent&#39;.</span>
  345 |     | <span class='neutral'>//    </span>
  346 |     | <span class='neutral'>//    Let &#39;l&#39; denote the number of members in the curve sequence. Since, we</span>
  347 |     | <span class='neutral'>//    already know &#39;qCurrent&#39; from dynamic parameters, we can determine &#39;l&#39;</span>
  348 |     | <span class='neutral'>//    without having to load an entire length slot! In other words, we keep</span>
  349 |     | <span class='neutral'>//    reading members of the curve sequence from protocol&#39;s storage (four</span>
  350 |     | <span class='neutral'>//    members per slot) until we encounter &#39;qCurrent&#39; which is already known</span>
  351 |     | <span class='neutral'>//    from dynamic parameters. Then, &#39;l&#39; can be determined based on the</span>
  352 |     | <span class='neutral'>//    position of &#39;qCurrent&#39; in the curve sequence.</span>
  353 |     | <span class='neutral'>//</span>
  354 |     | <span class='neutral'>//    For every integer &#39;0 &lt;= i &lt; l&#39;, denote the (i + 1)-th historical price</span>
  355 |     | <span class='neutral'>//    recorded by the curve sequence as &#39;p[i]&#39;. Additionally, to simplify the</span>
  356 |     | <span class='neutral'>//    notations, the out-of-range price &#39;p[l]&#39; is assigned the same value as</span>
  357 |     | <span class='neutral'>//    &#39;p[l - 1]&#39;. Now, for every integer &#39;0 &lt;= i &lt;= l&#39;, define also </span>
  358 |     | <span class='neutral'>//    </span>
  359 |     | <span class='neutral'>//      &#39;q[i] := log(p[i] / pOffset)&#39;.</span>
  360 |     | <span class='neutral'>//</span>
  361 |     | <span class='neutral'>//    The curve sequence is constructed in such a way that for every</span>
  362 |     | <span class='neutral'>//    &#39;2 &lt;= i &lt; l&#39;, we have:</span>
  363 |     | <span class='neutral'>//</span>
  364 |     | <span class='neutral'>//      &#39;min(q[i - 1], q[i - 2]) &lt; q[i] &lt; max(q[i - 1], q[i - 2])&#39;.</span>
  365 |     | <span class='neutral'>//</span>
  366 |     | <span class='neutral'>//    This ordering rule is verified upon initialization of any pool and it is</span>
  367 |     | <span class='neutral'>//    preserved by every amendment to the curve sequence.</span>
  368 |     | <span class='neutral'>//    </span>
  369 |     | <span class='neutral'>//    In order to use the curve sequence, we need to define a number of</span>
  370 |     | <span class='neutral'>//    functions. For every &#39;0 &lt;= i &lt;= l - 2&#39;, if &#39;q[i + 2] &lt; q[i]&#39; define</span>
  371 |     | <span class='neutral'>//</span>
  372 |     | <span class='neutral'>//      &#39;w_i : [qLower, qUpper] -&gt; [0, qSpacing]&#39;</span>
  373 |     | <span class='neutral'>//</span>
  374 |     | <span class='neutral'>//    as</span>
  375 |     | <span class='neutral'>//</span>
  376 |     | <span class='neutral'>//                  /</span>
  377 |     | <span class='neutral'>//                 |  q - q[i + 1]  if q[i + 2] &lt; q &lt; q[i]</span>
  378 |     | <span class='neutral'>//      &#39;w_i(q) := |                                       &#39;</span>
  379 |     | <span class='neutral'>//                 |  0             otherwise</span>
  380 |     | <span class='neutral'>//                  \</span>
  381 |     | <span class='neutral'>//</span>
  382 |     | <span class='neutral'>//    and if &#39;q[i] &lt; q[i + 2]&#39; define</span>
  383 |     | <span class='neutral'>//</span>
  384 |     | <span class='neutral'>//      &#39;w_i : [qLower, qUpper] -&gt; [0, qSpacing]&#39;</span>
  385 |     | <span class='neutral'>//</span>
  386 |     | <span class='neutral'>//    as</span>
  387 |     | <span class='neutral'>//</span>
  388 |     | <span class='neutral'>//                  /</span>
  389 |     | <span class='neutral'>//                 |  q[i + 1] - q  if q[i] &lt; q &lt; q[i + 2]</span>
  390 |     | <span class='neutral'>//      &#39;w_i(q) := |                                        &#39;</span>
  391 |     | <span class='neutral'>//                 |  0             otherwise</span>
  392 |     | <span class='neutral'>//                  \</span>
  393 |     | <span class='neutral'>//</span>
  394 |     | <span class='neutral'>//    Each of the above functions is regarded as a phase. Observe that the</span>
  395 |     | <span class='neutral'>//    diagram for each of the phase is a compactly supported (i.e., equal to</span>
  396 |     | <span class='neutral'>//    zero outside of a bounded interval) segment with either &#39;45&#39; or &#39;135&#39;</span>
  397 |     | <span class='neutral'>//    degrees angle. Define</span>
  398 |     | <span class='neutral'>//</span>
  399 |     | <span class='neutral'>//      &#39;w : [qLower, qUpper] -&gt; [0, qSpacing]&#39;</span>
  400 |     | <span class='neutral'>//</span>
  401 |     | <span class='neutral'>//    as</span>
  402 |     | <span class='neutral'>//</span>
  403 |     | <span class='neutral'>//               l - 2</span>
  404 |     | <span class='neutral'>//               -----</span>
  405 |     | <span class='neutral'>//               \</span>
  406 |     | <span class='neutral'>//      &#39;w(q) := /     w_i(q).</span>
  407 |     | <span class='neutral'>//               -----</span>
  408 |     | <span class='neutral'>//               i = 0</span>
  409 |     | <span class='neutral'>//</span>
  410 |     | <span class='neutral'>//    This function will be used to determine the distribution of liquidity</span>
  411 |     | <span class='neutral'>//    within the active interval &#39;[qLower, qUpper]&#39;. As we will discuss later</span>
  412 |     | <span class='neutral'>//    in this script, the distribution of liquidity is modified with every swap</span>
  413 |     | <span class='neutral'>//    via amendments to the curve sequence and this process ensures liquidity</span>
  414 |     | <span class='neutral'>//    growth for the LPs without the need to charge fees.</span>
  415 |     | <span class='neutral'>//</span>
  416 |     | <span class='neutral'>//    For example, let</span>
  417 |     | <span class='neutral'>//</span>
  418 |     | <span class='neutral'>//      &#39;q[0] := qUpper&#39;</span>
  419 |     | <span class='neutral'>//      &#39;q[1] := qLower&#39;</span>
  420 |     | <span class='neutral'>//      &#39;q[2]&#39;</span>
  421 |     | <span class='neutral'>//      &#39;q[3] := qCurrent&#39;</span>
  422 |     | <span class='neutral'>//</span>
  423 |     | <span class='neutral'>//    represent the curve sequence. Then,</span>
  424 |     | <span class='neutral'>//</span>
  425 |     | <span class='neutral'>//      &#39;w(q) := w_0(q) + w_1(q) + w_2(q)&#39;</span>
  426 |     | <span class='neutral'>//</span>
  427 |     | <span class='neutral'>//    can be plotted as follows:</span>
  428 |     | <span class='neutral'>//</span>
  429 |     | <span class='neutral'>//            w(q)</span>
  430 |     | <span class='neutral'>//              ^</span>
  431 |     | <span class='neutral'>//      spacing |                /</span>
  432 |     | <span class='neutral'>//              |               /</span>
  433 |     | <span class='neutral'>//              |              /</span>
  434 |     | <span class='neutral'>//              |             /</span>
  435 |     | <span class='neutral'>//              |            /</span>
  436 |     | <span class='neutral'>//              |           /</span>
  437 |     | <span class='neutral'>//              |          /</span>
  438 |     | <span class='neutral'>//              |\</span>
  439 |     | <span class='neutral'>//              | \</span>
  440 |     | <span class='neutral'>//              |  \</span>
  441 |     | <span class='neutral'>//              |   \</span>
  442 |     | <span class='neutral'>//              |        /</span>
  443 |     | <span class='neutral'>//              |       /</span>
  444 |     | <span class='neutral'>//              |      /</span>
  445 |     | <span class='neutral'>//              |     /</span>
  446 |     | <span class='neutral'>//            0 +----+----+-------+-&gt; q</span>
  447 |     | <span class='neutral'>//           qLower  |    |       |</span>
  448 |     | <span class='neutral'>//                   |   q[2]   qUpper</span>
  449 |     | <span class='neutral'>//                   |</span>
  450 |     | <span class='neutral'>//               qCurrent</span>
  451 |     | <span class='neutral'>//    </span>
  452 |     | <span class='neutral'>//    To summarize, reading the curve sequence from the protocol&#39;s storage</span>
  453 |     | <span class='neutral'>//    gives us access to &#39;qLower&#39;, &#39;qUpper&#39; and the function &#39;w&#39;.</span>
  454 |     | <span class='neutral'>//</span>
  455 |     | <span class='neutral'>//    The curve sequence is defined for every inactive liquidity interval as</span>
  456 |     | <span class='neutral'>//    well, although we do not need to keep track of them. For every integer</span>
  457 |     | <span class='neutral'>//    &#39;j &gt; 0&#39;, the curve sequence associated with the interval:</span>
  458 |     | <span class='neutral'>//</span>
  459 |     | <span class='neutral'>//      &#39;[qLower + j * qSpacing, qUpper + j * qSpacing]&#39;</span>
  460 |     | <span class='neutral'>//</span>
  461 |     | <span class='neutral'>//    is composed of only two members:</span>
  462 |     | <span class='neutral'>//</span>
  463 |     | <span class='neutral'>//      &#39;q[0] := qUpper + j * qSpacing&#39; </span>
  464 |     | <span class='neutral'>//      &#39;q[1] := qLower + j * qSpacing&#39;. </span>
  465 |     | <span class='neutral'>//</span>
  466 |     | <span class='neutral'>//    Hence, the function</span>
  467 |     | <span class='neutral'>//</span>
  468 |     | <span class='neutral'>//      &#39;w : [qLower + j * qSpacing, qUpper + j * qSpacing] -&gt; [0, qSpacing]&#39;</span>
  469 |     | <span class='neutral'>//</span>
  470 |     | <span class='neutral'>//    corresponding to that interval is defined as:</span>
  471 |     | <span class='neutral'>//</span>
  472 |     | <span class='neutral'>//      &#39;w(q) := q - qLower - j * qSpacing&#39;</span>
  473 |     | <span class='neutral'>//</span>
  474 |     | <span class='neutral'>//    which is consistent with the prior definition of &#39;w&#39; for the active</span>
  475 |     | <span class='neutral'>//    interval. Additionally, for every integer &#39;j &lt; 0&#39;, the curve sequence</span>
  476 |     | <span class='neutral'>//    associated with the interval:</span>
  477 |     | <span class='neutral'>//</span>
  478 |     | <span class='neutral'>//      &#39;[qLower + j * qSpacing, qUpper + j * qSpacing]&#39;</span>
  479 |     | <span class='neutral'>//</span>
  480 |     | <span class='neutral'>//    is composed of only two members:</span>
  481 |     | <span class='neutral'>//</span>
  482 |     | <span class='neutral'>//      &#39;q[0] := qLower + j * qSpacing&#39; </span>
  483 |     | <span class='neutral'>//      &#39;q[1] := qUpper + j * qSpacing&#39;. </span>
  484 |     | <span class='neutral'>//</span>
  485 |     | <span class='neutral'>//    Hence, the function</span>
  486 |     | <span class='neutral'>//</span>
  487 |     | <span class='neutral'>//      &#39;w : [qLower + j * qSpacing, qUpper + j * qSpacing] -&gt; [0, qSpacing]&#39;</span>
  488 |     | <span class='neutral'>//</span>
  489 |     | <span class='neutral'>//    corresponding to that interval is defined as:</span>
  490 |     | <span class='neutral'>//</span>
  491 |     | <span class='neutral'>//      &#39;w(q) := qUpper + j * qSpacing - q&#39;</span>
  492 |     | <span class='neutral'>//    </span>
  493 |     | <span class='neutral'>//    which is also consistent with our prior definition.</span>
  494 |     | <span class='neutral'>//</span>
  495 |     | <span class='neutral'>//    After reading the curve sequence for the active interval, we store</span>
  496 |     | <span class='neutral'>//    &#39;qBack&#39; and &#39;qNext&#39; in their dedicated memory spaces in order to keep</span>
  497 |     | <span class='neutral'>//    track of the boundaries of the active liquidity interval. In the present</span>
  498 |     | <span class='neutral'>//    example, since the swap is price decreasing, the initial values for</span>
  499 |     | <span class='neutral'>//    &#39;qBack&#39; and &#39;qNext&#39; are as follows:</span>
  500 |     | <span class='neutral'>//</span>
  501 |     | <span class='neutral'>//      &#39;qBack := qUpper&#39;,</span>
  502 |     | <span class='neutral'>//      &#39;qNext := qLower&#39;.</span>
  503 |     | <span class='neutral'>//</span>
  504 |     | <span class='neutral'>//    For price increasing swaps, these initial values are</span>
  505 |     | <span class='neutral'>//</span>
  506 |     | <span class='neutral'>//      &#39;qBack := qLower&#39;,</span>
  507 |     | <span class='neutral'>//      &#39;qNext := qUpper&#39;.</span>
  508 |     | <span class='neutral'>//</span>
  509 |     | <span class='neutral'>//    As discussed before, &#39;qBack&#39; and &#39;qNext&#39; are continuously updated</span>
  510 |     | <span class='neutral'>//    throughout the execution of a swap as we transition to new liquidity</span>
  511 |     | <span class='neutral'>//    intervals.</span>
  512 |     | <span class='neutral'>//</span>
  513 |     | <span class='neutral'>//  - Next, the kernel function is read from the storage smart contract&#39;s</span>
  514 |     | <span class='neutral'>//    bytecode. To this end, the dynamic parameter &#39;staticParamsStoragePointer&#39;</span>
  515 |     | <span class='neutral'>//    is used to calculate the address to the storage smart contract associated</span>
  516 |     | <span class='neutral'>//    with the pool whose bytecode contains the kernel function. The kernel,</span>
  517 |     | <span class='neutral'>//    denoted by</span>
  518 |     | <span class='neutral'>//</span>
  519 |     | <span class='neutral'>//      &#39;k : [0, qSpacing] -&gt; [0, 1]&#39;,</span>
  520 |     | <span class='neutral'>//</span>
  521 |     | <span class='neutral'>//    is a monotonically non-decreasing piecewise linear function which is</span>
  522 |     | <span class='neutral'>//    characterized via a list of breakpoints. Each breakpoint has a horizontal</span>
  523 |     | <span class='neutral'>//    coordinate as well as a vertical coordinate. Consider the following</span>
  524 |     | <span class='neutral'>//    examples:</span>
  525 |     | <span class='neutral'>//</span>
  526 |     | <span class='neutral'>//      - The sequence of breakpoints</span>
  527 |     | <span class='neutral'>//</span>
  528 |     | <span class='neutral'>//          &#39;(0, 0), (qSpacing, 1)&#39;</span>
  529 |     | <span class='neutral'>//</span>
  530 |     | <span class='neutral'>//        implies that the diagram of &#39;k&#39; is a single segment connecting the</span>
  531 |     | <span class='neutral'>//        point &#39;(0, 0)&#39; to the point &#39;(qSpacing, 1)&#39;. This leads to the kernel</span>
  532 |     | <span class='neutral'>//        function:</span>
  533 |     | <span class='neutral'>//</span>
  534 |     | <span class='neutral'>//          &#39;k(h) := h / qSpacing&#39;.</span>
  535 |     | <span class='neutral'>//</span>
  536 |     | <span class='neutral'>//      - The sequence of breakpoints</span>
  537 |     | <span class='neutral'>//</span>
  538 |     | <span class='neutral'>//          &#39;(0, 0), (qSpacing / 2, 1), (qSpacing, 1)&#39;</span>
  539 |     | <span class='neutral'>//</span>
  540 |     | <span class='neutral'>//        implies that the diagram of &#39;k&#39; is composed of two segments:</span>
  541 |     | <span class='neutral'>//</span>
  542 |     | <span class='neutral'>//          - The first segment connects the point &#39;(0, 0)&#39; to the point</span>
  543 |     | <span class='neutral'>//            &#39;(qSpacing / 2, 1)&#39;.</span>
  544 |     | <span class='neutral'>//</span>
  545 |     | <span class='neutral'>//          - The second segment connects the point &#39;(qSpacing / 2, 1)&#39; to the</span>
  546 |     | <span class='neutral'>//            point &#39;(qSpacing, 1)&#39;.</span>
  547 |     | <span class='neutral'>//</span>
  548 |     | <span class='neutral'>//        The combination of the two segments leads to the kernel function:</span>
  549 |     | <span class='neutral'>//</span>
  550 |     | <span class='neutral'>//                    /</span>
  551 |     | <span class='neutral'>//                   |  2 * h / qSpacing    if 0 &lt; q &lt; qSpacing / 2</span>
  552 |     | <span class='neutral'>//          &#39;k(h) := |                                                      &#39;.</span>
  553 |     | <span class='neutral'>//                   |  1                   if qSpacing / 2 &lt; q &lt; qSpacing</span>
  554 |     | <span class='neutral'>//                    \</span>
  555 |     | <span class='neutral'>//</span>
  556 |     | <span class='neutral'>//      - The sequence of breakpoints</span>
  557 |     | <span class='neutral'>//</span>
  558 |     | <span class='neutral'>//          &#39;(0, 0), (qSpacing / 2, 0), (qSpacing / 2, 1 / 2), (qSpacing, 1)&#39;</span>
  559 |     | <span class='neutral'>//</span>
  560 |     | <span class='neutral'>//        implies that the diagram of &#39;k&#39; is composed of three segments:</span>
  561 |     | <span class='neutral'>//</span>
  562 |     | <span class='neutral'>//          - The first segment belongs to the horizontal axis connecting the</span>
  563 |     | <span class='neutral'>//            point &#39;(0, 0)&#39; to the point &#39;(qSpacing / 2, 0)&#39;.</span>
  564 |     | <span class='neutral'>//</span>
  565 |     | <span class='neutral'>//          - The second segment is vertical, connecting the point</span>
  566 |     | <span class='neutral'>//            &#39;(qSpacing / 2, 0)&#39; to the point &#39;(qSpacing / 2, 1 / 2)&#39;. A</span>
  567 |     | <span class='neutral'>//            vertical segment (i.e., two consecutive breakpoints with equal</span>
  568 |     | <span class='neutral'>//            horizontal coordinates) indicates that the kernel function is</span>
  569 |     | <span class='neutral'>//            discontinuous which is permitted by the protocol. In this case,</span>
  570 |     | <span class='neutral'>//            we have a discontinuity at point &#39;qSpacing / 2&#39; because:</span>
  571 |     | <span class='neutral'>//            </span>
  572 |     | <span class='neutral'>//              &#39;0 == k(qSpacing / 2 - epsilon) != </span>
  573 |     | <span class='neutral'>//                    k(qSpacing / 2 + epsilon) == 1 / 2 + epsilon / qSpacing&#39;</span>
  574 |     | <span class='neutral'>//            </span>
  575 |     | <span class='neutral'>//            where &#39;epsilon &gt; 0&#39; is an arbitrarily small value approaching 0.</span>
  576 |     | <span class='neutral'>//</span>
  577 |     | <span class='neutral'>//          - The third segment connects the point &#39;(qSpacing / 2, 1 / 2)&#39; to</span>
  578 |     | <span class='neutral'>//            the point &#39;(qSpacing, 1)&#39;.</span>
  579 |     | <span class='neutral'>//</span>
  580 |     | <span class='neutral'>//        The combination of the three segments leads to the kernel function:</span>
  581 |     | <span class='neutral'>//</span>
  582 |     | <span class='neutral'>//                    /</span>
  583 |     | <span class='neutral'>//                   |  0               if 0 &lt; q &lt; qSpacing / 2</span>
  584 |     | <span class='neutral'>//          &#39;k(h) := |                                                  &#39;.</span>
  585 |     | <span class='neutral'>//                   |  h / qSpacing    if qSpacing / 2 &lt; q &lt; qSpacing</span>
  586 |     | <span class='neutral'>//                    \</span>
  587 |     | <span class='neutral'>//    </span>
  588 |     | <span class='neutral'>//    Hence, reading the kernel breakpoints from the storage smart contract</span>
  589 |     | <span class='neutral'>//    gives us access to the function &#39;k&#39;.</span>
  590 |     | <span class='neutral'>//    </span>
  591 |     | <span class='neutral'>//    Define</span>
  592 |     | <span class='neutral'>//</span>
  593 |     | <span class='neutral'>//      &#39;k(w(.)) : [qLower, qUpper] -&gt; [0, 1]&#39;</span>
  594 |     | <span class='neutral'>//</span>
  595 |     | <span class='neutral'>//    as the liquidity distribution function. As we will demonstrate next, one</span>
  596 |     | <span class='neutral'>//    can determine the outgoing amount from the pool and the incoming amount</span>
  597 |     | <span class='neutral'>//    to the pool by integrating the liquidity distribution function. More</span>
  598 |     | <span class='neutral'>//    precisely, consider a swap that involves a movement of price from</span>
  599 |     | <span class='neutral'>//    &#39;qCurrent&#39; to</span>
  600 |     | <span class='neutral'>//</span>
  601 |     | <span class='neutral'>//      &#39;qTarget := log(pTarget / pOffset)&#39;</span>
  602 |     | <span class='neutral'>//</span>
  603 |     | <span class='neutral'>//    within the same active liquidity interval, i.e.,</span>
  604 |     | <span class='neutral'>//</span>
  605 |     | <span class='neutral'>//      &#39;qLower &lt;= qTarget &lt;= qUpper&#39;.</span>
  606 |     | <span class='neutral'>//</span>
  607 |     | <span class='neutral'>//    If &#39;qCurrent &lt; qTarget, then the outgoing amount of &#39;tag0&#39; as a result of</span>
  608 |     | <span class='neutral'>//    this movement is proportional to the following integration of the</span>
  609 |     | <span class='neutral'>//    liquidity distribution function:</span>
  610 |     | <span class='neutral'>//</span>
  611 |     | <span class='neutral'>//                               - 8     / qTarget</span>
  612 |     | <span class='neutral'>//        currentToTarget      e        |    - h / 2</span>
  613 |     | <span class='neutral'>//      &#39;----------------- := ------- * |  e         k(w(h)) dh&#39;.</span>
  614 |     | <span class='neutral'>//           2 ** 216            2      |</span>
  615 |     | <span class='neutral'>//                                     / qCurrent</span>
  616 |     | <span class='neutral'>//</span>
  617 |     | <span class='neutral'>//    In this case, the incoming amount of &#39;tag1&#39; as a result of this movement</span>
  618 |     | <span class='neutral'>//    is proportional to the following integration of the liquidity</span>
  619 |     | <span class='neutral'>//    distribution function:</span>
  620 |     | <span class='neutral'>//</span>
  621 |     | <span class='neutral'>//                                       - 8     / qTarget</span>
  622 |     | <span class='neutral'>//        incomingCurrentToTarget      e        |    + h / 2</span>
  623 |     | <span class='neutral'>//      &#39;------------------------- := ------- * |  e         k(w(h)) dh&#39;.</span>
  624 |     | <span class='neutral'>//               2 ** 216                2      |</span>
  625 |     | <span class='neutral'>//                                             / qCurrent</span>
  626 |     | <span class='neutral'>//</span>
  627 |     | <span class='neutral'>//    On the other hand, if &#39;qTarget &lt; qCurrent&#39;, then the outgoing amount of</span>
  628 |     | <span class='neutral'>//    &#39;tag1&#39; and the incoming amount of &#39;tag0&#39;, respectively, are proportional</span>
  629 |     | <span class='neutral'>//    to the following integrations of the liquidity distribution function:</span>
  630 |     | <span class='neutral'>//</span>
  631 |     | <span class='neutral'>//                               - 8     / qCurrent</span>
  632 |     | <span class='neutral'>//        currentToTarget      e        |    + h / 2</span>
  633 |     | <span class='neutral'>//      &#39;----------------- := ------- * |  e         k(w(h)) dh&#39;,</span>
  634 |     | <span class='neutral'>//           2 ** 216            2      |</span>
  635 |     | <span class='neutral'>//                                     / qTarget</span>
  636 |     | <span class='neutral'>//</span>
  637 |     | <span class='neutral'>//                                       - 8     / qCurrent</span>
  638 |     | <span class='neutral'>//        incomingCurrentToTarget      e        |    - h / 2</span>
  639 |     | <span class='neutral'>//      &#39;------------------------- := ------- * |  e         k(w(h)) dh&#39;.</span>
  640 |     | <span class='neutral'>//                2 ** 216               2      |</span>
  641 |     | <span class='neutral'>//                                             / qTarget</span>
  642 |     | <span class='neutral'>//</span>
  643 |     | <span class='neutral'>//    Now, imagine a scenario where we want to move all the way from &#39;qCurrent&#39;</span>
  644 |     | <span class='neutral'>//    to &#39;qUpper&#39; which is a price increasing swap. Hence, in this case, the</span>
  645 |     | <span class='neutral'>//    outgoing amount of &#39;tag0&#39; is proportional to:</span>
  646 |     | <span class='neutral'>//</span>
  647 |     | <span class='neutral'>//                         - 8     / qUpper</span>
  648 |     | <span class='neutral'>//        integral0      e        |    - h / 2</span>
  649 |     | <span class='neutral'>//      &#39;----------- := ------- * |  e         k(w(h)) dh&#39;.</span>
  650 |     | <span class='neutral'>//        2 ** 216         2      |</span>
  651 |     | <span class='neutral'>//                               / qCurrent</span>
  652 |     | <span class='neutral'>//</span>
  653 |     | <span class='neutral'>//    Observe that moving from &#39;qCurrent&#39; to &#39;qUpper&#39; depletes the entire</span>
  654 |     | <span class='neutral'>//    reserve of &#39;tag0&#39;, within the interval &#39;[qLower, qUpper]&#39; (because we</span>
  655 |     | <span class='neutral'>//    cannot go further than that without transitioning to a new interval).</span>
  656 |     | <span class='neutral'>//    Hence, the total reserve of &#39;tag0&#39; within the interval &#39;[qLower, qUpper]&#39;</span>
  657 |     | <span class='neutral'>//    is proportional to &#39;integral0&#39; which is given by the above formula.</span>
  658 |     | <span class='neutral'>//</span>
  659 |     | <span class='neutral'>//    Similarly, imagine a scenario where we want to move all the way from</span>
  660 |     | <span class='neutral'>//    &#39;qCurrent&#39; to &#39;qLower&#39; which is a price decreasing swap. Hence, in this</span>
  661 |     | <span class='neutral'>//    case, the outgoing amount of &#39;tag1&#39; is proportional to:</span>
  662 |     | <span class='neutral'>//</span>
  663 |     | <span class='neutral'>//                         - 8     / qCurrent</span>
  664 |     | <span class='neutral'>//        integral1      e        |    + h / 2</span>
  665 |     | <span class='neutral'>//      &#39;----------- := ------- * |  e         k(w(h)) dh&#39;,</span>
  666 |     | <span class='neutral'>//        2 ** 216         2      |</span>
  667 |     | <span class='neutral'>//                               / qLower</span>
  668 |     | <span class='neutral'>//</span>
  669 |     | <span class='neutral'>//    Observe that moving from &#39;qCurrent&#39; to &#39;qLower&#39; depletes the entire</span>
  670 |     | <span class='neutral'>//    reserve of &#39;tag1&#39;, within the interval &#39;[qLower, qUpper]&#39; (because we</span>
  671 |     | <span class='neutral'>//    cannot go further than that without transitioning to a new interval).</span>
  672 |     | <span class='neutral'>//    Hence, the total reserve of &#39;tag1&#39; within the interval &#39;[qLower, qUpper]&#39;</span>
  673 |     | <span class='neutral'>//    is proportional to &#39;integral1&#39; which is given by the above formula.</span>
  674 |     | <span class='neutral'>//</span>
  675 |     | <span class='neutral'>//    The values &#39;integral0&#39; and &#39;integral1&#39; are stored among the dynamic</span>
  676 |     | <span class='neutral'>//    parameters. This is because storing and updating them with every swap is</span>
  677 |     | <span class='neutral'>//    more gas efficient than recalculating them.</span>
  678 |     | <span class='neutral'>//</span>
  679 |     | <span class='neutral'>//    To summarize, in order to execute a swap,</span>
  680 |     | <span class='neutral'>//</span>
  681 |     | <span class='neutral'>//      - the function &#39;w&#39; is formed by reading the members of the curve</span>
  682 |     | <span class='neutral'>//        sequence from the protocol&#39;s storage,</span>
  683 |     | <span class='neutral'>//   </span>
  684 |     | <span class='neutral'>//      - the kernel function &#39;k&#39; is formed by reading its breakpoints from the</span>
  685 |     | <span class='neutral'>//        pool&#39;s storage smart contract, and</span>
  686 |     | <span class='neutral'>//</span>
  687 |     | <span class='neutral'>//      - the outgoing amount from the pool and the incoming amount to the pool</span>
  688 |     | <span class='neutral'>//        are determined by integrating the liquidity distribution function</span>
  689 |     | <span class='neutral'>//        &#39;k(w(.))&#39;.</span>
  690 |     | <span class='neutral'>//</span>
  691 |     | <span class='neutral'>//    An alternative way to look at the notion of liquidity distribution is to</span>
  692 |     | <span class='neutral'>//    imagine a traditional automated market making (AMM) diagram as</span>
  693 |     | <span class='neutral'>//    illustrated below:</span>
  694 |     | <span class='neutral'>//</span>
  695 |     | <span class='neutral'>//                tag1   pUpper</span>
  696 |     | <span class='neutral'>//                  ^   /</span>
  697 |     | <span class='neutral'>//                  |  /</span>
  698 |     | <span class='neutral'>//                  | /</span>
  699 |     | <span class='neutral'>//                  *</span>
  700 |     | <span class='neutral'>//                  |.</span>
  701 |     | <span class='neutral'>//                  | .</span>
  702 |     | <span class='neutral'>//                  |  .    </span>
  703 |     | <span class='neutral'>//                  |   .           pCurrent</span>
  704 |     | <span class='neutral'>//                  |     .        /</span>
  705 |     | <span class='neutral'>//                  |       .     /</span>
  706 |     | <span class='neutral'>//                  |         .  /           pTarget</span>
  707 |     | <span class='neutral'>//        integral1 + - - - - - *           /</span>
  708 |     | <span class='neutral'>//                  |           |  .       /         pLower</span>
  709 |     | <span class='neutral'>//                  |           |     .   /         /</span>
  710 |     | <span class='neutral'>//                  |           |        *         /</span>
  711 |     | <span class='neutral'>//                  |           |            .    /</span>
  712 |     | <span class='neutral'>//                  +-----------+----------------*----&gt; tag0</span>
  713 |     | <span class='neutral'>//                              |</span>
  714 |     | <span class='neutral'>//                          integral0 </span>
  715 |     | <span class='neutral'>//</span>
  716 |     | <span class='neutral'>//    where the horizontal and vertical coordinates, respectively, correspond</span>
  717 |     | <span class='neutral'>//    to the reserves of &#39;tag0&#39; and &#39;tag1&#39;, in the active liquidity interval.</span>
  718 |     | <span class='neutral'>//</span>
  719 |     | <span class='neutral'>//    Remember that the current reserve of &#39;tag0&#39; in &#39;[qLower, qUpper]&#39; is</span>
  720 |     | <span class='neutral'>//    proportional to &#39;integral0&#39; and the current reserve of &#39;tag1&#39; in the same</span>
  721 |     | <span class='neutral'>//    interval is proportional to &#39;integral1&#39;. Because of this, the point</span>
  722 |     | <span class='neutral'>//    &#39;(integral0, integral1)&#39; in the above diagram is indicated as &#39;pCurrent&#39;</span>
  723 |     | <span class='neutral'>//    which is the current price of the pool. As a result, &#39;0 - pCurrent&#39; is</span>
  724 |     | <span class='neutral'>//    equal to the slope of the diagram at the point &#39;(integral0, integral1)&#39;.</span>
  725 |     | <span class='neutral'>//    </span>
  726 |     | <span class='neutral'>//    A swapper is permitted to move to any point that belongs to the above</span>
  727 |     | <span class='neutral'>//    diagram by giving or taking appropriate amounts of &#39;tag0&#39; and &#39;tag1&#39;.</span>
  728 |     | <span class='neutral'>//    When a swapper moves on the above diagram we calculate the outgoing and</span>
  729 |     | <span class='neutral'>//    incoming amounts of &#39;tag0&#39; and &#39;tag1&#39; by computing the two integrals</span>
  730 |     | <span class='neutral'>//    &#39;currentToTarget&#39; and &#39;incomingCurrentToTarget&#39;. In short, the shape of</span>
  731 |     | <span class='neutral'>//    the above diagram is determined by the liquidity distribution function</span>
  732 |     | <span class='neutral'>//    &#39;k(w(.))&#39;.</span>
  733 |     | <span class='neutral'>//</span>
  734 |     | <span class='neutral'>//    As we will discuss later in this script, after a movement to &#39;pTarget&#39;,</span>
  735 |     | <span class='neutral'>//    the curve sequence is amended in preparation for the next swap which</span>
  736 |     | <span class='neutral'>//    renders a different liquidity distribution function. Such amendment also</span>
  737 |     | <span class='neutral'>//    leads to a new AMM diagram with the following properties:</span>
  738 |     | <span class='neutral'>//</span>
  739 |     | <span class='neutral'>//    - The new diagram intersects with the old one at the point &#39;pTarget&#39;.</span>
  740 |     | <span class='neutral'>//      This is due to the conservation of interval reserves.</span>
  741 |     | <span class='neutral'>//</span>
  742 |     | <span class='neutral'>//    - The new diagram is tangent to the old one at point &#39;pTarget&#39;. This is</span>
  743 |     | <span class='neutral'>//      because our transition to a new AMM diagram should not change the price</span>
  744 |     | <span class='neutral'>//      of the pool, i.e., the slopes of the new diagrams should be the same as</span>
  745 |     | <span class='neutral'>//      the old diagrams at the intersection point which means that the two are</span>
  746 |     | <span class='neutral'>//      tangent.</span>
  747 |     | <span class='neutral'>//</span>
  748 |     | <span class='neutral'>//    The proposed structure for the kernel function enables the pool creators</span>
  749 |     | <span class='neutral'>//    to build custom AMM diagrams. Additionally, the proposed structure for</span>
  750 |     | <span class='neutral'>//    the curve sequence allows the protocol to keep track of AMM diagrams,</span>
  751 |     | <span class='neutral'>//    efficiently. In other words, the curve sequence and the kernel function</span>
  752 |     | <span class='neutral'>//    provide us with an efficient method to store the geometry of AMM diagrams</span>
  753 |     | <span class='neutral'>//    and to transform them into new ones.</span>
  754 |     | <span class='neutral'>//</span>
  755 |     | <span class='neutral'>//    Now, in order to derive the outgoing and incoming amounts from the</span>
  756 |     | <span class='neutral'>//    integral values &#39;currentToTarget&#39; and &#39;incomingCurrentToTarget&#39; we need</span>
  757 |     | <span class='neutral'>//    to access the static parameters that are explained next.</span>
  758 |     | <span class='neutral'>//</span>
  759 |     | <span class='neutral'>//  - The static parameters of the pool are read from the same storage smart </span>
  760 |     | <span class='neutral'>//    contract whose address is calculated using the dynamic parameter</span>
  761 |     | <span class='neutral'>//    &#39;staticParamsStoragePointer&#39;. This includes the following parameters:</span>
  762 |     | <span class='neutral'>//</span>
  763 |     | <span class='neutral'>//    - &#39;sqrtOffset&#39;: This is the square root of &#39;pOffset&#39; in &#39;X127&#39;</span>
  764 |     | <span class='neutral'>//      representation, i.e.,</span>
  765 |     | <span class='neutral'>//</span>
  766 |     | <span class='neutral'>//        &#39;sqrtOffset := (2 ** 127) * sqrt(pOffset)&#39;.</span>
  767 |     | <span class='neutral'>//</span>
  768 |     | <span class='neutral'>//      This value is used frequently for calculating any amount of &#39;tag1&#39;.</span>
  769 |     | <span class='neutral'>//      Because of this, we calculate it at the time of initialization and</span>
  770 |     | <span class='neutral'>//      store it among the static parameters.</span>
  771 |     | <span class='neutral'>//</span>
  772 |     | <span class='neutral'>//    - &#39;sqrtInverseOffset&#39;: This is the square root of &#39;1 / pOffset&#39; in &#39;X127&#39;</span>
  773 |     | <span class='neutral'>//      representation, i.e.,</span>
  774 |     | <span class='neutral'>//</span>
  775 |     | <span class='neutral'>//        &#39;sqrtInverseOffset := (2 ** 127) / sqrt(pOffset)&#39;</span>
  776 |     | <span class='neutral'>//</span>
  777 |     | <span class='neutral'>//      This value is used frequently for calculating any amount of &#39;tag0&#39;.</span>
  778 |     | <span class='neutral'>//      Because of this, we calculate it at the time of initialization and</span>
  779 |     | <span class='neutral'>//      store it among the static parameters.</span>
  780 |     | <span class='neutral'>//</span>
  781 |     | <span class='neutral'>//    - &#39;outgoingMax&#39;: This value is a kernel parameter in &#39;X216&#39;</span>
  782 |     | <span class='neutral'>//      representation which is defined as follows:</span>
  783 |     | <span class='neutral'>//</span>
  784 |     | <span class='neutral'>//                             - 8     / qSpacing</span>
  785 |     | <span class='neutral'>//          outgoingMax      e        |    - h / 2</span>
  786 |     | <span class='neutral'>//        &#39;------------- := ------- * |  e         k(h) dh&#39;.</span>
  787 |     | <span class='neutral'>//           2 ** 216          2      |</span>
  788 |     | <span class='neutral'>//                                   / 0</span>
  789 |     | <span class='neutral'>//</span>
  790 |     | <span class='neutral'>//      &#39;outgoingMax&#39; is used frequently for calculating any amount of &#39;tag0&#39;</span>
  791 |     | <span class='neutral'>//      and &#39;tag1&#39;. Because of this, we calculate &#39;outgoingMax&#39; and its modular</span>
  792 |     | <span class='neutral'>//      inverse at the time of initialization or anytime that the kernel</span>
  793 |     | <span class='neutral'>//      function is modified and then we store the resulting values among the</span>
  794 |     | <span class='neutral'>//      static parameters.</span>
  795 |     | <span class='neutral'>//</span>
  796 |     | <span class='neutral'>//      Now, we have all of the parameters that are needed to calculate the</span>
  797 |     | <span class='neutral'>//      outgoing amount from the pool and the incoming amount to the pool as</span>
  798 |     | <span class='neutral'>//      long as we remain within the current active liquidity interval.</span>
  799 |     | <span class='neutral'>//</span>
  800 |     | <span class='neutral'>//      For a price increasing swap we have:</span>
  801 |     | <span class='neutral'>//                                                               growth</span>
  802 |     | <span class='neutral'>//        &#39;amount0Partial := sqrtInverseOffset * sharesTotal * ---------- * </span>
  803 |     | <span class='neutral'>//                                                              2 ** 111</span>
  804 |     | <span class='neutral'>//                            currentToTarget</span>
  805 |     | <span class='neutral'>//                           -----------------&#39;,</span>
  806 |     | <span class='neutral'>//                              outgoingMax</span>
  807 |     | <span class='neutral'>//                                                        growth</span>
  808 |     | <span class='neutral'>//        &#39;amount1Partial := sqrtOffset * sharesTotal * ---------- * </span>
  809 |     | <span class='neutral'>//                                                       2 ** 111</span>
  810 |     | <span class='neutral'>//                            incomingCurrentToTarget</span>
  811 |     | <span class='neutral'>//                           -------------------------&#39;,</span>
  812 |     | <span class='neutral'>//                                  outgoingMax</span>
  813 |     | <span class='neutral'>//</span>
  814 |     | <span class='neutral'>//      where &#39;amount0Partial&#39; denotes the amount of outgoing &#39;tag0&#39; from the</span>
  815 |     | <span class='neutral'>//      pool and &#39;amount1Partial&#39; denotes the amount of incoming &#39;tag1&#39; to the</span>
  816 |     | <span class='neutral'>//      pool, as a result of swapping within the active liquidity interval,</span>
  817 |     | <span class='neutral'>//      where both of the amounts are in &#39;X127&#39; representation.</span>
  818 |     | <span class='neutral'>//</span>
  819 |     | <span class='neutral'>//      Similarly, for a price decreasing swap we have:</span>
  820 |     | <span class='neutral'>//                                                               growth</span>
  821 |     | <span class='neutral'>//        &#39;amount0Partial := sqrtInverseOffset * sharesTotal * ---------- * </span>
  822 |     | <span class='neutral'>//                                                              2 ** 111</span>
  823 |     | <span class='neutral'>//                            incomingCurrentToTarget</span>
  824 |     | <span class='neutral'>//                           -------------------------&#39;,</span>
  825 |     | <span class='neutral'>//                                  outgoingMax</span>
  826 |     | <span class='neutral'>//                                                        growth</span>
  827 |     | <span class='neutral'>//        &#39;amount1Partial := sqrtOffset * sharesTotal * ---------- * </span>
  828 |     | <span class='neutral'>//                                                       2 ** 111</span>
  829 |     | <span class='neutral'>//                            currentToTarget</span>
  830 |     | <span class='neutral'>//                           -----------------&#39;,</span>
  831 |     | <span class='neutral'>//                              outgoingMax</span>
  832 |     | <span class='neutral'>//</span>
  833 |     | <span class='neutral'>//      where &#39;amount0Partial&#39; denotes the amount of incoming &#39;tag0&#39; to the</span>
  834 |     | <span class='neutral'>//      pool and &#39;amount1Partial&#39; denotes the amount of outgoing &#39;tag1&#39; from</span>
  835 |     | <span class='neutral'>//      the pool, as a result of swapping within the active liquidity interval,</span>
  836 |     | <span class='neutral'>//      where both of the amounts are in &#39;X127&#39; representation.</span>
  837 |     | <span class='neutral'>//</span>
  838 |     | <span class='neutral'>//    - &#39;incomingMax&#39;: This value is a kernel parameter in &#39;X216&#39;</span>
  839 |     | <span class='neutral'>//      representation which is defined as follows:</span>
  840 |     | <span class='neutral'>//</span>
  841 |     | <span class='neutral'>//                             - 8 - qSpacing / 2     / qSpacing</span>
  842 |     | <span class='neutral'>//          incomingMax      e                       |    + h / 2</span>
  843 |     | <span class='neutral'>//        &#39;------------- := ---------------------- * |  e         k(h) dh&#39;.</span>
  844 |     | <span class='neutral'>//           2 ** 216                  2             |</span>
  845 |     | <span class='neutral'>//                                                  / 0</span>
  846 |     | <span class='neutral'>//</span>
  847 |     | <span class='neutral'>//      Consider a scenario where the price of the pool is moved all the way</span>
  848 |     | <span class='neutral'>//      from the left interval boundary &#39;qLower&#39;, to the right interval</span>
  849 |     | <span class='neutral'>//      boundary &#39;qUpper&#39;, as part of a swap. In this case, let </span>
  850 |     | <span class='neutral'>//      &#39;amount0Partial&#39; denote the amount of outgoing &#39;tag0&#39; from the pool and</span>
  851 |     | <span class='neutral'>//      let &#39;amount1Partial&#39; denote the amount of incoming &#39;tag1&#39; to the pool,</span>
  852 |     | <span class='neutral'>//      as a result of swapping within the entire interval, &#39;[qLower, qUpper]&#39;</span>
  853 |     | <span class='neutral'>//      where both of the amounts are in &#39;X127&#39; representation. Then, we have:</span>
  854 |     | <span class='neutral'>//</span>
  855 |     | <span class='neutral'>//        &#39;amount0Partial ==</span>
  856 |     | <span class='neutral'>//                                             growth</span>
  857 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * ---------- *</span>
  858 |     | <span class='neutral'>//                                            2 ** 111</span>
  859 |     | <span class='neutral'>//</span>
  860 |     | <span class='neutral'>//                            - 8     / qUpper</span>
  861 |     | <span class='neutral'>//           2 ** 216       e        |                     - h / 2</span>
  862 |     | <span class='neutral'>//         ------------- * ------- * |   k(h - qLower) * e         dh ==</span>
  863 |     | <span class='neutral'>//          outgoingMax       2      |</span>
  864 |     | <span class='neutral'>//                                  / qLower</span>
  865 |     | <span class='neutral'>//</span>
  866 |     | <span class='neutral'>//                                             growth</span>
  867 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * ---------- *</span>
  868 |     | <span class='neutral'>//                                            2 ** 111</span>
  869 |     | <span class='neutral'>//</span>
  870 |     | <span class='neutral'>//                            - 8 - qLower / 2     / qSpacing</span>
  871 |     | <span class='neutral'>//           2 ** 216       e                     |            - h / 2</span>
  872 |     | <span class='neutral'>//         ------------- * -------------------- * |   k(h) * e         dh ==</span>
  873 |     | <span class='neutral'>//          outgoingMax              2            |</span>
  874 |     | <span class='neutral'>//                                               / 0</span>
  875 |     | <span class='neutral'>//</span>
  876 |     | <span class='neutral'>//                                             growth       - qLower / 2</span>
  877 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * ---------- * e              &#39;</span>
  878 |     | <span class='neutral'>//                                            2 ** 111</span>
  879 |     | <span class='neutral'>//</span>
  880 |     | <span class='neutral'>//      and</span>
  881 |     | <span class='neutral'>//</span>
  882 |     | <span class='neutral'>//        &#39;amount1Partial ==</span>
  883 |     | <span class='neutral'>//                                      growth</span>
  884 |     | <span class='neutral'>//         sqrtOffset * sharesTotal * ---------- *</span>
  885 |     | <span class='neutral'>//                                     2 ** 111</span>
  886 |     | <span class='neutral'>//</span>
  887 |     | <span class='neutral'>//                            - 8     / qUpper</span>
  888 |     | <span class='neutral'>//           2 ** 216       e        |                     + h / 2</span>
  889 |     | <span class='neutral'>//         ------------- * ------- * |   k(h - qLower) * e         dh ==</span>
  890 |     | <span class='neutral'>//          outgoingMax       2      |</span>
  891 |     | <span class='neutral'>//                                  / qLower</span>
  892 |     | <span class='neutral'>//</span>
  893 |     | <span class='neutral'>//                                      growth       2 ** 216</span>
  894 |     | <span class='neutral'>//         sqrtOffset * sharesTotal * ---------- * ------------- * </span>
  895 |     | <span class='neutral'>//                                     2 ** 111     outgoingMax</span>
  896 |     | <span class='neutral'>//</span>
  897 |     | <span class='neutral'>//            - 8 + (qUpper - qSpacing) / 2     / qSpacing</span>
  898 |     | <span class='neutral'>//          e                                  |            + h / 2</span>
  899 |     | <span class='neutral'>//         --------------------------------- * |   k(h) * e         dh ==</span>
  900 |     | <span class='neutral'>//                         2                   |</span>
  901 |     | <span class='neutral'>//                                            / 0</span>
  902 |     | <span class='neutral'>//</span>
  903 |     | <span class='neutral'>//                                      growth</span>
  904 |     | <span class='neutral'>//         sqrtOffset * sharesTotal * ---------- * </span>
  905 |     | <span class='neutral'>//                                     2 ** 111</span>
  906 |     | <span class='neutral'>//</span>
  907 |     | <span class='neutral'>//          incomingMax      + qUpper / 2</span>
  908 |     | <span class='neutral'>//         ------------- * e              &#39;.</span>
  909 |     | <span class='neutral'>//          outgoingMax</span>
  910 |     | <span class='neutral'>//</span>
  911 |     | <span class='neutral'>//      Consider another scenario where the price of the pool is moved all the</span>
  912 |     | <span class='neutral'>//      way from the right interval boundary &#39;qUpper&#39;, to the left interval</span>
  913 |     | <span class='neutral'>//      boundary &#39;qLower&#39;, as part of a swap. In this case, let</span>
  914 |     | <span class='neutral'>//      &#39;amount1Partial&#39; denote the amount of outgoing &#39;tag1&#39; from the pool and</span>
  915 |     | <span class='neutral'>//      let &#39;amount0Partial&#39; denote the amount of incoming &#39;tag0&#39; to the</span>
  916 |     | <span class='neutral'>//      pool, as a result of swapping within the the entire interval,</span>
  917 |     | <span class='neutral'>//      &#39;[qLower, qUpper]&#39; where both of the amounts are in &#39;X127&#39;</span>
  918 |     | <span class='neutral'>//      representation. Then, we have:</span>
  919 |     | <span class='neutral'>//</span>
  920 |     | <span class='neutral'>//        &#39;amount1Partial ==</span>
  921 |     | <span class='neutral'>//                                      growth</span>
  922 |     | <span class='neutral'>//         sqrtOffset * sharesTotal * ---------- *</span>
  923 |     | <span class='neutral'>//                                     2 ** 111</span>
  924 |     | <span class='neutral'>//</span>
  925 |     | <span class='neutral'>//                            - 8     / qUpper</span>
  926 |     | <span class='neutral'>//           2 ** 216       e        |                     + h / 2</span>
  927 |     | <span class='neutral'>//         ------------- * ------- * |   k(qUpper - h) * e         dh ==</span>
  928 |     | <span class='neutral'>//          outgoingMax       2      |</span>
  929 |     | <span class='neutral'>//                                  / qLower</span>
  930 |     | <span class='neutral'>//</span>
  931 |     | <span class='neutral'>//                                      growth</span>
  932 |     | <span class='neutral'>//         sqrtOffset * sharesTotal * ---------- *</span>
  933 |     | <span class='neutral'>//                                     2 ** 111</span>
  934 |     | <span class='neutral'>//</span>
  935 |     | <span class='neutral'>//                            - 8 + qUpper / 2     / qSpacing</span>
  936 |     | <span class='neutral'>//           2 ** 216       e                     |            - h / 2</span>
  937 |     | <span class='neutral'>//         ------------- * -------------------- * |   k(h) * e         dh ==</span>
  938 |     | <span class='neutral'>//          outgoingMax              2            |</span>
  939 |     | <span class='neutral'>//                                               / 0</span>
  940 |     | <span class='neutral'>//</span>
  941 |     | <span class='neutral'>//                                      growth       + qUpper / 2</span>
  942 |     | <span class='neutral'>//         sqrtOffset * sharesTotal * ---------- * e              &#39;.</span>
  943 |     | <span class='neutral'>//                                     2 ** 111</span>
  944 |     | <span class='neutral'>//</span>
  945 |     | <span class='neutral'>//      and</span>
  946 |     | <span class='neutral'>//</span>
  947 |     | <span class='neutral'>//        &#39;amount0Partial ==</span>
  948 |     | <span class='neutral'>//                                             growth</span>
  949 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * ---------- *</span>
  950 |     | <span class='neutral'>//                                            2 ** 111</span>
  951 |     | <span class='neutral'>//</span>
  952 |     | <span class='neutral'>//                            - 8     / qUpper</span>
  953 |     | <span class='neutral'>//           2 ** 216       e        |                     - h / 2</span>
  954 |     | <span class='neutral'>//         ------------- * ------- * |   k(qUpper - h) * e         dh ==</span>
  955 |     | <span class='neutral'>//          outgoingMax       2      |</span>
  956 |     | <span class='neutral'>//                                  / qLower</span>
  957 |     | <span class='neutral'>//</span>
  958 |     | <span class='neutral'>//                                             growth       2 ** 216</span>
  959 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * ---------- * ------------- * </span>
  960 |     | <span class='neutral'>//                                            2 ** 111     outgoingMax</span>
  961 |     | <span class='neutral'>//</span>
  962 |     | <span class='neutral'>//            - 8 - (qLower + qSpacing) / 2     / qSpacing</span>
  963 |     | <span class='neutral'>//          e                                  |            + h / 2</span>
  964 |     | <span class='neutral'>//         --------------------------------- * |   k(h) * e         dh ==</span>
  965 |     | <span class='neutral'>//                          2                  |</span>
  966 |     | <span class='neutral'>//                                            / 0</span>
  967 |     | <span class='neutral'>//</span>
  968 |     | <span class='neutral'>//                                             growth</span>
  969 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * ---------- * </span>
  970 |     | <span class='neutral'>//                                            2 ** 111</span>
  971 |     | <span class='neutral'>//</span>
  972 |     | <span class='neutral'>//          incomingMax      - qLower / 2</span>
  973 |     | <span class='neutral'>//         ------------- * e              &#39;.</span>
  974 |     | <span class='neutral'>//          outgoingMax</span>
  975 |     | <span class='neutral'>//</span>
  976 |     | <span class='neutral'>//      Hence, in order to facilitate the calculation of &#39;amount0Partial&#39; and</span>
  977 |     | <span class='neutral'>//      &#39;amount1Partial&#39; in such scenarios, we calculate &#39;incomingMax&#39; at the</span>
  978 |     | <span class='neutral'>//      time of initialization or anytime that the kernel function is modified</span>
  979 |     | <span class='neutral'>//      and then we store the resulting value among the static parameters.</span>
  980 |     | <span class='neutral'>//</span>
  981 |     | <span class='neutral'>//      Lastly, we are going to prove the inequality</span>
  982 |     | <span class='neutral'>//</span>
  983 |     | <span class='neutral'>//        &#39;incomingMax &gt;= outgoingMax&#39;</span>
  984 |     | <span class='neutral'>//</span>
  985 |     | <span class='neutral'>//      which will be used later in this script. According to the definitions</span>
  986 |     | <span class='neutral'>//      for &#39;outgoingMax&#39; and &#39;incomingMax&#39;, we have:</span>
  987 |     | <span class='neutral'>//</span>
  988 |     | <span class='neutral'>//                             - 8 - qSpacing / 2     / qSpacing</span>
  989 |     | <span class='neutral'>//          incomingMax      e                       |    + h / 2</span>
  990 |     | <span class='neutral'>//        &#39;------------- := ---------------------- * |  e         k(h) dh</span>
  991 |     | <span class='neutral'>//           2 ** 216                  2             |</span>
  992 |     | <span class='neutral'>//                                                  / 0</span>
  993 |     | <span class='neutral'>//</span>
  994 |     | <span class='neutral'>//                             - 8     / qSpacing</span>
  995 |     | <span class='neutral'>//                           e        |             - (qSpacing - h) / 2</span>
  996 |     | <span class='neutral'>//                       == ------- * |    k(h) * e                      dh</span>
  997 |     | <span class='neutral'>//                             2      |</span>
  998 |     | <span class='neutral'>//                                   / 0</span>
  999 |     | <span class='neutral'>//</span>
 1000 |     | <span class='neutral'>//                             - 8     / qSpacing</span>
 1001 |     | <span class='neutral'>//                           e        |           - h / 2        outgoingMax</span>
 1002 |     | <span class='neutral'>//                       &gt;= ------- * |  k(h) * e         dh == -------------&#39;.</span>
 1003 |     | <span class='neutral'>//                             2      |                           2 ** 216</span>
 1004 |     | <span class='neutral'>//                                   / 0</span>
 1005 |     | <span class='neutral'>//</span>
 1006 |     | <span class='neutral'>//      which is concluded from Hardy–Littlewood inequality and the fact that</span>
 1007 |     | <span class='neutral'>//      &#39;exp(- (qSpacing - h) / 2)&#39; is an increasing rearrangement of</span>
 1008 |     | <span class='neutral'>//      &#39;exp(- h / 2)&#39;.</span>
 1009 |     | <span class='neutral'>//  </span>
 1010 |     | <span class='neutral'>//  - In the previous steps we read the dynamic parameters, the curve sequence,</span>
 1011 |     | <span class='neutral'>//    the kernel function, and the static parameters. The next step is to move</span>
 1012 |     | <span class='neutral'>//    the price towards &#39;qNext&#39; until any of the following conditions are met:</span>
 1013 |     | <span class='neutral'>//</span>
 1014 |     | <span class='neutral'>//    (a) &#39;amountSpecified&#39; is fulfilled, after which the swap is halted.</span>
 1015 |     | <span class='neutral'>//</span>
 1016 |     | <span class='neutral'>//    (b) &#39;qLimit&#39; is reached, after which the swap is halted.</span>
 1017 |     | <span class='neutral'>//</span>
 1018 |     | <span class='neutral'>//    (c) &#39;qNext&#39; is reached, after which we transition to a new interval.</span>
 1019 |     | <span class='neutral'>//</span>
 1020 |     | <span class='neutral'>//    Before doing so, we need to verify the condition,</span>
 1021 |     | <span class='neutral'>//</span>
 1022 |     | <span class='neutral'>//      &#39;sharesTotal &gt;= crossThreshold&#39;.</span>
 1023 |     | <span class='neutral'>//</span>
 1024 |     | <span class='neutral'>//    If true, we move the price within the current interval, if not we halt</span>
 1025 |     | <span class='neutral'>//    the swap.</span>
 1026 |     | <span class='neutral'>//</span>
 1027 |     | <span class='neutral'>//    As we move the price from &#39;qCurrent&#39; towards &#39;qNext&#39;, the integrals</span>
 1028 |     | <span class='neutral'>//    &#39;currentToTarget&#39; and &#39;incomingCurrentToTarget&#39; are continuously</span>
 1029 |     | <span class='neutral'>//    incremented as they are cumulatively calculated piece by piece. This</span>
 1030 |     | <span class='neutral'>//    process involves exploring the liquidity distribution function &#39;k(w(h))&#39;</span>
 1031 |     | <span class='neutral'>//    within the active liquidity interval. Since &#39;k(w(.))&#39; is a piecewise</span>
 1032 |     | <span class='neutral'>//    linear function, we proceed piece by piece and we increment both</span>
 1033 |     | <span class='neutral'>//    &#39;currentToTarget&#39; and &#39;incomingCurrentToTarget&#39; as we move forward. The</span>
 1034 |     | <span class='neutral'>//    process of exploring &#39;k(w(.))&#39; is explained later in this script and in</span>
 1035 |     | <span class='neutral'>//    &#39;Interval.sol&#39;.</span>
 1036 |     | <span class='neutral'>//</span>
 1037 |     | <span class='neutral'>//    In the present example, since &#39;zeroForOne == True&#39; and</span>
 1038 |     | <span class='neutral'>//    &#39;amountSpecified == +oo &gt; 0&#39;, we have:</span>
 1039 |     | <span class='neutral'>//</span>
 1040 |     | <span class='neutral'>//      &#39;zeroForOne == exactInput&#39;</span>
 1041 |     | <span class='neutral'>//</span>
 1042 |     | <span class='neutral'>//    which indicates that &#39;amountSpecified&#39; is with respect to &#39;tag0&#39;.</span>
 1043 |     | <span class='neutral'>//</span>
 1044 |     | <span class='neutral'>//    Remember that for price decreasing swaps (as is the case in this</span>
 1045 |     | <span class='neutral'>//    example), as long as we remain within the current active liquidity</span>
 1046 |     | <span class='neutral'>//    interval, the amount of incoming &#39;tag0&#39; is calculated as:</span>
 1047 |     | <span class='neutral'>//</span>
 1048 |     | <span class='neutral'>//                                                             growth</span>
 1049 |     | <span class='neutral'>//      &#39;amount0Partial == sqrtInverseOffset * sharesTotal * ---------- * </span>
 1050 |     | <span class='neutral'>//                                                            2 ** 111</span>
 1051 |     | <span class='neutral'>//                          incomingCurrentToTarget</span>
 1052 |     | <span class='neutral'>//                         -------------------------&#39;,</span>
 1053 |     | <span class='neutral'>//                                outgoingMax</span>
 1054 |     | <span class='neutral'>//</span>
 1055 |     | <span class='neutral'>//    which means that in order for us to meet the stopping criteria (a), we</span>
 1056 |     | <span class='neutral'>//    should have:</span>
 1057 |     | <span class='neutral'>//                                                                growth</span>
 1058 |     | <span class='neutral'>//      &#39;|amountSpecified| == sqrtInverseOffset * sharesTotal * ---------- * </span>
 1059 |     | <span class='neutral'>//                                                               2 ** 111</span>
 1060 |     | <span class='neutral'>//                             incomingCurrentToTarget</span>
 1061 |     | <span class='neutral'>//                            -------------------------&#39;,</span>
 1062 |     | <span class='neutral'>//                                   outgoingMax</span>
 1063 |     | <span class='neutral'>//    or equivalently,</span>
 1064 |     | <span class='neutral'>//</span>
 1065 |     | <span class='neutral'>//      &#39;incomingCurrentToTarget == </span>
 1066 |     | <span class='neutral'>//</span>
 1067 |     | <span class='neutral'>//                      |amountSpecified|          1          2 ** 111</span>
 1068 |     | <span class='neutral'>//       outgoingMax * ------------------- * ------------- * ----------&#39;.</span>
 1069 |     | <span class='neutral'>//                      sqrtInverseOffset     sharesTotal      growth</span>
 1070 |     | <span class='neutral'>//</span>
 1071 |     | <span class='neutral'>//    As we increment &#39;currentToTarget&#39; and &#39;incomingCurrentToTarget&#39; by</span>
 1072 |     | <span class='neutral'>//    moving towards &#39;qNext&#39;, at every step (i.e., with each piece of the</span>
 1073 |     | <span class='neutral'>//    liquidity distribution function &#39;k(w(.))&#39;) we need to determine whether</span>
 1074 |     | <span class='neutral'>//    &#39;amountSpecified&#39; is fulfilled or not. To that end, before starting the</span>
 1075 |     | <span class='neutral'>//    exploration, the protocol calculates the right hand side of the above</span>
 1076 |     | <span class='neutral'>//    equation, i.e.,</span>
 1077 |     | <span class='neutral'>//</span>
 1078 |     | <span class='neutral'>//                      |amountSpecified|          1          2 ** 111</span>
 1079 |     | <span class='neutral'>//       outgoingMax * ------------------- * ------------- * ----------&#39;.</span>
 1080 |     | <span class='neutral'>//                      sqrtInverseOffset     sharesTotal      growth</span>
 1081 |     | <span class='neutral'>//</span>
 1082 |     | <span class='neutral'>//    which is regarded as &#39;integralLimit&#39;, and stores its &#39;X216&#39;</span>
 1083 |     | <span class='neutral'>//    representation in the memory space which is pointed to by</span>
 1084 |     | <span class='neutral'>//    &#39;_integralLimit_&#39;.</span>
 1085 |     | <span class='neutral'>//</span>
 1086 |     | <span class='neutral'>//    Consider a hypothetical swap for which &#39;exactInput == false&#39;. Then, every</span>
 1087 |     | <span class='neutral'>//    time that we increment &#39;currentToTarget&#39;, we check whether it has</span>
 1088 |     | <span class='neutral'>//    exceeded &#39;integralLimit&#39;. Once it has, we use the method</span>
 1089 |     | <span class='neutral'>//    &#39;searchOutgoingTarget&#39; in &#39;Interval.sol&#39; to find the precise value</span>
 1090 |     | <span class='neutral'>//</span>
 1091 |     | <span class='neutral'>//      &#39;qTarget := log(pTarget / pOffset)&#39;</span>
 1092 |     | <span class='neutral'>//</span>
 1093 |     | <span class='neutral'>//    in order to have</span>
 1094 |     | <span class='neutral'>//</span>
 1095 |     | <span class='neutral'>//      &#39;currentToTarget == integralLimit&#39;</span>
 1096 |     | <span class='neutral'>//</span>
 1097 |     | <span class='neutral'>//    which guarantees that &#39;amountSpecified&#39; is fulfilled.</span>
 1098 |     | <span class='neutral'>//</span>
 1099 |     | <span class='neutral'>//    If &#39;exactInput == true&#39;, as is the case in our current example, every</span>
 1100 |     | <span class='neutral'>//    time that we increment &#39;incomingCurrentToTarget&#39;, we check whether it has</span>
 1101 |     | <span class='neutral'>//    exceeded &#39;integralLimit&#39;. Once it has, we use the method</span>
 1102 |     | <span class='neutral'>//    &#39;searchIncomingTarget&#39; in &#39;Interval.sol&#39; to find the precise value</span>
 1103 |     | <span class='neutral'>//</span>
 1104 |     | <span class='neutral'>//      &#39;qTarget := log(pTarget / pOffset)&#39;</span>
 1105 |     | <span class='neutral'>//</span>
 1106 |     | <span class='neutral'>//    in order to have</span>
 1107 |     | <span class='neutral'>//</span>
 1108 |     | <span class='neutral'>//      &#39;incomingCurrentToTarget == integralLimit&#39;</span>
 1109 |     | <span class='neutral'>//</span>
 1110 |     | <span class='neutral'>//    which guarantees that &#39;amountSpecified&#39; is fulfilled.</span>
 1111 |     | <span class='neutral'>//</span>
 1112 |     | <span class='neutral'>//    After either of the above searches, the price of the pool is moved to</span>
 1113 |     | <span class='neutral'>//    &#39;qTarget&#39; and the corresponding outgoing and incoming amounts are</span>
 1114 |     | <span class='neutral'>//    calculated.</span>
 1115 |     | <span class='neutral'>//</span>
 1116 |     | <span class='neutral'>//    Throughout the execution of the swap, whenever we enter a new liquidity</span>
 1117 |     | <span class='neutral'>//    interval, both &#39;amountSpecified&#39; and &#39;integralLimit&#39; are updated. This is</span>
 1118 |     | <span class='neutral'>//    further explained in the next step.</span>
 1119 |     | <span class='neutral'>//</span>
 1120 |     | <span class='neutral'>//    However, remember that in the present example, we have</span>
 1121 |     | <span class='neutral'>//    &#39;amountSpecified == +oo&#39; which means that:</span>
 1122 |     | <span class='neutral'>//</span>
 1123 |     | <span class='neutral'>//      &#39;integralLimit := outgoingMax * </span>
 1124 |     | <span class='neutral'>//</span>
 1125 |     | <span class='neutral'>//        |amountSpecified|          1          2 ** 111</span>
 1126 |     | <span class='neutral'>//       ------------------- * ------------- * ---------- == +oo&#39;.</span>
 1127 |     | <span class='neutral'>//        sqrtInverseOffset     sharesTotal      growth</span>
 1128 |     | <span class='neutral'>//</span>
 1129 |     | <span class='neutral'>//    Hence, &#39;incomingCurrentToTarget&#39; may never exceed &#39;integralLimit&#39; and the</span>
 1130 |     | <span class='neutral'>//    stopping criteria (a) is not reachable. Put simply, since</span>
 1131 |     | <span class='neutral'>//    &#39;amountSpecified&#39; is equal to infinity, we may never reach it and we only</span>
 1132 |     | <span class='neutral'>//    need to worry about &#39;qLimit&#39; and &#39;qNext&#39;.</span>
 1133 |     | <span class='neutral'>//</span>
 1134 |     | <span class='neutral'>//    In order to keep track of (b) and (c) concurrently, the protocol</span>
 1135 |     | <span class='neutral'>//    calculates</span>
 1136 |     | <span class='neutral'>//</span>
 1137 |     | <span class='neutral'>//      &#39;qLimitWithinInterval := min(max(qLower, qLimit), qUpper)&#39;</span>
 1138 |     | <span class='neutral'>//</span>
 1139 |     | <span class='neutral'>//    and stores it in the memory space which is referred to by</span>
 1140 |     | <span class='neutral'>//    &#39;_logPriceLimitOffsettedWithinInterval_&#39;. As we move forward with pieces</span>
 1141 |     | <span class='neutral'>//    of the liquidity distribution function, we continuously check whether</span>
 1142 |     | <span class='neutral'>//    &#39;qLimitWithinInterval&#39; is reached. If so, we either need to halt the swap</span>
 1143 |     | <span class='neutral'>//    (stopping criteria (b)) or transition to a new interval (stopping</span>
 1144 |     | <span class='neutral'>//    criteria (c)).</span>
 1145 |     | <span class='neutral'>//</span>
 1146 |     | <span class='neutral'>//    In our example, it can be easily observed that</span>
 1147 |     | <span class='neutral'>//</span>
 1148 |     | <span class='neutral'>//      &#39;qLimitWithinInterval == qNext&#39;</span>
 1149 |     | <span class='neutral'>//</span>
 1150 |     | <span class='neutral'>//    as illustrated below:</span>
 1151 |     | <span class='neutral'>//</span>
 1152 |     | <span class='neutral'>//                                             qLimitWithinInterval</span>
 1153 |     | <span class='neutral'>//                                                      |</span>
 1154 |     | <span class='neutral'>//                  qLimit                              |  qCurrent</span>
 1155 |     | <span class='neutral'>//                     |                                |     |</span>
 1156 |     | <span class='neutral'>//     ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
 1157 |     | <span class='neutral'>//                                                      |             |</span>
 1158 |     | <span class='neutral'>//                                                    qNext         qBack</span>
 1159 |     | <span class='neutral'>//</span>
 1160 |     | <span class='neutral'>//    Hence, in the present active liquidity interval, we do not need to worry</span>
 1161 |     | <span class='neutral'>//    about &#39;qLimit&#39; either and we can move forward until we reach &#39;qNext&#39;.</span>
 1162 |     | <span class='neutral'>//    After that, we need to update a number of parameters, including:</span>
 1163 |     | <span class='neutral'>//</span>
 1164 |     | <span class='neutral'>//    - &#39;amount0&#39;: This is the total amount of &#39;tag0&#39; which is traded as a</span>
 1165 |     | <span class='neutral'>//      result of this swap. In this example, since our swap is price</span>
 1166 |     | <span class='neutral'>//      decreasing, we should have &#39;amount0 &gt; 0&#39; which indicates that &#39;amount0&#39;</span>
 1167 |     | <span class='neutral'>//      is incoming to the pool. Hence, according to the above formulas, with</span>
 1168 |     | <span class='neutral'>//      each interval that we transact in, &#39;amount0&#39; should be incremented by:</span>
 1169 |     | <span class='neutral'>//</span>
 1170 |     | <span class='neutral'>//                                                               growth</span>
 1171 |     | <span class='neutral'>//        &#39;amount0Partial := sqrtInverseOffset * sharesTotal * ---------- *</span>
 1172 |     | <span class='neutral'>//                                                              2 ** 111</span>
 1173 |     | <span class='neutral'>//                            incomingCurrentToTarget</span>
 1174 |     | <span class='neutral'>//                           -------------------------&#39;</span>
 1175 |     | <span class='neutral'>//                                  outgoingMax</span>
 1176 |     | <span class='neutral'>//</span>
 1177 |     | <span class='neutral'>//    - &#39;amount1&#39;: This is the total amount of &#39;tag1&#39; which is traded as a</span>
 1178 |     | <span class='neutral'>//      result of this swap. In this example, since our swap is price</span>
 1179 |     | <span class='neutral'>//      decreasing, we should have &#39;amount1 &lt; 0&#39; which indicates that &#39;amount1&#39;</span>
 1180 |     | <span class='neutral'>//      is outgoing from the pool. Hence, according to the above formulas, with</span>
 1181 |     | <span class='neutral'>//      each interval that we transact in, &#39;amount1&#39; should be decremented by:</span>
 1182 |     | <span class='neutral'>//</span>
 1183 |     | <span class='neutral'>//                                                        growth</span>
 1184 |     | <span class='neutral'>//        &#39;amount1Partial := sqrtOffset * sharesTotal * ---------- *</span>
 1185 |     | <span class='neutral'>//                                                       2 ** 111</span>
 1186 |     | <span class='neutral'>//                            currentToTarget</span>
 1187 |     | <span class='neutral'>//                           -----------------&#39;</span>
 1188 |     | <span class='neutral'>//                              outgoingMax</span>
 1189 |     | <span class='neutral'>//</span>
 1190 |     | <span class='neutral'>//    - &#39;amountSpecified&#39;: Since the swap is partially fulfilled, we should</span>
 1191 |     | <span class='neutral'>//      decrement &#39;amountSpecified&#39; by &#39;amount0Partial&#39; to reflect this:</span>
 1192 |     | <span class='neutral'>//</span>
 1193 |     | <span class='neutral'>//        &#39;amountSpecified -= amount0Partial&#39;.</span>
 1194 |     | <span class='neutral'>//</span>
 1195 |     | <span class='neutral'>//    - &#39;curve&#39;: As explained before, when we transact in a liquidity interval,</span>
 1196 |     | <span class='neutral'>//      as part of a swap, we then need to amend the curve sequence for that</span>
 1197 |     | <span class='neutral'>//      interval in preparation for the next swap. In this example, the</span>
 1198 |     | <span class='neutral'>//      amendment is straightforward. Since we are about to transition out of</span>
 1199 |     | <span class='neutral'>//      the interval &#39;[qLower, qUpper]&#39;, it should turn into an inactive</span>
 1200 |     | <span class='neutral'>//      interval. Hence, the corresponding curve sequence for this interval</span>
 1201 |     | <span class='neutral'>//      should transform into a sequence of length two as is the case for every</span>
 1202 |     | <span class='neutral'>//      inactive liquidity interval. Following the pattern that was introduced</span>
 1203 |     | <span class='neutral'>//      earlier for inactive liquidity intervals, the amended curve sequence</span>
 1204 |     | <span class='neutral'>//      for &#39;[qLower, qUpper]&#39; should be:</span>
 1205 |     | <span class='neutral'>//</span>
 1206 |     | <span class='neutral'>//        &#39;q[0] := qUpper&#39;,</span>
 1207 |     | <span class='neutral'>//        &#39;q[1] := qLower&#39;.</span>
 1208 |     | <span class='neutral'>//</span>
 1209 |     | <span class='neutral'>//      This amendment, transforms the function &#39;w&#39; associated with</span>
 1210 |     | <span class='neutral'>//      &#39;[qLower, qUpper]&#39; from the following:</span>
 1211 |     | <span class='neutral'>//</span>
 1212 |     | <span class='neutral'>//            w(q)</span>
 1213 |     | <span class='neutral'>//              ^</span>
 1214 |     | <span class='neutral'>//      spacing |                /</span>
 1215 |     | <span class='neutral'>//              |               /</span>
 1216 |     | <span class='neutral'>//              |              /</span>
 1217 |     | <span class='neutral'>//              |             /</span>
 1218 |     | <span class='neutral'>//              |            /</span>
 1219 |     | <span class='neutral'>//              |           /</span>
 1220 |     | <span class='neutral'>//              |          /</span>
 1221 |     | <span class='neutral'>//              |\</span>
 1222 |     | <span class='neutral'>//              | \</span>
 1223 |     | <span class='neutral'>//              |  \</span>
 1224 |     | <span class='neutral'>//              |   \</span>
 1225 |     | <span class='neutral'>//              |        /</span>
 1226 |     | <span class='neutral'>//              |       /</span>
 1227 |     | <span class='neutral'>//              |      /</span>
 1228 |     | <span class='neutral'>//              |     /</span>
 1229 |     | <span class='neutral'>//            0 +----+----+-------+-&gt; q</span>
 1230 |     | <span class='neutral'>//           qLower  |    |       |</span>
 1231 |     | <span class='neutral'>//                   |   q[2]  qUpper</span>
 1232 |     | <span class='neutral'>//                   |</span>
 1233 |     | <span class='neutral'>//               qCurrent</span>
 1234 |     | <span class='neutral'>//</span>
 1235 |     | <span class='neutral'>//      to a new function:</span>
 1236 |     | <span class='neutral'>//</span>
 1237 |     | <span class='neutral'>//        &#39;wAmended(q) := q - qLower&#39;</span>
 1238 |     | <span class='neutral'>//</span>
 1239 |     | <span class='neutral'>//      which can be plotted as follows:</span>
 1240 |     | <span class='neutral'>//</span>
 1241 |     | <span class='neutral'>//          wAmended(q)</span>
 1242 |     | <span class='neutral'>//              ^</span>
 1243 |     | <span class='neutral'>//      spacing |                /</span>
 1244 |     | <span class='neutral'>//              |               /</span>
 1245 |     | <span class='neutral'>//              |              /</span>
 1246 |     | <span class='neutral'>//              |             /</span>
 1247 |     | <span class='neutral'>//              |            /</span>
 1248 |     | <span class='neutral'>//              |           /</span>
 1249 |     | <span class='neutral'>//              |          /</span>
 1250 |     | <span class='neutral'>//              |         /</span>
 1251 |     | <span class='neutral'>//              |        /</span>
 1252 |     | <span class='neutral'>//              |       /</span>
 1253 |     | <span class='neutral'>//              |      /</span>
 1254 |     | <span class='neutral'>//              |     /</span>
 1255 |     | <span class='neutral'>//              |    /</span>
 1256 |     | <span class='neutral'>//              |   /</span>
 1257 |     | <span class='neutral'>//              |  /</span>
 1258 |     | <span class='neutral'>//              | /</span>
 1259 |     | <span class='neutral'>//              |/</span>
 1260 |     | <span class='neutral'>//            0 +-----------------+-&gt; q</span>
 1261 |     | <span class='neutral'>//           qLower               |</span>
 1262 |     | <span class='neutral'>//                             qUpper</span>
 1263 |     | <span class='neutral'>//</span>
 1264 |     | <span class='neutral'>//      As we will demonstrate next, this procedure results in positive growth</span>
 1265 |     | <span class='neutral'>//      for liquidity providers.</span>
 1266 |     | <span class='neutral'>//</span>
 1267 |     | <span class='neutral'>//    - &#39;growth&#39;: As discussed earlier, before transitioning out of the</span>
 1268 |     | <span class='neutral'>//      interval &#39;[qLower, qUpper]&#39;, the curve sequence for this interval is</span>
 1269 |     | <span class='neutral'>//      amended. This action, changes the function &#39;w&#39; to &#39;wAmended&#39; which in</span>
 1270 |     | <span class='neutral'>//      turn changes the liquidity distribution function from &#39;k(w(.))&#39; to</span>
 1271 |     | <span class='neutral'>//      &#39;k(wAmended(.))&#39;. However, the amount of reserve for &#39;tag0&#39; within</span>
 1272 |     | <span class='neutral'>//      &#39;[qLower, qUpper]&#39; should stay the same before and after the amendment</span>
 1273 |     | <span class='neutral'>//      of the curve sequence. This is because modifying the curve sequence is</span>
 1274 |     | <span class='neutral'>//      a change in our trading policy and it does not introduce or remove any</span>
 1275 |     | <span class='neutral'>//      amount of liquidity. Hence, in order to conserve the amount of &#39;tag0&#39;</span>
 1276 |     | <span class='neutral'>//      within &#39;[qLower, qUpper]&#39; despite the transformation of &#39;w&#39; to</span>
 1277 |     | <span class='neutral'>//      &#39;wAmended&#39;, we need to make an adjustment to the &#39;growth&#39; value and</span>
 1278 |     | <span class='neutral'>//      turn it into &#39;growthAmended&#39;. In order to determine &#39;growthAmended&#39;,</span>
 1279 |     | <span class='neutral'>//      the following equation is solved:</span>
 1280 |     | <span class='neutral'>//</span>
 1281 |     | <span class='neutral'>//        &#39;totalReserveOfTag0Before == totalReserveOfTag0After&#39;</span>
 1282 |     | <span class='neutral'>//</span>
 1283 |     | <span class='neutral'>//      where &#39;totalReserveOfTag0Before&#39; is the total amount of &#39;tag0&#39; within</span>
 1284 |     | <span class='neutral'>//      &#39;[qLower, qUpper]&#39; which is calculated based on &#39;k(w(.))&#39;, whereas</span>
 1285 |     | <span class='neutral'>//      &#39;totalReserveOfTag0After&#39; is the same value calculated based on</span>
 1286 |     | <span class='neutral'>//      &#39;k(wAmended(.))&#39;. The two sides of the equation can be derived as:</span>
 1287 |     | <span class='neutral'>//</span>
 1288 |     | <span class='neutral'>//        &#39;totalReserveOfTag0Before = sqrtInverseOffset * sharesTotal * </span>
 1289 |     | <span class='neutral'>//</span>
 1290 |     | <span class='neutral'>//                                         - 8     / qUpper</span>
 1291 |     | <span class='neutral'>//           growth       2 ** 216       e        |    - h / 2</span>
 1292 |     | <span class='neutral'>//         ---------- * ------------- * ------- * |  e         k(w(h)) dh&#39;,</span>
 1293 |     | <span class='neutral'>//          2 ** 111     outgoingMax       2      |</span>
 1294 |     | <span class='neutral'>//                                               / qLower</span>
 1295 |     | <span class='neutral'>//</span>
 1296 |     | <span class='neutral'>//        &#39;totalReserveOfTag0After = sqrtInverseOffset * sharesTotal * </span>
 1297 |     | <span class='neutral'>//</span>
 1298 |     | <span class='neutral'>//          growthAmended       2 ** 216</span>
 1299 |     | <span class='neutral'>//         --------------- * ------------- *</span>
 1300 |     | <span class='neutral'>//             2 ** 111       outgoingMax</span>
 1301 |     | <span class='neutral'>//</span>
 1302 |     | <span class='neutral'>//            - 8     / qUpper</span>
 1303 |     | <span class='neutral'>//          e        |    - h / 2</span>
 1304 |     | <span class='neutral'>//         ------- * |  e         k(wAmended(h)) dh&#39;,</span>
 1305 |     | <span class='neutral'>//            2      |</span>
 1306 |     | <span class='neutral'>//                  / qLower</span>
 1307 |     | <span class='neutral'>//</span>
 1308 |     | <span class='neutral'>//      Hence, &#39;growthAmended&#39; can be derived as:</span>
 1309 |     | <span class='neutral'>//</span>
 1310 |     | <span class='neutral'>//                                           / qUpper</span>
 1311 |     | <span class='neutral'>//                                          |    - h / 2</span>
 1312 |     | <span class='neutral'>//                                          |  e         k(w(h)) dh</span>
 1313 |     | <span class='neutral'>//                                          |</span>
 1314 |     | <span class='neutral'>//                                         / qLower</span>
 1315 |     | <span class='neutral'>//        &#39;growthAmended == growth * ---------------------------------&#39;.</span>
 1316 |     | <span class='neutral'>//                                       / qUpper</span>
 1317 |     | <span class='neutral'>//                                      |    - h / 2</span>
 1318 |     | <span class='neutral'>//                                      |  e         k(wAmended(h)) dh</span>
 1319 |     | <span class='neutral'>//                                      |</span>
 1320 |     | <span class='neutral'>//                                     / qLower</span>
 1321 |     | <span class='neutral'>//</span>
 1322 |     | <span class='neutral'>//      Observe that &#39;wAmended&#39; is a monotonically non-decreasing rearrangement</span>
 1323 |     | <span class='neutral'>//      of &#39;w&#39;. This is because pieces of &#39;wAmended&#39; can be flipped and</span>
 1324 |     | <span class='neutral'>//      rearranged in order to transform its diagram to the diagram of &#39;w&#39;. On</span>
 1325 |     | <span class='neutral'>//      the other hand, since &#39;k&#39; is a monotonically non-decreasing function,</span>
 1326 |     | <span class='neutral'>//      we can conclude that &#39;k(wAmended(.))&#39; is a monotonically non-decreasing</span>
 1327 |     | <span class='neutral'>//      rearrangement of &#39;k(w(.))&#39;. Hence, according to the Hardy–Littlewood</span>
 1328 |     | <span class='neutral'>//      inequality, we have:</span>
 1329 |     | <span class='neutral'>//</span>
 1330 |     | <span class='neutral'>//            / qUpper                             / qUpper</span>
 1331 |     | <span class='neutral'>//           |    - h / 2                         |    - h / 2</span>
 1332 |     | <span class='neutral'>//        &#39;  |  e         k(wAmended(h)) dh  &lt;=   |  e         k(w(h)) dh &#39;</span>
 1333 |     | <span class='neutral'>//           |                                    |</span>
 1334 |     | <span class='neutral'>//          / qLower                             / qLower</span>
 1335 |     | <span class='neutral'>//      </span>
 1336 |     | <span class='neutral'>//      which concludes that:</span>
 1337 |     | <span class='neutral'>//</span>
 1338 |     | <span class='neutral'>//        &#39;growthAmended &gt;= growth&#39;.</span>
 1339 |     | <span class='neutral'>//</span>
 1340 |     | <span class='neutral'>//      This is exactly what we want!</span>
 1341 |     | <span class='neutral'>//</span>
 1342 |     | <span class='neutral'>//      To summarize, when we transact in a liquidity interval as part of a</span>
 1343 |     | <span class='neutral'>//      swap, we then need to amend the curve sequence for that interval. After</span>
 1344 |     | <span class='neutral'>//      that, in order to make up for the transformation of &#39;w&#39; to &#39;wAmended&#39;,</span>
 1345 |     | <span class='neutral'>//      the &#39;growth&#39; value should be incremented according to the above formula</span>
 1346 |     | <span class='neutral'>//      for &#39;growthAmended&#39;.</span>
 1347 |     | <span class='neutral'>//</span>
 1348 |     | <span class='neutral'>//    - &#39;qCurrent&#39;: Lastly, as we move the price of the pool to &#39;qNext&#39;, the</span>
 1349 |     | <span class='neutral'>//      value for &#39;qCurrent&#39; should be updated to reflect this change. which is</span>
 1350 |     | <span class='neutral'>//      illustrated as follows:</span>
 1351 |     | <span class='neutral'>//</span>
 1352 |     | <span class='neutral'>//                qLimit                              qCurrent</span>
 1353 |     | <span class='neutral'>//                   |                                   |</span>
 1354 |     | <span class='neutral'>//      ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
 1355 |     | <span class='neutral'>//                                                       |             |</span>
 1356 |     | <span class='neutral'>//                                                     qNext         qBack</span>
 1357 |     | <span class='neutral'>//    </span>
 1358 |     | <span class='neutral'>//    Now, we are ready to transition out of the interval &#39;[qLower, qUpper]&#39;</span>
 1359 |     | <span class='neutral'>//    which is explained next.</span>
 1360 |     | <span class='neutral'>//</span>
 1361 |     | <span class='neutral'>//  - In the previous step we moved the price of the pool to &#39;qNext&#39; to</span>
 1362 |     | <span class='neutral'>//    partially fulfill the requested swap. In this step, we transition from</span>
 1363 |     | <span class='neutral'>//    the original liquidity interval &#39;[qLower, qUpper]&#39; to its adjacent</span>
 1364 |     | <span class='neutral'>//    interval &#39;[qLower - qSpacing, qUpper - qSpacing]&#39;. This transition</span>
 1365 |     | <span class='neutral'>//    involves updating the following parameters:</span>
 1366 |     | <span class='neutral'>//</span>
 1367 |     | <span class='neutral'>//    - &#39;sharesTotal&#39;: The current value of &#39;sharesTotal&#39; reflects the total</span>
 1368 |     | <span class='neutral'>//      number of shares within &#39;[qLower, qUpper]&#39;. As we are transitioning to</span>
 1369 |     | <span class='neutral'>//      &#39;[qLower - qSpacing, qUpper - qSpacing]&#39;, this value should be modified</span>
 1370 |     | <span class='neutral'>//      in order to reflect the total number of shares in the new active</span>
 1371 |     | <span class='neutral'>//      interval.</span>
 1372 |     | <span class='neutral'>//</span>
 1373 |     | <span class='neutral'>//      We keep track of the total share values in all of the liquidity</span>
 1374 |     | <span class='neutral'>//      intervals via the mapping &#39;sharesDelta&#39; within protocol&#39;s storage. Let</span>
 1375 |     | <span class='neutral'>//      &#39;qBoundary&#39; denote an arbitrary boundary for a liquidity interval,</span>
 1376 |     | <span class='neutral'>//      i.e.,</span>
 1377 |     | <span class='neutral'>//</span>
 1378 |     | <span class='neutral'>//        &#39;qBoundary == qLower + j * qSpacing&#39;</span>
 1379 |     | <span class='neutral'>//</span>
 1380 |     | <span class='neutral'>//      for some integer &#39;j&#39;. Let &#39;sharesTotalLeft&#39; and &#39;sharesTotalRight&#39;</span>
 1381 |     | <span class='neutral'>//      denote the total number of shares within the intervals</span>
 1382 |     | <span class='neutral'>//</span>
 1383 |     | <span class='neutral'>//        &#39;[qBoundary - qSpacing, qBoundary]&#39; and</span>
 1384 |     | <span class='neutral'>//        &#39;[qBoundary, qBoundary + qSpacing]&#39;,</span>
 1385 |     | <span class='neutral'>//</span>
 1386 |     | <span class='neutral'>//      respectively. Define:</span>
 1387 |     | <span class='neutral'>//</span>
 1388 |     | <span class='neutral'>//        &#39;sharesDelta[qBoundary] := sharesTotalRight - sharesTotalLeft&#39;.</span>
 1389 |     | <span class='neutral'>//</span>
 1390 |     | <span class='neutral'>//      In other words, &#39;sharesDelta[qBoundary]&#39; is defined as the difference</span>
 1391 |     | <span class='neutral'>//      between the total number of shares within the two liquidity intervals</span>
 1392 |     | <span class='neutral'>//      that contain &#39;qBoundary&#39;.</span>
 1393 |     | <span class='neutral'>//</span>
 1394 |     | <span class='neutral'>//      Hence, for price increasing swaps, as we transition to a new interval,</span>
 1395 |     | <span class='neutral'>//      &#39;sharesTotal&#39; should be modified as follows:</span>
 1396 |     | <span class='neutral'>//</span>
 1397 |     | <span class='neutral'>//        &#39;sharesTotal += sharesDelta[qNext]&#39;,</span>
 1398 |     | <span class='neutral'>//</span>
 1399 |     | <span class='neutral'>//      and for price decreasing swaps, as we transition to a new interval,</span>
 1400 |     | <span class='neutral'>//      &#39;sharesTotal&#39; should be modified as follows:</span>
 1401 |     | <span class='neutral'>//</span>
 1402 |     | <span class='neutral'>//        &#39;sharesTotal -= sharesDelta[qNext]&#39;.</span>
 1403 |     | <span class='neutral'>//</span>
 1404 |     | <span class='neutral'>//      This way of accounting for the total shares makes liquidity deposit or</span>
 1405 |     | <span class='neutral'>//      withdrawal by LPs more efficient. Imagine an example where an LP</span>
 1406 |     | <span class='neutral'>//      intends to deposit &#39;100&#39; shares in every interval within the range</span>
 1407 |     | <span class='neutral'>//      &#39;qLower - i * qSpacing&#39; to &#39;qUpper + j * qSpacing&#39;, where &#39;i&#39; and &#39;j&#39;</span>
 1408 |     | <span class='neutral'>//      are arbitrary non-negative integers. In this case, we need to add &#39;100&#39;</span>
 1409 |     | <span class='neutral'>//      shares to every one of the following intervals:</span>
 1410 |     | <span class='neutral'>//</span>
 1411 |     | <span class='neutral'>//        &#39;[qLower - i * qSpacing, qUpper - i * qSpacing]&#39;,</span>
 1412 |     | <span class='neutral'>//          .</span>
 1413 |     | <span class='neutral'>//          .</span>
 1414 |     | <span class='neutral'>//          .</span>
 1415 |     | <span class='neutral'>//        &#39;[qLower - 1 * qSpacing, qUpper - 1 * qSpacing]&#39;,</span>
 1416 |     | <span class='neutral'>//        &#39;[qLower               , qUpper               ]&#39;,</span>
 1417 |     | <span class='neutral'>//        &#39;[qLower + 1 * qSpacing, qUpper + 1 * qSpacing]&#39;,</span>
 1418 |     | <span class='neutral'>//          .</span>
 1419 |     | <span class='neutral'>//          .</span>
 1420 |     | <span class='neutral'>//          .</span>
 1421 |     | <span class='neutral'>//        &#39;[qLower + j * qSpacing, qUpper + j * qSpacing]&#39;.</span>
 1422 |     | <span class='neutral'>//</span>
 1423 |     | <span class='neutral'>//      However, it may not be efficient or even possible to enumerated every</span>
 1424 |     | <span class='neutral'>//      single one of the &#39;i + j + 1&#39; intervals and thanks to &#39;sharesDelta&#39;, we</span>
 1425 |     | <span class='neutral'>//      do not need to do that! Alternatively, in order to account for the</span>
 1426 |     | <span class='neutral'>//      additional &#39;100&#39; shares, the protocol:</span>
 1427 |     | <span class='neutral'>//</span>
 1428 |     | <span class='neutral'>//      - increments &#39;sharesDelta[qLower - i * qSpacing]&#39; by &#39;100&#39;,</span>
 1429 |     | <span class='neutral'>//</span>
 1430 |     | <span class='neutral'>//      - increments &#39;sharesTotal&#39; by &#39;100&#39;,</span>
 1431 |     | <span class='neutral'>//</span>
 1432 |     | <span class='neutral'>//      - decrements &#39;sharesDelta[qUpper + j * qSpacing]&#39; by &#39;100&#39;,</span>
 1433 |     | <span class='neutral'>//</span>
 1434 |     | <span class='neutral'>//      which is sufficient to updated the total number of shares in every</span>
 1435 |     | <span class='neutral'>//      liquidity interval within the intended range.</span>
 1436 |     | <span class='neutral'>//</span>
 1437 |     | <span class='neutral'>//    - &#39;growth&#39;: In the prior step, we updated the content of the memory space</span>
 1438 |     | <span class='neutral'>//      which is pointed to by &#39;_growth_&#39;, according to the following formula:</span>
 1439 |     | <span class='neutral'>//</span>
 1440 |     | <span class='neutral'>//                                          / qUpper</span>
 1441 |     | <span class='neutral'>//                                         |    - h / 2</span>
 1442 |     | <span class='neutral'>//                                         |  e         k(w(h)) dh</span>
 1443 |     | <span class='neutral'>//                                         |</span>
 1444 |     | <span class='neutral'>//                                        / qLower</span>
 1445 |     | <span class='neutral'>//        &#39;growthAmended == growth * ----------------------------------&#39;.</span>
 1446 |     | <span class='neutral'>//                                       / qUpper</span>
 1447 |     | <span class='neutral'>//                                      |    - h / 2</span>
 1448 |     | <span class='neutral'>//                                      |  e         k(wAmended(h)) dh</span>
 1449 |     | <span class='neutral'>//                                      |</span>
 1450 |     | <span class='neutral'>//                                     / qLower</span>
 1451 |     | <span class='neutral'>//</span>
 1452 |     | <span class='neutral'>//      Hence, the current value stored in this memory space reflects the</span>
 1453 |     | <span class='neutral'>//      updated liquidity growth within &#39;[qLower, qUpper]&#39; (as a result of the</span>
 1454 |     | <span class='neutral'>//      partial swap that moved the price to &#39;qNext&#39;).</span>
 1455 |     | <span class='neutral'>//</span>
 1456 |     | <span class='neutral'>//      Now, as we are transitioning out of &#39;[qLower, qUpper]&#39;, &#39;growthAmended&#39;</span>
 1457 |     | <span class='neutral'>//      which currently resides in the memory has to be written somewhere in</span>
 1458 |     | <span class='neutral'>//      the protocol&#39;s storage, and then the amount of liquidity growth within</span>
 1459 |     | <span class='neutral'>//</span>
 1460 |     | <span class='neutral'>//        &#39;[qLower - qSpacing, qUpper - qSpacing]&#39;</span>
 1461 |     | <span class='neutral'>//</span>
 1462 |     | <span class='neutral'>//      should be loaded in the memory so that we can transact within this new</span>
 1463 |     | <span class='neutral'>//      interval.</span>
 1464 |     | <span class='neutral'>//</span>
 1465 |     | <span class='neutral'>//      We keep track of these &#39;growth&#39; values for all of the liquidity</span>
 1466 |     | <span class='neutral'>//      intervals, via the mapping &#39;growthMultiplier&#39;. For every integer &#39;m&#39;,</span>
 1467 |     | <span class='neutral'>//      let &#39;growth(m)&#39; denote the &#39;growth&#39; value for the interval</span>
 1468 |     | <span class='neutral'>//</span>
 1469 |     | <span class='neutral'>//        &#39;[qLower + m * qSpacing, qUpper + m * qSpacing]&#39;.</span>
 1470 |     | <span class='neutral'>//</span>
 1471 |     | <span class='neutral'>//      Hence, &#39;growth(0)&#39; corresponds to &#39;[qLower, qUpper]&#39; which is the</span>
 1472 |     | <span class='neutral'>//      current value stored in memory. </span>
 1473 |     | <span class='neutral'>//</span>
 1474 |     | <span class='neutral'>//      Now, for every integer &#39;m &gt;= 1&#39; define:</span>
 1475 |     | <span class='neutral'>//</span>
 1476 |     | <span class='neutral'>//          growthMultiplier[qLower + m * qSpacing]</span>
 1477 |     | <span class='neutral'>//        &#39;----------------------------------------- := </span>
 1478 |     | <span class='neutral'>//                         2 ** 208</span>
 1479 |     | <span class='neutral'>//         ---- +oo</span>
 1480 |     | <span class='neutral'>//         \            growth(+j)      (- qLower - j * qSpacing) / 2</span>
 1481 |     | <span class='neutral'>//         /           ------------ * e                               &#39;.</span>
 1482 |     | <span class='neutral'>//         ---- j = m    2 ** 111</span>
 1483 |     | <span class='neutral'>//</span>
 1484 |     | <span class='neutral'>//      According to the above definition, for every integer &#39;m &gt;= 1&#39;,</span>
 1485 |     | <span class='neutral'>//</span>
 1486 |     | <span class='neutral'>//          sqrtInverseOffset     growthMultiplier[qLower + m * qSpacing]</span>
 1487 |     | <span class='neutral'>//        &#39;------------------- * -----------------------------------------&#39;</span>
 1488 |     | <span class='neutral'>//              2 ** 127                         2 ** 208</span>
 1489 |     | <span class='neutral'>//</span>
 1490 |     | <span class='neutral'>//      is equal to the total amount of &#39;tag0&#39; corresponding to a single</span>
 1491 |     | <span class='neutral'>//      liquidity provider&#39;s share in every interval spanning from</span>
 1492 |     | <span class='neutral'>//      &#39;qLower + m * qSpacing&#39; to &#39;+oo&#39;.</span>
 1493 |     | <span class='neutral'>//</span>
 1494 |     | <span class='neutral'>//      Similarly, for every integer &#39;m &gt;= 1&#39; define:</span>
 1495 |     | <span class='neutral'>//</span>
 1496 |     | <span class='neutral'>//          growthMultiplier[qUpper - m * qSpacing]</span>
 1497 |     | <span class='neutral'>//        &#39;----------------------------------------- := </span>
 1498 |     | <span class='neutral'>//                         2 ** 208</span>
 1499 |     | <span class='neutral'>//         ---- +oo</span>
 1500 |     | <span class='neutral'>//         \            growth(-j)      (+ qUpper - j * qSpacing) / 2</span>
 1501 |     | <span class='neutral'>//         /           ------------ * e                               &#39;.</span>
 1502 |     | <span class='neutral'>//         ---- j = m    2 ** 111</span>
 1503 |     | <span class='neutral'>//</span>
 1504 |     | <span class='neutral'>//      According to the above definition, for every integer &#39;m &gt;= 1&#39;,</span>
 1505 |     | <span class='neutral'>//</span>
 1506 |     | <span class='neutral'>//          sqrtOffset     growthMultiplier[qUpper - m * qSpacing]</span>
 1507 |     | <span class='neutral'>//        &#39;------------ * -----------------------------------------&#39;</span>
 1508 |     | <span class='neutral'>//           2 ** 127                     2 ** 208</span>
 1509 |     | <span class='neutral'>//</span>
 1510 |     | <span class='neutral'>//      is equal to the total amount of &#39;tag1&#39; corresponding to a single</span>
 1511 |     | <span class='neutral'>//      liquidity provider&#39;s share in every interval spanning from &#39;-oo&#39; to</span>
 1512 |     | <span class='neutral'>//      &#39;qUpper - m * qSpacing&#39;.</span>
 1513 |     | <span class='neutral'>//</span>
 1514 |     | <span class='neutral'>//      The following illustration further elaborates the notion of </span>
 1515 |     | <span class='neutral'>//      &#39;growthMultiplier&#39;:</span>
 1516 |     | <span class='neutral'>//</span>
 1517 |     | <span class='neutral'>//                                         growthMultiplier[qUpper + qSpacing]</span>
 1518 |     | <span class='neutral'>//                                                                    |--&gt;</span>
 1519 |     | <span class='neutral'>//       growthMultiplier[qLower - qSpacing]                          |</span>
 1520 |     | <span class='neutral'>//           &lt;--|                                                     |</span>
 1521 |     | <span class='neutral'>//              |                        growthMultiplier[qUpper]     |</span>
 1522 |     | <span class='neutral'>//              |                                   |--&gt;              |</span>
 1523 |     | <span class='neutral'>//              |      growthMultiplier[qLower]     |                 |</span>
 1524 |     | <span class='neutral'>//              |              &lt;--|                 |                 |</span>
 1525 |     | <span class='neutral'>//              |                 |     growth      |                 |</span>
 1526 |     | <span class='neutral'>//              |                 |       ==        |                 |</span>
 1527 |     | <span class='neutral'>//              |    growth(-1)   |    growth(0)    |    growth(+1)   |</span>
 1528 |     | <span class='neutral'>//       ... &lt;--+-----------------+-----------------+-----------------+--&gt; ...</span>
 1529 |     | <span class='neutral'>//                                |                 |</span>
 1530 |     | <span class='neutral'>//                              qLower           qUpper</span>
 1531 |     | <span class='neutral'>//</span>
 1532 |     | <span class='neutral'>//      In the above figure, &#39;growthMultiplier[qUpper]&#39; and</span>
 1533 |     | <span class='neutral'>//      &#39;growthMultiplier[qUpper + qSpacing]&#39; point towards &#39;+oo&#39;. This is</span>
 1534 |     | <span class='neutral'>//      because these two values are proportional to the the amount of &#39;tag0&#39;</span>
 1535 |     | <span class='neutral'>//      for a single share in every interval within &#39;[qUpper, +oo]&#39; and</span>
 1536 |     | <span class='neutral'>//      &#39;[qUpper + qSpacing, +oo]&#39;, respectively. This is also the case for</span>
 1537 |     | <span class='neutral'>//      every &#39;growthMultiplier[qBoundary]&#39; where &#39;qBoundary&#39; is on the right</span>
 1538 |     | <span class='neutral'>//      side of the active liquidity interval as it is proportional to the</span>
 1539 |     | <span class='neutral'>//      amount of &#39;tag0&#39; for a single share in every interval within</span>
 1540 |     | <span class='neutral'>//      &#39;[qBoundary, +oo]&#39;.</span>
 1541 |     | <span class='neutral'>//</span>
 1542 |     | <span class='neutral'>//      On the contrary, &#39;growthMultiplier[qLower]&#39; and</span>
 1543 |     | <span class='neutral'>//      &#39;growthMultiplier[qLower - qSpacing]&#39; point towards &#39;-oo&#39;. This is</span>
 1544 |     | <span class='neutral'>//      because these two values are proportional to the the amount of &#39;tag1&#39;</span>
 1545 |     | <span class='neutral'>//      for a single share in every interval within &#39;[-oo, qLower]&#39; and</span>
 1546 |     | <span class='neutral'>//      &#39;[-oo, qLower - qSpacing]&#39;, respectively. This is also the case for</span>
 1547 |     | <span class='neutral'>//      every &#39;growthMultiplier[qBoundary]&#39; where &#39;qBoundary&#39; is on the left</span>
 1548 |     | <span class='neutral'>//      side of the active liquidity interval as it is proportional to the</span>
 1549 |     | <span class='neutral'>//      amount of &#39;tag1&#39; for a single share in every interval whithin</span>
 1550 |     | <span class='neutral'>//      &#39;[-oo, qBoundary]&#39;.</span>
 1551 |     | <span class='neutral'>//</span>
 1552 |     | <span class='neutral'>//      Instead of storing the growth value for each inactive interval, the</span>
 1553 |     | <span class='neutral'>//      protocol stores the mapping &#39;growthMultiplier&#39;.</span>
 1554 |     | <span class='neutral'>//</span>
 1555 |     | <span class='neutral'>//      This way of accounting for the growth values makes liquidity deposit or</span>
 1556 |     | <span class='neutral'>//      withdrawal by LPs more efficient. Imagine an example where an LP</span>
 1557 |     | <span class='neutral'>//      intends to deposit &#39;100&#39; shares in every interval within the range</span>
 1558 |     | <span class='neutral'>//      &#39;qLower + i * qSpacing&#39; to &#39;qUpper + j * qSpacing&#39;, where &#39;i&#39; and &#39;j&#39;</span>
 1559 |     | <span class='neutral'>//      are arbitrary positive integers. In this case, we need to calculate the</span>
 1560 |     | <span class='neutral'>//      amount of &#39;tag0&#39; corresponding to &#39;100&#39; shares in every one of the</span>
 1561 |     | <span class='neutral'>//      following intervals:</span>
 1562 |     | <span class='neutral'>//</span>
 1563 |     | <span class='neutral'>//        &#39;[qLower + i       * qSpacing, qUpper + i       * qSpacing]&#39;,</span>
 1564 |     | <span class='neutral'>//        &#39;[qLower + (i + 1) * qSpacing, qUpper + (i + 1) * qSpacing]&#39;,</span>
 1565 |     | <span class='neutral'>//          .</span>
 1566 |     | <span class='neutral'>//          .</span>
 1567 |     | <span class='neutral'>//          .</span>
 1568 |     | <span class='neutral'>//        &#39;[qLower + (j - 1) * qSpacing, qUpper + (j - 1) * qSpacing]&#39;,</span>
 1569 |     | <span class='neutral'>//        &#39;[qLower + j       * qSpacing, qUpper + j       * qSpacing]&#39;.</span>
 1570 |     | <span class='neutral'>//</span>
 1571 |     | <span class='neutral'>//      However, it may not be efficient or even possible to enumerated every</span>
 1572 |     | <span class='neutral'>//      single one of the &#39;j - i + 1&#39; intervals and thanks to</span>
 1573 |     | <span class='neutral'>//      &#39;growthMultiplier&#39;, we do not need to do that! Alternatively, the</span>
 1574 |     | <span class='neutral'>//      protocol calculates the amount of &#39;tag0&#39; that needs to be deposited</span>
 1575 |     | <span class='neutral'>//      using the following formula:</span>
 1576 |     | <span class='neutral'>//</span>
 1577 |     | <span class='neutral'>//                sqrtInverseOffset</span>
 1578 |     | <span class='neutral'>//        &#39;100 * ------------------- * (</span>
 1579 |     | <span class='neutral'>//                    2 ** 127</span>
 1580 |     | <span class='neutral'>//</span>
 1581 |     | <span class='neutral'>//                          growthMultiplier[qLower + i * qSpacing]</span>
 1582 |     | <span class='neutral'>//                         ----------------------------------------- - </span>
 1583 |     | <span class='neutral'>//                                          2 ** 208</span>
 1584 |     | <span class='neutral'>//</span>
 1585 |     | <span class='neutral'>//                          growthMultiplier[qUpper + j * qSpacing]</span>
 1586 |     | <span class='neutral'>//                         -----------------------------------------</span>
 1587 |     | <span class='neutral'>//                                          2 ** 208</span>
 1588 |     | <span class='neutral'>//         )&#39;.</span>
 1589 |     | <span class='neutral'>//</span>
 1590 |     | <span class='neutral'>//      The following figure visualizes the direction of the growth multipliers</span>
 1591 |     | <span class='neutral'>//      prior to the transition from &#39;[qLower, qUpper]&#39; to the new interval</span>
 1592 |     | <span class='neutral'>//      &#39;[qLower - qSpacing, qUpper - qSpacing]&#39;:</span>
 1593 |     | <span class='neutral'>//</span>
 1594 |     | <span class='neutral'>//                           growthMultiplier[qCurrent - qSpacing]</span>
 1595 |     | <span class='neutral'>//                                      &lt;--|</span>
 1596 |     | <span class='neutral'>//                                         |            growthMultiplier[qBack]</span>
 1597 |     | <span class='neutral'>//                                         |                           |--&gt;</span>
 1598 |     | <span class='neutral'>//                                         | growthMultiplier[qCurrent]|</span>
 1599 |     | <span class='neutral'>//                                         |          &lt;--|             |</span>
 1600 |     | <span class='neutral'>//                qLimit                   |             |             |</span>
 1601 |     | <span class='neutral'>//                   |                     |  growth(-1) |  growth(0)  |</span>
 1602 |     | <span class='neutral'>//      ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
 1603 |     | <span class='neutral'>//                                                       |             |</span>
 1604 |     | <span class='neutral'>//                                                     qNext         qBack</span>
 1605 |     | <span class='neutral'>//                                                       |</span>
 1606 |     | <span class='neutral'>//                                                    qCurrent</span>
 1607 |     | <span class='neutral'>//</span>
 1608 |     | <span class='neutral'>//      where &#39;growth(0) := growthAmended&#39;. As shown in the above figure,</span>
 1609 |     | <span class='neutral'>//      &#39;growthMultiplier[qBack]&#39; points towards &#39;+oo&#39; because it is on the</span>
 1610 |     | <span class='neutral'>//      right side of the active liquidity interval whereas</span>
 1611 |     | <span class='neutral'>//      &#39;growthMultiplier[qCurrent]&#39; and &#39;growthMultiplier[qCurrent - qSpacing]&#39;</span>
 1612 |     | <span class='neutral'>//      point towards &#39;-oo&#39; because they are on the left side of the active</span>
 1613 |     | <span class='neutral'>//      liquidity interval.</span>
 1614 |     | <span class='neutral'>//</span>
 1615 |     | <span class='neutral'>//      As part of this interval transition, we need to take the following</span>
 1616 |     | <span class='neutral'>//      steps:</span>
 1617 |     | <span class='neutral'>//      </span>
 1618 |     | <span class='neutral'>//      - &#39;growth(-1)&#39; is the value which is supposed to replace</span>
 1619 |     | <span class='neutral'>//        &#39;growthAmended&#39; in the memory space which is pointed to by</span>
 1620 |     | <span class='neutral'>//        &#39;_growth_&#39;. However, since the protocol does not store growth values</span>
 1621 |     | <span class='neutral'>//        for inactive intervals, we do not have direct access to &#39;growth(-1)&#39;.</span>
 1622 |     | <span class='neutral'>//        Because of this, we calculate it via the following formula:</span>
 1623 |     | <span class='neutral'>//</span>
 1624 |     | <span class='neutral'>//            growth(-1)       - qCurrent / 2</span>
 1625 |     | <span class='neutral'>//          &#39;------------ == e                * ( </span>
 1626 |     | <span class='neutral'>//             2 ** 111</span>
 1627 |     | <span class='neutral'>//</span>
 1628 |     | <span class='neutral'>//             growthMultiplier[qCurrent]</span>
 1629 |     | <span class='neutral'>//            ---------------------------- - </span>
 1630 |     | <span class='neutral'>//                      2 ** 208</span>
 1631 |     | <span class='neutral'>//</span>
 1632 |     | <span class='neutral'>//             growthMultiplier[qCurrent - qSpacing]</span>
 1633 |     | <span class='neutral'>//            ---------------------------------------</span>
 1634 |     | <span class='neutral'>//                           2 ** 208</span>
 1635 |     | <span class='neutral'>//           )&#39;</span>
 1636 |     | <span class='neutral'>//</span>
 1637 |     | <span class='neutral'>//      - Next, we need to recalculate &#39;growthMultiplier[qCurrent]&#39; because it</span>
 1638 |     | <span class='neutral'>//        is currently pointing to &#39;-oo&#39; since &#39;qCurrent&#39; is on the left side</span>
 1639 |     | <span class='neutral'>//        of &#39;[qLower, qUpper]&#39;. However, once we transition, &#39;qCurrent&#39; would</span>
 1640 |     | <span class='neutral'>//        be on the right side of the active liquidity interval</span>
 1641 |     | <span class='neutral'>//</span>
 1642 |     | <span class='neutral'>//          &#39;[qLower - qSpacing, qUpper - qSpacing]&#39;</span>
 1643 |     | <span class='neutral'>//</span>
 1644 |     | <span class='neutral'>//        which means that it should point to &#39;+oo&#39;. Hence,</span>
 1645 |     | <span class='neutral'>//        &#39;growthMultiplier[qCurrent]&#39; is recalculated via the following</span>
 1646 |     | <span class='neutral'>//        formula:</span>
 1647 |     | <span class='neutral'>//</span>
 1648 |     | <span class='neutral'>//            growthMultiplier[qCurrent]      growthMultiplier[qBack]</span>
 1649 |     | <span class='neutral'>//          &#39;---------------------------- := ------------------------- +</span>
 1650 |     | <span class='neutral'>//                    2 ** 208                       2 ** 208</span>
 1651 |     | <span class='neutral'>//</span>
 1652 |     | <span class='neutral'>//            growthAmended      - qCurrent / 2</span>
 1653 |     | <span class='neutral'>//           --------------- * e                &#39;.</span>
 1654 |     | <span class='neutral'>//              2 ** 111</span>
 1655 |     | <span class='neutral'>//</span>
 1656 |     | <span class='neutral'>//        Observe that according to the above formula, &#39;growthAmended&#39; is</span>
 1657 |     | <span class='neutral'>//        incorporated into &#39;growthMultiplier[qCurrent]&#39; which is where it is</span>
 1658 |     | <span class='neutral'>//        kept track of.</span>
 1659 |     | <span class='neutral'>//</span>
 1660 |     | <span class='neutral'>//      The following figure illustrates the above modification of the</span>
 1661 |     | <span class='neutral'>//      &#39;growthMultiplier&#39; mapping:</span>
 1662 |     | <span class='neutral'>//</span>
 1663 |     | <span class='neutral'>//                           growthMultiplier[qCurrent - qSpacing]</span>
 1664 |     | <span class='neutral'>//                                      &lt;--|</span>
 1665 |     | <span class='neutral'>//                                         |            growthMultiplier[qBack]</span>
 1666 |     | <span class='neutral'>//                                         |                           |--&gt;</span>
 1667 |     | <span class='neutral'>//                                         | growthMultiplier[qCurrent]|</span>
 1668 |     | <span class='neutral'>//                                         |             |--&gt;          |</span>
 1669 |     | <span class='neutral'>//                qLimit                   |             |             |</span>
 1670 |     | <span class='neutral'>//                   |                     |             |             |</span>
 1671 |     | <span class='neutral'>//      ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
 1672 |     | <span class='neutral'>//                                                       |             |</span>
 1673 |     | <span class='neutral'>//                                                     qNext         qBack</span>
 1674 |     | <span class='neutral'>//                                                       |</span>
 1675 |     | <span class='neutral'>//                                                    qCurrent</span>
 1676 |     | <span class='neutral'>//</span>
 1677 |     | <span class='neutral'>//    - &#39;qBack&#39; and &#39;qNext&#39;: Since we are dealing with a price decreasing swap,</span>
 1678 |     | <span class='neutral'>//      the values &#39;qBack&#39; and &#39;qNext&#39; should be modified as follows in order</span>
 1679 |     | <span class='neutral'>//      to represent the new liquidity interval that we are transitioning to:</span>
 1680 |     | <span class='neutral'>//</span>
 1681 |     | <span class='neutral'>//        &#39;qBack -= qSpacing&#39;,</span>
 1682 |     | <span class='neutral'>//        &#39;qNext -= qSpacing&#39;.</span>
 1683 |     | <span class='neutral'>//</span>
 1684 |     | <span class='neutral'>//      which is illustrated below:</span>
 1685 |     | <span class='neutral'>//</span>
 1686 |     | <span class='neutral'>//                qLimit                              qCurrent</span>
 1687 |     | <span class='neutral'>//                   |                                   |</span>
 1688 |     | <span class='neutral'>//      ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
 1689 |     | <span class='neutral'>//                                         |             |</span>
 1690 |     | <span class='neutral'>//                                       qNext         qBack</span>
 1691 |     | <span class='neutral'>//    </span>
 1692 |     | <span class='neutral'>//    - &#39;curve&#39;: As we discussed before, since</span>
 1693 |     | <span class='neutral'>//</span>
 1694 |     | <span class='neutral'>//          &#39;[qLower - qSpacing, qUpper - qSpacing]&#39;</span>
 1695 |     | <span class='neutral'>//</span>
 1696 |     | <span class='neutral'>//      is currently inactive, its corresponding curve sequence is composed of</span>
 1697 |     | <span class='neutral'>//      only two members:</span>
 1698 |     | <span class='neutral'>//</span>
 1699 |     | <span class='neutral'>//      &#39;q[0] := qUpper - qSpacing&#39;,</span>
 1700 |     | <span class='neutral'>//      &#39;q[1] := qLower - qSpacing&#39;.</span>
 1701 |     | <span class='neutral'>//</span>
 1702 |     | <span class='neutral'>//      As part of the transition, we discard the previous curve sequence and</span>
 1703 |     | <span class='neutral'>//      initiate this above curve sequence in memory.</span>
 1704 |     | <span class='neutral'>//</span>
 1705 |     | <span class='neutral'>//    Now, the transition to &#39;[qLower - qSpacing, qUpper - qSpacing]&#39; is</span>
 1706 |     | <span class='neutral'>//    complete and throughout the remainder of this example, we refer to this</span>
 1707 |     | <span class='neutral'>//    interval as the active liquidity interval. Additionally, we redefine:</span>
 1708 |     | <span class='neutral'>//</span>
 1709 |     | <span class='neutral'>//      &#39;qUpper := qUpper - qSpacing&#39;, </span>
 1710 |     | <span class='neutral'>//      &#39;qLower := qLower - qSpacing&#39;</span>
 1711 |     | <span class='neutral'>//</span>
 1712 |     | <span class='neutral'>//    which allows us to continue using the notation &#39;[qLower, qUpper]&#39; in</span>
 1713 |     | <span class='neutral'>//    order to refer to the active liquidity interval.</span>
 1714 |     | <span class='neutral'>//</span>
 1715 |     | <span class='neutral'>//  - In this step, we need to determine whether we should explore the active</span>
 1716 |     | <span class='neutral'>//    interval &#39;[qLower, qUpper]&#39; or to cross it entirely, i.e., all the way</span>
 1717 |     | <span class='neutral'>//    from &#39;qBack&#39; to &#39;qNext&#39;. In the former case, we need to integrate the</span>
 1718 |     | <span class='neutral'>//    liquidity distribution function &#39;k(w(.))&#39; piece by piece through which</span>
 1719 |     | <span class='neutral'>//    the &#39;incomingCurrentToTarget&#39; and &#39;currentToTarget&#39; are calculated. As we</span>
 1720 |     | <span class='neutral'>//    discussed before, the calculation of these integrals leads to</span>
 1721 |     | <span class='neutral'>//    &#39;amount0Partial&#39; and &#39;amount1Partial&#39;, respectively. However, the latter</span>
 1722 |     | <span class='neutral'>//    case is more efficient because if the active interval is crossed </span>
 1723 |     | <span class='neutral'>//    entirely, then the precalculated integrals &#39;incomingMax&#39; and</span>
 1724 |     | <span class='neutral'>//    &#39;outgoingMax&#39; can be used to determine &#39;amount0Partial&#39; and</span>
 1725 |     | <span class='neutral'>//    &#39;amount1Partial&#39;. In order for the protocol to be able to cross the</span>
 1726 |     | <span class='neutral'>//    active interval entirely the following two criteria should be met:</span>
 1727 |     | <span class='neutral'>//</span>
 1728 |     | <span class='neutral'>//    (a) The cross must not violate &#39;qLimit&#39;. In other words, for price</span>
 1729 |     | <span class='neutral'>//        increasing swaps we should have</span>
 1730 |     | <span class='neutral'>//</span>
 1731 |     | <span class='neutral'>//          &#39;qNext &lt;= qLimit&#39;</span>
 1732 |     | <span class='neutral'>//</span>
 1733 |     | <span class='neutral'>//        and for price decreasing swaps, we should have</span>
 1734 |     | <span class='neutral'>//</span>
 1735 |     | <span class='neutral'>//          &#39;qLimit &lt;= qNext&#39;.</span>
 1736 |     | <span class='neutral'>//</span>
 1737 |     | <span class='neutral'>//        which is the case in the present example.</span>
 1738 |     | <span class='neutral'>//</span>
 1739 |     | <span class='neutral'>//    (b) The cross must not violate &#39;amountSpecified&#39;. In order words, if</span>
 1740 |     | <span class='neutral'>//        &#39;exactInput == false&#39;, then the outgoing amount from the pool as a</span>
 1741 |     | <span class='neutral'>//        result of crossing all the way from &#39;qBack&#39; to &#39;qNext&#39; must not</span>
 1742 |     | <span class='neutral'>//        exceed the remaining absolute value &#39;0 - amountSpecified&#39;. Similarly,</span>
 1743 |     | <span class='neutral'>//        if &#39;exactInput == true&#39;, then the incoming amount to the pool as a</span>
 1744 |     | <span class='neutral'>//        result of crossing all the way from &#39;qBack&#39; to &#39;qNext&#39; must not</span>
 1745 |     | <span class='neutral'>//        exceed the remaining value &#39;amountSpecified&#39;.</span>
 1746 |     | <span class='neutral'>//</span>
 1747 |     | <span class='neutral'>//        In order to verify this, we first need to recalculate &#39;integralLimit&#39;</span>
 1748 |     | <span class='neutral'>//        based on the decremented value for &#39;|amountSpecified|&#39;:</span>
 1749 |     | <span class='neutral'>//        </span>
 1750 |     | <span class='neutral'>//          &#39;integralLimit :=</span>
 1751 |     | <span class='neutral'>//</span>
 1752 |     | <span class='neutral'>//                          |amountSpecified|          1          2 ** 111</span>
 1753 |     | <span class='neutral'>//           outgoingMax * ------------------- * ------------- * ----------</span>
 1754 |     | <span class='neutral'>//                          sqrtInverseOffset     sharesTotal      growth</span>
 1755 |     | <span class='neutral'>//</span>
 1756 |     | <span class='neutral'>//           == +oo&#39;.</span>
 1757 |     | <span class='neutral'>//</span>
 1758 |     | <span class='neutral'>//        which remains equal to &#39;+oo&#39; for this example.</span>
 1759 |     | <span class='neutral'>//</span>
 1760 |     | <span class='neutral'>//        Next, we need to define the notion of &#39;integralLimitInterval&#39; which</span>
 1761 |     | <span class='neutral'>//        is compared with &#39;integralLimit&#39; in order to determine if</span>
 1762 |     | <span class='neutral'>//        &#39;amountSpecified&#39; is violated or not. Consider the following four</span>
 1763 |     | <span class='neutral'>//        scenarios:</span>
 1764 |     | <span class='neutral'>//</span>
 1765 |     | <span class='neutral'>//        - If the swap is price increasing and &#39;exactInput == false&#39;, define:</span>
 1766 |     | <span class='neutral'>//</span>
 1767 |     | <span class='neutral'>//                                         - 8     / qUpper</span>
 1768 |     | <span class='neutral'>//            integralLimitInterval      e        |    - h / 2</span>
 1769 |     | <span class='neutral'>//          &#39;----------------------- := ------- * |  e         k(h - qLower) dh</span>
 1770 |     | <span class='neutral'>//                   2 ** 216              2      |</span>
 1771 |     | <span class='neutral'>//                                               / qLower</span>
 1772 |     | <span class='neutral'>//</span>
 1773 |     | <span class='neutral'>//                - qLower / 2    outgoingMax</span>
 1774 |     | <span class='neutral'>//           == e              * -------------&#39;</span>
 1775 |     | <span class='neutral'>//                                 2 ** 216</span>
 1776 |     | <span class='neutral'>//</span>
 1777 |     | <span class='neutral'>//        - If the swap is price increasing and &#39;exactInput == true&#39;, define:</span>
 1778 |     | <span class='neutral'>//</span>
 1779 |     | <span class='neutral'>//                                         - 8     / qUpper</span>
 1780 |     | <span class='neutral'>//            integralLimitInterval      e        |    + h / 2</span>
 1781 |     | <span class='neutral'>//          &#39;----------------------- := ------- * |  e         k(h - qLower) dh</span>
 1782 |     | <span class='neutral'>//                   2 ** 216              2      |</span>
 1783 |     | <span class='neutral'>//                                               / qLower</span>
 1784 |     | <span class='neutral'>//</span>
 1785 |     | <span class='neutral'>//                + qUpper / 2    incomingMax</span>
 1786 |     | <span class='neutral'>//           == e              * -------------&#39;</span>
 1787 |     | <span class='neutral'>//                                 2 ** 216</span>
 1788 |     | <span class='neutral'>//</span>
 1789 |     | <span class='neutral'>//        - If the swap is price decreasing and &#39;exactInput == false&#39;, define:</span>
 1790 |     | <span class='neutral'>//</span>
 1791 |     | <span class='neutral'>//                                         - 8     / qUpper</span>
 1792 |     | <span class='neutral'>//            integralLimitInterval      e        |    + h / 2</span>
 1793 |     | <span class='neutral'>//          &#39;----------------------- := ------- * |  e         k(qUpper - h) dh</span>
 1794 |     | <span class='neutral'>//                   2 ** 216              2      |</span>
 1795 |     | <span class='neutral'>//                                               / qLower</span>
 1796 |     | <span class='neutral'>//</span>
 1797 |     | <span class='neutral'>//                + qUpper / 2    outgoingMax</span>
 1798 |     | <span class='neutral'>//           == e              * -------------&#39;</span>
 1799 |     | <span class='neutral'>//                                 2 ** 216</span>
 1800 |     | <span class='neutral'>//</span>
 1801 |     | <span class='neutral'>//        - If the swap is price decreasing and &#39;exactInput == true&#39;, define:</span>
 1802 |     | <span class='neutral'>//</span>
 1803 |     | <span class='neutral'>//                                         - 8     / qUpper</span>
 1804 |     | <span class='neutral'>//            integralLimitInterval      e        |    - h / 2</span>
 1805 |     | <span class='neutral'>//          &#39;----------------------- := ------- * |  e         k(qUpper - h) dh</span>
 1806 |     | <span class='neutral'>//                   2 ** 216              2      |</span>
 1807 |     | <span class='neutral'>//                                               / qLower</span>
 1808 |     | <span class='neutral'>//</span>
 1809 |     | <span class='neutral'>//                - qLower / 2    incomingMax</span>
 1810 |     | <span class='neutral'>//           == e              * -------------&#39;</span>
 1811 |     | <span class='neutral'>//                                 2 ** 216</span>
 1812 |     | <span class='neutral'>// </span>
 1813 |     | <span class='neutral'>//        In the first and the fourth cases above, &#39;amountSpecified&#39; is in</span>
 1814 |     | <span class='neutral'>//        &#39;tag0&#39;. By crossing the active interval entirely, the absolute value</span>
 1815 |     | <span class='neutral'>//        &#39;|amountSpecified|&#39; is decremented by:</span>
 1816 |     | <span class='neutral'>//</span>
 1817 |     | <span class='neutral'>//                                               growth</span>
 1818 |     | <span class='neutral'>//          &#39;sqrtInverseOffset * sharesTotal * ---------- * </span>
 1819 |     | <span class='neutral'>//                                              2 ** 111</span>
 1820 |     | <span class='neutral'>//            integralLimitInterval</span>
 1821 |     | <span class='neutral'>//           -----------------------&#39;,</span>
 1822 |     | <span class='neutral'>//                 outgoingMax</span>
 1823 |     | <span class='neutral'>// </span>
 1824 |     | <span class='neutral'>//        In the second and the third cases above, &#39;amountSpecified&#39; is in</span>
 1825 |     | <span class='neutral'>//        &#39;tag1&#39;. By crossing the active interval entirely, the absolute value</span>
 1826 |     | <span class='neutral'>//        &#39;|amountSpecified|&#39; is decremented by:</span>
 1827 |     | <span class='neutral'>//</span>
 1828 |     | <span class='neutral'>//                                        growth      integralLimitInterval</span>
 1829 |     | <span class='neutral'>//          &#39;sqrtOffset * sharesTotal * ---------- * -----------------------&#39;,</span>
 1830 |     | <span class='neutral'>//                                       2 ** 111          outgoingMax</span>
 1831 |     | <span class='neutral'>//</span>
 1832 |     | <span class='neutral'>//        Hence, in both cases, by crossing the active interval, the limit</span>
 1833 |     | <span class='neutral'>//        imposed by &#39;amountSpecified&#39; is not violated if and only if:</span>
 1834 |     | <span class='neutral'>//        </span>
 1835 |     | <span class='neutral'>//          &#39;integralLimitInterval &lt;= integralLimit&#39;.</span>
 1836 |     | <span class='neutral'>//</span>
 1837 |     | <span class='neutral'>//    In the present example, since &#39;integralLimit == +oo&#39; and</span>
 1838 |     | <span class='neutral'>//    &#39;qLimit &lt;= qNext&#39; both (a) and (b) are satisfied which means that we can</span>
 1839 |     | <span class='neutral'>//    cross the active interval and move the price to &#39;qNext&#39; directly, while</span>
 1840 |     | <span class='neutral'>//    determining the outgoing and incoming amounts based on the precalculated</span>
 1841 |     | <span class='neutral'>//    parameters of the pool.</span>
 1842 |     | <span class='neutral'>//</span>
 1843 |     | <span class='neutral'>//    Once again, before the execution of this cross, we need to verify the</span>
 1844 |     | <span class='neutral'>//    condition, &#39;sharesTotal &gt;= crossThreshold&#39;. If not met, the swap call is</span>
 1845 |     | <span class='neutral'>//    halted and the current values accumulated as &#39;amount0&#39; and &#39;amount1&#39; are</span>
 1846 |     | <span class='neutral'>//    exchanged.</span>
 1847 |     | <span class='neutral'>//</span>
 1848 |     | <span class='neutral'>//  - In order to move the price from &#39;qBack&#39; to &#39;qNext&#39;, we need to update a</span>
 1849 |     | <span class='neutral'>//    number of parameters, including:</span>
 1850 |     | <span class='neutral'>//</span>
 1851 |     | <span class='neutral'>//    - &#39;amount0&#39;: According to the above formulas, as we move the price all</span>
 1852 |     | <span class='neutral'>//      the way from &#39;qBack&#39; to &#39;qNext&#39;, &#39;amount0&#39; should be incremented by:</span>
 1853 |     | <span class='neutral'>//</span>
 1854 |     | <span class='neutral'>//                                                               growth</span>
 1855 |     | <span class='neutral'>//        &#39;amount0Partial == sqrtInverseOffset * sharesTotal * ---------- *</span>
 1856 |     | <span class='neutral'>//                                                              2 ** 111</span>
 1857 |     | <span class='neutral'>//          incomingMax      - qLower / 2</span>
 1858 |     | <span class='neutral'>//         ------------- * e              &#39;.</span>
 1859 |     | <span class='neutral'>//          outgoingMax</span>
 1860 |     | <span class='neutral'>//</span>
 1861 |     | <span class='neutral'>//    - &#39;amount1&#39;: According to the above formulas, as we move the price all</span>
 1862 |     | <span class='neutral'>//      the way from &#39;qBack&#39; to &#39;qNext&#39;, &#39;amount1&#39; should be decremented by:</span>
 1863 |     | <span class='neutral'>//</span>
 1864 |     | <span class='neutral'>//                                                        growth</span>
 1865 |     | <span class='neutral'>//        &#39;amount1Partial == sqrtOffset * sharesTotal * ---------- * </span>
 1866 |     | <span class='neutral'>//                                                       2 ** 111</span>
 1867 |     | <span class='neutral'>//                             + qUpper / 2</span>
 1868 |     | <span class='neutral'>//                           e              &#39;.</span>
 1869 |     | <span class='neutral'>//</span>
 1870 |     | <span class='neutral'>//    - &#39;amountSpecified&#39;: Since the swap is partially fulfilled, we should</span>
 1871 |     | <span class='neutral'>//      decrement &#39;amountSpecified&#39; by &#39;amount0Partial&#39; to reflect this:</span>
 1872 |     | <span class='neutral'>//</span>
 1873 |     | <span class='neutral'>//        &#39;amountSpecified -= amount0Partial&#39;.</span>
 1874 |     | <span class='neutral'>//</span>
 1875 |     | <span class='neutral'>//    - &#39;curve&#39;: Following the pattern that was introduced earlier, for</span>
 1876 |     | <span class='neutral'>//      inactive liquidity intervals, the amended curve sequence for</span>
 1877 |     | <span class='neutral'>//      &#39;[qLower, qUpper]&#39; should be:</span>
 1878 |     | <span class='neutral'>//</span>
 1879 |     | <span class='neutral'>//        &#39;q[0] := qUpper&#39;,</span>
 1880 |     | <span class='neutral'>//        &#39;q[1] := qLower&#39;.</span>
 1881 |     | <span class='neutral'>//</span>
 1882 |     | <span class='neutral'>//      This amendment, transforms the function &#39;w&#39; associated with</span>
 1883 |     | <span class='neutral'>//      &#39;[qLower, qUpper]&#39; from the following:</span>
 1884 |     | <span class='neutral'>//</span>
 1885 |     | <span class='neutral'>//            w(q)</span>
 1886 |     | <span class='neutral'>//              ^</span>
 1887 |     | <span class='neutral'>//      spacing |\</span>
 1888 |     | <span class='neutral'>//              | \</span>
 1889 |     | <span class='neutral'>//              |  \</span>
 1890 |     | <span class='neutral'>//              |   \</span>
 1891 |     | <span class='neutral'>//              |    \</span>
 1892 |     | <span class='neutral'>//              |     \</span>
 1893 |     | <span class='neutral'>//              |      \</span>
 1894 |     | <span class='neutral'>//              |       \</span>
 1895 |     | <span class='neutral'>//              |        \</span>
 1896 |     | <span class='neutral'>//              |         \</span>
 1897 |     | <span class='neutral'>//              |          \</span>
 1898 |     | <span class='neutral'>//              |           \</span>
 1899 |     | <span class='neutral'>//              |            \</span>
 1900 |     | <span class='neutral'>//              |             \</span>
 1901 |     | <span class='neutral'>//              |              \</span>
 1902 |     | <span class='neutral'>//              |               \</span>
 1903 |     | <span class='neutral'>//              |                \</span>
 1904 |     | <span class='neutral'>//            0 +-----------------+-&gt; q</span>
 1905 |     | <span class='neutral'>//           qLower               |</span>
 1906 |     | <span class='neutral'>//                              qUpper</span>
 1907 |     | <span class='neutral'>//                                |</span>
 1908 |     | <span class='neutral'>//                            qCurrent</span>
 1909 |     | <span class='neutral'>//</span>
 1910 |     | <span class='neutral'>//      to a new function:</span>
 1911 |     | <span class='neutral'>//</span>
 1912 |     | <span class='neutral'>//        &#39;wAmended(q) := q - qLower&#39;</span>
 1913 |     | <span class='neutral'>//</span>
 1914 |     | <span class='neutral'>//      which can be plotted as follows:</span>
 1915 |     | <span class='neutral'>//</span>
 1916 |     | <span class='neutral'>//          wAmended(q)</span>
 1917 |     | <span class='neutral'>//              ^</span>
 1918 |     | <span class='neutral'>//      spacing |                /</span>
 1919 |     | <span class='neutral'>//              |               /</span>
 1920 |     | <span class='neutral'>//              |              /</span>
 1921 |     | <span class='neutral'>//              |             /</span>
 1922 |     | <span class='neutral'>//              |            /</span>
 1923 |     | <span class='neutral'>//              |           /</span>
 1924 |     | <span class='neutral'>//              |          /</span>
 1925 |     | <span class='neutral'>//              |         /</span>
 1926 |     | <span class='neutral'>//              |        /</span>
 1927 |     | <span class='neutral'>//              |       /</span>
 1928 |     | <span class='neutral'>//              |      /</span>
 1929 |     | <span class='neutral'>//              |     /</span>
 1930 |     | <span class='neutral'>//              |    /</span>
 1931 |     | <span class='neutral'>//              |   /</span>
 1932 |     | <span class='neutral'>//              |  /</span>
 1933 |     | <span class='neutral'>//              | /</span>
 1934 |     | <span class='neutral'>//              |/</span>
 1935 |     | <span class='neutral'>//            0 +-----------------+-&gt; q</span>
 1936 |     | <span class='neutral'>//           qLower               |</span>
 1937 |     | <span class='neutral'>//                              qUpper</span>
 1938 |     | <span class='neutral'>//</span>
 1939 |     | <span class='neutral'>//      As we will demonstrate next, this procedure results in growth for</span>
 1940 |     | <span class='neutral'>//      liquidity providers.</span>
 1941 |     | <span class='neutral'>//</span>
 1942 |     | <span class='neutral'>//    - &#39;growth&#39;: As discussed earlier, since the liquidity distribution</span>
 1943 |     | <span class='neutral'>//      function &#39;k(w(.))&#39; is modified to &#39;k(wAmended(.))&#39;, we need to make an</span>
 1944 |     | <span class='neutral'>//      adjustment to the &#39;growth&#39; value and turn it into &#39;growthAmended&#39;.</span>
 1945 |     | <span class='neutral'>//      In order to determine &#39;growthAmended&#39;, the following equation is</span>
 1946 |     | <span class='neutral'>//      solved:</span>
 1947 |     | <span class='neutral'>//</span>
 1948 |     | <span class='neutral'>//        &#39;totalReserveOfTag0Before == totalReserveOfTag0After&#39;</span>
 1949 |     | <span class='neutral'>//</span>
 1950 |     | <span class='neutral'>//      where &#39;totalReserveOfTag0Before&#39; is the total amount of &#39;tag0&#39; within</span>
 1951 |     | <span class='neutral'>//      &#39;[qLower, qUpper]&#39; which is calculated based on &#39;k(w(.))&#39;, whereas</span>
 1952 |     | <span class='neutral'>//      &#39;totalReserveOfTag0After&#39; is the same value calculated based on</span>
 1953 |     | <span class='neutral'>//      &#39;k(wAmended(.))&#39;. The two sides of the equation can be derived as:</span>
 1954 |     | <span class='neutral'>//</span>
 1955 |     | <span class='neutral'>//        &#39;totalReserveOfTag0Before == sqrtInverseOffset * sharesTotal * </span>
 1956 |     | <span class='neutral'>//</span>
 1957 |     | <span class='neutral'>//                                         - 8     / qUpper</span>
 1958 |     | <span class='neutral'>//           growth       2 ** 216       e        |    - h / 2</span>
 1959 |     | <span class='neutral'>//         ---------- * ------------- * ------- * |  e         k(w(h)) dh ==</span>
 1960 |     | <span class='neutral'>//          2 ** 111     outgoingMax       2      |</span>
 1961 |     | <span class='neutral'>//                                               / qLower</span>
 1962 |     | <span class='neutral'>//</span>
 1963 |     | <span class='neutral'>//                                             growth       2 ** 216</span>
 1964 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * ---------- * ------------- *</span>
 1965 |     | <span class='neutral'>//                                            2 ** 111     outgoingMax</span>
 1966 |     | <span class='neutral'>//</span>
 1967 |     | <span class='neutral'>//            - 8     / qUpper</span>
 1968 |     | <span class='neutral'>//          e        |    - h / 2</span>
 1969 |     | <span class='neutral'>//         ------- * |  e         k(qUpper - h) dh ==</span>
 1970 |     | <span class='neutral'>//            2      |</span>
 1971 |     | <span class='neutral'>//                  / qLower</span>
 1972 |     | <span class='neutral'>//</span>
 1973 |     | <span class='neutral'>//                                             growth</span>
 1974 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * ---------- * </span>
 1975 |     | <span class='neutral'>//                                            2 ** 111</span>
 1976 |     | <span class='neutral'>//</span>
 1977 |     | <span class='neutral'>//          incomingMax      - qLower / 2</span>
 1978 |     | <span class='neutral'>//         ------------- * e              &#39;.</span>
 1979 |     | <span class='neutral'>//          outgoingMax</span>
 1980 |     | <span class='neutral'>//</span>
 1981 |     | <span class='neutral'>//      and</span>
 1982 |     | <span class='neutral'>//</span>
 1983 |     | <span class='neutral'>//        &#39;totalReserveOfTag0After ==</span>
 1984 |     | <span class='neutral'>//</span>
 1985 |     | <span class='neutral'>//                                            growthAmended</span>
 1986 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * --------------- * </span>
 1987 |     | <span class='neutral'>//                                              2 ** 111</span>
 1988 |     | <span class='neutral'>//</span>
 1989 |     | <span class='neutral'>//                            - 8     / qUpper</span>
 1990 |     | <span class='neutral'>//            2 ** 216      e        |    - h / 2</span>
 1991 |     | <span class='neutral'>//         ------------- * ------- * |  e         k(h - qLower) dh&#39; == </span>
 1992 |     | <span class='neutral'>//          outgoingMax       2      |</span>
 1993 |     | <span class='neutral'>//                                  / qLower</span>
 1994 |     | <span class='neutral'>//</span>
 1995 |     | <span class='neutral'>//                                            growthAmended</span>
 1996 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * --------------- *</span>
 1997 |     | <span class='neutral'>//                                              2 ** 111</span>
 1998 |     | <span class='neutral'>//</span>
 1999 |     | <span class='neutral'>//           - qLower / 2</span>
 2000 |     | <span class='neutral'>//         e              &#39;.</span>
 2001 |     | <span class='neutral'>//</span>
 2002 |     | <span class='neutral'>//</span>
 2003 |     | <span class='neutral'>//      Hence, &#39;growthAmended&#39; is given by the following formula:</span>
 2004 |     | <span class='neutral'>//</span>
 2005 |     | <span class='neutral'>//                                    incomingMax</span>
 2006 |     | <span class='neutral'>//        &#39;growthAmended == growth * -------------&#39;.</span>
 2007 |     | <span class='neutral'>//                                    outgoingMax</span>
 2008 |     | <span class='neutral'>//</span>
 2009 |     | <span class='neutral'>//      As proven earlier, &#39;incomingMax&#39; is always greater than or equal to</span>
 2010 |     | <span class='neutral'>//      &#39;outgoingMax&#39;. Hence, crossing the active interval results in growth.</span>
 2011 |     | <span class='neutral'>//</span>
 2012 |     | <span class='neutral'>//    - &#39;qCurrent&#39;: Lastly, as we move the price of the pool to &#39;qNext&#39;, the</span>
 2013 |     | <span class='neutral'>//      value for &#39;qCurrent&#39; should be updated to reflect this change., which</span>
 2014 |     | <span class='neutral'>//      is illustrated as follows:</span>
 2015 |     | <span class='neutral'>//</span>
 2016 |     | <span class='neutral'>//                qLimit                qCurrent</span>
 2017 |     | <span class='neutral'>//                   |                     |</span>
 2018 |     | <span class='neutral'>//      ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
 2019 |     | <span class='neutral'>//                                         |             |</span>
 2020 |     | <span class='neutral'>//                                       qNext         qBack</span>
 2021 |     | <span class='neutral'>//</span>
 2022 |     | <span class='neutral'>//  - Similar to the prior steps, as we reach &#39;qNext&#39;, we transition from the</span>
 2023 |     | <span class='neutral'>//    original liquidity interval &#39;[qLower, qUpper]&#39; to its adjacent interval</span>
 2024 |     | <span class='neutral'>//    &#39;[qLower - qSpacing, qUpper - qSpacing]&#39;. This transition involves the</span>
 2025 |     | <span class='neutral'>//    adjustment of growth multipliers. In addition we need to update &#39;growth&#39;</span>
 2026 |     | <span class='neutral'>//    &#39;sharesTotal&#39;, &#39;qBack&#39;, &#39;qNext&#39;, as well as the curve sequence. The new</span>
 2027 |     | <span class='neutral'>//    status of the pool following this transition is illustrated as follows:</span>
 2028 |     | <span class='neutral'>//</span>
 2029 |     | <span class='neutral'>//                qLimit                qCurrent</span>
 2030 |     | <span class='neutral'>//                   |                     |</span>
 2031 |     | <span class='neutral'>//      ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
 2032 |     | <span class='neutral'>//                           |             |</span>
 2033 |     | <span class='neutral'>//                         qNext         qBack</span>
 2034 |     | <span class='neutral'>//</span>
 2035 |     | <span class='neutral'>//  - Similar to the prior steps, as we transition to a new liquidity interval,</span>
 2036 |     | <span class='neutral'>//    we determine whether we should cross this new active interval entirely or</span>
 2037 |     | <span class='neutral'>//    not. In the present example, since &#39;qLimit &lt;= qNext&#39; and </span>
 2038 |     | <span class='neutral'>//    &#39;amountSpecified == +oo&#39;, we need to cross one more time. This action</span>
 2039 |     | <span class='neutral'>//    will modify &#39;amount0&#39;, &#39;amount1&#39;, &#39;growth&#39;, as well as the curve</span>
 2040 |     | <span class='neutral'>//    sequence. Additionally, crossing the active interval moves &#39;qCurrent&#39; to</span>
 2041 |     | <span class='neutral'>//    &#39;qNext&#39; which is illustrated below:</span>
 2042 |     | <span class='neutral'>//</span>
 2043 |     | <span class='neutral'>//                        qCurrent</span>
 2044 |     | <span class='neutral'>//                qLimit     |</span>
 2045 |     | <span class='neutral'>//                   |       |</span>
 2046 |     | <span class='neutral'>//      ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
 2047 |     | <span class='neutral'>//                           |             |</span>
 2048 |     | <span class='neutral'>//                         qNext         qBack</span>
 2049 |     | <span class='neutral'>//</span>
 2050 |     | <span class='neutral'>//  - Next, we need to perform another transition in order to enter the</span>
 2051 |     | <span class='neutral'>//    liquidity interval that contains &#39;qLimit&#39;. The new status of the pool</span>
 2052 |     | <span class='neutral'>//    following this transition is illustrated as follows:</span>
 2053 |     | <span class='neutral'>//</span>
 2054 |     | <span class='neutral'>//                        qCurrent</span>
 2055 |     | <span class='neutral'>//                qLimit     |</span>
 2056 |     | <span class='neutral'>//                   |       |</span>
 2057 |     | <span class='neutral'>//      ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
 2058 |     | <span class='neutral'>//             |             |</span>
 2059 |     | <span class='neutral'>//           qNext         qBack</span>
 2060 |     | <span class='neutral'>//  </span>
 2061 |     | <span class='neutral'>//  - Once again, as we transition to a new liquidity interval, we determine</span>
 2062 |     | <span class='neutral'>//    whether we should cross this new active interval entirely or not. This,</span>
 2063 |     | <span class='neutral'>//    time, since &#39;qNext &lt; qLimit&#39;, we should transact within the active</span>
 2064 |     | <span class='neutral'>//    interval as opposed to crossing it. To this end, we move the price</span>
 2065 |     | <span class='neutral'>//    towards &#39;qNext&#39; until either of the following conditions are met:</span>
 2066 |     | <span class='neutral'>//</span>
 2067 |     | <span class='neutral'>//    (a) &#39;amountSpecified&#39; is fulfilled.</span>
 2068 |     | <span class='neutral'>//</span>
 2069 |     | <span class='neutral'>//    (b) &#39;qLimit&#39; is reached.</span>
 2070 |     | <span class='neutral'>//</span>
 2071 |     | <span class='neutral'>//    We move the price from &#39;qCurrent&#39; towards &#39;qNext&#39; by enumerating pieces</span>
 2072 |     | <span class='neutral'>//    of the present liquidity distribution function &#39;k(w(.))&#39;. To this end,</span>
 2073 |     | <span class='neutral'>//    the memory pointers &#39;_begin_&#39; and &#39;_target_&#39; are used in order to keep</span>
 2074 |     | <span class='neutral'>//    track of the two endpoints for the current piece under exploration. Here,</span>
 2075 |     | <span class='neutral'>//    we refer to these endpoints as &#39;qBegin&#39; and &#39;qTarget&#39;.</span>
 2076 |     | <span class='neutral'>//</span>
 2077 |     | <span class='neutral'>//    We start with &#39;qBegin == qCurrent&#39; and move forward by continuously</span>
 2078 |     | <span class='neutral'>//    updating &#39;qBegin&#39; and &#39;qTarget&#39;. In each step, the integrals</span>
 2079 |     | <span class='neutral'>//    &#39;currentToTarget&#39; and &#39;incomingCurrentToTarget&#39; are incremented to</span>
 2080 |     | <span class='neutral'>//    account for the outgoing amount from the pool and the incoming amount to</span>
 2081 |     | <span class='neutral'>//    the pool.</span>
 2082 |     | <span class='neutral'>//</span>
 2083 |     | <span class='neutral'>//    While incrementing the two integrals, we need to continuously monitor</span>
 2084 |     | <span class='neutral'>//    condition (a). To that end, we once again calculate &#39;integralLimit&#39;</span>
 2085 |     | <span class='neutral'>//</span>
 2086 |     | <span class='neutral'>//      &#39;integralLimit := outgoingMax * </span>
 2087 |     | <span class='neutral'>//</span>
 2088 |     | <span class='neutral'>//        |amountSpecified|          1          2 ** 111</span>
 2089 |     | <span class='neutral'>//       ------------------- * ------------- * ---------- == +oo&#39;.</span>
 2090 |     | <span class='neutral'>//        sqrtInverseOffset     sharesTotal      growth</span>
 2091 |     | <span class='neutral'>//</span>
 2092 |     | <span class='neutral'>//    With each increment of &#39;incomingCurrentToTarget&#39; we check whether it has</span>
 2093 |     | <span class='neutral'>//    exceeded &#39;integralLimit&#39; in which case the swap is halted (alternatively,</span>
 2094 |     | <span class='neutral'>//    in the case where &#39;exactInput == false&#39;, we need to continuously check</span>
 2095 |     | <span class='neutral'>//    whether &#39;currentToTarget&#39; has exceeded &#39;integralLimit&#39; or not). However,</span>
 2096 |     | <span class='neutral'>//    this stopping criteria does not apply to this example because</span>
 2097 |     | <span class='neutral'>//    &#39;integralLimit == +oo&#39;.</span>
 2098 |     | <span class='neutral'>//</span>
 2099 |     | <span class='neutral'>//    Hence, we can move forward until the stopping criteria (b) is met, i.e.,</span>
 2100 |     | <span class='neutral'>//    until</span>
 2101 |     | <span class='neutral'>//</span>
 2102 |     | <span class='neutral'>//      &#39;qTarget == qLimit&#39;.</span>
 2103 |     | <span class='neutral'>//</span>
 2104 |     | <span class='neutral'>//    Once the above condition is met, we need to update a number of</span>
 2105 |     | <span class='neutral'>//    parameters, including:</span>
 2106 |     | <span class='neutral'>//</span>
 2107 |     | <span class='neutral'>//    - &#39;amount0&#39;: As discussed in the prior steps, the following increment</span>
 2108 |     | <span class='neutral'>//      should be applied to &#39;amount0&#39;:</span>
 2109 |     | <span class='neutral'>//                                                               growth</span>
 2110 |     | <span class='neutral'>//        &#39;amount0Partial := sqrtInverseOffset * sharesTotal * ---------- *</span>
 2111 |     | <span class='neutral'>//                                                              2 ** 111</span>
 2112 |     | <span class='neutral'>//                            incomingCurrentToTarget</span>
 2113 |     | <span class='neutral'>//                           -------------------------&#39;</span>
 2114 |     | <span class='neutral'>//                                  outgoingMax</span>
 2115 |     | <span class='neutral'>//</span>
 2116 |     | <span class='neutral'>//    - &#39;amount1&#39;: As discussed in the prior steps, the following decrement</span>
 2117 |     | <span class='neutral'>//      should be applied to &#39;amount1&#39;:</span>
 2118 |     | <span class='neutral'>//                                                        growth</span>
 2119 |     | <span class='neutral'>//        &#39;amount1Partial := sqrtOffset * sharesTotal * ---------- *</span>
 2120 |     | <span class='neutral'>//                                                       2 ** 111</span>
 2121 |     | <span class='neutral'>//                            currentToTarget</span>
 2122 |     | <span class='neutral'>//                           -----------------&#39;</span>
 2123 |     | <span class='neutral'>//                              outgoingMax</span>
 2124 |     | <span class='neutral'>//</span>
 2125 |     | <span class='neutral'>//    - &#39;amountSpecified&#39;: Since the swap is partially fulfilled, we should</span>
 2126 |     | <span class='neutral'>//      decrement &#39;amountSpecified&#39; by &#39;amount0Partial&#39; to reflect this:</span>
 2127 |     | <span class='neutral'>//</span>
 2128 |     | <span class='neutral'>//        &#39;amountSpecified -= amount0Partial&#39;.</span>
 2129 |     | <span class='neutral'>//</span>
 2130 |     | <span class='neutral'>//    - &#39;qCurrent&#39;: Since we moved the price of the pool to &#39;qLimit&#39;, the value</span>
 2131 |     | <span class='neutral'>//      for &#39;qCurrent&#39; in memory (i.e., the content of the memory space which</span>
 2132 |     | <span class='neutral'>//      is pointed to by &#39;_logPriceCurrent_&#39;) should be updated to</span>
 2133 |     | <span class='neutral'>//</span>
 2134 |     | <span class='neutral'>//        &#39;qCurrent := qTarget&#39;.</span>
 2135 |     | <span class='neutral'>//</span>
 2136 |     | <span class='neutral'>//      This is illustrated as follows:</span>
 2137 |     | <span class='neutral'>//</span>
 2138 |     | <span class='neutral'>//                qTarget</span>
 2139 |     | <span class='neutral'>//                   |</span>
 2140 |     | <span class='neutral'>//                qLimit</span>
 2141 |     | <span class='neutral'>//                   |</span>
 2142 |     | <span class='neutral'>//      ... &lt;--+-------------+-------------+-------------+-------------+--&gt; ...</span>
 2143 |     | <span class='neutral'>//             |     |       |</span>
 2144 |     | <span class='neutral'>//           qNext   |     qBack</span>
 2145 |     | <span class='neutral'>//                   |</span>
 2146 |     | <span class='neutral'>//               qCurrent</span>
 2147 |     | <span class='neutral'>//</span>
 2148 |     | <span class='neutral'>//    - &#39;curve&#39; and &#39;growth&#39;: Now that the target price is determined as well</span>
 2149 |     | <span class='neutral'>//      as the outgoing and incoming amounts, we need to update the AMM curve </span>
 2150 |     | <span class='neutral'>//      in preparation for the next swap. To this end, the curve sequence</span>
 2151 |     | <span class='neutral'>//      should be amended. In doing so, we need to respect certain</span>
 2152 |     | <span class='neutral'>//      requirements:</span>
 2153 |     | <span class='neutral'>//</span>
 2154 |     | <span class='neutral'>//      Firstly, remember that the last member of the curve sequence should</span>
 2155 |     | <span class='neutral'>//      always correspond to the current price of the pool, i.e., &#39;qCurrent&#39;.</span>
 2156 |     | <span class='neutral'>//      Now that we have set &#39;qCurrent&#39; to &#39;qTarget&#39; the curve sequence should</span>
 2157 |     | <span class='neutral'>//      be amended with this new value in preparation for the next swap.</span>
 2158 |     | <span class='neutral'>//</span>
 2159 |     | <span class='neutral'>//      Secondly, we should be mindful of the fact that amending the curve</span>
 2160 |     | <span class='neutral'>//      sequence changes the liquidity distribution function from &#39;k(w(.))&#39; to</span>
 2161 |     | <span class='neutral'>//      &#39;k(wAmended(.))&#39; and we need to make sure that this change does not</span>
 2162 |     | <span class='neutral'>//      affect our accounting of the total interval reserves with respect to</span>
 2163 |     | <span class='neutral'>//      both tags. More precisely, the curve sequence must be amended subject</span>
 2164 |     | <span class='neutral'>//      to the following constraints:</span>
 2165 |     | <span class='neutral'>//</span>
 2166 |     | <span class='neutral'>//        &#39;totalReserveOfTag0Before == totalReserveOfTag0After&#39;</span>
 2167 |     | <span class='neutral'>//</span>
 2168 |     | <span class='neutral'>//        &#39;totalReserveOfTag1Before == totalReserveOfTag1After&#39;</span>
 2169 |     | <span class='neutral'>//</span>
 2170 |     | <span class='neutral'>//      where &#39;totalReserveOfTag0Before&#39; and &#39;totalReserveOfTag1Before&#39;,</span>
 2171 |     | <span class='neutral'>//      respectively, are the total reserves of &#39;tag0&#39; and &#39;tag1&#39; within</span>
 2172 |     | <span class='neutral'>//      &#39;[qLower, qUpper]&#39; that are calculated based on &#39;k(w(.))&#39;, whereas</span>
 2173 |     | <span class='neutral'>//      &#39;totalReserveOfTag0After&#39; and &#39;totalReserveOfTag1After&#39; are the same</span>
 2174 |     | <span class='neutral'>//      amounts that are calculated based on &#39;k(wAmended(.))&#39;.</span>
 2175 |     | <span class='neutral'>//</span>
 2176 |     | <span class='neutral'>//      The two sides of the first equation can be derived as:</span>
 2177 |     | <span class='neutral'>//</span>
 2178 |     | <span class='neutral'>//        &#39;totalReserveOfTag0Before := sqrtInverseOffset * sharesTotal * </span>
 2179 |     | <span class='neutral'>//</span>
 2180 |     | <span class='neutral'>//                                         - 8     / qUpper</span>
 2181 |     | <span class='neutral'>//           growth       2 ** 216       e        |    - h / 2</span>
 2182 |     | <span class='neutral'>//         ---------- * ------------- * ------- * |  e         k(w(h)) dh&#39;,</span>
 2183 |     | <span class='neutral'>//          2 ** 111     outgoingMax       2      |</span>
 2184 |     | <span class='neutral'>//                                               / qTarget</span>
 2185 |     | <span class='neutral'>//      and</span>
 2186 |     | <span class='neutral'>//</span>
 2187 |     | <span class='neutral'>//        &#39;totalReserveOfTag0After := </span>
 2188 |     | <span class='neutral'>//</span>
 2189 |     | <span class='neutral'>//                                            growthAmended</span>
 2190 |     | <span class='neutral'>//         sqrtInverseOffset * sharesTotal * --------------- *</span>
 2191 |     | <span class='neutral'>//                                               2 ** 111</span>
 2192 |     | <span class='neutral'>//</span>
 2193 |     | <span class='neutral'>//                            - 8     / qUpper</span>
 2194 |     | <span class='neutral'>//           2 ** 216       e        |    - h / 2</span>
 2195 |     | <span class='neutral'>//         ------------- * ------- * |  e         k(wAmended(h)) dh&#39;,</span>
 2196 |     | <span class='neutral'>//          outgoingMax       2      |</span>
 2197 |     | <span class='neutral'>//                                  / qTarget</span>
 2198 |     | <span class='neutral'>//</span>
 2199 |     | <span class='neutral'>//      which simplify the first equation to:</span>
 2200 |     | <span class='neutral'>//</span>
 2201 |     | <span class='neutral'>//                               / qUpper</span>
 2202 |     | <span class='neutral'>//                              |    - h / 2</span>
 2203 |     | <span class='neutral'>//                              |  e         k(wAmended(h)) dh</span>
 2204 |     | <span class='neutral'>//                              |</span>
 2205 |     | <span class='neutral'>//              growth         / qTarget</span>
 2206 |     | <span class='neutral'>//        &#39;--------------- == ---------------------------------&#39;.</span>
 2207 |     | <span class='neutral'>//          growthAmended           / qUpper</span>
 2208 |     | <span class='neutral'>//                                 |    - h / 2</span>
 2209 |     | <span class='neutral'>//                                 |  e         k(w(h)) dh</span>
 2210 |     | <span class='neutral'>//                                 |</span>
 2211 |     | <span class='neutral'>//                                / qTarget</span>
 2212 |     | <span class='neutral'>//</span>
 2213 |     | <span class='neutral'>//      The two sides of the second equation can be derived as:</span>
 2214 |     | <span class='neutral'>//</span>
 2215 |     | <span class='neutral'>//        &#39;totalReserveOfTag1Before := sqrtOffset * sharesTotal * </span>
 2216 |     | <span class='neutral'>//</span>
 2217 |     | <span class='neutral'>//                                         - 8     / qTarget</span>
 2218 |     | <span class='neutral'>//           growth       2 ** 216       e        |    + h / 2</span>
 2219 |     | <span class='neutral'>//         ---------- * ------------- * ------- * |  e         k(w(h)) dh&#39;,</span>
 2220 |     | <span class='neutral'>//          2 ** 111     outgoingMax       2      |</span>
 2221 |     | <span class='neutral'>//                                               / qLower</span>
 2222 |     | <span class='neutral'>//      and</span>
 2223 |     | <span class='neutral'>//</span>
 2224 |     | <span class='neutral'>//        &#39;totalReserveOfTag1After := </span>
 2225 |     | <span class='neutral'>//</span>
 2226 |     | <span class='neutral'>//                                     growthAmended      2 ** 216</span>
 2227 |     | <span class='neutral'>//         sqrtOffset * sharesTotal * --------------- * ------------- *</span>
 2228 |     | <span class='neutral'>//                                        2 ** 111       outgoingMax</span>
 2229 |     | <span class='neutral'>//</span>
 2230 |     | <span class='neutral'>//            - 8     / qTarget</span>
 2231 |     | <span class='neutral'>//          e        |    + h / 2</span>
 2232 |     | <span class='neutral'>//         ------- * |  e         k(wAmended(h)) dh&#39;,</span>
 2233 |     | <span class='neutral'>//            2      |</span>
 2234 |     | <span class='neutral'>//                  / qLower</span>
 2235 |     | <span class='neutral'>//</span>
 2236 |     | <span class='neutral'>//      which simplifies the second equation to:</span>
 2237 |     | <span class='neutral'>//</span>
 2238 |     | <span class='neutral'>//                               / qTarget</span>
 2239 |     | <span class='neutral'>//                              |    + h / 2</span>
 2240 |     | <span class='neutral'>//                              |  e         k(wAmended(h)) dh</span>
 2241 |     | <span class='neutral'>//                              |</span>
 2242 |     | <span class='neutral'>//            growth           / qLower</span>
 2243 |     | <span class='neutral'>//        &#39;--------------- == ---------------------------------&#39;.</span>
 2244 |     | <span class='neutral'>//          growthAmended           / qTarget</span>
 2245 |     | <span class='neutral'>//                                 |    + h / 2</span>
 2246 |     | <span class='neutral'>//                                 |  e         k(w(h)) dh</span>
 2247 |     | <span class='neutral'>//                                 |</span>
 2248 |     | <span class='neutral'>//                                / qLower</span>
 2249 |     | <span class='neutral'>//</span>
 2250 |     | <span class='neutral'>//      Based on the above equations, finding &#39;growthAmended&#39; with respect to</span>
 2251 |     | <span class='neutral'>//      &#39;k(w(.))&#39; and &#39;k(wAmended(.))&#39; is straightforward.</span>
 2252 |     | <span class='neutral'>//</span>
 2253 |     | <span class='neutral'>//      However, in order to satisfy both of the equations, we should have:</span>
 2254 |     | <span class='neutral'>//</span>
 2255 |     | <span class='neutral'>//            / qTarget                         / qUpper</span>
 2256 |     | <span class='neutral'>//           |   + h/2                         |   - h/2</span>
 2257 |     | <span class='neutral'>//           |  e      k(wAmended(h)) dh       |  e      k(wAmended(h)) dh</span>
 2258 |     | <span class='neutral'>//           |                                 |</span>
 2259 |     | <span class='neutral'>//          / qLower                          / qTarget</span>
 2260 |     | <span class='neutral'>//        &#39;------------------------------ == ------------------------------&#39;.</span>
 2261 |     | <span class='neutral'>//               / qTarget                         / qUpper</span>
 2262 |     | <span class='neutral'>//              |    + h/2                        |    - h/2</span>
 2263 |     | <span class='neutral'>//              |  e       k(w(h)) dh             |  e       k(w(h)) dh</span>
 2264 |     | <span class='neutral'>//              |                                 |</span>
 2265 |     | <span class='neutral'>//             / qLower                          / qTarget</span>
 2266 |     | <span class='neutral'>//</span>
 2267 |     | <span class='neutral'>//      Because of the above constraint, we need to take an additional step</span>
 2268 |     | <span class='neutral'>//      prior to amending the curve sequence with &#39;qTarget&#39;.</span>
 2269 |     | <span class='neutral'>//</span>
 2270 |     | <span class='neutral'>//      Observe that the current curve sequence is last updated when we</span>
 2271 |     | <span class='neutral'>//      transitioned into &#39;[qLower, qUpper]&#39; and it is composed of the</span>
 2272 |     | <span class='neutral'>//      following two points:</span>
 2273 |     | <span class='neutral'>//</span>
 2274 |     | <span class='neutral'>//        &#39;q[0] := qLower&#39;,</span>
 2275 |     | <span class='neutral'>//        &#39;q[1] := qUpper&#39;.</span>
 2276 |     | <span class='neutral'>//</span>
 2277 |     | <span class='neutral'>//      The corresponding diagram for the current curve sequence is illustrated</span>
 2278 |     | <span class='neutral'>//      as follows:</span>
 2279 |     | <span class='neutral'>//</span>
 2280 |     | <span class='neutral'>//            w(q)</span>
 2281 |     | <span class='neutral'>//              ^</span>
 2282 |     | <span class='neutral'>//      spacing |                /</span>
 2283 |     | <span class='neutral'>//              |               /</span>
 2284 |     | <span class='neutral'>//              |              /</span>
 2285 |     | <span class='neutral'>//              |             /</span>
 2286 |     | <span class='neutral'>//              |            /</span>
 2287 |     | <span class='neutral'>//              |           /</span>
 2288 |     | <span class='neutral'>//              |          /</span>
 2289 |     | <span class='neutral'>//              |\</span>
 2290 |     | <span class='neutral'>//              | \</span>
 2291 |     | <span class='neutral'>//              |  \</span>
 2292 |     | <span class='neutral'>//              |   \</span>
 2293 |     | <span class='neutral'>//              |        /</span>
 2294 |     | <span class='neutral'>//              |       /</span>
 2295 |     | <span class='neutral'>//              |      /</span>
 2296 |     | <span class='neutral'>//              |     /</span>
 2297 |     | <span class='neutral'>//            0 +----+----+-------+-&gt; q</span>
 2298 |     | <span class='neutral'>//           qLower  |    |       |</span>
 2299 |     | <span class='neutral'>//                   |   q[2]  qUpper</span>
 2300 |     | <span class='neutral'>//                   |</span>
 2301 |     | <span class='neutral'>//               qCurrent</span>
 2302 |     | <span class='neutral'>//</span>
 2303 |     | <span class='neutral'>//            w(q)</span>
 2304 |     | <span class='neutral'>//              ^</span>
 2305 |     | <span class='neutral'>//      spacing |\</span>
 2306 |     | <span class='neutral'>//              | \</span>
 2307 |     | <span class='neutral'>//              |  \</span>
 2308 |     | <span class='neutral'>//              |   \</span>
 2309 |     | <span class='neutral'>//              |    \</span>
 2310 |     | <span class='neutral'>//              |     \</span>
 2311 |     | <span class='neutral'>//              |      \</span>
 2312 |     | <span class='neutral'>//              |       \</span>
 2313 |     | <span class='neutral'>//              |        \</span>
 2314 |     | <span class='neutral'>//              |         \</span>
 2315 |     | <span class='neutral'>//              |          \</span>
 2316 |     | <span class='neutral'>//              |           \</span>
 2317 |     | <span class='neutral'>//              |            \</span>
 2318 |     | <span class='neutral'>//              |             \</span>
 2319 |     | <span class='neutral'>//              |              \</span>
 2320 |     | <span class='neutral'>//            0 +-------+------+-&gt; q</span>
 2321 |     | <span class='neutral'>//           qLower     |      |</span>
 2322 |     | <span class='neutral'>//                      |    qUpper</span>
 2323 |     | <span class='neutral'>//                      |</span>
 2324 |     | <span class='neutral'>//                   qTarget</span>
 2325 |     | <span class='neutral'>//</span>
 2326 |     | <span class='neutral'>//      Before amending the curve sequence with &#39;qTarget&#39;, we first determine a</span>
 2327 |     | <span class='neutral'>//      point between &#39;qTarget&#39; and &#39;qNext == qLower&#39; which is regarded as</span>
 2328 |     | <span class='neutral'>//      &#39;qOvershoot&#39;:</span>
 2329 |     | <span class='neutral'>//</span>
 2330 |     | <span class='neutral'>//            w(q)</span>
 2331 |     | <span class='neutral'>//              ^</span>
 2332 |     | <span class='neutral'>//      spacing |\</span>
 2333 |     | <span class='neutral'>//              | \</span>
 2334 |     | <span class='neutral'>//              |  \</span>
 2335 |     | <span class='neutral'>//              |   \</span>
 2336 |     | <span class='neutral'>//              |    \</span>
 2337 |     | <span class='neutral'>//              |     \</span>
 2338 |     | <span class='neutral'>//              |      \</span>
 2339 |     | <span class='neutral'>//              |       \</span>
 2340 |     | <span class='neutral'>//              |        \</span>
 2341 |     | <span class='neutral'>//              |         \</span>
 2342 |     | <span class='neutral'>//              |          \</span>
 2343 |     | <span class='neutral'>//              |           \</span>
 2344 |     | <span class='neutral'>//              |            \</span>
 2345 |     | <span class='neutral'>//              |             \</span>
 2346 |     | <span class='neutral'>//              |              \</span>
 2347 |     | <span class='neutral'>//              |               \</span>
 2348 |     | <span class='neutral'>//              |                \</span>
 2349 |     | <span class='neutral'>//            0 +----+----+-------+-&gt; q</span>
 2350 |     | <span class='neutral'>//           qLower  |    |       |</span>
 2351 |     | <span class='neutral'>//                   |    |     qUpper</span>
 2352 |     | <span class='neutral'>//                   |    |</span>
 2353 |     | <span class='neutral'>//                   | qTarget</span>
 2354 |     | <span class='neutral'>//                   |</span>
 2355 |     | <span class='neutral'>//               qOvershoot</span>
 2356 |     | <span class='neutral'>//</span>
 2357 |     | <span class='neutral'>//      Then, the curve sequence is amended with &#39;qOvershoot&#39; which leads to</span>
 2358 |     | <span class='neutral'>//      the following sequence:</span>
 2359 |     | <span class='neutral'>//</span>
 2360 |     | <span class='neutral'>//        &#39;q[0] := qUpper&#39;,</span>
 2361 |     | <span class='neutral'>//        &#39;q[1] := qLower&#39;,</span>
 2362 |     | <span class='neutral'>//        &#39;q[2] := qOvershoot&#39;.</span>
 2363 |     | <span class='neutral'>//</span>
 2364 |     | <span class='neutral'>//      and the following diagram:</span>
 2365 |     | <span class='neutral'>//</span>
 2366 |     | <span class='neutral'>//              ^</span>
 2367 |     | <span class='neutral'>//      spacing |\</span>
 2368 |     | <span class='neutral'>//              | \</span>
 2369 |     | <span class='neutral'>//              |  \</span>
 2370 |     | <span class='neutral'>//              |                /</span>
 2371 |     | <span class='neutral'>//              |               /</span>
 2372 |     | <span class='neutral'>//              |              /</span>
 2373 |     | <span class='neutral'>//              |             /</span>
 2374 |     | <span class='neutral'>//              |            /</span>
 2375 |     | <span class='neutral'>//              |           /</span>
 2376 |     | <span class='neutral'>//              |          /</span>
 2377 |     | <span class='neutral'>//              |         /</span>
 2378 |     | <span class='neutral'>//              |        /</span>
 2379 |     | <span class='neutral'>//              |       /</span>
 2380 |     | <span class='neutral'>//              |      /</span>
 2381 |     | <span class='neutral'>//              |     /</span>
 2382 |     | <span class='neutral'>//            0 +----+----+-------+-&gt; q</span>
 2383 |     | <span class='neutral'>//           qLower  |    |       |</span>
 2384 |     | <span class='neutral'>//                   |    |     qUpper</span>
 2385 |     | <span class='neutral'>//                   |    |</span>
 2386 |     | <span class='neutral'>//                   |  qTarget</span>
 2387 |     | <span class='neutral'>//                   |</span>
 2388 |     | <span class='neutral'>//               qOvershoot</span>
 2389 |     | <span class='neutral'>//</span>
 2390 |     | <span class='neutral'>//      In this case, amending the curve sequence has increased its length.</span>
 2391 |     | <span class='neutral'>//      However, this is not always the case. As explained in &#39;Curve.sol&#39;, this</span>
 2392 |     | <span class='neutral'>//      process may involve clearing a number of members from the end of the</span>
 2393 |     | <span class='neutral'>//      curve sequence and then inserting the new member.</span>
 2394 |     | <span class='neutral'>//</span>
 2395 |     | <span class='neutral'>//      After the amendment with &#39;qOvershoot&#39;, the resulting curve sequence is</span>
 2396 |     | <span class='neutral'>//      then amended with &#39;qTarget&#39; which leads to the following sequence:</span>
 2397 |     | <span class='neutral'>//</span>
 2398 |     | <span class='neutral'>//        &#39;q[0] := qUpper&#39;,</span>
 2399 |     | <span class='neutral'>//        &#39;q[1] := qLower&#39;,</span>
 2400 |     | <span class='neutral'>//        &#39;q[2] := qOvershoot&#39;,</span>
 2401 |     | <span class='neutral'>//        &#39;q[3] := qTarget&#39;.</span>
 2402 |     | <span class='neutral'>//</span>
 2403 |     | <span class='neutral'>//      and the following diagram:</span>
 2404 |     | <span class='neutral'>//</span>
 2405 |     | <span class='neutral'>//          wAmended(q)</span>
 2406 |     | <span class='neutral'>//              ^</span>
 2407 |     | <span class='neutral'>//      spacing |\</span>
 2408 |     | <span class='neutral'>//              | \</span>
 2409 |     | <span class='neutral'>//              |  \</span>
 2410 |     | <span class='neutral'>//              |   \</span>
 2411 |     | <span class='neutral'>//              |                /</span>
 2412 |     | <span class='neutral'>//              |               /</span>
 2413 |     | <span class='neutral'>//              |              /</span>
 2414 |     | <span class='neutral'>//              |             /</span>
 2415 |     | <span class='neutral'>//              |            /</span>
 2416 |     | <span class='neutral'>//              |           /</span>
 2417 |     | <span class='neutral'>//              |          /</span>
 2418 |     | <span class='neutral'>//              |     \</span>
 2419 |     | <span class='neutral'>//              |      \</span>
 2420 |     | <span class='neutral'>//              |       \</span>
 2421 |     | <span class='neutral'>//              |        \</span>
 2422 |     | <span class='neutral'>//            0 +----+----+-------+-&gt; q</span>
 2423 |     | <span class='neutral'>//           qLower  |    |       |</span>
 2424 |     | <span class='neutral'>//                   |    |     qUpper</span>
 2425 |     | <span class='neutral'>//                   |    |</span>
 2426 |     | <span class='neutral'>//                   | qTarget</span>
 2427 |     | <span class='neutral'>//                   |</span>
 2428 |     | <span class='neutral'>//               qOvershoot</span>
 2429 |     | <span class='neutral'>//</span>
 2430 |     | <span class='neutral'>//      The purpose of first amending with &#39;qOvershoot&#39; is to have an</span>
 2431 |     | <span class='neutral'>//      additional degree of freedom in order to satisfy the equation:</span>
 2432 |     | <span class='neutral'>//</span>
 2433 |     | <span class='neutral'>//        &#39;f(qOvershoot) == 0&#39;</span>
 2434 |     | <span class='neutral'>//</span>
 2435 |     | <span class='neutral'>//      where</span>
 2436 |     | <span class='neutral'>//</span>
 2437 |     | <span class='neutral'>//        &#39;f(qOvershoot) :=</span>
 2438 |     | <span class='neutral'>//</span>
 2439 |     | <span class='neutral'>//            / qUpper                         / qTarget</span>
 2440 |     | <span class='neutral'>//           |   - h/2                        |   + h/2</span>
 2441 |     | <span class='neutral'>//           |  e      k(wAmended(h)) dh      |  e      k(wAmended(h)) dh</span>
 2442 |     | <span class='neutral'>//           |                                |</span>
 2443 |     | <span class='neutral'>//          / qTarget                        / qLower</span>
 2444 |     | <span class='neutral'>//         ------------------------------ - ------------------------------&#39;.</span>
 2445 |     | <span class='neutral'>//               / qUpper                         / qTarget</span>
 2446 |     | <span class='neutral'>//              |    - h/2                       |    + h/2</span>
 2447 |     | <span class='neutral'>//              |  e       k(w(h)) dh            |  e       k(w(h)) dh</span>
 2448 |     | <span class='neutral'>//              |                                |</span>
 2449 |     | <span class='neutral'>//             / qTarget                        / qLower</span>
 2450 |     | <span class='neutral'>//</span>
 2451 |     | <span class='neutral'>//      By investigating the above equation, we can observe that:</span>
 2452 |     | <span class='neutral'>//</span>
 2453 |     | <span class='neutral'>//        - Both of the denominators are fixed. This is because at this stage,</span>
 2454 |     | <span class='neutral'>//          &#39;qTarget&#39; is fully determined either through &#39;qLimit&#39; or</span>
 2455 |     | <span class='neutral'>//          &#39;amountSpecified&#39;. Additionally, the current curve sequence is</span>
 2456 |     | <span class='neutral'>//          fixed which dictates the shape of &#39;w(.)&#39;.</span>
 2457 |     | <span class='neutral'>//</span>
 2458 |     | <span class='neutral'>//        - Both of the numerators are functions of &#39;qOvershoot&#39;. This is</span>
 2459 |     | <span class='neutral'>//          because &#39;wAmended(.)&#39; can be fully characterized by</span>
 2460 |     | <span class='neutral'>//</span>
 2461 |     | <span class='neutral'>//            - the current curve sequence which is fixed,</span>
 2462 |     | <span class='neutral'>//</span>
 2463 |     | <span class='neutral'>//            - &#39;qTarget&#39; which is also fixed,</span>
 2464 |     | <span class='neutral'>//</span>
 2465 |     | <span class='neutral'>//            - and &#39;qOvershoot&#39; which is the only unknown value that we are</span>
 2466 |     | <span class='neutral'>//              trying to determine.</span>
 2467 |     | <span class='neutral'>//</span>
 2468 |     | <span class='neutral'>//      Hence, in order to update the liquidity distribution function from</span>
 2469 |     | <span class='neutral'>//      &#39;k(w(.))&#39; to &#39;k(wAmended(.))&#39;, which updates the AMM diagram of the</span>
 2470 |     | <span class='neutral'>//      active interval, we need to solve the above equation with respect to</span>
 2471 |     | <span class='neutral'>//      &#39;qOvershoot&#39;. As proven in nofeeswap&#39;s yellowpaper, there always exist</span>
 2472 |     | <span class='neutral'>//      a root between &#39;qTarget&#39; and &#39;qNext&#39; that satisfies:</span>
 2473 |     | <span class='neutral'>//</span>
 2474 |     | <span class='neutral'>//        &#39;growthAmended &gt;= growth&#39;.</span>
 2475 |     | <span class='neutral'>//</span>
 2476 |     | <span class='neutral'>//      This root is found via numerical search by running the methods</span>
 2477 |     | <span class='neutral'>//      &#39;moveOvershoot&#39; and &#39;searchOvershoot&#39; from &#39;Interval.sol&#39;.</span>
 2478 |     | <span class='neutral'>//</span>
 2479 |     | <span class='neutral'>//      Remember that &#39;k(w(.))&#39; and &#39;k(wAmended(.))&#39; are piecewise linear</span>
 2480 |     | <span class='neutral'>//      functions whose domains cover the entire active interval. The method</span>
 2481 |     | <span class='neutral'>//      &#39;moveOvershoot&#39; from &#39;Interval.sol&#39; identifies a range within</span>
 2482 |     | <span class='neutral'>//      &#39;[qLower, qUpper]&#39;:</span>
 2483 |     | <span class='neutral'>//</span>
 2484 |     | <span class='neutral'>//        - in which &#39;k(w(.))&#39; is linear,</span>
 2485 |     | <span class='neutral'>//</span>
 2486 |     | <span class='neutral'>//        - in which &#39;k(wAmended(.))&#39; is linear, and</span>
 2487 |     | <span class='neutral'>//</span>
 2488 |     | <span class='neutral'>//        - to which &#39;qOvershoot&#39; belongs.</span>
 2489 |     | <span class='neutral'>//</span>
 2490 |     | <span class='neutral'>//      Since &#39;f(.)&#39; is a continuous function, the membership of a root (i.e.,</span>
 2491 |     | <span class='neutral'>//      &#39;qOvershoot&#39;) to a particular range can be verified by evaluating the</span>
 2492 |     | <span class='neutral'>//      sign of &#39;f(.)&#39; at the two ends of the range. Hence, in light of the</span>
 2493 |     | <span class='neutral'>//      intermediate value theorem, if the signs at the two ends of the range</span>
 2494 |     | <span class='neutral'>//      are different, then there has to be a root somewhere within this</span>
 2495 |     | <span class='neutral'>//      range.</span>
 2496 |     | <span class='neutral'>//</span>
 2497 |     | <span class='neutral'>//      Next, the method &#39;searchOvershoot&#39; from &#39;Interval.sol&#39; performs a</span>
 2498 |     | <span class='neutral'>//      Newton search in order to pinpoint the precise value of &#39;qOvershoot&#39;</span>
 2499 |     | <span class='neutral'>//      within the range that is identified by &#39;moveOvershoot&#39;.</span>
 2500 |     | <span class='neutral'>//</span>
 2501 |     | <span class='neutral'>//      Once &#39;qOvershoot&#39; is calculated, we proceed with the two amendments to</span>
 2502 |     | <span class='neutral'>//      the curve sequence via &#39;qOvershoot&#39; and &#39;qTarget&#39;.</span>
 2503 |     | <span class='neutral'>//</span>
 2504 |     | <span class='neutral'>//      After that, we derive &#39;growthAmended&#39; based on the following formula:</span>
 2505 |     | <span class='neutral'>//</span>
 2506 |     | <span class='neutral'>//                                          / qTarget</span>
 2507 |     | <span class='neutral'>//                                         |    + h / 2</span>
 2508 |     | <span class='neutral'>//                                         |  e         k(w(h)) dh</span>
 2509 |     | <span class='neutral'>//                                         |</span>
 2510 |     | <span class='neutral'>//                                        / qLower</span>
 2511 |     | <span class='neutral'>//        &#39;growthAmended == growth * ---------------------------------&#39;.</span>
 2512 |     | <span class='neutral'>//                                      / qTarget</span>
 2513 |     | <span class='neutral'>//                                     |    + h / 2</span>
 2514 |     | <span class='neutral'>//                                     |  e         k(wAmended(h)) dh</span>
 2515 |     | <span class='neutral'>//                                     |</span>
 2516 |     | <span class='neutral'>//                                    / qLower</span>
 2517 |     | <span class='neutral'>//</span>
 2518 |     | <span class='neutral'>//      This concludes the update of our liquidity distribution function (or</span>
 2519 |     | <span class='neutral'>//      equivalently, the update of our AMM diagram) for the next swap.</span>
 2520 |     | <span class='neutral'>//</span>
 2521 |     | <span class='neutral'>//  - The last step involves writing the dynamic parameters of the pool as well</span>
 2522 |     | <span class='neutral'>//    as the amended curve sequence in the protocol&#39;s storage which concludes</span>
 2523 |     | <span class='neutral'>//    this example.</span>
 2524 |     | <span class='neutral'></span>
 2525 |     | <span class='neutral'>// Swap Inputs</span>
 2526 |     | <span class='neutral'>// ----------------------------------------------------------------------------</span>
 2527 |     | <span class='neutral'>// The following memory pointers correspond to the inputs of the method &#39;swap&#39;</span>
 2528 |     | <span class='neutral'>// from &#39;Nofeeswap.sol&#39;. Each parameter is read from calldata via the method</span>
 2529 |     | <span class='neutral'>// &#39;readSwapInput&#39; from &#39;Calldata.sol&#39;. Then, the parameters are transformed to</span>
 2530 |     | <span class='neutral'>// appropriate formats and stored in their dedicated memory locations as listed</span>
 2531 |     | <span class='neutral'>// below. Throughout the execution of the swap, the following memory pointers</span>
 2532 |     | <span class='neutral'>// as well as the corresponding getter functions can be used to access each</span>
 2533 |     | <span class='neutral'>// parameter. Moreover, when invoking an applicable hook these input parameters</span>
 2534 |     | <span class='neutral'>// are passed to the hook as calldata and they can be accessed via the</span>
 2535 |     | <span class='neutral'>// corresponding calldata pointers and getter functions that are listed in</span>
 2536 |     | <span class='neutral'>// &#39;HookCalldata.sol&#39;.</span>
 2537 |     | <span class='unexecuted'>uint16 constant _swapInput_ = 248;</span>
 2538 |     | <span class='neutral'></span>
 2539 |     | <span class='neutral'>// &#39;crossThreshold&#39; refers to a minimum limit on the total number of shares</span>
 2540 |     | <span class='neutral'>// that should be available in any interval for the &#39;swap&#39; method to transact</span>
 2541 |     | <span class='neutral'>// in that interval.</span>
 2542 |     | <span class='neutral'>//</span>
 2543 |     | <span class='neutral'>// For example, if &#39;crossThreshold == 50&#39;, then there has to be a minimum of</span>
 2544 |     | <span class='neutral'>// 50 shares present in an interval so that the algorithm either enters that</span>
 2545 |     | <span class='neutral'>// interval or crosses it entirely. Once we encounter an interval with the</span>
 2546 |     | <span class='neutral'>// total number of shares less than 50, the &#39;swap&#39; call is halted and the price</span>
 2547 |     | <span class='neutral'>// of the pool does not go beyond that point.</span>
 2548 |     | <span class='neutral'>//</span>
 2549 |     | <span class='neutral'>// However, if &#39;crossThreshold == 0&#39;, which is the default, no minimum number</span>
 2550 |     | <span class='neutral'>// of shares is imposed.</span>
 2551 |     | <span class='neutral'>//</span>
 2552 |     | <span class='neutral'>// The calldata layout of the method &#39;swap&#39; in &#39;Nofeeswap.sol&#39; does not have a</span>
 2553 |     | <span class='neutral'>// slot dedicated to &#39;crossThreshold&#39;. Instead, the two inputs &#39;crossThreshold&#39;</span>
 2554 |     | <span class='neutral'>// and &#39;zeroForOne&#39; share the same slot in calldata as illustrated below:</span>
 2555 |     | <span class='neutral'>//</span>
 2556 |     | <span class='neutral'>//     +---------------------------+---------------------------+</span>
 2557 |     | <span class='neutral'>//     | crossThreshold (128 bits) |   zeroForOne (128 bits)   |</span>
 2558 |     | <span class='neutral'>//     +---------------------------+---------------------------+</span>
 2559 |     | <span class='neutral'>//</span>
 2560 |     | <span class='neutral'>// &#39;crossThreshold&#39; occupies the most significant 128 bits and &#39;zeroForOne&#39;</span>
 2561 |     | <span class='neutral'>// occupies the least significant 128 bits. Hence, 16 bytes are reserved for</span>
 2562 |     | <span class='neutral'>// &#39;crossThreshold&#39; in memory.</span>
 2563 |     | <span class='neutral'>uint16 constant _crossThreshold_ = 248;</span>
 2564 |     | <span class='neutral'></span>
 2565 |     | <span class='neutral'>// The input &#39;amountSpecified&#39; of the &#39;swap&#39; method in &#39;Nofeeswap.sol&#39; is a</span>
 2566 |     | <span class='neutral'>// signed integer. If positive (&#39;exactInput == true&#39;), this value represents</span>
 2567 |     | <span class='neutral'>// the requested incoming amount to be given to the pool as a result of the</span>
 2568 |     | <span class='neutral'>// swap call. If negative (&#39;exactInput == false&#39;), this value represents the</span>
 2569 |     | <span class='neutral'>// requested outgoing amount to be taken from the pool as a result of the swap</span>
 2570 |     | <span class='neutral'>// call. As an initial step of the swap algorithm, the method &#39;readSwapInput&#39;</span>
 2571 |     | <span class='neutral'>// from &#39;Calldata.sol&#39; performs the following actions:</span>
 2572 |     | <span class='neutral'>//</span>
 2573 |     | <span class='neutral'>//  - Reads the integer representation of &#39;amountSpecified&#39; from the dedicated</span>
 2574 |     | <span class='neutral'>//    calldata slot.</span>
 2575 |     | <span class='neutral'>//</span>
 2576 |     | <span class='neutral'>//  - Caps it by &#39;2 ** 127 - 1&#39; from above and by &#39;1 - 2 ** 127&#39; from below.</span>
 2577 |     | <span class='neutral'>//</span>
 2578 |     | <span class='neutral'>//  - Transforms it to the &#39;X127&#39; format.</span>
 2579 |     | <span class='neutral'>//</span>
 2580 |     | <span class='neutral'>//  - Stores the resulting value in the 32 byte memory space which is referred</span>
 2581 |     | <span class='neutral'>//    to by &#39;_amountSpecified_&#39;.</span>
 2582 |     | <span class='neutral'>//</span>
 2583 |     | <span class='neutral'>// Throughout the execution of the swap, &#39;amountSpecified&#39; is partially</span>
 2584 |     | <span class='neutral'>// fulfilled with each interval that we visit and because of this, the content</span>
 2585 |     | <span class='neutral'>// of this memory space is continuously updated.</span>
 2586 |     | <span class='neutral'>//</span>
 2587 |     | <span class='neutral'>// Due to limited granularity of logarithmic price in &#39;X59&#39; representation, a</span>
 2588 |     | <span class='neutral'>// requested amount may not be fulfilled. However,</span>
 2589 |     | <span class='neutral'>//</span>
 2590 |     | <span class='neutral'>//  - if &#39;amountSpecified &gt; 0&#39;, the incoming amount to be given to the pool as</span>
 2591 |     | <span class='neutral'>//    a result of the swap call must not exceed &#39;amountSpecified&#39;.</span>
 2592 |     | <span class='neutral'>//</span>
 2593 |     | <span class='neutral'>//  - if &#39;amountSpecified &lt; 0&#39;, the outgoing amount to be taken from the pool</span>
 2594 |     | <span class='neutral'>//    as a result of the swap call must be greater than or equal to</span>
 2595 |     | <span class='neutral'>//    &#39;0 - amountSpecified&#39;.</span>
 2596 |     | <span class='neutral'>//</span>
 2597 |     | <span class='neutral'>// 32 bytes are reserved for the &#39;X127&#39; representation of &#39;amountSpecified&#39; in</span>
 2598 |     | <span class='neutral'>// memory.</span>
 2599 |     | <span class='neutral'>uint16 constant _amountSpecified_ = 264;</span>
 2600 |     | <span class='neutral'></span>
 2601 |     | <span class='neutral'>// The input &#39;logPriceLimit&#39; of the &#39;swap&#39; method in &#39;Nofeeswap.sol&#39; is a</span>
 2602 |     | <span class='neutral'>// signed value in &#39;X59&#39; format. Define</span>
 2603 |     | <span class='neutral'>//</span>
 2604 |     | <span class='neutral'>//  &#39;pLimit := exp(logPriceLimit / (2 ** 59))&#39;.</span>
 2605 |     | <span class='neutral'>//</span>
 2606 |     | <span class='neutral'>// The input &#39;logPriceLimit&#39; imposes a limit on the price of the pool post</span>
 2607 |     | <span class='neutral'>// execution of the swap call.</span>
 2608 |     | <span class='neutral'>//</span>
 2609 |     | <span class='neutral'>//  - For price increasing swaps, &#39;logPriceLimit&#39; serves as an upper bound, in</span>
 2610 |     | <span class='neutral'>//    which case the price of the pool must not exceed &#39;pLimit&#39;.</span>
 2611 |     | <span class='neutral'>//</span>
 2612 |     | <span class='neutral'>//  - For price decreasing swaps, &#39;logPriceLimit&#39; serves as a lower bound, in</span>
 2613 |     | <span class='neutral'>//    which case the price of the pool must not subceed &#39;pLimit&#39;.</span>
 2614 |     | <span class='neutral'>//</span>
 2615 |     | <span class='neutral'>// In both cases, once the price of the pool reaches &#39;pLimit&#39;, the execution of</span>
 2616 |     | <span class='neutral'>// the swap is halted. Put simply, no amount of tags are traded with any price</span>
 2617 |     | <span class='neutral'>// worst than &#39;pLimit&#39; for the swapper.</span>
 2618 |     | <span class='neutral'>//</span>
 2619 |     | <span class='neutral'>// 32 bytes are reserved for &#39;logPriceLimit&#39; in memory.</span>
 2620 |     | <span class='neutral'>uint16 constant _logPriceLimit_ = 296;</span>
 2621 |     | <span class='neutral'></span>
 2622 |     | <span class='neutral'>// Let &#39;pLower&#39; and &#39;pUpper&#39;, respectively, denote the minimum and maximum</span>
 2623 |     | <span class='neutral'>// price in the current active liquidity interval and define</span>
 2624 |     | <span class='neutral'>//</span>
 2625 |     | <span class='neutral'>//  &#39;qLower := log(pLower / pOffset)&#39;</span>
 2626 |     | <span class='neutral'>//  &#39;qUpper := log(pUpper / pOffset)&#39;</span>
 2627 |     | <span class='neutral'>//  &#39;qSpacing := log(pUpper / pLower)&#39;,</span>
 2628 |     | <span class='neutral'>//  &#39;qMost  := + 16 - 1 / (2 ** 59) - qSpacing&#39;.</span>
 2629 |     | <span class='neutral'>//  &#39;qLeast := - 16 + 1 / (2 ** 59) + qSpacing&#39;.</span>
 2630 |     | <span class='neutral'>//</span>
 2631 |     | <span class='neutral'>// As previously argued, for every integer &#39;j&#39;, the interval</span>
 2632 |     | <span class='neutral'>//</span>
 2633 |     | <span class='neutral'>//  &#39;[qLower + j * qSpacing, qUpper + j * qSpacing]&#39;</span>
 2634 |     | <span class='neutral'>//</span>
 2635 |     | <span class='neutral'>// is a valid liquidity interval if and only if:</span>
 2636 |     | <span class='neutral'>//</span>
 2637 |     | <span class='neutral'>//  &#39;- qMost &lt;= qLower + j * qSpacing&#39;</span>
 2638 |     | <span class='neutral'>//</span>
 2639 |     | <span class='neutral'>// and</span>
 2640 |     | <span class='neutral'>//</span>
 2641 |     | <span class='neutral'>//  &#39;qUpper + j * qSpacing &lt;= + qMost.</span>
 2642 |     | <span class='neutral'>//</span>
 2643 |     | <span class='neutral'>// This includes the current active liquidity interval &#39;[qLower, qUpper]&#39;</span>
 2644 |     | <span class='neutral'>// which corresponds to &#39;j == 0&#39;.</span>
 2645 |     | <span class='neutral'>//</span>
 2646 |     | <span class='neutral'>// Because of this,</span>
 2647 |     | <span class='neutral'>//</span>
 2648 |     | <span class='neutral'>//  &#39;qCurrent := log(pCurrent / pOffset)&#39;</span>
 2649 |     | <span class='neutral'>//</span>
 2650 |     | <span class='neutral'>// always satisfies</span>
 2651 |     | <span class='neutral'>//</span>
 2652 |     | <span class='neutral'>//  &#39;qCurrent &gt;= qLeast + ((qLower - qLeast) % qSpacing)&#39;</span>
 2653 |     | <span class='neutral'>//</span>
 2654 |     | <span class='neutral'>// and</span>
 2655 |     | <span class='neutral'>//</span>
 2656 |     | <span class='neutral'>//  &#39;qCurrent &lt;= qMost - ((qMost - qLower) % qSpacing)&#39;</span>
 2657 |     | <span class='neutral'>//</span>
 2658 |     | <span class='neutral'>// where &#39;pCurrent&#39; is the current price of the pool.</span>
 2659 |     | <span class='neutral'>//</span>
 2660 |     | <span class='neutral'>// In order to enforce the above inequalities, the following value is</span>
 2661 |     | <span class='neutral'>// calculated in the method &#39;setSwapParams&#39; of &#39;swap.sol&#39;:</span>
 2662 |     | <span class='neutral'>//</span>
 2663 |     | <span class='neutral'>//  &#39;qLimit := min(</span>
 2664 |     | <span class='neutral'>//     max(</span>
 2665 |     | <span class='neutral'>//       qLeast + ((qLower - qLeast) % qSpacing),</span>
 2666 |     | <span class='neutral'>//       log(pLimit / pOffset)</span>
 2667 |     | <span class='neutral'>//     ),</span>
 2668 |     | <span class='neutral'>//     qMost - ((qMost - qLower) % qSpacing)</span>
 2669 |     | <span class='neutral'>//   )&#39;</span>
 2670 |     | <span class='neutral'>//</span>
 2671 |     | <span class='neutral'>// based on &#39;qLower&#39;, &#39;qUpper&#39;, and &#39;logPriceLimit&#39;. Then, the offset binary</span>
 2672 |     | <span class='neutral'>// &#39;X59&#39; representation of &#39;qLimit&#39;, i.e.,</span>
 2673 |     | <span class='neutral'>//</span>
 2674 |     | <span class='neutral'>//  &#39;logPriceLimitOffsetted := (2 ** 59) * (16 + qLimit)&#39;</span>
 2675 |     | <span class='neutral'>//</span>
 2676 |     | <span class='neutral'>// is stored in the memory space which is pointed to by</span>
 2677 |     | <span class='neutral'>// &#39;_logPriceLimitOffsetted_&#39;.</span>
 2678 |     | <span class='neutral'>//</span>
 2679 |     | <span class='neutral'>// Because</span>
 2680 |     | <span class='neutral'>// </span>
 2681 |     | <span class='neutral'>//  &#39;- 16 + 1 / (2 ** 59) &lt;= qLimit &lt;= + 16 - 1 / (2 ** 59)&#39;,</span>
 2682 |     | <span class='neutral'>//</span>
 2683 |     | <span class='neutral'>// we have</span>
 2684 |     | <span class='neutral'>//</span>
 2685 |     | <span class='neutral'>//  &#39;1 &lt;= logPriceLimitOffsetted &lt;= (2 ** 64) - 1&#39;,</span>
 2686 |     | <span class='neutral'>//</span>
 2687 |     | <span class='neutral'>// which is why 8 bytes are reserved for &#39;logPriceLimitOffsetted&#39; in memory.</span>
 2688 |     | <span class='neutral'>uint16 constant _logPriceLimitOffsetted_ = 328;</span>
 2689 |     | <span class='neutral'></span>
 2690 |     | <span class='neutral'>// Swap Parameters</span>
 2691 |     | <span class='neutral'>// ----------------------------------------------------------------------------</span>
 2692 |     | <span class='neutral'>// The following memory pointers correspond to a number of secondary parameters</span>
 2693 |     | <span class='neutral'>// that are derived and stored in memory in order to facilitate the execution</span>
 2694 |     | <span class='neutral'>// of each &#39;swap&#39; call. The following memory pointers as well as the</span>
 2695 |     | <span class='neutral'>// corresponding getter functions can be used to access each parameter.</span>
 2696 |     | <span class='neutral'>// Moreover, when invoking either of the &#39;midSwap&#39; and &#39;postSwap&#39; hooks, if</span>
 2697 |     | <span class='neutral'>// applicable, these parameters are included in memory snapshot that is passed</span>
 2698 |     | <span class='neutral'>// to the hook as calldata. Hence they can be accessed via the corresponding</span>
 2699 |     | <span class='neutral'>// calldata pointers and getter functions that are listed in</span>
 2700 |     | <span class='neutral'>// &#39;HookCalldata.sol&#39;.</span>
 2701 |     | <span class='neutral'>uint16 constant _swapParams_ = 336;</span>
 2702 |     | <span class='neutral'></span>
 2703 |     | <span class='neutral'>// As discussed before, the calldata layout of the method &#39;swap&#39; in</span>
 2704 |     | <span class='neutral'>// &#39;Nofeeswap.sol&#39; does not have a slot dedicated to &#39;crossThreshold&#39; or</span>
 2705 |     | <span class='neutral'>// &#39;zeroForOne&#39;. Instead, the two inputs &#39;crossThreshold&#39; and &#39;zeroForOne&#39;</span>
 2706 |     | <span class='neutral'>// share the same slot in calldata as illustrated below:</span>
 2707 |     | <span class='neutral'>//</span>
 2708 |     | <span class='neutral'>//     +---------------------------+---------------------------+</span>
 2709 |     | <span class='neutral'>//     | crossThreshold (128 bits) |   zeroForOne (128 bits)   |</span>
 2710 |     | <span class='neutral'>//     +---------------------------+---------------------------+</span>
 2711 |     | <span class='neutral'>//</span>
 2712 |     | <span class='neutral'>// &#39;crossThreshold&#39; occupies the most significant 128 bits and &#39;zeroForOne&#39;</span>
 2713 |     | <span class='neutral'>// occupies the least significant 128 bits.</span>
 2714 |     | <span class='neutral'>//</span>
 2715 |     | <span class='neutral'>//  - If the given &#39;zeroForOne&#39; input is equal to &#39;0&#39;, then the swap is price</span>
 2716 |     | <span class='neutral'>//    increasing in which case &#39;tag0&#39; is outgoing from the pool and &#39;tag1&#39; is</span>
 2717 |     | <span class='neutral'>//    incoming to the pool.</span>
 2718 |     | <span class='neutral'>//</span>
 2719 |     | <span class='neutral'>//  - If the given &#39;zeroForOne&#39; input is equal to &#39;1&#39;, then the swap is price</span>
 2720 |     | <span class='neutral'>//    decreasing in which case &#39;tag0&#39; is incoming to the pool and &#39;tag1&#39; is</span>
 2721 |     | <span class='neutral'>//    outgoing from the pool.</span>
 2722 |     | <span class='neutral'>//</span>
 2723 |     | <span class='neutral'>//  - If the given &#39;zeroForOne&#39; input is equal to any other value, then the</span>
 2724 |     | <span class='neutral'>//    movement of the price is towards &#39;logPriceLimit&#39;, i.e., the swap is price</span>
 2725 |     | <span class='neutral'>//    increasing if</span>
 2726 |     | <span class='neutral'>//</span>
 2727 |     | <span class='neutral'>//      &#39;pCurrent &lt; pLimit&#39;</span>
 2728 |     | <span class='neutral'>//</span>
 2729 |     | <span class='neutral'>//    and the swap is price decreasing if</span>
 2730 |     | <span class='neutral'>//</span>
 2731 |     | <span class='neutral'>//      &#39;pLimit &lt; pCurrent&#39;</span>
 2732 |     | <span class='neutral'>//</span>
 2733 |     | <span class='neutral'>//    where</span>
 2734 |     | <span class='neutral'>//</span>
 2735 |     | <span class='neutral'>//      &#39;pLimit := exp(logPriceLimit / (2 ** 59))&#39;.</span>
 2736 |     | <span class='neutral'>//</span>
 2737 |     | <span class='neutral'>//    and &#39;pCurrent&#39; represents the current price of the pool.</span>
 2738 |     | <span class='neutral'>//</span>
 2739 |     | <span class='neutral'>// A single byte is reserved for this memory space. After the investigation of</span>
 2740 |     | <span class='neutral'>// calldata and comparing &#39;pCurrent&#39; with &#39;pLimit&#39;,</span>
 2741 |     | <span class='neutral'>//</span>
 2742 |     | <span class='neutral'>//   - If the swap is deemed to be price increasing, then the byte which is</span>
 2743 |     | <span class='neutral'>//     pointed to by &#39;_zeroForOne_&#39; is left as &#39;0x00&#39;.</span>
 2744 |     | <span class='neutral'>//</span>
 2745 |     | <span class='neutral'>//   - If the swap is price decreasing, then this byte is populated with</span>
 2746 |     | <span class='neutral'>//     &#39;0xFF&#39;.</span>
 2747 |     | <span class='neutral'>//</span>
 2748 |     | <span class='neutral'>// The getter function &#39;getZeroForOne&#39; in this script and the getter function</span>
 2749 |     | <span class='neutral'>// &#39;getZeroForOneFromCalldata&#39; in &#39;HookCalldata.sol&#39; give access to the content</span>
 2750 |     | <span class='neutral'>// of this memory space (or calldata in the context of the hook contract) as a</span>
 2751 |     | <span class='neutral'>// boolean with &#39;false&#39; and &#39;true&#39; representing price increasing and price</span>
 2752 |     | <span class='neutral'>// decreasing swaps, respectively.</span>
 2753 |     | <span class='neutral'>uint16 constant _zeroForOne_ = 336;</span>
 2754 |     | <span class='neutral'></span>
 2755 |     | <span class='neutral'>// The input &#39;amountSpecified&#39; of the &#39;swap&#39; method in &#39;Nofeeswap.sol&#39; is a</span>
 2756 |     | <span class='neutral'>// signed integer. The following memory spaces contains the sign of</span>
 2757 |     | <span class='neutral'>// &#39;amountSpecified&#39; which can be accessed as a boolean. To this end, a single</span>
 2758 |     | <span class='neutral'>// byte is reserved in memory which is pointed to by &#39;_exactInput_&#39;.</span>
 2759 |     | <span class='neutral'>//</span>
 2760 |     | <span class='neutral'>//   - If &#39;amountSpecified &gt; 0&#39;, then &#39;amountSpecified&#39; represents the</span>
 2761 |     | <span class='neutral'>//     requested incoming amount to be given to the pool as a result of the</span>
 2762 |     | <span class='neutral'>//     swap call. In this case the byte which is pointed to by &#39;_exactInput_&#39;</span>
 2763 |     | <span class='neutral'>//     is left as &#39;0x00&#39;.</span>
 2764 |     | <span class='neutral'>//</span>
 2765 |     | <span class='neutral'>//   - If &#39;amountSpecified &lt; 0&#39;, then &#39;0 - amountSpecified&#39; represents the</span>
 2766 |     | <span class='neutral'>//     requested outgoing amount to be taken from the pool as a result of the</span>
 2767 |     | <span class='neutral'>//     swap call. In this case the byte which is pointed to by &#39;_exactInput_&#39;</span>
 2768 |     | <span class='neutral'>//     is populated with &#39;0xFF&#39;.</span>
 2769 |     | <span class='neutral'>//</span>
 2770 |     | <span class='neutral'>// The getter function &#39;getExactInput&#39; in this script and the getter function</span>
 2771 |     | <span class='neutral'>// &#39;getExactInputFromCalldata&#39; in &#39;HookCalldata.sol&#39; give access to the content</span>
 2772 |     | <span class='neutral'>// of this memory space (or calldata in the context of the hook contract) as a</span>
 2773 |     | <span class='neutral'>// boolean with &#39;false&#39; and &#39;true&#39; representing exact output and exact input </span>
 2774 |     | <span class='neutral'>// swaps, respectively.</span>
 2775 |     | <span class='neutral'>uint16 constant _exactInput_ = 337;</span>
 2776 |     | <span class='neutral'></span>
 2777 |     | <span class='neutral'>// The execution of a swap call may involve transacting in a single liquidity</span>
 2778 |     | <span class='neutral'>// interval, or it may require visits to multiple intervals.</span>
 2779 |     | <span class='neutral'>//</span>
 2780 |     | <span class='neutral'>// If &#39;crossThreshold&#39; and &#39;logPriceLimitOffsetted&#39; are not binding, and in the</span>
 2781 |     | <span class='neutral'>// presence of sufficient liquidity, the protocol should be able to fulfill</span>
 2782 |     | <span class='neutral'>// &#39;amountSpecified&#39; in the current active interval. This process involves a</span>
 2783 |     | <span class='neutral'>// movement of price from</span>
 2784 |     | <span class='neutral'>//</span>
 2785 |     | <span class='neutral'>//  &#39;qCurrent := log(pCurrent / pOffset)&#39;</span>
 2786 |     | <span class='neutral'>//</span>
 2787 |     | <span class='neutral'>// to</span>
 2788 |     | <span class='neutral'>//</span>
 2789 |     | <span class='neutral'>//  &#39;qTarget := log(pTarget / pOffset)&#39;</span>
 2790 |     | <span class='neutral'>//</span>
 2791 |     | <span class='neutral'>// within the same active liquidity interval, i.e.,</span>
 2792 |     | <span class='neutral'>//</span>
 2793 |     | <span class='neutral'>//   &#39;qLower &lt;= qTarget &lt;= qUpper&#39;.</span>
 2794 |     | <span class='neutral'>//</span>
 2795 |     | <span class='neutral'>// In order to accomplish this, we need to solve the equation:</span>
 2796 |     | <span class='neutral'>//</span>
 2797 |     | <span class='neutral'>//  &#39;|amountSpecified| == </span>
 2798 |     | <span class='neutral'>//</span>
 2799 |     | <span class='neutral'>//      (getZeroForOne() != getExactInput() ? sqrtOffset : sqrtInverseOffset) * </span>
 2800 |     | <span class='neutral'>//</span>
 2801 |     | <span class='neutral'>//                      growth</span>
 2802 |     | <span class='neutral'>//      sharesTotal * ---------- * </span>
 2803 |     | <span class='neutral'>//                     2 ** 111</span>
 2804 |     | <span class='neutral'>//</span>
 2805 |     | <span class='neutral'>//       getExactInput() ? incomingCurrentToTarget : currentToTarget</span>
 2806 |     | <span class='neutral'>//      -------------------------------------------------------------&#39;,</span>
 2807 |     | <span class='neutral'>//                                outgoingMax</span>
 2808 |     | <span class='neutral'>//</span>
 2809 |     | <span class='neutral'>// where &#39;|amountSpecified|&#39;, &#39;sqrtOffset&#39;, &#39;sqrtInverseOffset&#39;, &#39;outgoingMax&#39;,</span>
 2810 |     | <span class='neutral'>// &#39;sharesTotal&#39;, and &#39;growth&#39; remain fixed as long as we are in the same</span>
 2811 |     | <span class='neutral'>// interval.</span>
 2812 |     | <span class='neutral'>//</span>
 2813 |     | <span class='neutral'>// Hence, as an initial step of a swap call&#39;s execution and with each visit to</span>
 2814 |     | <span class='neutral'>// a new interval, the following value is calculated in &#39;X216&#39; format:</span>
 2815 |     | <span class='neutral'>//</span>
 2816 |     | <span class='neutral'>//  &#39;integralLimit := min(</span>
 2817 |     | <span class='neutral'>//</span>
 2818 |     | <span class='neutral'>//      oneX216 - epsilonX216,</span>
 2819 |     | <span class='neutral'>//</span>
 2820 |     | <span class='neutral'>//                           1          2 ** 111</span>
 2821 |     | <span class='neutral'>//      outgoingMax *  ------------- * ---------- *</span>
 2822 |     | <span class='neutral'>//                      sharesTotal      growth</span>
 2823 |     | <span class='neutral'>//</span>
 2824 |     | <span class='neutral'>//                                |amountSpecified|</span>
 2825 |     | <span class='neutral'>//      -----------------------------------------------------------------------</span>
 2826 |     | <span class='neutral'>//       (getZeroForOne() != getExactInput()) ? sqrtOffset : sqrtInverseOffset</span>
 2827 |     | <span class='neutral'>//</span>
 2828 |     | <span class='neutral'>//   )&#39;.</span>
 2829 |     | <span class='neutral'>//</span>
 2830 |     | <span class='neutral'>// Based on the above equations, it is straightforward to verify that</span>
 2831 |     | <span class='neutral'>// &#39;amountSpecified&#39; is fulfilled if and only if:</span>
 2832 |     | <span class='neutral'>//</span>
 2833 |     | <span class='neutral'>//   &#39;getExactInput() ? incomingCurrentToTarget : currentToTarget</span>
 2834 |     | <span class='neutral'>//     == </span>
 2835 |     | <span class='neutral'>//    integralLimit&#39;.</span>
 2836 |     | <span class='neutral'>//</span>
 2837 |     | <span class='neutral'>// Since the left-hand side is a function of &#39;qTarget&#39;, the above equation is</span>
 2838 |     | <span class='neutral'>// solved by methods &#39;searchOutgoingTarget&#39; and &#39;searchIncomingTarget&#39; in</span>
 2839 |     | <span class='neutral'>// &#39;Interval.sol&#39; in order to calculate the precise value of &#39;qTarget&#39; that</span>
 2840 |     | <span class='neutral'>// fulfills &#39;amountSpecified&#39;. These two methods work with &#39;integralLimit&#39;.</span>
 2841 |     | <span class='neutral'>//</span>
 2842 |     | <span class='neutral'>// &#39;integralLimit&#39; is less than &#39;oneX216&#39; and does not exceed 216 bits. Hence,</span>
 2843 |     | <span class='neutral'>// 27 bytes are reserved for the memory space that stores &#39;integralLimit&#39;.</span>
 2844 |     | <span class='neutral'>uint16 constant _integralLimit_ = 338;</span>
 2845 |     | <span class='neutral'></span>
 2846 |     | <span class='neutral'>// Let &#39;pLower&#39; and &#39;pUpper&#39;, respectively, denote the minimum and maximum</span>
 2847 |     | <span class='neutral'>// price in the current active liquidity interval and define</span>
 2848 |     | <span class='neutral'>//</span>
 2849 |     | <span class='neutral'>//  &#39;qLower := log(pLower / pOffset)&#39;,</span>
 2850 |     | <span class='neutral'>//  &#39;qUpper := log(pUpper / pOffset)&#39;.</span>
 2851 |     | <span class='neutral'>//</span>
 2852 |     | <span class='neutral'>// By crossing the active interval entirely from one end to the other end, the</span>
 2853 |     | <span class='neutral'>// absolute value &#39;|amountSpecified|&#39; is decremented by</span>
 2854 |     | <span class='neutral'>//</span>
 2855 |     | <span class='neutral'>//  &#39;(getZeroForOne() != getExactInput() ? sqrtOffset : sqrtInverseOffset) * </span>
 2856 |     | <span class='neutral'>//</span>
 2857 |     | <span class='neutral'>//                   growth      integralLimitInterval</span>
 2858 |     | <span class='neutral'>//   sharesTotal * ---------- * -----------------------&#39;,</span>
 2859 |     | <span class='neutral'>//                  2 ** 111          outgoingMax</span>
 2860 |     | <span class='neutral'>//</span>
 2861 |     | <span class='neutral'>// where &#39;integralLimitInterval&#39; for the present interval is defined as</span>
 2862 |     | <span class='neutral'>//</span>
 2863 |     | <span class='neutral'>//  &#39;integralLimitInterval := (getExactInput() ? incomingMax : outgoingMax)</span>
 2864 |     | <span class='neutral'>//</span>
 2865 |     | <span class='neutral'>//           (getZeroForOne() != getExactInput() ? - qLower : + qUpper) / 2</span>
 2866 |     | <span class='neutral'>//       * e                                                               &#39;.</span>
 2867 |     | <span class='neutral'>//</span>
 2868 |     | <span class='neutral'>// By crossing the active interval, the limit imposed by &#39;amountSpecified&#39; is</span>
 2869 |     | <span class='neutral'>// not violated if and only if:</span>
 2870 |     | <span class='neutral'>//        </span>
 2871 |     | <span class='neutral'>//  &#39;integralLimitInterval &lt;= integralLimit&#39;.</span>
 2872 |     | <span class='neutral'>//</span>
 2873 |     | <span class='neutral'>// Hence, &#39;integralLimitInterval&#39; can be used to determined whether we should</span>
 2874 |     | <span class='neutral'>// cross a new active interval entirely or not.</span>
 2875 |     | <span class='neutral'>//</span>
 2876 |     | <span class='neutral'>// &#39;integralLimitInterval&#39; is calculated with each visit to a new interval and</span>
 2877 |     | <span class='neutral'>// stored in the 27 bytes memory space which is pointed to by</span>
 2878 |     | <span class='neutral'>// &#39;_integralLimitInterval_&#39;.</span>
 2879 |     | <span class='neutral'>uint16 constant _integralLimitInterval_ = 365;</span>
 2880 |     | <span class='neutral'></span>
 2881 |     | <span class='neutral'>// Throughout the execution of a swap, this 32 bytes memory space hosts the</span>
 2882 |     | <span class='neutral'>// &#39;X127&#39; representation of &#39;amount0&#39; which is the total amount of &#39;tag0&#39; that</span>
 2883 |     | <span class='neutral'>// is traded so far. Concluding the visit to each interval involves</span>
 2884 |     | <span class='neutral'>// incrementing the absolute value &#39;|amount0|&#39; with</span>
 2885 |     | <span class='neutral'>//                                                         growth</span>
 2886 |     | <span class='neutral'>//  &#39;amount0Partial := sqrtInverseOffset * sharesTotal * ---------- *</span>
 2887 |     | <span class='neutral'>//                                                        2 ** 111</span>
 2888 |     | <span class='neutral'>//</span>
 2889 |     | <span class='neutral'>//   (getZeroForOne() ? incomingCurrentToTarget : currentToTarget)&#39;.</span>
 2890 |     | <span class='neutral'>//</span>
 2891 |     | <span class='neutral'>// If positive, &#39;amount0&#39; is incoming to the pool and if negative it is</span>
 2892 |     | <span class='neutral'>// outgoing from the pool.</span>
 2893 |     | <span class='neutral'>uint16 constant _amount0_ = 392;</span>
 2894 |     | <span class='neutral'></span>
 2895 |     | <span class='neutral'>// Throughout the execution of a swap, this 32 bytes memory space hosts the</span>
 2896 |     | <span class='neutral'>// &#39;X127&#39; representation of &#39;amount1&#39; which is the total amount of &#39;tag1&#39; that</span>
 2897 |     | <span class='neutral'>// is traded so far. Concluding the visit to each interval involves</span>
 2898 |     | <span class='neutral'>// incrementing the absolute value &#39;|amount1|&#39; with</span>
 2899 |     | <span class='neutral'>//                                                  growth</span>
 2900 |     | <span class='neutral'>//  &#39;amount1Partial := sqrtOffset * sharesTotal * ---------- *</span>
 2901 |     | <span class='neutral'>//                                                 2 ** 111</span>
 2902 |     | <span class='neutral'>//</span>
 2903 |     | <span class='neutral'>//   (getZeroForOne() ? currentToTarget : incomingCurrentToTarget)&#39;.</span>
 2904 |     | <span class='neutral'>//</span>
 2905 |     | <span class='neutral'>// If positive, &#39;amount1&#39; is incoming to the pool and if negative it is</span>
 2906 |     | <span class='neutral'>// outgoing from the pool.</span>
 2907 |     | <span class='neutral'>uint16 constant _amount1_ = 424;</span>
 2908 |     | <span class='neutral'></span>
 2909 |     | <span class='neutral'>// At each point throughout the execution of a swap, as we transition from</span>
 2910 |     | <span class='neutral'>// each interval to the next one, the memory pointer &#39;_back_&#39; is used in order</span>
 2911 |     | <span class='neutral'>// to keep track of the active interval boundary in the opposite direction of</span>
 2912 |     | <span class='neutral'>// the swap.</span>
 2913 |     | <span class='neutral'>//</span>
 2914 |     | <span class='neutral'>// Let &#39;pLower&#39; and &#39;pUpper&#39;, respectively, denote the minimum and maximum</span>
 2915 |     | <span class='neutral'>// price in the current active liquidity interval and define</span>
 2916 |     | <span class='neutral'>//</span>
 2917 |     | <span class='neutral'>//  &#39;qBack := log((getZeroForOne() ? pUpper : pLower) / pOffset)&#39;.</span>
 2918 |     | <span class='neutral'>//</span>
 2919 |     | <span class='neutral'>// The 62 bytes memory space which is pointed to by &#39;_back_&#39; hosts the</span>
 2920 |     | <span class='neutral'>// following values:</span>
 2921 |     | <span class='neutral'>//</span>
 2922 |     | <span class='neutral'>//  &#39;_back_.log() := (2 ** 59) * (16 + qBack)&#39;,</span>
 2923 |     | <span class='neutral'>//  &#39;_back_.sqrt(false) := (2 ** 216) * exp(- 8 - qBack / 2)&#39;,</span>
 2924 |     | <span class='neutral'>//  &#39;_back_.sqrt(true) := (2 ** 216) * exp(- 8 + qBack / 2)&#39;.</span>
 2925 |     | <span class='neutral'>//</span>
 2926 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The logarithmic price</span>
 2927 |     | <span class='neutral'>// &#39;_back_.log()&#39; occupies 64 bits, whereas &#39;_back_.sqrt(false)&#39; and</span>
 2928 |     | <span class='neutral'>// &#39;_back_.sqrt(true)&#39; occupy 216 bits each.</span>
 2929 |     | <span class='neutral'>uint16 constant _back_ = 456;</span>
 2930 |     | <span class='neutral'></span>
 2931 |     | <span class='neutral'>// At each point throughout the execution of a swap, as we transition from</span>
 2932 |     | <span class='neutral'>// each interval to the next one, the memory pointer &#39;_next_&#39; is used in order</span>
 2933 |     | <span class='neutral'>// to keep track of the active interval boundary in the direction of the swap.</span>
 2934 |     | <span class='neutral'>//</span>
 2935 |     | <span class='neutral'>// Let &#39;pLower&#39; and &#39;pUpper&#39;, respectively, denote the minimum and maximum</span>
 2936 |     | <span class='neutral'>// price in the current active liquidity interval and define</span>
 2937 |     | <span class='neutral'>//</span>
 2938 |     | <span class='neutral'>//  &#39;qNext := log((getZeroForOne() ? pLower : pUpper) / pOffset)&#39;.</span>
 2939 |     | <span class='neutral'>//</span>
 2940 |     | <span class='neutral'>// The 62 bytes memory space which is pointed to by &#39;_next_&#39; hosts the</span>
 2941 |     | <span class='neutral'>// following values:</span>
 2942 |     | <span class='neutral'>//</span>
 2943 |     | <span class='neutral'>//  &#39;_next_.log() := (2 ** 59) * (16 + qNext)&#39;,</span>
 2944 |     | <span class='neutral'>//  &#39;_next_.sqrt(false) := (2 ** 216) * exp(- 8 - qNext / 2)&#39;,</span>
 2945 |     | <span class='neutral'>//  &#39;_next_.sqrt(true) := (2 ** 216) * exp(- 8 + qNext / 2)&#39;.</span>
 2946 |     | <span class='neutral'>//</span>
 2947 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The logarithmic price</span>
 2948 |     | <span class='neutral'>// &#39;_next_.log()&#39; occupies 64 bits, whereas &#39;_next_.sqrt(false)&#39; and</span>
 2949 |     | <span class='neutral'>// &#39;_next_.sqrt(true)&#39; occupy 216 bits each.</span>
 2950 |     | <span class='neutral'>uint16 constant _next_ = 518;</span>
 2951 |     | <span class='neutral'></span>
 2952 |     | <span class='neutral'>// An LP may choose any consecutive range of liquidity intervals to deposit</span>
 2953 |     | <span class='neutral'>// their liquidity. By doing so, the LP acquires a number of shares in every</span>
 2954 |     | <span class='neutral'>// liquidity interval that belongs to the given range.</span>
 2955 |     | <span class='neutral'>//</span>
 2956 |     | <span class='neutral'>// Let &#39;pLower&#39; and &#39;pUpper&#39;, respectively, denote the minimum and maximum</span>
 2957 |     | <span class='neutral'>// price in the current active liquidity interval and define</span>
 2958 |     | <span class='neutral'>//</span>
 2959 |     | <span class='neutral'>//  &#39;qLower := log(pLower / pOffset)&#39;,</span>
 2960 |     | <span class='neutral'>//  &#39;qUpper := log(pUpper / pOffset)&#39;.</span>
 2961 |     | <span class='neutral'>//</span>
 2962 |     | <span class='neutral'>// Additionally, let</span>
 2963 |     | <span class='neutral'>// </span>
 2964 |     | <span class='neutral'>//    sqrtInverseOffset     growthMultiplier[qUpper]</span>
 2965 |     | <span class='neutral'>//  &#39;------------------- * --------------------------&#39;</span>
 2966 |     | <span class='neutral'>//         2 ** 127                 2 ** 208</span>
 2967 |     | <span class='neutral'>//</span>
 2968 |     | <span class='neutral'>// represent the total amount of &#39;tag0&#39; corresponding to a single liquidity</span>
 2969 |     | <span class='neutral'>// provider&#39;s share from &#39;qUpper&#39; to &#39;+oo&#39; and</span>
 2970 |     | <span class='neutral'>//</span>
 2971 |     | <span class='neutral'>//    sqrtOffset     growthMultiplier[qLower]</span>
 2972 |     | <span class='neutral'>//  &#39;------------ * --------------------------&#39;</span>
 2973 |     | <span class='neutral'>//     2 ** 127             2 ** 208</span>
 2974 |     | <span class='neutral'>//</span>
 2975 |     | <span class='neutral'>// represent the total amount of &#39;tag1&#39; corresponding to a single liquidity</span>
 2976 |     | <span class='neutral'>// provider&#39;s share from &#39;-oo&#39; to &#39;qLower&#39;.</span>
 2977 |     | <span class='neutral'>//</span>
 2978 |     | <span class='neutral'>// The 32 bytes memory space which is pointed to by &#39;_backGrowthMultiplier_&#39;</span>
 2979 |     | <span class='neutral'>// hosts the &#39;X208&#39; representation of</span>
 2980 |     | <span class='neutral'>// &#39;growthMultiplier[getZeroForOne() ? qUpper : qLower]&#39;.</span>
 2981 |     | <span class='neutral'>//</span>
 2982 |     | <span class='neutral'>// The 32 bytes memory space which is pointed to by &#39;_nextGrowthMultiplier_&#39;</span>
 2983 |     | <span class='neutral'>// hosts the &#39;X208&#39; representation of</span>
 2984 |     | <span class='neutral'>// &#39;growthMultiplier[getZeroForOne() ? qLower : qUpper]&#39;.</span>
 2985 |     | <span class='neutral'>uint16 constant _backGrowthMultiplier_ = 580;</span>
 2986 |     | <span class='neutral'>uint16 constant _nextGrowthMultiplier_ = 612;</span>
 2987 |     | <span class='neutral'></span>
 2988 |     | <span class='neutral'>// Interval Parameters</span>
 2989 |     | <span class='neutral'>// ----------------------------------------------------------------------------</span>
 2990 |     | <span class='neutral'>// The following memory pointers correspond to the main variables that are used</span>
 2991 |     | <span class='neutral'>// to calculate swaps within the active liquidity interval.</span>
 2992 |     | <span class='neutral'>//</span>
 2993 |     | <span class='neutral'>// Let &#39;pCurrent&#39; denote the current price of the pool and let &#39;pLower&#39; and</span>
 2994 |     | <span class='neutral'>// &#39;pUpper&#39;, respectively, denote the minimum and maximum price in the current</span>
 2995 |     | <span class='neutral'>// active liquidity interval. Define:</span>
 2996 |     | <span class='neutral'>//</span>
 2997 |     | <span class='neutral'>//  &#39;qLower := log(pLower / pOffset)&#39;,</span>
 2998 |     | <span class='neutral'>//  &#39;qUpper := log(pUpper / pOffset)&#39;,</span>
 2999 |     | <span class='neutral'>//  &#39;qSpacing := log(pUpper / pLower)&#39;,</span>
 3000 |     | <span class='neutral'>//  &#39;qCurrent := log(pCurrent / pOffset)&#39;.</span>
 3001 |     | <span class='neutral'>//</span>
 3002 |     | <span class='neutral'>// Then we have:</span>
 3003 |     | <span class='neutral'>//</span>
 3004 |     | <span class='neutral'>//  &#39;qLower &lt;= qCurrent &lt;= qUpper&#39;,</span>
 3005 |     | <span class='neutral'>//</span>
 3006 |     | <span class='neutral'>// Consider a swap that involves a movement of price from &#39;qCurrent&#39; to</span>
 3007 |     | <span class='neutral'>//</span>
 3008 |     | <span class='neutral'>//  &#39;qTarget := log(pTarget / pOffset)&#39;</span>
 3009 |     | <span class='neutral'>//</span>
 3010 |     | <span class='neutral'>// within the same active liquidity interval, i.e.,</span>
 3011 |     | <span class='neutral'>//</span>
 3012 |     | <span class='neutral'>//  &#39;qLower &lt;= qTarget &lt;= qUpper&#39;.</span>
 3013 |     | <span class='neutral'>//</span>
 3014 |     | <span class='neutral'>// Notice that &#39;qTarget&#39; is an unknown value which will be determined based on</span>
 3015 |     | <span class='neutral'>// one of the followings:</span>
 3016 |     | <span class='neutral'>//</span>
 3017 |     | <span class='neutral'>//  - &#39;qLimitWithinInterval&#39;, which is calculated based on the input</span>
 3018 |     | <span class='neutral'>//    &#39;logPriceLimit&#39; as well as &#39;qLower&#39; and &#39;qUpper&#39;. It is stored in the</span>
 3019 |     | <span class='neutral'>//    memory space which is pointed to by</span>
 3020 |     | <span class='neutral'>//    &#39;_logPriceLimitOffsettedWithinInterval_&#39;.</span>
 3021 |     | <span class='neutral'>//</span>
 3022 |     | <span class='neutral'>//  - &#39;integralLimit&#39;, which is calculated based on the input &#39;amountSpecified&#39;</span>
 3023 |     | <span class='neutral'>//    and is stored in the memory space which is pointed to by</span>
 3024 |     | <span class='neutral'>//    &#39;_integralLimit_&#39;.</span>
 3025 |     | <span class='neutral'>//</span>
 3026 |     | <span class='neutral'>// After determination of &#39;qTarget&#39;, the amounts of &#39;tag0&#39; and &#39;tag1&#39; to be</span>
 3027 |     | <span class='neutral'>// exchanged as a result of the movement within &#39;[qLower, qUpper]&#39; are equal</span>
 3028 |     | <span class='neutral'>// to:</span>
 3029 |     | <span class='neutral'>//</span>
 3030 |     | <span class='neutral'>//                                                         growth</span>
 3031 |     | <span class='neutral'>//  &#39;amount0Partial := sqrtInverseOffset * sharesTotal * ---------- *</span>
 3032 |     | <span class='neutral'>//                                                        2 ** 111</span>
 3033 |     | <span class='neutral'>//</span>
 3034 |     | <span class='neutral'>//    getZeroForOne() ? incomingCurrentToTarget : currentToTarget</span>
 3035 |     | <span class='neutral'>//   -------------------------------------------------------------&#39;,</span>
 3036 |     | <span class='neutral'>//                            outgoingMax</span>
 3037 |     | <span class='neutral'>// and</span>
 3038 |     | <span class='neutral'>//                                                  growth</span>
 3039 |     | <span class='neutral'>//  &#39;amount1Partial := sqrtOffset * sharesTotal * ---------- *</span>
 3040 |     | <span class='neutral'>//                                                 2 ** 111</span>
 3041 |     | <span class='neutral'>//</span>
 3042 |     | <span class='neutral'>//    getZeroForOne() ? currentToTarget : incomingCurrentToTarget</span>
 3043 |     | <span class='neutral'>//   -------------------------------------------------------------&#39;,</span>
 3044 |     | <span class='neutral'>//                            outgoingMax</span>
 3045 |     | <span class='neutral'>//</span>
 3046 |     | <span class='neutral'>// where the parameters &#39;sqrtInverseOffset&#39;, &#39;sqrtOffset&#39;, &#39;sharesTotal&#39;,</span>
 3047 |     | <span class='neutral'>// &#39;growth&#39;, and &#39;outgoingMax&#39; remain fixed throughout the movement from</span>
 3048 |     | <span class='neutral'>// &#39;qCurrent&#39; to &#39;qTarget&#39;.</span>
 3049 |     | <span class='neutral'>//</span>
 3050 |     | <span class='neutral'>// While searching for &#39;qTarget&#39;, the two integrals &#39;currentToTarget&#39; and</span>
 3051 |     | <span class='neutral'>// &#39;incomingCurrentToTarget&#39; are calculated. These two integrals are defined as</span>
 3052 |     | <span class='neutral'>// follows:</span>
 3053 |     | <span class='neutral'>//</span>
 3054 |     | <span class='neutral'>//                           - 8</span>
 3055 |     | <span class='neutral'>//    currentToTarget      e</span>
 3056 |     | <span class='neutral'>//  &#39;----------------- := ------- * (</span>
 3057 |     | <span class='neutral'>//       2 ** 216            2</span>
 3058 |     | <span class='neutral'>//</span>
 3059 |     | <span class='neutral'>//                         / qCurrent                 / qTarget</span>
 3060 |     | <span class='neutral'>//                        |    + h / 2               |    - h / 2</span>
 3061 |     | <span class='neutral'>//     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh</span>
 3062 |     | <span class='neutral'>//                        |                          |</span>
 3063 |     | <span class='neutral'>//                       / qTarget                  / qCurrent</span>
 3064 |     | <span class='neutral'>//</span>
 3065 |     | <span class='neutral'>//   )&#39;</span>
 3066 |     | <span class='neutral'>//</span>
 3067 |     | <span class='neutral'>// and</span>
 3068 |     | <span class='neutral'>//                                   - 8</span>
 3069 |     | <span class='neutral'>//    incomingCurrentToTarget      e</span>
 3070 |     | <span class='neutral'>//  &#39;------------------------- := ------- * (</span>
 3071 |     | <span class='neutral'>//           2 ** 216                2</span>
 3072 |     | <span class='neutral'>//</span>
 3073 |     | <span class='neutral'>//                         / qCurrent                 / qTarget</span>
 3074 |     | <span class='neutral'>//                        |    - h / 2               |    + h / 2</span>
 3075 |     | <span class='neutral'>//     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh</span>
 3076 |     | <span class='neutral'>//                        |                          |</span>
 3077 |     | <span class='neutral'>//                       / qTarget                  / qCurrent</span>
 3078 |     | <span class='neutral'>//</span>
 3079 |     | <span class='neutral'>//   )&#39;.</span>
 3080 |     | <span class='neutral'>//</span>
 3081 |     | <span class='neutral'>// To further clarify the above definitions, we first need to define the</span>
 3082 |     | <span class='neutral'>// function &#39;w(.)&#39; which is constructed based on the curve sequence.</span>
 3083 |     | <span class='neutral'>//</span>
 3084 |     | <span class='neutral'>// The curve sequence comprises 64 bit logarithmic prices in the form of</span>
 3085 |     | <span class='neutral'>//</span>
 3086 |     | <span class='neutral'>//  &#39;(2 ** 59) * (16 + qHistorical)&#39;</span>
 3087 |     | <span class='neutral'>//</span>
 3088 |     | <span class='neutral'>// where every &#39;qHistorical&#39; satisfies:</span>
 3089 |     | <span class='neutral'>//</span>
 3090 |     | <span class='neutral'>//  &#39;qLower &lt;= qHistorical &lt;= qUpper&#39;.</span>
 3091 |     | <span class='neutral'>//</span>
 3092 |     | <span class='neutral'>// Hence, each slot of the curve sequence consists of up to four members. The</span>
 3093 |     | <span class='neutral'>// curve sequence should have at least two members. The first and the second</span>
 3094 |     | <span class='neutral'>// members are &#39;qLower&#39; and &#39;qUpper&#39; with the order depending on the pool&#39;s</span>
 3095 |     | <span class='neutral'>// history. The last member is always &#39;qCurrent&#39;. Consider the following curve</span>
 3096 |     | <span class='neutral'>// sequence:</span>
 3097 |     | <span class='neutral'>// </span>
 3098 |     | <span class='neutral'>//  &#39;q[0], q[1], q[2], ..., q[l - 1]&#39;</span>
 3099 |     | <span class='neutral'>//</span>
 3100 |     | <span class='neutral'>// where &#39;l&#39; is the number of members. Additionally, to simplify the notations,</span>
 3101 |     | <span class='neutral'>// the out-of-range member &#39;q[l]&#39; is assigned the same value as &#39;q[l - 1]&#39;. In</span>
 3102 |     | <span class='neutral'>// order for the above sequence to be considered valid, we should have:</span>
 3103 |     | <span class='neutral'>//</span>
 3104 |     | <span class='neutral'>//  &#39;min(q[i - 1], q[i - 2]) &lt; q[i] &lt; max(q[i - 1], q[i - 2])&#39;.</span>
 3105 |     | <span class='neutral'>//</span>
 3106 |     | <span class='neutral'>// for every &#39;2 &lt;= i &lt; l&#39;. Define</span>
 3107 |     | <span class='neutral'>// </span>
 3108 |     | <span class='neutral'>//  &#39;w : [qLower, qUpper] -&gt; [0, qSpacing]&#39;</span>
 3109 |     | <span class='neutral'>//</span>
 3110 |     | <span class='neutral'>// as</span>
 3111 |     | <span class='neutral'>//           l - 2</span>
 3112 |     | <span class='neutral'>//           -----</span>
 3113 |     | <span class='neutral'>//           \</span>
 3114 |     | <span class='neutral'>//  &#39;w(q) := /     w_i(q)&#39;.</span>
 3115 |     | <span class='neutral'>//           -----</span>
 3116 |     | <span class='neutral'>//           i = 0</span>
 3117 |     | <span class='neutral'>//</span>
 3118 |     | <span class='neutral'>// where for every &#39;0 &lt;= i &lt;= l - 2&#39;, the function</span>
 3119 |     | <span class='neutral'>//</span>
 3120 |     | <span class='neutral'>//  &#39;w_i : [qLower, qUpper] -&gt; [0, qSpacing]&#39;</span>
 3121 |     | <span class='neutral'>//</span>
 3122 |     | <span class='neutral'>// is regarded as a phase which is defined as</span>
 3123 |     | <span class='neutral'>//</span>
 3124 |     | <span class='neutral'>//  &#39;w_i(q) :=</span>
 3125 |     | <span class='neutral'>//</span>
 3126 |     | <span class='neutral'>//    /</span>
 3127 |     | <span class='neutral'>//   |  |q - q[i + 1]|  if  min(q[i], q[i + 2]) &lt; q &lt; max(q[i], q[i + 2])</span>
 3128 |     | <span class='neutral'>//   |                                                                    &#39;.</span>
 3129 |     | <span class='neutral'>//   |  0               otherwise</span>
 3130 |     | <span class='neutral'>//    \</span>
 3131 |     | <span class='neutral'>//</span>
 3132 |     | <span class='neutral'>// Observe that for each &#39;0 &lt;= i &lt;= l - 2&#39;, the phase &#39;w_i&#39; can be</span>
 3133 |     | <span class='neutral'>// characterized via the following three consecutive members of the curve</span>
 3134 |     | <span class='neutral'>// sequence:</span>
 3135 |     | <span class='neutral'>//</span>
 3136 |     | <span class='neutral'>//  &#39;q[i], q[i + 1], q[i + 2]&#39;</span>
 3137 |     | <span class='neutral'>//</span>
 3138 |     | <span class='neutral'>// Next, we need to define the function &#39;k(.)&#39; which is constructed from the</span>
 3139 |     | <span class='neutral'>// kernel. The kernel is composed of breakpoints. Let &#39;m + 1&#39; denote the number</span>
 3140 |     | <span class='neutral'>// of these breakpoints. For every integer &#39;0 &lt;= i &lt;= m&#39; the i-th breakpoint of</span>
 3141 |     | <span class='neutral'>// the kernel represents the pair &#39;(b[i], c[i])&#39; where</span>
 3142 |     | <span class='neutral'>//</span>
 3143 |     | <span class='neutral'>//  &#39;0 == b[0] &lt;  b[1] &lt;= b[2] &lt;= ... &lt;= b[m - 1] &lt;  b[m] == qSpacing&#39;,</span>
 3144 |     | <span class='neutral'>//  &#39;0 == c[0] &lt;= c[1] &lt;= c[2] &lt;= ... &lt;= c[m - 1] &lt;= c[m] == 1&#39;.</span>
 3145 |     | <span class='neutral'>// </span>
 3146 |     | <span class='neutral'>// Each breakpoint occupies 64 bytes, in which:</span>
 3147 |     | <span class='neutral'>//</span>
 3148 |     | <span class='neutral'>//  - the &#39;X15&#39; representation of &#39;(2 ** 15) * c[i]&#39; occupies 2 bytes,</span>
 3149 |     | <span class='neutral'>//</span>
 3150 |     | <span class='neutral'>//  - the &#39;X59&#39; representation of &#39;(2 ** 59) * b[i]&#39; occupies 8 bytes,</span>
 3151 |     | <span class='neutral'>//</span>
 3152 |     | <span class='neutral'>//  - the &#39;X216&#39; representation of &#39;(2 ** 216) * exp(- b[i] / 2)&#39; occupies 27</span>
 3153 |     | <span class='neutral'>//    bytes,</span>
 3154 |     | <span class='neutral'>//</span>
 3155 |     | <span class='neutral'>//  - the &#39;X216&#39; representation of &#39;(2 ** 216) * exp(- 16 + b[i] / 2)&#39; occupies</span>
 3156 |     | <span class='neutral'>//    27 bytes.</span>
 3157 |     | <span class='neutral'>//</span>
 3158 |     | <span class='neutral'>// The above-mentioned layout is illustrated as follows:</span>
 3159 |     | <span class='neutral'>//</span>
 3160 |     | <span class='neutral'>//                      A 512 bit kernel breakpoint</span>
 3161 |     | <span class='neutral'>//  +--+--------+---------------------------+---------------------------+</span>
 3162 |     | <span class='neutral'>//  |  | 8 byte |          27 byte          |          27 byte          |</span>
 3163 |     | <span class='neutral'>//  +--+--------+---------------------------+---------------------------+</span>
 3164 |     | <span class='neutral'>//  |  |        |                           |</span>
 3165 |     | <span class='neutral'>//  |  |        |                            \</span>
 3166 |     | <span class='neutral'>//  |  |        |                             (2 ** 216) * exp(- 16 + b[i] / 2)</span>
 3167 |     | <span class='neutral'>//  |  |         \</span>
 3168 |     | <span class='neutral'>//  |  |          (2 ** 216) * exp(- b[i] / 2)</span>
 3169 |     | <span class='neutral'>//  |   \</span>
 3170 |     | <span class='neutral'>//  |    (2 ** 59) * b[i]</span>
 3171 |     | <span class='neutral'>//   \</span>
 3172 |     | <span class='neutral'>//    (2 ** 15) * c[i]</span>
 3173 |     | <span class='neutral'>//</span>
 3174 |     | <span class='neutral'>// Consider the following list of kernel breakpoints:</span>
 3175 |     | <span class='neutral'>//</span>
 3176 |     | <span class='neutral'>//  &#39;(b[0], c[0]), (b[1], c[1]), (b[2], c[2]), ..., (b[m], c[m])&#39;</span>
 3177 |     | <span class='neutral'>//</span>
 3178 |     | <span class='neutral'>// and for every integer &#39;0 &lt; i &lt;= m&#39;, define</span>
 3179 |     | <span class='neutral'>//</span>
 3180 |     | <span class='neutral'>//  &#39;k_i : [0, qSpacing] -&gt; [0, 1]&#39;</span>
 3181 |     | <span class='neutral'>//</span>
 3182 |     | <span class='neutral'>// as</span>
 3183 |     | <span class='neutral'>//</span>
 3184 |     | <span class='neutral'>//  &#39;k_i(q) :=</span>
 3185 |     | <span class='neutral'>//</span>
 3186 |     | <span class='neutral'>//    /            c[i] - c[i - 1]</span>
 3187 |     | <span class='neutral'>//   | c[i - 1] + ----------------- * (q - b[i - 1])  if  b[i - 1] &lt; q &lt; b[i]</span>
 3188 |     | <span class='neutral'>//   |             b[i] - b[i - 1]                                           &#39;,</span>
 3189 |     | <span class='neutral'>//   | 0                                              otherwise</span>
 3190 |     | <span class='neutral'>//    \</span>
 3191 |     | <span class='neutral'>//</span>
 3192 |     | <span class='neutral'>// which means that if &#39;b[i - 1] == b[i]&#39;, then &#39;k_i(q) := 0&#39;. Now, the kernel</span>
 3193 |     | <span class='neutral'>// function</span>
 3194 |     | <span class='neutral'>// </span>
 3195 |     | <span class='neutral'>//  &#39;k : [0, qSpacing] -&gt; [0, 1]&#39;</span>
 3196 |     | <span class='neutral'>//</span>
 3197 |     | <span class='neutral'>// is defined as</span>
 3198 |     | <span class='neutral'>//</span>
 3199 |     | <span class='neutral'>//             m</span>
 3200 |     | <span class='neutral'>//           -----</span>
 3201 |     | <span class='neutral'>//           \</span>
 3202 |     | <span class='neutral'>//  &#39;k(q) := /     k_i(q)&#39;.</span>
 3203 |     | <span class='neutral'>//           -----</span>
 3204 |     | <span class='neutral'>//           i = 1</span>
 3205 |     | <span class='neutral'>//</span>
 3206 |     | <span class='neutral'>// Define the liquidity distribution function</span>
 3207 |     | <span class='neutral'>//</span>
 3208 |     | <span class='neutral'>//  &#39;k(w(.)) : [qLower, qUpper] -&gt; [0, 1]&#39;</span>
 3209 |     | <span class='neutral'>//</span>
 3210 |     | <span class='neutral'>// for the active interval as the composition of &#39;k(.)&#39; with &#39;w(.)&#39;.</span>
 3211 |     | <span class='neutral'>//</span>
 3212 |     | <span class='neutral'>// As argued above, while searching for &#39;qTarget&#39;, the integrals</span>
 3213 |     | <span class='neutral'>// &#39;currentToTarget&#39; and &#39;incomingCurrentToTarget&#39; are calculated based on</span>
 3214 |     | <span class='neutral'>// &#39;k(w(.))&#39; which enables the protocol to determine &#39;amount0Partial&#39; and</span>
 3215 |     | <span class='neutral'>// &#39;amount1Partial&#39; when moving the price from &#39;qCurrent&#39; to &#39;qTarget&#39;. In</span>
 3216 |     | <span class='neutral'>// addition, we need to calculate two other integrals that are referred to as</span>
 3217 |     | <span class='neutral'>// &#39;currentToOrigin&#39; and &#39;originToOvershoot&#39; which will be defined later in</span>
 3218 |     | <span class='neutral'>// this script. Next, we explain how this search is conducted.</span>
 3219 |     | <span class='neutral'>//</span>
 3220 |     | <span class='neutral'>// Remember that both &#39;w(.)&#39; and &#39;k(.)&#39; are piecewise linear functions. As a</span>
 3221 |     | <span class='neutral'>// result, &#39;k(w(.))&#39; is also piecewise linear. In search for &#39;qTarget&#39;, we</span>
 3222 |     | <span class='neutral'>// enumerate the pieces of &#39;k(w(.))&#39;, one by one, until we discover the piece</span>
 3223 |     | <span class='neutral'>// to which &#39;qTarget&#39; belongs. To this end, the two indices &#39;indexCurve&#39; and</span>
 3224 |     | <span class='neutral'>// &#39;indexKernelTotal&#39; are employed:</span>
 3225 |     | <span class='neutral'>//</span>
 3226 |     | <span class='neutral'>//  - &#39;indexCurve&#39; keeps track of the current phase under exploration (i.e.,</span>
 3227 |     | <span class='neutral'>//    the piece of &#39;w(.)&#39;). Remember, that &#39;w_indexCurve&#39; can be characterized</span>
 3228 |     | <span class='neutral'>//    via the following three consecutive members of the curve sequence:</span>
 3229 |     | <span class='neutral'>//</span>
 3230 |     | <span class='neutral'>//      &#39;q[indexCurve], q[indexCurve + 1], q[indexCurve + 2]&#39;.</span>
 3231 |     | <span class='neutral'>//</span>
 3232 |     | <span class='neutral'>//    Here, we refer to &#39;q[indexCurve + 1]&#39; and &#39;q[indexCurve]&#39; as &#39;qOrigin&#39;</span>
 3233 |     | <span class='neutral'>//    and &#39;qEnd&#39;, respectively. Throughout the search, &#39;qOrigin&#39; and &#39;qEnd&#39;</span>
 3234 |     | <span class='neutral'>//    are stored, respectively, in the memory spaces which are pointed to by</span>
 3235 |     | <span class='neutral'>//    &#39;_origin_&#39; and &#39;_end_&#39;, and they are updated with each transition to a</span>
 3236 |     | <span class='neutral'>//    new phase.</span>
 3237 |     | <span class='neutral'>//</span>
 3238 |     | <span class='neutral'>//    Additionally, the memory space which is pointed to by &#39;_direction_&#39; keeps</span>
 3239 |     | <span class='neutral'>//    track of the boolean:</span>
 3240 |     | <span class='neutral'>//</span>
 3241 |     | <span class='neutral'>//      &#39;qEnd &lt; q[indexCurve + 2]&#39;.</span>
 3242 |     | <span class='neutral'>//</span>
 3243 |     | <span class='neutral'>//    Hence, &#39;getDirection() == false&#39; means that we are currently searching</span>
 3244 |     | <span class='neutral'>//    within the range</span>
 3245 |     | <span class='neutral'>//    </span>
 3246 |     | <span class='neutral'>//      &#39;q[indexCurve + 2] &lt; q &lt; qEnd&#39;</span>
 3247 |     | <span class='neutral'>//</span>
 3248 |     | <span class='neutral'>//    in which</span>
 3249 |     | <span class='neutral'>//</span>
 3250 |     | <span class='neutral'>//      &#39;w(q) == w_indexCurve(q) == q - qOrigin&#39;.</span>
 3251 |     | <span class='neutral'>//</span>
 3252 |     | <span class='neutral'>//    Whereas, &#39;getDirection() == true&#39; means that we are currently searching</span>
 3253 |     | <span class='neutral'>//    within the range</span>
 3254 |     | <span class='neutral'>//    </span>
 3255 |     | <span class='neutral'>//      &#39;qEnd &lt; q &lt; q[indexCurve + 2]&#39;</span>
 3256 |     | <span class='neutral'>//</span>
 3257 |     | <span class='neutral'>//    in which</span>
 3258 |     | <span class='neutral'>//</span>
 3259 |     | <span class='neutral'>//      &#39;w(q) == w_indexCurve(q) == qOrigin - q&#39;.</span>
 3260 |     | <span class='neutral'>//</span>
 3261 |     | <span class='neutral'>//    In order to determine whether &#39;qTarget&#39; belongs to the current range</span>
 3262 |     | <span class='neutral'>//    under exploration, i.e., the range between</span>
 3263 |     | <span class='neutral'>//</span>
 3264 |     | <span class='neutral'>//      &#39;min(qEnd, q[indexCurve + 2])&#39;</span>
 3265 |     | <span class='neutral'>//</span>
 3266 |     | <span class='neutral'>//    and</span>
 3267 |     | <span class='neutral'>//</span>
 3268 |     | <span class='neutral'>//      &#39;max(qEnd, q[indexCurve + 2])&#39;</span>
 3269 |     | <span class='neutral'>//</span>
 3270 |     | <span class='neutral'>//    we start from the price &#39;q[indexCurve + 2]&#39; and proceed towards the price</span>
 3271 |     | <span class='neutral'>//    &#39;qEnd&#39; by enumerating the pieces of</span>
 3272 |     | <span class='neutral'>//</span>
 3273 |     | <span class='neutral'>//      &#39;k(w(q)) == getDirection() ? k(qOrigin - q) : k(q - qOrigin)&#39;</span>
 3274 |     | <span class='neutral'>//</span>
 3275 |     | <span class='neutral'>//    one by one. The fact that &#39;w(.)&#39; is a linear function throughout the</span>
 3276 |     | <span class='neutral'>//    above range, means that we only need to worry about the pieces of either</span>
 3277 |     | <span class='neutral'>//    &#39;k(qOrigin - q)&#39; or &#39;k(q - qOrigin)&#39;, depending on the direction.</span>
 3278 |     | <span class='neutral'>//</span>
 3279 |     | <span class='neutral'>//    The process of enumerating phases starts with the following initial</span>
 3280 |     | <span class='neutral'>//    state:</span>
 3281 |     | <span class='neutral'>//</span>
 3282 |     | <span class='neutral'>//      - &#39;indexCurve := l - 2&#39;,</span>
 3283 |     | <span class='neutral'>//</span>
 3284 |     | <span class='neutral'>//      - &#39;qOrigin := q[indexCurve + 1] == q[l - 1] == qCurrent&#39;,</span>
 3285 |     | <span class='neutral'>//</span>
 3286 |     | <span class='neutral'>//      - &#39;qEnd := q[indexCurve] == q[l - 2]&#39;.</span>
 3287 |     | <span class='neutral'>//</span>
 3288 |     | <span class='neutral'>//    Once we reach &#39;qEnd&#39;, we transition to a new phase by</span>
 3289 |     | <span class='neutral'>//</span>
 3290 |     | <span class='neutral'>//      - decrementing &#39;indexCurve&#39; by one,</span>
 3291 |     | <span class='neutral'>//</span>
 3292 |     | <span class='neutral'>//      - updating &#39;qOrigin&#39; and &#39;qEnd&#39;,</span>
 3293 |     | <span class='neutral'>//</span>
 3294 |     | <span class='neutral'>//      - updating the direction flag,</span>
 3295 |     | <span class='neutral'>//</span>
 3296 |     | <span class='neutral'>//    and the cycle continues until we reach the phase to which &#39;qTarget&#39;</span>
 3297 |     | <span class='neutral'>//    belongs.</span>
 3298 |     | <span class='neutral'>//</span>
 3299 |     | <span class='neutral'>//  - &#39;indexKernelTotal&#39; keeps track of the pieces of the kernel function that</span>
 3300 |     | <span class='neutral'>//    we enumerate as we explore the current phase. As defined earlier, let:</span>
 3301 |     | <span class='neutral'>//</span>
 3302 |     | <span class='neutral'>//      - &#39;qOrigin := q[indexCurve + 1]&#39;</span>
 3303 |     | <span class='neutral'>//</span>
 3304 |     | <span class='neutral'>//      - &#39;qEnd := q[indexCurve]&#39;</span>
 3305 |     | <span class='neutral'>//</span>
 3306 |     | <span class='neutral'>//      - &#39;getDirection() := qEnd &lt; q[indexCurve + 2]&#39;</span>
 3307 |     | <span class='neutral'>//</span>
 3308 |     | <span class='neutral'>//    correspond to the current phase under exploration which leads to the</span>
 3309 |     | <span class='neutral'>//    following simplification of the liquidity distribution function:</span>
 3310 |     | <span class='neutral'>//</span>
 3311 |     | <span class='neutral'>//      &#39;k(w(q)) == getDirection() ? k(qOrigin - q) : k(q - qOrigin)&#39;</span>
 3312 |     | <span class='neutral'>//</span>
 3313 |     | <span class='neutral'>//    within the range</span>
 3314 |     | <span class='neutral'>//</span>
 3315 |     | <span class='neutral'>//      &#39;min(q[indexCurve + 2], qEnd) &lt; q &lt; max(q[indexCurve + 2], qEnd)&#39;.</span>
 3316 |     | <span class='neutral'>//</span>
 3317 |     | <span class='neutral'>//    Hence, as we move from &#39;q[indexCurve + 2]&#39; to &#39;qEnd&#39;, each piece of</span>
 3318 |     | <span class='neutral'>//    &#39;k(w(.))&#39; can be characterized via the following four vertical and</span>
 3319 |     | <span class='neutral'>//    horizontal coordinates:</span>
 3320 |     | <span class='neutral'>//</span>
 3321 |     | <span class='neutral'>//      &#39;cTotal0 := c[indexKernelTotal - 1]&#39;,</span>
 3322 |     | <span class='neutral'>//</span>
 3323 |     | <span class='neutral'>//      &#39;qTotal0 := getDirection() ? </span>
 3324 |     | <span class='neutral'>//                  qOrigin - b[indexKernelTotal - 1] : </span>
 3325 |     | <span class='neutral'>//                  qOrigin + b[indexKernelTotal - 1]&#39;,</span>
 3326 |     | <span class='neutral'>//</span>
 3327 |     | <span class='neutral'>//      &#39;cTotal1 := c[indexKernelTotal]&#39;,</span>
 3328 |     | <span class='neutral'>//</span>
 3329 |     | <span class='neutral'>//      &#39;qTotal1 := getDirection() ? </span>
 3330 |     | <span class='neutral'>//                  qOrigin - b[indexKernelTotal] : </span>
 3331 |     | <span class='neutral'>//                  qOrigin + b[indexKernelTotal]&#39;.</span>
 3332 |     | <span class='neutral'>//</span>
 3333 |     | <span class='neutral'>//    The pair &#39;(cTotal0, qTotal0)&#39; is stored in the memory space which is</span>
 3334 |     | <span class='neutral'>//    pointed to by &#39;_total0_&#39; and similarly, the pair &#39;(cTotal1, qTotal1)&#39; is</span>
 3335 |     | <span class='neutral'>//    stored in the memory space which is pointed to by &#39;_total1_&#39;.</span>
 3336 |     | <span class='neutral'>//</span>
 3337 |     | <span class='neutral'>//    Hence, the function &#39;k(w(.))&#39; is linear within the intersection of the</span>
 3338 |     | <span class='neutral'>//    two ranges:</span>
 3339 |     | <span class='neutral'>//</span>
 3340 |     | <span class='neutral'>//      &#39;min(q[indexCurve + 2], qEnd) &lt; q &lt; max(q[indexCurve + 2], qEnd)&#39;,</span>
 3341 |     | <span class='neutral'>//</span>
 3342 |     | <span class='neutral'>//    and</span>
 3343 |     | <span class='neutral'>//</span>
 3344 |     | <span class='neutral'>//      &#39;min(qTotal0, qTotal1) &lt; q &lt; max(qTotal0, qTotal1)&#39;.</span>
 3345 |     | <span class='neutral'>//</span>
 3346 |     | <span class='neutral'>//    As long as &#39;k(w(.))&#39; is linear, we have closed-forms for all of the</span>
 3347 |     | <span class='neutral'>//    integrals that we intend to calculate. Hence, it is important to keep</span>
 3348 |     | <span class='neutral'>//    track of the domain in which &#39;k(w(.))&#39; is linear and to update it as we</span>
 3349 |     | <span class='neutral'>//    move forward in our search. Moreover, we need to make sure that &#39;qTarget&#39;</span>
 3350 |     | <span class='neutral'>//    does not go beyond &#39;qLimitWithinInterval&#39;. Hence, with each transition to</span>
 3351 |     | <span class='neutral'>//    a new phase or a new piece of the kernel function, we make the following</span>
 3352 |     | <span class='neutral'>//    two updates:</span>
 3353 |     | <span class='neutral'>//</span>
 3354 |     | <span class='neutral'>//      &#39;qBegin := getDirection() ? </span>
 3355 |     | <span class='neutral'>//                 min(q[indexCurve + 2], qTotal0) : </span>
 3356 |     | <span class='neutral'>//                 max(q[indexCurve + 2], qTotal0)&#39;,</span>
 3357 |     | <span class='neutral'>//</span>
 3358 |     | <span class='neutral'>//      &#39;qTarget := (</span>
 3359 |     | <span class='neutral'>//                    getDirection() == getZeroForOne()</span>
 3360 |     | <span class='neutral'>//                  ) ? (</span>
 3361 |     | <span class='neutral'>//                    getDirection() ? </span>
 3362 |     | <span class='neutral'>//                    max(max(qEnd, qTotal1), qLimitWithinInterval) : </span>
 3363 |     | <span class='neutral'>//                    min(min(qEnd, qTotal1), qLimitWithinInterval)</span>
 3364 |     | <span class='neutral'>//                  ) : (</span>
 3365 |     | <span class='neutral'>//                    getDirection() ? </span>
 3366 |     | <span class='neutral'>//                    max(qEnd, qTotal1) : </span>
 3367 |     | <span class='neutral'>//                    min(qEnd, qTotal1)</span>
 3368 |     | <span class='neutral'>//                  )&#39;,</span>
 3369 |     | <span class='neutral'>//</span>
 3370 |     | <span class='neutral'>//    where &#39;qBegin&#39; and &#39;qTarget&#39; are stored, respectively, in the memory</span>
 3371 |     | <span class='neutral'>//    spaces that are pointed to by &#39;_begin_&#39; and &#39;_target_&#39;. Both values are</span>
 3372 |     | <span class='neutral'>//    updated with each transition to a new phase or a new piece of &#39;k(w(.))&#39;.</span>
 3373 |     | <span class='neutral'>//</span>
 3374 |     | <span class='neutral'>//    The process of enumerating the pieces of the kernel function starts with</span>
 3375 |     | <span class='neutral'>//    the initial state &#39;indexKernelTotal := 1&#39;.</span>
 3376 |     | <span class='neutral'>//</span>
 3377 |     | <span class='neutral'>// While searching for &#39;qTarget&#39;, we need to calculate the following two</span>
 3378 |     | <span class='neutral'>// integrals, in addition to &#39;currentToTarget&#39; and &#39;incomingCurrentToTarget&#39;:</span>
 3379 |     | <span class='neutral'>//</span>
 3380 |     | <span class='neutral'>//                           - 8</span>
 3381 |     | <span class='neutral'>//    currentToOrigin      e</span>
 3382 |     | <span class='neutral'>//  &#39;----------------- := ------- * (</span>
 3383 |     | <span class='neutral'>//       2 ** 216            2</span>
 3384 |     | <span class='neutral'>//</span>
 3385 |     | <span class='neutral'>//                         / qOrigin                  / qCurrent</span>
 3386 |     | <span class='neutral'>//                        |    - h / 2               |    + h / 2</span>
 3387 |     | <span class='neutral'>//     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh</span>
 3388 |     | <span class='neutral'>//                        |                          |</span>
 3389 |     | <span class='neutral'>//                       / qCurrent                 / qOrigin</span>
 3390 |     | <span class='neutral'>//</span>
 3391 |     | <span class='neutral'>//   )&#39;</span>
 3392 |     | <span class='neutral'>//</span>
 3393 |     | <span class='neutral'>// and</span>
 3394 |     | <span class='neutral'>//                             - 8</span>
 3395 |     | <span class='neutral'>//    originToOvershoot      e</span>
 3396 |     | <span class='neutral'>//  &#39;------------------- := ------- * (</span>
 3397 |     | <span class='neutral'>//        2 ** 216             2</span>
 3398 |     | <span class='neutral'>//</span>
 3399 |     | <span class='neutral'>//     getZeroForOne() ? </span>
 3400 |     | <span class='neutral'>//</span>
 3401 |     | <span class='neutral'>//       / qOrigin</span>
 3402 |     | <span class='neutral'>//      |    + h / 2</span>
 3403 |     | <span class='neutral'>//      |  e         k(qOrigin - h) dh :</span>
 3404 |     | <span class='neutral'>//      |</span>
 3405 |     | <span class='neutral'>//     / qTarget</span>
 3406 |     | <span class='neutral'>//</span>
 3407 |     | <span class='neutral'>//       / qTarget</span>
 3408 |     | <span class='neutral'>//      |    - h / 2</span>
 3409 |     | <span class='neutral'>//      |  e         k(h - qOrigin) dh</span>
 3410 |     | <span class='neutral'>//      |</span>
 3411 |     | <span class='neutral'>//     / qOrigin</span>
 3412 |     | <span class='neutral'>//</span>
 3413 |     | <span class='neutral'>//   )&#39;.</span>
 3414 |     | <span class='neutral'>//</span>
 3415 |     | <span class='neutral'>// To summarize, the four integrals:</span>
 3416 |     | <span class='neutral'>//</span>
 3417 |     | <span class='neutral'>//  - &#39;currentToTarget&#39;,</span>
 3418 |     | <span class='neutral'>//</span>
 3419 |     | <span class='neutral'>//  - &#39;incomingCurrentToTarget&#39;,</span>
 3420 |     | <span class='neutral'>//</span>
 3421 |     | <span class='neutral'>//  - &#39;currentToOrigin&#39;, and</span>
 3422 |     | <span class='neutral'>//</span>
 3423 |     | <span class='neutral'>//  - &#39;originToOvershoot&#39;,</span>
 3424 |     | <span class='neutral'>//</span>
 3425 |     | <span class='neutral'>// are incremented with each decrement of &#39;indexCurve&#39; or increment of</span>
 3426 |     | <span class='neutral'>// &#39;indexKernelTotal&#39;.</span>
 3427 |     | <span class='neutral'>//</span>
 3428 |     | <span class='neutral'>// The following figure illustrates the ranges covered by the above integrals</span>
 3429 |     | <span class='neutral'>// in the case of &#39;getZeroForOne() == false&#39;, i.e., &#39;qCurrent &lt; qTarget&#39;:</span>
 3430 |     | <span class='neutral'>//</span>
 3431 |     | <span class='neutral'>//                                                currentToTarget</span>
 3432 |     | <span class='neutral'>//                                                exp(- h / 2) * k(w(h))</span>
 3433 |     | <span class='neutral'>//           currentToOrigin                    / </span>
 3434 |     | <span class='neutral'>//    exp(+ h / 2) * k(w(h))                   /\ </span>
 3435 |     | <span class='neutral'>//                          \                 /   incomingCurrentToTarget</span>
 3436 |     | <span class='neutral'>//                           \               /    exp(+ h / 2) * k(w(h))</span>
 3437 |     | <span class='neutral'>//                            \             /</span>
 3438 |     | <span class='neutral'>//                     |&lt;------------&gt;|&lt;--------&gt;|</span>
 3439 |     | <span class='neutral'>//                     |              |          |</span>
 3440 |     | <span class='neutral'>//      +--------------+--------------+----------+------------------+</span>
 3441 |     | <span class='neutral'>//      |              |              |          |                  |</span>
 3442 |     | <span class='neutral'>//    qLower           |          qCurrent       |                qUpper</span>
 3443 |     | <span class='neutral'>//                     |                         |</span>
 3444 |     | <span class='neutral'>//                     |&lt;-----------------------&gt;|</span>
 3445 |     | <span class='neutral'>//                     |            \            |</span>
 3446 |     | <span class='neutral'>//                  qOrigin          \        qTarget == qOvershoot</span>
 3447 |     | <span class='neutral'>//                                    \</span>
 3448 |     | <span class='neutral'>//                             originToOvershoot</span>
 3449 |     | <span class='neutral'>//                             exp(- h / 2) * k(h - qOrigin)</span>
 3450 |     | <span class='neutral'>//</span>
 3451 |     | <span class='neutral'>// The search for &#39;qTarget&#39; is conducted by calling the method &#39;moveTarget()&#39;</span>
 3452 |     | <span class='neutral'>// from &#39;Interval.sol&#39; in a loop until either of the following condition are</span>
 3453 |     | <span class='neutral'>// met:</span>
 3454 |     | <span class='neutral'>//</span>
 3455 |     | <span class='neutral'>//  - &#39;qLimitWithinInterval == qTarget&#39;, or</span>
 3456 |     | <span class='neutral'>//</span>
 3457 |     | <span class='neutral'>//  - &#39;integralLimit == (</span>
 3458 |     | <span class='neutral'>//       getExactInput() ? incomingCurrentToTarget : currentToTarget</span>
 3459 |     | <span class='neutral'>//     )&#39;.</span>
 3460 |     | <span class='neutral'>//</span>
 3461 |     | <span class='neutral'>// Define:</span>
 3462 |     | <span class='neutral'>//</span>
 3463 |     | <span class='neutral'>//                                - 8     / qUpper</span>
 3464 |     | <span class='neutral'>//    integral0Incremented      e        |    - h / 2</span>
 3465 |     | <span class='neutral'>//  &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;,</span>
 3466 |     | <span class='neutral'>//          2 ** 216              2      |</span>
 3467 |     | <span class='neutral'>//                                      / qTarget</span>
 3468 |     | <span class='neutral'>//</span>
 3469 |     | <span class='neutral'>//                                - 8     / qTarget</span>
 3470 |     | <span class='neutral'>//    integral1Incremented      e        |    + h / 2</span>
 3471 |     | <span class='neutral'>//  &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;.</span>
 3472 |     | <span class='neutral'>//          2 ** 216              2      |</span>
 3473 |     | <span class='neutral'>//                                      / qLower</span>
 3474 |     | <span class='neutral'>//</span>
 3475 |     | <span class='neutral'>// Now, the total reserves of &#39;tag0&#39; and &#39;tag1&#39; within &#39;[qLower, qUpper]&#39; after</span>
 3476 |     | <span class='neutral'>// the movement of price from &#39;qCurrent&#39; to &#39;qTarget&#39; (i.e., after the exchange</span>
 3477 |     | <span class='neutral'>// of &#39;amount0Partial&#39; and &#39;amount1Partial&#39;) are equal to </span>
 3478 |     | <span class='neutral'>//</span>
 3479 |     | <span class='neutral'>//                                       growth      integral0Incremented</span>
 3480 |     | <span class='neutral'>//  &#39;sqrtInverseOffset * sharesTotal * ---------- * ----------------------&#39;</span>
 3481 |     | <span class='neutral'>//                                      2 ** 111         outgoingMax</span>
 3482 |     | <span class='neutral'>//</span>
 3483 |     | <span class='neutral'>// and</span>
 3484 |     | <span class='neutral'>//</span>
 3485 |     | <span class='neutral'>//                                growth      integral1Incremented</span>
 3486 |     | <span class='neutral'>//  &#39;sqrtOffset * sharesTotal * ---------- * ----------------------&#39;,</span>
 3487 |     | <span class='neutral'>//                               2 ** 111         outgoingMax</span>
 3488 |     | <span class='neutral'>//</span>
 3489 |     | <span class='neutral'>// respectively. The ranges covered by &#39;integral0Incremented&#39; and</span>
 3490 |     | <span class='neutral'>// &#39;integral1Incremented&#39; are illustrated as follows:</span>
 3491 |     | <span class='neutral'>//</span>
 3492 |     | <span class='neutral'>//                                                    integral0Incremented</span>
 3493 |     | <span class='neutral'>//                                                    exp(- h / 2) * k(w(h))</span>
 3494 |     | <span class='neutral'>//                integral1Incremented               /</span>
 3495 |     | <span class='neutral'>//                exp(+ h / 2) * k(w(h))            /</span>
 3496 |     | <span class='neutral'>//      |&lt;--------------------------------------&gt;|&lt;----------------&gt;|</span>
 3497 |     | <span class='neutral'>//      |                                        |                  |</span>
 3498 |     | <span class='neutral'>//      +----------------------------------------+------------------+</span>
 3499 |     | <span class='neutral'>//      |                                        |                  |</span>
 3500 |     | <span class='neutral'>//    qLower                                  qTarget             qUpper</span>
 3501 |     | <span class='neutral'>//</span>
 3502 |     | <span class='neutral'>// After the search for &#39;qTarget&#39; is concluded, and &#39;amount0Partial&#39; and</span>
 3503 |     | <span class='neutral'>// &#39;amount1Partial&#39; are calculated, we need to determine &#39;qOvershoot&#39;. If</span>
 3504 |     | <span class='neutral'>// &#39;getZeroForOne() == false&#39;, we have</span>
 3505 |     | <span class='neutral'>//</span>
 3506 |     | <span class='neutral'>//  &#39;qTarget &lt;= qOvershoot &lt;= qUpper&#39;</span>
 3507 |     | <span class='neutral'>//</span>
 3508 |     | <span class='neutral'>// and if &#39;getZeroForOne() == true&#39;, we have</span>
 3509 |     | <span class='neutral'>//</span>
 3510 |     | <span class='neutral'>//  &#39;qLower &lt;= qOvershoot &lt;= qTarget&#39;.</span>
 3511 |     | <span class='neutral'>//</span>
 3512 |     | <span class='neutral'>// The curve sequence is first amended with &#39;qOvershoot&#39; and then &#39;qTarget&#39;, in</span>
 3513 |     | <span class='neutral'>// preparation for the next swap.</span>
 3514 |     | <span class='neutral'>//</span>
 3515 |     | <span class='neutral'>// To this end, define:</span>
 3516 |     | <span class='neutral'>//                              - 8</span>
 3517 |     | <span class='neutral'>//    currentToOvershoot      e</span>
 3518 |     | <span class='neutral'>//  &#39;-------------------- := ------- * (</span>
 3519 |     | <span class='neutral'>//         2 ** 216             2</span>
 3520 |     | <span class='neutral'>//</span>
 3521 |     | <span class='neutral'>//                         / qCurrent                 / qOvershoot</span>
 3522 |     | <span class='neutral'>//                        |    + h / 2               |    - h / 2</span>
 3523 |     | <span class='neutral'>//     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh</span>
 3524 |     | <span class='neutral'>//                        |                          |</span>
 3525 |     | <span class='neutral'>//                       / qOvershoot               / qCurrent</span>
 3526 |     | <span class='neutral'>//</span>
 3527 |     | <span class='neutral'>//   )&#39;</span>
 3528 |     | <span class='neutral'>//</span>
 3529 |     | <span class='neutral'>// and</span>
 3530 |     | <span class='neutral'>//                             - 8</span>
 3531 |     | <span class='neutral'>//    targetToOvershoot      e</span>
 3532 |     | <span class='neutral'>//  &#39;------------------- := ------- * (</span>
 3533 |     | <span class='neutral'>//         2 ** 216            2</span>
 3534 |     | <span class='neutral'>//</span>
 3535 |     | <span class='neutral'>//     getZeroForOne()</span>
 3536 |     | <span class='neutral'>//</span>
 3537 |     | <span class='neutral'>//         / qTarget</span>
 3538 |     | <span class='neutral'>//        |    + h / 2</span>
 3539 |     | <span class='neutral'>//     ?  |  e         k(qTarget - h) dh</span>
 3540 |     | <span class='neutral'>//        |</span>
 3541 |     | <span class='neutral'>//       / qOvershoot</span>
 3542 |     | <span class='neutral'>//</span>
 3543 |     | <span class='neutral'>//         / qOvershoot</span>
 3544 |     | <span class='neutral'>//        |    - h / 2</span>
 3545 |     | <span class='neutral'>//     :  |  e         k(h - qTarget) dh</span>
 3546 |     | <span class='neutral'>//        |</span>
 3547 |     | <span class='neutral'>//       / qTarget</span>
 3548 |     | <span class='neutral'>//</span>
 3549 |     | <span class='neutral'>//   )&#39;</span>
 3550 |     | <span class='neutral'>//</span>
 3551 |     | <span class='neutral'>// While searching for &#39;qOvershoot&#39;, the four integrals:</span>
 3552 |     | <span class='neutral'>//</span>
 3553 |     | <span class='neutral'>//  - &#39;currentToOvershoot&#39;,</span>
 3554 |     | <span class='neutral'>//</span>
 3555 |     | <span class='neutral'>//  - &#39;targetToOvershoot&#39;,</span>
 3556 |     | <span class='neutral'>//</span>
 3557 |     | <span class='neutral'>//  - &#39;originToOvershoot&#39;, and</span>
 3558 |     | <span class='neutral'>//</span>
 3559 |     | <span class='neutral'>//  - &#39;currentToOrigin&#39;,</span>
 3560 |     | <span class='neutral'>//</span>
 3561 |     | <span class='neutral'>// are kept track of. The following figure illustrates the ranges covered by</span>
 3562 |     | <span class='neutral'>// the above integrals in the case of &#39;getZeroForOne() == false&#39;, i.e.,</span>
 3563 |     | <span class='neutral'>// &#39;qCurrent &lt; qTarget&#39;:</span>
 3564 |     | <span class='neutral'>//</span>
 3565 |     | <span class='neutral'>//           currentToOrigin                      currentToOvershoot</span>
 3566 |     | <span class='neutral'>//    exp(+ h / 2) * k(w(h))                      exp(- h / 2) * k(w(h))</span>
 3567 |     | <span class='neutral'>//                          \                    /</span>
 3568 |     | <span class='neutral'>//                           \                  /</span>
 3569 |     | <span class='neutral'>//                            \                /</span>
 3570 |     | <span class='neutral'>//              |&lt;-------------------&gt;|&lt;---------------&gt;|</span>
 3571 |     | <span class='neutral'>//              |                     |                 |</span>
 3572 |     | <span class='neutral'>//              |                     |    qTarget      |</span>
 3573 |     | <span class='neutral'>//              |                     |       |         |</span>
 3574 |     | <span class='neutral'>//      +-------+---------------------+-------+---------+-----------+</span>
 3575 |     | <span class='neutral'>//      |       |                     |       |         |           |</span>
 3576 |     | <span class='neutral'>//    qLower    |                 qCurrent    |&lt;-------&gt;|         qUpper</span>
 3577 |     | <span class='neutral'>//              |                                  /    |</span>
 3578 |     | <span class='neutral'>//              |                                 /     |</span>
 3579 |     | <span class='neutral'>//              |                targetToOvershoot      |</span>
 3580 |     | <span class='neutral'>//              |    exp(- h / 2) * k(h - qTarget)      |</span>
 3581 |     | <span class='neutral'>//              |                                       |</span>
 3582 |     | <span class='neutral'>//              |                                       |</span>
 3583 |     | <span class='neutral'>//              |&lt;-------------------------------------&gt;|</span>
 3584 |     | <span class='neutral'>//              |                     /                 |</span>
 3585 |     | <span class='neutral'>//           qOrigin                 /              qOvershoot</span>
 3586 |     | <span class='neutral'>//                                  /</span>
 3587 |     | <span class='neutral'>//                                 /</span>
 3588 |     | <span class='neutral'>//                originToOvershoot</span>
 3589 |     | <span class='neutral'>//    exp(- h / 2) * k(h - qOrigin)</span>
 3590 |     | <span class='neutral'>//</span>
 3591 |     | <span class='neutral'>// Now, in order to find &#39;qOvershoot&#39;, we need to solve the equation:</span>
 3592 |     | <span class='neutral'>//</span>
 3593 |     | <span class='neutral'>//   &#39;f(qOvershoot) == 0&#39;</span>
 3594 |     | <span class='neutral'>//</span>
 3595 |     | <span class='neutral'>// where</span>
 3596 |     | <span class='neutral'>//</span>
 3597 |     | <span class='neutral'>//   &#39;f(qOvershoot) := getZeroForOne() ? </span>
 3598 |     | <span class='neutral'>//                     s0(qOvershoot) - s1(qOvershoot) : </span>
 3599 |     | <span class='neutral'>//                     s1(qOvershoot) - s0(qOvershoot)&#39;,</span>
 3600 |     | <span class='neutral'>//</span>
 3601 |     | <span class='neutral'>// and the two functions &#39;s0&#39; and &#39;s1&#39; are defined as:</span>
 3602 |     | <span class='neutral'>//</span>
 3603 |     | <span class='neutral'>//                          - 8      / qTarget</span>
 3604 |     | <span class='neutral'>//                        e         |   + h / 2</span>
 3605 |     | <span class='neutral'>//                       ------- *  |  e        k(wAmended(h)) dh</span>
 3606 |     | <span class='neutral'>//                          2       |</span>
 3607 |     | <span class='neutral'>//                                 / qLower</span>
 3608 |     | <span class='neutral'>//   &#39;s1(qOvershoot) := ------------------------------------------&#39;,</span>
 3609 |     | <span class='neutral'>//                                integral1Incremented</span>
 3610 |     | <span class='neutral'>//</span>
 3611 |     | <span class='neutral'>//                          - 8      / qUpper</span>
 3612 |     | <span class='neutral'>//                        e         |   - h / 2</span>
 3613 |     | <span class='neutral'>//                       ------- *  |  e        k(wAmended(h)) dh</span>
 3614 |     | <span class='neutral'>//                          2       |</span>
 3615 |     | <span class='neutral'>//                                 / qTarget</span>
 3616 |     | <span class='neutral'>//   &#39;s0(qOvershoot) := ------------------------------------------&#39;.</span>
 3617 |     | <span class='neutral'>//                                integral0Incremented</span>
 3618 |     | <span class='neutral'>//</span>
 3619 |     | <span class='neutral'>// Now, according to the amendement procedure which is described in</span>
 3620 |     | <span class='neutral'>// &#39;Curve.sol&#39;, if &#39;getZeroForOne() == false&#39;, we have:</span>
 3621 |     | <span class='neutral'>//</span>
 3622 |     | <span class='neutral'>//                       / k(w(h))            if  qOvershoot &lt; h &lt; qUpper</span>
 3623 |     | <span class='neutral'>//   &#39;k(wAmended(h)) == |  k(h - qTarget)     if  qTarget &lt; h &lt; qOvershoot &#39;</span>
 3624 |     | <span class='neutral'>//                      |  k(qOvershoot - h)  if  qOrigin &lt; h &lt; qTarget</span>
 3625 |     | <span class='neutral'>//                       \ k(w(h))            if  qLower &lt; h &lt; qOrigin</span>
 3626 |     | <span class='neutral'>//</span>
 3627 |     | <span class='neutral'>// and if &#39;getZeroForOne() == true&#39;, we have:</span>
 3628 |     | <span class='neutral'>//</span>
 3629 |     | <span class='neutral'>//                       / k(w(h))            if  qLower &lt; h &lt; qOvershoot</span>
 3630 |     | <span class='neutral'>//   &#39;k(wAmended(h)) == |  k(qTarget - h)     if  qOvershoot &lt; h &lt; qTarget &#39;.</span>
 3631 |     | <span class='neutral'>//                      |  k(h - qOvershoot)  if  qTarget &lt; h &lt; qOrigin</span>
 3632 |     | <span class='neutral'>//                       \ k(w(h))            if  qOrigin &lt; h &lt; qUpper</span>
 3633 |     | <span class='neutral'>//</span>
 3634 |     | <span class='neutral'>// For the case &#39;getZeroForOne() == false&#39;, the above formulas conclude that:</span>
 3635 |     | <span class='neutral'>//</span>
 3636 |     | <span class='neutral'>//  - the numerator of &#39;s1&#39; is equal to:</span>
 3637 |     | <span class='neutral'>//</span>
 3638 |     | <span class='neutral'>//        - 8     / qTarget</span>
 3639 |     | <span class='neutral'>//      e        |    + h / 2</span>
 3640 |     | <span class='neutral'>//    &#39;------- * |  e         k(wAmended(h)) dh == </span>
 3641 |     | <span class='neutral'>//        2      |</span>
 3642 |     | <span class='neutral'>//              / qLower</span>
 3643 |     | <span class='neutral'>//</span>
 3644 |     | <span class='neutral'>//        - 8     / qOrigin</span>
 3645 |     | <span class='neutral'>//      e        |    + h / 2</span>
 3646 |     | <span class='neutral'>//     ------- * |  e         k(wAmended(h)) dh +</span>
 3647 |     | <span class='neutral'>//        2      |</span>
 3648 |     | <span class='neutral'>//              / qLower</span>
 3649 |     | <span class='neutral'>//</span>
 3650 |     | <span class='neutral'>//                                - 8     / qTarget</span>
 3651 |     | <span class='neutral'>//                              e        |    + h / 2</span>
 3652 |     | <span class='neutral'>//                             ------- * |  e         k(wAmended(h)) dh ==</span>
 3653 |     | <span class='neutral'>//                                2      |</span>
 3654 |     | <span class='neutral'>//                                      / qOrigin</span>
 3655 |     | <span class='neutral'>//</span>
 3656 |     | <span class='neutral'>//        - 8     / qOrigin</span>
 3657 |     | <span class='neutral'>//      e        |    + h / 2</span>
 3658 |     | <span class='neutral'>//     ------- * |  e         k(w(h)) dh +</span>
 3659 |     | <span class='neutral'>//        2      |</span>
 3660 |     | <span class='neutral'>//              / qLower</span>
 3661 |     | <span class='neutral'>//</span>
 3662 |     | <span class='neutral'>//                                - 8     / qTarget</span>
 3663 |     | <span class='neutral'>//                              e        |    + h / 2</span>
 3664 |     | <span class='neutral'>//                             ------- * |  e         k(qOvershoot - h) dh ==</span>
 3665 |     | <span class='neutral'>//                                2      |</span>
 3666 |     | <span class='neutral'>//                                      / qOrigin</span>
 3667 |     | <span class='neutral'>//</span>
 3668 |     | <span class='neutral'>//        - 8     / qOrigin</span>
 3669 |     | <span class='neutral'>//      e        |    + h / 2</span>
 3670 |     | <span class='neutral'>//     ------- * |  e         k(w(h)) dh +</span>
 3671 |     | <span class='neutral'>//        2      |</span>
 3672 |     | <span class='neutral'>//              / qLower</span>
 3673 |     | <span class='neutral'>//</span>
 3674 |     | <span class='neutral'>//                                - 8     / qOvershoot</span>
 3675 |     | <span class='neutral'>//                              e        |    + h / 2</span>
 3676 |     | <span class='neutral'>//                             ------- * |  e         k(qOvershoot - h) dh -</span>
 3677 |     | <span class='neutral'>//                                2      |</span>
 3678 |     | <span class='neutral'>//                                      / qOrigin</span>
 3679 |     | <span class='neutral'>//</span>
 3680 |     | <span class='neutral'>//                                - 8     / qOvershoot</span>
 3681 |     | <span class='neutral'>//                              e        |    + h / 2</span>
 3682 |     | <span class='neutral'>//                             ------- * |  e         k(qOvershoot - h) dh ==</span>
 3683 |     | <span class='neutral'>//                                2      |</span>
 3684 |     | <span class='neutral'>//                                      / qTarget</span>
 3685 |     | <span class='neutral'>//</span>
 3686 |     | <span class='neutral'>//        - 8     / qTarget</span>
 3687 |     | <span class='neutral'>//      e        |    + h / 2</span>
 3688 |     | <span class='neutral'>//     ------- * |  e         k(w(h)) dh - </span>
 3689 |     | <span class='neutral'>//        2      |</span>
 3690 |     | <span class='neutral'>//              / qLower</span>
 3691 |     | <span class='neutral'>//</span>
 3692 |     | <span class='neutral'>//        - 8     / qTarget                   - 8     / qCurrent</span>
 3693 |     | <span class='neutral'>//      e        |    + h / 2               e        |    + h / 2</span>
 3694 |     | <span class='neutral'>//     ------- * |  e         k(w(h)) dh - ------- * |  e         k(w(h)) dh +</span>
 3695 |     | <span class='neutral'>//        2      |                            2      |</span>
 3696 |     | <span class='neutral'>//              / qCurrent                          / qOrigin</span>
 3697 |     | <span class='neutral'>//</span>
 3698 |     | <span class='neutral'>//        - 8 + (qOrigin + qOvershoot) / 2     / qOvershoot</span>
 3699 |     | <span class='neutral'>//      e                                     |    - h / 2</span>
 3700 |     | <span class='neutral'>//     ------------------------------------ * |  e         k(h - qOrigin) dh -</span>
 3701 |     | <span class='neutral'>//                        2                   |</span>
 3702 |     | <span class='neutral'>//                                           / qOrigin</span>
 3703 |     | <span class='neutral'>//</span>
 3704 |     | <span class='neutral'>//        - 8 + (qTarget + qOvershoot) / 2     / qOvershoot</span>
 3705 |     | <span class='neutral'>//      e                                     |    - h / 2</span>
 3706 |     | <span class='neutral'>//     ------------------------------------ * |  e         k(h - qTarget) dh ==</span>
 3707 |     | <span class='neutral'>//                        2                   |</span>
 3708 |     | <span class='neutral'>//                                           / qTarget</span>
 3709 |     | <span class='neutral'>//</span>
 3710 |     | <span class='neutral'>//      integral1Incremented - incomingCurrentToTarget - currentToOrigin</span>
 3711 |     | <span class='neutral'>//     ------------------------------------------------------------------ + </span>
 3712 |     | <span class='neutral'>//                                  2 ** 216</span>
 3713 |     | <span class='neutral'>//</span>
 3714 |     | <span class='neutral'>//      exp((qOrigin + qOvershoot) / 2) * originToOvershoot</span>
 3715 |     | <span class='neutral'>//     ----------------------------------------------------- - </span>
 3716 |     | <span class='neutral'>//                            2 ** 216</span>
 3717 |     | <span class='neutral'>//</span>
 3718 |     | <span class='neutral'>//      exp((qTarget + qOvershoot) / 2) * targetToOvershoot</span>
 3719 |     | <span class='neutral'>//     -----------------------------------------------------&#39;.</span>
 3720 |     | <span class='neutral'>//                            2 ** 216</span>
 3721 |     | <span class='neutral'>//</span>
 3722 |     | <span class='neutral'>//  - the numerator of &#39;s0&#39; is equal to:</span>
 3723 |     | <span class='neutral'>//</span>
 3724 |     | <span class='neutral'>//        - 8     / qUpper</span>
 3725 |     | <span class='neutral'>//      e        |    - h / 2</span>
 3726 |     | <span class='neutral'>//    &#39;------- * |  e         k(wAmended(h)) dh == </span>
 3727 |     | <span class='neutral'>//        2      |</span>
 3728 |     | <span class='neutral'>//              / qTarget</span>
 3729 |     | <span class='neutral'>//</span>
 3730 |     | <span class='neutral'>//        - 8     / qOvershoot</span>
 3731 |     | <span class='neutral'>//      e        |    - h / 2</span>
 3732 |     | <span class='neutral'>//     ------- * |  e         k(wAmended(h)) dh +</span>
 3733 |     | <span class='neutral'>//        2      |</span>
 3734 |     | <span class='neutral'>//              / qTarget</span>
 3735 |     | <span class='neutral'>//</span>
 3736 |     | <span class='neutral'>//                                - 8     / qUpper</span>
 3737 |     | <span class='neutral'>//                              e        |    - h / 2</span>
 3738 |     | <span class='neutral'>//                             ------- * |  e         k(wAmended(h)) dh == </span>
 3739 |     | <span class='neutral'>//                                2      |</span>
 3740 |     | <span class='neutral'>//                                      / qOvershoot</span>
 3741 |     | <span class='neutral'>//</span>
 3742 |     | <span class='neutral'>//        - 8     / qOvershoot</span>
 3743 |     | <span class='neutral'>//      e        |    - h / 2</span>
 3744 |     | <span class='neutral'>//     ------- * |  e         k(h - qTarget) dh +</span>
 3745 |     | <span class='neutral'>//        2      |</span>
 3746 |     | <span class='neutral'>//              / qTarget</span>
 3747 |     | <span class='neutral'>//</span>
 3748 |     | <span class='neutral'>//                                - 8     / qUpper</span>
 3749 |     | <span class='neutral'>//                              e        |    - h / 2</span>
 3750 |     | <span class='neutral'>//                             ------- * |  e         k(w(h)) dh == </span>
 3751 |     | <span class='neutral'>//                                2      |</span>
 3752 |     | <span class='neutral'>//                                      / qOvershoot</span>
 3753 |     | <span class='neutral'>//</span>
 3754 |     | <span class='neutral'>//        - 8     / qOvershoot</span>
 3755 |     | <span class='neutral'>//      e        |    - h / 2</span>
 3756 |     | <span class='neutral'>//     ------- * |  e         k(h - qTarget) dh +</span>
 3757 |     | <span class='neutral'>//        2      |</span>
 3758 |     | <span class='neutral'>//              / qTarget</span>
 3759 |     | <span class='neutral'>//</span>
 3760 |     | <span class='neutral'>//        - 8     / qTarget                   - 8     / qUpper</span>
 3761 |     | <span class='neutral'>//      e        |    - h / 2               e        |    - h / 2</span>
 3762 |     | <span class='neutral'>//     ------- * |  e         k(w(h)) dh + ------- * |  e         k(w(h)) dh -</span>
 3763 |     | <span class='neutral'>//        2      |                            2      |</span>
 3764 |     | <span class='neutral'>//              / qCurrent                          / qTarget</span>
 3765 |     | <span class='neutral'>//</span>
 3766 |     | <span class='neutral'>//        - 8     / qOvershoot</span>
 3767 |     | <span class='neutral'>//      e        |</span>
 3768 |     | <span class='neutral'>//     ------- * |  e         k(w(h)) dh == </span>
 3769 |     | <span class='neutral'>//        2      |</span>
 3770 |     | <span class='neutral'>//              / qCurrent</span>
 3771 |     | <span class='neutral'>//</span>
 3772 |     | <span class='neutral'>//      targetToOvershoot + currentToTarget</span>
 3773 |     | <span class='neutral'>//     ------------------------------------- + </span>
 3774 |     | <span class='neutral'>//                    2 ** 216</span>
 3775 |     | <span class='neutral'>//</span>
 3776 |     | <span class='neutral'>//      integral0Incremented - currentToOvershoot</span>
 3777 |     | <span class='neutral'>//     -------------------------------------------&#39;.</span>
 3778 |     | <span class='neutral'>//                       2 ** 216</span>
 3779 |     | <span class='neutral'>//</span>
 3780 |     | <span class='neutral'>// Similar arguments can be made for the case &#39;getZeroForOne() == true&#39; and for</span>
 3781 |     | <span class='neutral'>// both cases, we have:</span>
 3782 |     | <span class='neutral'>//</span>
 3783 |     | <span class='neutral'>//   &#39;f(qOvershoot) := getZeroForOne() ? (</span>
 3784 |     | <span class='neutral'>//</span>
 3785 |     | <span class='neutral'>//      (</span>
 3786 |     | <span class='neutral'>//</span>
 3787 |     | <span class='neutral'>//        exp(- (qOrigin + qOvershoot) / 2) * originToOvershoot -</span>
 3788 |     | <span class='neutral'>//</span>
 3789 |     | <span class='neutral'>//        exp(- (qTarget + qOvershoot) / 2) * targetToOvershoot - </span>
 3790 |     | <span class='neutral'>//</span>
 3791 |     | <span class='neutral'>//        incomingCurrentToTarget - currentToOrigin</span>
 3792 |     | <span class='neutral'>//</span>
 3793 |     | <span class='neutral'>//      ) / integral0Incremented - (</span>
 3794 |     | <span class='neutral'>//</span>
 3795 |     | <span class='neutral'>//        targetToOvershoot + currentToTarget - currentToOvershoot</span>
 3796 |     | <span class='neutral'>//      </span>
 3797 |     | <span class='neutral'>//      ) / integral1Incremented</span>
 3798 |     | <span class='neutral'>//</span>
 3799 |     | <span class='neutral'>//    ) : (</span>
 3800 |     | <span class='neutral'>//</span>
 3801 |     | <span class='neutral'>//      (</span>
 3802 |     | <span class='neutral'>//</span>
 3803 |     | <span class='neutral'>//        exp(+ (qOrigin + qOvershoot) / 2) * originToOvershoot -</span>
 3804 |     | <span class='neutral'>//</span>
 3805 |     | <span class='neutral'>//        exp(+ (qTarget + qOvershoot) / 2) * targetToOvershoot - </span>
 3806 |     | <span class='neutral'>//</span>
 3807 |     | <span class='neutral'>//        incomingCurrentToTarget - currentToOrigin</span>
 3808 |     | <span class='neutral'>//</span>
 3809 |     | <span class='neutral'>//      ) / integral1Incremented - (</span>
 3810 |     | <span class='neutral'>//</span>
 3811 |     | <span class='neutral'>//        targetToOvershoot + currentToTarget - currentToOvershoot</span>
 3812 |     | <span class='neutral'>//      </span>
 3813 |     | <span class='neutral'>//      ) / integral0Incremented</span>
 3814 |     | <span class='neutral'>//</span>
 3815 |     | <span class='neutral'>//    )&#39;.</span>
 3816 |     | <span class='neutral'>//</span>
 3817 |     | <span class='neutral'>// We use Newton&#39;s method in order to pinpoint the precise value for</span>
 3818 |     | <span class='neutral'>// &#39;qOvershoot&#39; which satisfies:</span>
 3819 |     | <span class='neutral'>//</span>
 3820 |     | <span class='neutral'>//   &#39;f(qOvershoot) == 0&#39;.</span>
 3821 |     | <span class='neutral'>//</span>
 3822 |     | <span class='neutral'>// To this end, we need access to a simple and closed-form expression for all</span>
 3823 |     | <span class='neutral'>// of the above integrals. Hence, we first need to restrict our search to a</span>
 3824 |     | <span class='neutral'>// domain in which both &#39;k(w(.))&#39; and &#39;k(|h - qTarget|)&#39; are linear.</span>
 3825 |     | <span class='neutral'>//</span>
 3826 |     | <span class='neutral'>// Hence, prior to the above-mentioned numerical search, we first need to move</span>
 3827 |     | <span class='neutral'>// &#39;qOvershoot&#39; from &#39;qTarget&#39; towards &#39;qNext&#39; until we determine the</span>
 3828 |     | <span class='neutral'>// followings:</span>
 3829 |     | <span class='neutral'>//</span>
 3830 |     | <span class='neutral'>//   - The piece of &#39;k(w(.))&#39; to which &#39;qOvershoot&#39; belongs.</span>
 3831 |     | <span class='neutral'>//</span>
 3832 |     | <span class='neutral'>//   - The piece of &#39;k(|h - qTarget|)&#39; to which &#39;qOvershoot&#39; belongs.</span>
 3833 |     | <span class='neutral'>//</span>
 3834 |     | <span class='neutral'>// The former is accomplished via a similar procedure as we delineated before</span>
 3835 |     | <span class='neutral'>// in search for &#39;qTarget&#39;. Put simply, we start with</span>
 3836 |     | <span class='neutral'>//</span>
 3837 |     | <span class='neutral'>//   &#39;qOvershoot := qTarget&#39;</span>
 3838 |     | <span class='neutral'>//</span>
 3839 |     | <span class='neutral'>// because</span>
 3840 |     | <span class='neutral'>//</span>
 3841 |     | <span class='neutral'>//   &#39;f(qTarget) &lt; 0&#39;,</span>
 3842 |     | <span class='neutral'>//</span>
 3843 |     | <span class='neutral'>// and we keep moving &#39;qOvershoot&#39; forward until we encounter a point that</span>
 3844 |     | <span class='neutral'>// satisfies:</span>
 3845 |     | <span class='neutral'>//</span>
 3846 |     | <span class='neutral'>//   &#39;f(qOvershoot) &gt; 0&#39;.</span>
 3847 |     | <span class='neutral'>//</span>
 3848 |     | <span class='neutral'>// Throughout the movement from &#39;qTarget&#39; towards &#39;qNext&#39;, we keep track of the</span>
 3849 |     | <span class='neutral'>// current phase under exploration using the variables:</span>
 3850 |     | <span class='neutral'>//</span>
 3851 |     | <span class='neutral'>//   - &#39;indexCurve&#39;, &#39;qOrigin&#39;, &#39;qEnd&#39;, &#39;direction&#39;,</span>
 3852 |     | <span class='neutral'>//</span>
 3853 |     | <span class='neutral'>// and we keep track of the current piece of the kernel function using the</span>
 3854 |     | <span class='neutral'>// variables:</span>
 3855 |     | <span class='neutral'>//</span>
 3856 |     | <span class='neutral'>//   - &#39;indexKernelTotal&#39;, &#39;cTotal0&#39;, &#39;cTotal1&#39;, &#39;qTotal0&#39;, &#39;qTotal1&#39;</span>
 3857 |     | <span class='neutral'>//</span>
 3858 |     | <span class='neutral'>// Throughout the search for &#39;qOvershoot&#39;, the piece of &#39;k(|h - qTarget|)&#39; to</span>
 3859 |     | <span class='neutral'>// which &#39;qOvershoot&#39; belongs is determined using an additional index:</span>
 3860 |     | <span class='neutral'>//</span>
 3861 |     | <span class='neutral'>//  - &#39;indexKernelForward&#39; keeps track of the pieces of the function</span>
 3862 |     | <span class='neutral'>//    &#39;k(|h - qTarget|)&#39; that we enumerate as we move from &#39;qTarget&#39; to</span>
 3863 |     | <span class='neutral'>//    &#39;qOvershoot&#39;. Each piece of &#39;k(|h - qTarget|)&#39; can be characterized via</span>
 3864 |     | <span class='neutral'>//    the following four vertical and horizontal coordinates:</span>
 3865 |     | <span class='neutral'>//</span>
 3866 |     | <span class='neutral'>//      &#39;cForward0 := c[indexKernelForward - 1]&#39;,</span>
 3867 |     | <span class='neutral'>//</span>
 3868 |     | <span class='neutral'>//      &#39;qForward0 := getZeroForOne() ? </span>
 3869 |     | <span class='neutral'>//                    qTarget - b[indexKernelForward - 1] : </span>
 3870 |     | <span class='neutral'>//                    qTarget + b[indexKernelForward - 1]&#39;,</span>
 3871 |     | <span class='neutral'>//</span>
 3872 |     | <span class='neutral'>//      &#39;cForward1 := c[indexKernelForward]&#39;,</span>
 3873 |     | <span class='neutral'>//</span>
 3874 |     | <span class='neutral'>//      &#39;qForward1 := getZeroForOne() ? </span>
 3875 |     | <span class='neutral'>//                    qTarget - b[indexKernelForward] : </span>
 3876 |     | <span class='neutral'>//                    qTarget + b[indexKernelForward]&#39;.</span>
 3877 |     | <span class='neutral'>//</span>
 3878 |     | <span class='neutral'>//    The pair &#39;(cForward0, qForward0)&#39; is stored in the memory space which is</span>
 3879 |     | <span class='neutral'>//    pointed to by &#39;_forward0_&#39; and similarly, the pair</span>
 3880 |     | <span class='neutral'>//    &#39;(cForward1, qForward1)&#39; is stored in the memory space which is pointed</span>
 3881 |     | <span class='neutral'>//    to by &#39;_forward1_&#39;.</span>
 3882 |     | <span class='neutral'>//</span>
 3883 |     | <span class='neutral'>//    Hence, the function &#39;k(|. - qTarget|)&#39; is linear within the range:</span>
 3884 |     | <span class='neutral'>//</span>
 3885 |     | <span class='neutral'>//      &#39;min(qForward0, qForward1) &lt; q &lt; max(qForward0, qForward1)&#39;.</span>
 3886 |     | <span class='neutral'>//</span>
 3887 |     | <span class='neutral'>//    and the function &#39;k(w(.))&#39; is linear within the intersection of the two</span>
 3888 |     | <span class='neutral'>//    ranges:</span>
 3889 |     | <span class='neutral'>//</span>
 3890 |     | <span class='neutral'>//      &#39;min(q[indexCurve + 2], qEnd) &lt; q &lt; max(q[indexCurve + 2], qEnd)&#39;,</span>
 3891 |     | <span class='neutral'>//</span>
 3892 |     | <span class='neutral'>//    and</span>
 3893 |     | <span class='neutral'>//</span>
 3894 |     | <span class='neutral'>//      &#39;min(qTotal0, qTotal1) &lt; q &lt; max(qTotal0, qTotal1)&#39;.</span>
 3895 |     | <span class='neutral'>//</span>
 3896 |     | <span class='neutral'>//    Now, in order to have closed-forms for all of the integrals that the</span>
 3897 |     | <span class='neutral'>//    formula for &#39;f(qOvershoot)&#39; comprises, at each step, we keep track of the</span>
 3898 |     | <span class='neutral'>//    domain in which both &#39;k(w(.))&#39; and &#39;k(|. - qTarget|)&#39; are linear and we</span>
 3899 |     | <span class='neutral'>//    update this domain as we move forward in our search. Hence, with every</span>
 3900 |     | <span class='neutral'>//    update of &#39;indexCurve&#39;, &#39;indexKernelTotal&#39;, and &#39;indexKernelForward&#39;, we</span>
 3901 |     | <span class='neutral'>//    make the following two updates:</span>
 3902 |     | <span class='neutral'>//</span>
 3903 |     | <span class='neutral'>//      &#39;qBegin := (</span>
 3904 |     | <span class='neutral'>//                   direction == getZeroForOne()</span>
 3905 |     | <span class='neutral'>//                 ) ? (</span>
 3906 |     | <span class='neutral'>//                   direction ? </span>
 3907 |     | <span class='neutral'>//                   max(max(q[indexCurve + 2], qTotal0), qForward0) : </span>
 3908 |     | <span class='neutral'>//                   min(min(q[indexCurve + 2], qTotal0), qForward0)</span>
 3909 |     | <span class='neutral'>//                 ) : (</span>
 3910 |     | <span class='neutral'>//                   direction ? </span>
 3911 |     | <span class='neutral'>//                   max(q[indexCurve + 2], qTotal0) : </span>
 3912 |     | <span class='neutral'>//                   min(q[indexCurve + 2], qTotal0)</span>
 3913 |     | <span class='neutral'>//                 )&#39;,</span>
 3914 |     | <span class='neutral'>//</span>
 3915 |     | <span class='neutral'>//      &#39;qOvershoot := (</span>
 3916 |     | <span class='neutral'>//                       direction == getZeroForOne()</span>
 3917 |     | <span class='neutral'>//                     ) ? (</span>
 3918 |     | <span class='neutral'>//                       direction ? </span>
 3919 |     | <span class='neutral'>//                       max(max(qEnd, qTotal1), qForward1) : </span>
 3920 |     | <span class='neutral'>//                       min(min(qEnd, qTotal1), qForward1)</span>
 3921 |     | <span class='neutral'>//                     ) : (</span>
 3922 |     | <span class='neutral'>//                       direction ? </span>
 3923 |     | <span class='neutral'>//                       max(qEnd, qTotal1) : </span>
 3924 |     | <span class='neutral'>//                       min(qEnd, qTotal1)</span>
 3925 |     | <span class='neutral'>//                     )&#39;,</span>
 3926 |     | <span class='neutral'>//</span>
 3927 |     | <span class='neutral'>//    where &#39;qBegin&#39; and &#39;qOvershoot&#39; are stored, respectively, in the memory</span>
 3928 |     | <span class='neutral'>//    spaces that are pointed to by &#39;_begin_&#39; and &#39;_overshoot_&#39;. Both values</span>
 3929 |     | <span class='neutral'>//    are updated with each transition to a new phase, a new piece of</span>
 3930 |     | <span class='neutral'>//    &#39;k(w(.))&#39;, or a new piece of &#39;k(|. - qTarget|)&#39;.</span>
 3931 |     | <span class='neutral'>//</span>
 3932 |     | <span class='neutral'>//    The process of enumerating the pieces of &#39;k(|. - qTarget|)&#39; starts with</span>
 3933 |     | <span class='neutral'>//    the initial state &#39;indexKernelForward := 1&#39;.</span>
 3934 |     | <span class='neutral'>//</span>
 3935 |     | <span class='neutral'>// Determining the search domain to which &#39;qOvershoot&#39; belongs and in which</span>
 3936 |     | <span class='neutral'>// both &#39;k(w(.))&#39; and &#39;k(|. - qTarget|)&#39; are linear, is conducted by calling</span>
 3937 |     | <span class='neutral'>// the method &#39;moveOvershoot&#39; from &#39;Interval.sol&#39; in a loop until the following</span>
 3938 |     | <span class='neutral'>// condition is met:</span>
 3939 |     | <span class='neutral'>//</span>
 3940 |     | <span class='neutral'>//   &#39;f(qBegin) &lt;= 0&#39; and &#39;f(qOvershoot) &gt;  0&#39;.</span>
 3941 |     | <span class='neutral'>//</span>
 3942 |     | <span class='neutral'>// Then, according to the intermediate value theorem, there exists a solution</span>
 3943 |     | <span class='neutral'>// in this search domain which satisfies:</span>
 3944 |     | <span class='neutral'>//</span>
 3945 |     | <span class='neutral'>//   &#39;f(qOvershoot) == 0&#39;.</span>
 3946 |     | <span class='neutral'>//</span>
 3947 |     | <span class='neutral'>// Then, this solution is found by calling the method &#39;searchOvershoot&#39; from</span>
 3948 |     | <span class='neutral'>// &#39;Interval.sol&#39;.</span>
 3949 |     | <span class='neutral'>//</span>
 3950 |     | <span class='neutral'>// In order to calculate the Newton step at each stage, we need to find the</span>
 3951 |     | <span class='neutral'>// derivative of &#39;f(.)&#39;. If &#39;getZeroForOne() == false&#39;, then we have:</span>
 3952 |     | <span class='neutral'>//</span>
 3953 |     | <span class='neutral'>//          d f</span>
 3954 |     | <span class='neutral'>//   &#39;-------------- ==</span>
 3955 |     | <span class='neutral'>//     d qOvershoot</span>
 3956 |     | <span class='neutral'>//</span>
 3957 |     | <span class='neutral'>//    (</span>
 3958 |     | <span class='neutral'>//</span>
 3959 |     | <span class='neutral'>//        + (qOrigin + qOvershoot) / 2    originToOvershoot</span>
 3960 |     | <span class='neutral'>//      e                              * ------------------- -</span>
 3961 |     | <span class='neutral'>//                                              2</span>
 3962 |     | <span class='neutral'>//</span>
 3963 |     | <span class='neutral'>//        + (qTarget + qOvershoot) / 2    targetToOvershoot</span>
 3964 |     | <span class='neutral'>//      e                              * ------------------- +</span>
 3965 |     | <span class='neutral'>//                                              2</span>
 3966 |     | <span class='neutral'>//         - 8 + qOrigin / 2</span>
 3967 |     | <span class='neutral'>//       e</span>
 3968 |     | <span class='neutral'>//      --------------------- * k(qOvershoot - qOrigin) -</span>
 3969 |     | <span class='neutral'>//                2</span>
 3970 |     | <span class='neutral'>//</span>
 3971 |     | <span class='neutral'>//         - 8 + qTarget / 2</span>
 3972 |     | <span class='neutral'>//       e</span>
 3973 |     | <span class='neutral'>//      --------------------- * k(qOvershoot - qTarget)</span>
 3974 |     | <span class='neutral'>//                2</span>
 3975 |     | <span class='neutral'>//</span>
 3976 |     | <span class='neutral'>//    ) / integral1Incremented - (</span>
 3977 |     | <span class='neutral'>//</span>
 3978 |     | <span class='neutral'>//         - 8 - qOvershoot / 2</span>
 3979 |     | <span class='neutral'>//       e</span>
 3980 |     | <span class='neutral'>//      ------------------------ * k(qOvershoot - qTarget) - </span>
 3981 |     | <span class='neutral'>//                  2</span>
 3982 |     | <span class='neutral'>//</span>
 3983 |     | <span class='neutral'>//         - 8 - qOvershoot / 2</span>
 3984 |     | <span class='neutral'>//       e</span>
 3985 |     | <span class='neutral'>//      ------------------------ * k(qOvershoot - qOrigin) </span>
 3986 |     | <span class='neutral'>//                  2</span>
 3987 |     | <span class='neutral'>//</span>
 3988 |     | <span class='neutral'>//    ) / integral0Incremented&#39;.</span>
 3989 |     | <span class='neutral'>//</span>
 3990 |     | <span class='neutral'>// If &#39;getZeroForOne() == true&#39;, then we have:</span>
 3991 |     | <span class='neutral'>//</span>
 3992 |     | <span class='neutral'>//          d f</span>
 3993 |     | <span class='neutral'>//   &#39;-------------- ==</span>
 3994 |     | <span class='neutral'>//     d qOvershoot</span>
 3995 |     | <span class='neutral'>//</span>
 3996 |     | <span class='neutral'>//    (</span>
 3997 |     | <span class='neutral'>//</span>
 3998 |     | <span class='neutral'>//         - 8 + qOvershoot / 2</span>
 3999 |     | <span class='neutral'>//       e</span>
 4000 |     | <span class='neutral'>//      ------------------------ * k(qTarget - qOvershoot) - </span>
 4001 |     | <span class='neutral'>//                  2</span>
 4002 |     | <span class='neutral'>//</span>
 4003 |     | <span class='neutral'>//         - 8 + qOvershoot / 2</span>
 4004 |     | <span class='neutral'>//       e</span>
 4005 |     | <span class='neutral'>//      ------------------------ * k(qOrigin - qOvershoot) </span>
 4006 |     | <span class='neutral'>//                  2</span>
 4007 |     | <span class='neutral'>//</span>
 4008 |     | <span class='neutral'>//    ) / integral1Incremented - (</span>
 4009 |     | <span class='neutral'>//</span>
 4010 |     | <span class='neutral'>//        - (qOrigin + qOvershoot) / 2    originToOvershoot</span>
 4011 |     | <span class='neutral'>//      e                              * ------------------- -</span>
 4012 |     | <span class='neutral'>//                                              2</span>
 4013 |     | <span class='neutral'>//</span>
 4014 |     | <span class='neutral'>//        - (qTarget + qOvershoot) / 2    targetToOvershoot</span>
 4015 |     | <span class='neutral'>//      e                              * ------------------- +</span>
 4016 |     | <span class='neutral'>//                                              2</span>
 4017 |     | <span class='neutral'>//         - 8 - qOrigin / 2</span>
 4018 |     | <span class='neutral'>//       e</span>
 4019 |     | <span class='neutral'>//      --------------------- * k(qOrigin - qOvershoot) - </span>
 4020 |     | <span class='neutral'>//                2</span>
 4021 |     | <span class='neutral'>//</span>
 4022 |     | <span class='neutral'>//         - 8 - qTarget / 2</span>
 4023 |     | <span class='neutral'>//       e</span>
 4024 |     | <span class='neutral'>//      --------------------- * k(qTarget - qOvershoot)</span>
 4025 |     | <span class='neutral'>//                2</span>
 4026 |     | <span class='neutral'>//</span>
 4027 |     | <span class='neutral'>//    ) / integral0Incremented&#39;.</span>
 4028 |     | <span class='neutral'>//</span>
 4029 |     | <span class='neutral'>// After the calulation of &#39;qOvershoot&#39;, the amended values &#39;growthAmended&#39;, </span>
 4030 |     | <span class='neutral'>// &#39;integral0Amended&#39; and &#39;integral1Amended&#39; are determined as follows:</span>
 4031 |     | <span class='neutral'>//</span>
 4032 |     | <span class='neutral'>//                         growth              growth</span>
 4033 |     | <span class='neutral'>//  &#39;growthAmended == ---------------- == ----------------&#39;,</span>
 4034 |     | <span class='neutral'>//                     s0(qOvershoot)      s1(qOvershoot)</span>
 4035 |     | <span class='neutral'>//</span>
 4036 |     | <span class='neutral'>//                            - 8     / qUpper</span>
 4037 |     | <span class='neutral'>//    integral0Amended      e        |    - h / 2</span>
 4038 |     | <span class='neutral'>//  &#39;------------------ := ------- * |  e         k(wAmended(h)) dh == </span>
 4039 |     | <span class='neutral'>//        2 ** 216            2      |</span>
 4040 |     | <span class='neutral'>//                                  / qTarget</span>
 4041 |     | <span class='neutral'>//</span>
 4042 |     | <span class='neutral'>//                              growth        integral0Incremented</span>
 4043 |     | <span class='neutral'>//                         --------------- * ----------------------&#39;,</span>
 4044 |     | <span class='neutral'>//                          growthAmended           2 ** 216</span>
 4045 |     | <span class='neutral'>//</span>
 4046 |     | <span class='neutral'>//                            - 8     / qTarget</span>
 4047 |     | <span class='neutral'>//    integral1Amended      e        |    + h / 2</span>
 4048 |     | <span class='neutral'>//  &#39;------------------ := ------- * |  e         k(wAmended(h)) dh == </span>
 4049 |     | <span class='neutral'>//        2 ** 216            2      |</span>
 4050 |     | <span class='neutral'>//                                  / qLower</span>
 4051 |     | <span class='neutral'>//</span>
 4052 |     | <span class='neutral'>//                              growth        integral0Incremented</span>
 4053 |     | <span class='neutral'>//                         --------------- * ----------------------&#39;,</span>
 4054 |     | <span class='neutral'>//                          growthAmended           2 ** 216</span>
 4055 |     | <span class='neutral'>//</span>
 4056 |     | <span class='neutral'>// where the ranges covered by &#39;integral0Amended&#39; and &#39;integral1Amended&#39; are</span>
 4057 |     | <span class='neutral'>// illustrated as follows:</span>
 4058 |     | <span class='neutral'>//</span>
 4059 |     | <span class='neutral'>//                         integral0Amended</span>
 4060 |     | <span class='neutral'>//                         exp(- h / 2) * k(wAmended(h))</span>
 4061 |     | <span class='neutral'>//                                                      \</span>
 4062 |     | <span class='neutral'>//             integral1Amended                          \</span>
 4063 |     | <span class='neutral'>//             exp(+ h / 2) * k(wAmended(h))              \</span>
 4064 |     | <span class='neutral'>//      |&lt;--------------------------------------&gt;|&lt;----------------&gt;|</span>
 4065 |     | <span class='neutral'>//      |                                        |                  |</span>
 4066 |     | <span class='neutral'>//      +----------------------------------------+------------------+</span>
 4067 |     | <span class='neutral'>//      |                                        |                  |</span>
 4068 |     | <span class='neutral'>//    qLower                                  qTarget             qUpper</span>
 4069 |     | <span class='neutral'>//</span>
 4070 |     | <span class='neutral'>// In the following section, the memory pointers that are used for the purpose</span>
 4071 |     | <span class='neutral'>// of the above calculations are introduced.</span>
 4072 |     | <span class='neutral'>uint16 constant _interval_ = 644;</span>
 4073 |     | <span class='neutral'></span>
 4074 |     | <span class='neutral'>// The direction of the current &#39;phase&#39; under exploration. Everytime that we</span>
 4075 |     | <span class='neutral'>// move from one &#39;phase&#39; to the next, by decrementing &#39;indexCurve&#39; this binary</span>
 4076 |     | <span class='neutral'>// value is flipped. &#39;direction&#39; should not be confused with &#39;zeroForOne&#39; which</span>
 4077 |     | <span class='neutral'>// does not change throughout a swap. Define:</span>
 4078 |     | <span class='neutral'>//</span>
 4079 |     | <span class='neutral'>//  &#39;qEnd := q[indexCurve]&#39;.</span>
 4080 |     | <span class='neutral'>//</span>
 4081 |     | <span class='neutral'>// &#39;direction = 0x00&#39; if &#39;q[indexCurve + 2] &lt; qEnd&#39;, i.e., when we are moving</span>
 4082 |     | <span class='neutral'>// towards &#39;+oo&#39;, in search for &#39;qTarget&#39; or &#39;qOvershoot&#39;. In this case, for</span>
 4083 |     | <span class='neutral'>// every &#39;q[indexCurve + 2] &lt; h &lt; qEnd&#39;, we have:</span>
 4084 |     | <span class='neutral'>//</span>
 4085 |     | <span class='neutral'>//  &#39;w(h) := h - qOrigin&#39;.</span>
 4086 |     | <span class='neutral'>//</span>
 4087 |     | <span class='neutral'>// &#39;direction = 0xFF&#39; if &#39;qEnd &lt; q[indexCurve + 2]&#39;, i.e., when we are moving</span>
 4088 |     | <span class='neutral'>// towards &#39;-oo&#39;, in search for &#39;qTarget&#39; or &#39;qOvershoot&#39;. In this case, for</span>
 4089 |     | <span class='neutral'>// every &#39;qEnd &lt; h &lt; q[indexCurve + 2]&#39;, we have:</span>
 4090 |     | <span class='neutral'>//</span>
 4091 |     | <span class='neutral'>//  &#39;w(h) := qOrigin - h&#39;.</span>
 4092 |     | <span class='neutral'>//</span>
 4093 |     | <span class='neutral'>uint16 constant _direction_ = 644;</span>
 4094 |     | <span class='neutral'></span>
 4095 |     | <span class='neutral'>// The index of &#39;qEnd&#39; among the members of the &#39;curve&#39;, i.e.,</span>
 4096 |     | <span class='neutral'>//</span>
 4097 |     | <span class='neutral'>//  &#39;qEnd == q[indexCurve]&#39;.</span>
 4098 |     | <span class='neutral'>//</span>
 4099 |     | <span class='neutral'>// While searching for &#39;qTarget&#39; and &#39;qOvershoot&#39;, the value of &#39;indexCurve&#39;</span>
 4100 |     | <span class='neutral'>// starts from &#39;curveLength - twoIndex&#39; and is decremented by &#39;oneIndex&#39; with</span>
 4101 |     | <span class='neutral'>// each run of the function &#39;movePhase()&#39; in &#39;Interval.sol&#39;.</span>
 4102 |     | <span class='neutral'>uint16 constant _indexCurve_ = 645;</span>
 4103 |     | <span class='neutral'></span>
 4104 |     | <span class='neutral'>// The index of &#39;qTotal1&#39; and &#39;cTotal1&#39; among the breakpoints of the &#39;kernel&#39;,</span>
 4105 |     | <span class='neutral'>// i.e.,</span>
 4106 |     | <span class='neutral'>//</span>
 4107 |     | <span class='neutral'>//  &#39;cTotal0 := c[indexKernelTotal - 1]&#39;,</span>
 4108 |     | <span class='neutral'>//</span>
 4109 |     | <span class='neutral'>//  &#39;qTotal0 := direction ? </span>
 4110 |     | <span class='neutral'>//              qOrigin - b[indexKernelTotal - 1] : </span>
 4111 |     | <span class='neutral'>//              qOrigin + b[indexKernelTotal - 1]&#39;,</span>
 4112 |     | <span class='neutral'>//</span>
 4113 |     | <span class='neutral'>//  &#39;cTotal1 == c[indexKernelTotal]&#39;,</span>
 4114 |     | <span class='neutral'>//</span>
 4115 |     | <span class='neutral'>//  &#39;qTotal1 == direction ? </span>
 4116 |     | <span class='neutral'>//              qOrigin - b[indexKernelTotal] : </span>
 4117 |     | <span class='neutral'>//              qOrigin + b[indexKernelTotal]&#39;.</span>
 4118 |     | <span class='neutral'>//</span>
 4119 |     | <span class='neutral'>// While searching for &#39;qTarget&#39; and &#39;qOvershoot&#39;, the value of</span>
 4120 |     | <span class='neutral'>// &#39;indexKernelTotal&#39; starts from &#39;oneIndex&#39; and is incremented by &#39;oneIndex&#39;</span>
 4121 |     | <span class='neutral'>// with each transition to a new piece of kernel as we explore &#39;k(w(h))&#39;.</span>
 4122 |     | <span class='neutral'>//</span>
 4123 |     | <span class='neutral'>// If &#39;getDirection() == false&#39;, then we have:</span>
 4124 |     | <span class='neutral'>//</span>
 4125 |     | <span class='neutral'>//  &#39;k(w(h)) == k(h - qOrigin) == k_indexKernelTotal(h - qOrigin) :=</span>
 4126 |     | <span class='neutral'>//</span>
 4127 |     | <span class='neutral'>//                         cTotal1 - cTotal0</span>
 4128 |     | <span class='neutral'>//              cTotal0 + ------------------- * (h - qTotal0)&#39;.</span>
 4129 |     | <span class='neutral'>//                         qTotal1 - qTotal0</span>
 4130 |     | <span class='neutral'>//</span>
 4131 |     | <span class='neutral'>// for every &#39;qBegin &lt; h &lt; qTarget&#39;.</span>
 4132 |     | <span class='neutral'>//</span>
 4133 |     | <span class='neutral'>// If &#39;getDirection() == true&#39;, then we have:</span>
 4134 |     | <span class='neutral'>//</span>
 4135 |     | <span class='neutral'>//  &#39;k(w(h)) == k(qOrigin - h) == k_indexKernelTotal(qOrigin - h) :=</span>
 4136 |     | <span class='neutral'>//</span>
 4137 |     | <span class='neutral'>//                         cTotal1 - cTotal0</span>
 4138 |     | <span class='neutral'>//              cTotal0 + ------------------- * (qTotal0 - h)&#39;.</span>
 4139 |     | <span class='neutral'>//                         qTotal0 - qTotal1</span>
 4140 |     | <span class='neutral'>//</span>
 4141 |     | <span class='neutral'>// for every &#39;qTarget &lt; h &lt; qBegin&#39;.</span>
 4142 |     | <span class='neutral'>uint16 constant _indexKernelTotal_ = 647;</span>
 4143 |     | <span class='neutral'></span>
 4144 |     | <span class='neutral'>// The index of &#39;qForward1&#39; and &#39;cForward1&#39; among the breakpoints of the</span>
 4145 |     | <span class='neutral'>// &#39;kernel&#39;, i.e.,</span>
 4146 |     | <span class='neutral'>//</span>
 4147 |     | <span class='neutral'>//  &#39;cForward0 := c[indexKernelForward - 1]&#39;,</span>
 4148 |     | <span class='neutral'>//</span>
 4149 |     | <span class='neutral'>//  &#39;qForward0 := getZeroForOne() ? </span>
 4150 |     | <span class='neutral'>//                qTarget - b[indexKernelForward - 1] : </span>
 4151 |     | <span class='neutral'>//                qTarget + b[indexKernelForward - 1]&#39;,</span>
 4152 |     | <span class='neutral'>//</span>
 4153 |     | <span class='neutral'>//  &#39;cForward1 := c[indexKernelForward]&#39;,</span>
 4154 |     | <span class='neutral'>//</span>
 4155 |     | <span class='neutral'>//  &#39;qForward1 := getZeroForOne() ? </span>
 4156 |     | <span class='neutral'>//                qTarget - b[indexKernelForward] : </span>
 4157 |     | <span class='neutral'>//                qTarget + b[indexKernelForward]&#39;.</span>
 4158 |     | <span class='neutral'>//</span>
 4159 |     | <span class='neutral'>// While searching for &#39;qOvershoot&#39;, the value of &#39;indexKernelForward&#39; starts</span>
 4160 |     | <span class='neutral'>// from &#39;oneIndex&#39; and is incremented by &#39;oneIndex&#39; with each transition to a</span>
 4161 |     | <span class='neutral'>// new piece of kernel.</span>
 4162 |     | <span class='neutral'>//</span>
 4163 |     | <span class='neutral'>// If &#39;getZeroForOne() == false&#39;, then we have:</span>
 4164 |     | <span class='neutral'>//</span>
 4165 |     | <span class='neutral'>//  &#39;k(h - qTarget) == k_indexKernelForward(h - qTarget) :=</span>
 4166 |     | <span class='neutral'>//</span>
 4167 |     | <span class='neutral'>//                                  cForward1 - cForward0</span>
 4168 |     | <span class='neutral'>//                     cForward0 + ----------------------- * (h - qForward0)&#39;.</span>
 4169 |     | <span class='neutral'>//                                  qForward1 - qForward0</span>
 4170 |     | <span class='neutral'>//</span>
 4171 |     | <span class='neutral'>// for every &#39;qBegin &lt; h &lt; qOvershoot&#39;.</span>
 4172 |     | <span class='neutral'>//</span>
 4173 |     | <span class='neutral'>// If &#39;getZeroForOne() == true&#39;, then we have:</span>
 4174 |     | <span class='neutral'>//</span>
 4175 |     | <span class='neutral'>//  &#39;k(qTarget - h) == k_indexKernelForward(qTarget - h) :=</span>
 4176 |     | <span class='neutral'>//</span>
 4177 |     | <span class='neutral'>//                                  cForward1 - cForward0</span>
 4178 |     | <span class='neutral'>//                     cForward0 + ----------------------- * (qForward0 - h)&#39;.</span>
 4179 |     | <span class='neutral'>//                                  qForward0 - qForward1</span>
 4180 |     | <span class='neutral'>//</span>
 4181 |     | <span class='neutral'>// for every &#39;qOvershoot &lt; h &lt; qBegin&#39;.</span>
 4182 |     | <span class='neutral'>uint16 constant _indexKernelForward_ = 649;</span>
 4183 |     | <span class='neutral'></span>
 4184 |     | <span class='neutral'>// Let &#39;pLower&#39; and &#39;pUpper&#39; be the minimum and maximum price in the active</span>
 4185 |     | <span class='neutral'>// liquidity interval and define</span>
 4186 |     | <span class='neutral'>//</span>
 4187 |     | <span class='neutral'>//  &#39;qLower := log(pLower / pOffset)&#39;,</span>
 4188 |     | <span class='neutral'>//  &#39;qUpper := log(pUpper / pOffset)&#39;.</span>
 4189 |     | <span class='neutral'>//  &#39;qLimitWithinInterval := min(max(qLower, qLimit), qUpper)&#39;</span>
 4190 |     | <span class='neutral'>//</span>
 4191 |     | <span class='neutral'>// The value set as &#39;logPriceLimitOffsetted&#39; may be outside of the current</span>
 4192 |     | <span class='neutral'>// active liquidity interval. In such cases, we first need to perform a swap</span>
 4193 |     | <span class='neutral'>// towards the current interval boundary and then we transition to a new</span>
 4194 |     | <span class='neutral'>// interval. In order to perform the former step, &#39;qLimitWithinInterval&#39; is</span>
 4195 |     | <span class='neutral'>// calculated and its offset binary &#39;X59&#39; representation, i.e.,</span>
 4196 |     | <span class='neutral'>//</span>
 4197 |     | <span class='neutral'>//  &#39;_origin_.log() := (2 ** 59) * (16 + qOrigin)&#39;</span>
 4198 |     | <span class='neutral'>//</span>
 4199 |     | <span class='neutral'>// is stored in the memory space which pointed to by</span>
 4200 |     | <span class='neutral'>// &#39;_logPriceLimitOffsettedWithinInterval_&#39;.</span>
 4201 |     | <span class='neutral'>uint16 constant _logPriceLimitOffsettedWithinInterval_ = 651;</span>
 4202 |     | <span class='neutral'></span>
 4203 |     | <span class='neutral'>// Let &#39;pCurrent&#39; represent the current price within the active liquidity</span>
 4204 |     | <span class='neutral'>// interval (prior to the movement to &#39;qTarget&#39; or &#39;qNext&#39;). This value</span>
 4205 |     | <span class='neutral'>// corresponds to the last member of the curve. Define:</span>
 4206 |     | <span class='neutral'>//</span>
 4207 |     | <span class='neutral'>//  &#39;qCurrent := log(pCurrent / pOffset)&#39;,</span>
 4208 |     | <span class='neutral'>//</span>
 4209 |     | <span class='neutral'>// The 62 bytes memory space which is pointed to by &#39;_current_&#39; hosts the</span>
 4210 |     | <span class='neutral'>// following values:</span>
 4211 |     | <span class='neutral'>//</span>
 4212 |     | <span class='neutral'>//  &#39;_current_.log() := (2 ** 59) * (16 + qCurrent)&#39;,</span>
 4213 |     | <span class='neutral'>//  &#39;_current_.sqrt(false) := (2 ** 216) * exp(- 8 - qCurrent / 2)&#39;,</span>
 4214 |     | <span class='neutral'>//  &#39;_current_.sqrt(true) := (2 ** 216) * exp(- 8 + qCurrent / 2)&#39;.</span>
 4215 |     | <span class='neutral'>//</span>
 4216 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The logarithmic price</span>
 4217 |     | <span class='neutral'>// &#39;_current_.log()&#39; occupies 64 bits, whereas &#39;_current_.sqrt(false)&#39; and</span>
 4218 |     | <span class='neutral'>// &#39;_current_.sqrt(true)&#39; occupy 216 bits each.</span>
 4219 |     | <span class='neutral'>uint16 constant _current_ = 659;</span>
 4220 |     | <span class='neutral'></span>
 4221 |     | <span class='neutral'>// Let &#39;indexCurve&#39; represent the index of the current phase under exploration.</span>
 4222 |     | <span class='neutral'>// Define:</span>
 4223 |     | <span class='neutral'>//</span>
 4224 |     | <span class='neutral'>//  &#39;qOrigin := q[indexCurve + 1]&#39;,</span>
 4225 |     | <span class='neutral'>//</span>
 4226 |     | <span class='neutral'>//  &#39;qEnd := q[indexCurve]&#39;.</span>
 4227 |     | <span class='neutral'>//</span>
 4228 |     | <span class='neutral'>// If &#39;getDirection() == false&#39;, for every &#39;q[indexCurve + 2] &lt; h &lt; qEnd&#39;, we</span>
 4229 |     | <span class='neutral'>// have:</span>
 4230 |     | <span class='neutral'>//</span>
 4231 |     | <span class='neutral'>//  &#39;w(h) := h - qOrigin&#39;.</span>
 4232 |     | <span class='neutral'>//</span>
 4233 |     | <span class='neutral'>// If &#39;getDirection() == true&#39;, for every &#39;qEnd &lt; h &lt; q[indexCurve + 2]&#39;, we</span>
 4234 |     | <span class='neutral'>// have:</span>
 4235 |     | <span class='neutral'>//</span>
 4236 |     | <span class='neutral'>//  &#39;w(h) := qOrigin - h&#39;.</span>
 4237 |     | <span class='neutral'>//</span>
 4238 |     | <span class='neutral'>// The 62 bytes memory space which is pointed to by &#39;_origin_&#39; hosts the</span>
 4239 |     | <span class='neutral'>// following values:</span>
 4240 |     | <span class='neutral'>//</span>
 4241 |     | <span class='neutral'>//  &#39;_origin_.log() := (2 ** 59) * (16 + qOrigin)&#39;,</span>
 4242 |     | <span class='neutral'>//  &#39;_origin_.sqrt(false) := (2 ** 216) * exp(- 8 - qOrigin / 2)&#39;,</span>
 4243 |     | <span class='neutral'>//  &#39;_origin_.sqrt(true) := (2 ** 216) * exp(- 8 + qOrigin / 2)&#39;.</span>
 4244 |     | <span class='neutral'>//</span>
 4245 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The logarithmic price</span>
 4246 |     | <span class='neutral'>// &#39;_origin_.log()&#39; occupies 64 bits, whereas &#39;_origin_.sqrt(false)&#39; and</span>
 4247 |     | <span class='neutral'>// &#39;_origin_.sqrt(true)&#39; occupy 216 bits each.</span>
 4248 |     | <span class='neutral'>uint16 constant _origin_ = 721;</span>
 4249 |     | <span class='neutral'></span>
 4250 |     | <span class='neutral'>// At every step of searching for &#39;qTarget&#39;, the range</span>
 4251 |     | <span class='neutral'>//</span>
 4252 |     | <span class='neutral'>//  &#39;min(qBegin, qTarget) &lt; h &lt; max(qBegin, qTarget)&#39;</span>
 4253 |     | <span class='neutral'>//</span>
 4254 |     | <span class='neutral'>// represents a piece of the liquidity distribution function &#39;k(w(.))&#39; in which</span>
 4255 |     | <span class='neutral'>// &#39;k(w(.))&#39; is linear. More precisely, if &#39;getDirection() == false&#39;, we have:</span>
 4256 |     | <span class='neutral'>//</span>
 4257 |     | <span class='neutral'>//  &#39;k(w(h)) == k(h - qOrigin) == k_indexKernelTotal(h - qOrigin) :=</span>
 4258 |     | <span class='neutral'>//</span>
 4259 |     | <span class='neutral'>//                         cTotal1 - cTotal0</span>
 4260 |     | <span class='neutral'>//              cTotal0 + ------------------- * (h - qTotal0)&#39;.</span>
 4261 |     | <span class='neutral'>//                         qTotal1 - qTotal0</span>
 4262 |     | <span class='neutral'>//</span>
 4263 |     | <span class='neutral'>// for every &#39;qBegin &lt; h &lt; qTarget&#39; and if &#39;getDirection() == true&#39;, we have:</span>
 4264 |     | <span class='neutral'>//</span>
 4265 |     | <span class='neutral'>//  &#39;k(w(h)) == k(qOrigin - h) == k_indexKernelTotal(qOrigin - h) :=</span>
 4266 |     | <span class='neutral'>//</span>
 4267 |     | <span class='neutral'>//                         cTotal1 - cTotal0</span>
 4268 |     | <span class='neutral'>//              cTotal0 + ------------------- * (qTotal0 - h)&#39;.</span>
 4269 |     | <span class='neutral'>//                         qTotal0 - qTotal1</span>
 4270 |     | <span class='neutral'>//</span>
 4271 |     | <span class='neutral'>// for every &#39;qTarget &lt; h &lt; qBegin&#39;.</span>
 4272 |     | <span class='neutral'>//</span>
 4273 |     | <span class='neutral'>// At the stage where we search for &#39;qTarget&#39;, we have</span>
 4274 |     | <span class='neutral'>//</span>
 4275 |     | <span class='neutral'>//  &#39;qBegin := direction ? </span>
 4276 |     | <span class='neutral'>//             min(q[indexCurve + 2], qTotal0) : </span>
 4277 |     | <span class='neutral'>//             max(q[indexCurve + 2], qTotal0)&#39;.</span>
 4278 |     | <span class='neutral'>//</span>
 4279 |     | <span class='neutral'>// At every step of searching for &#39;qOvershoot&#39;, the following inequality</span>
 4280 |     | <span class='neutral'>//</span>
 4281 |     | <span class='neutral'>//  &#39;min(qBegin, qOvershoot) &lt; h &lt; max(qBegin, qOvershoot)&#39;</span>
 4282 |     | <span class='neutral'>//</span>
 4283 |     | <span class='neutral'>// represents a range in which both &#39;k(w(.))&#39; and &#39;k(|. - qTarget|)&#39; are</span>
 4284 |     | <span class='neutral'>// linear. More precisely, if &#39;getZeroForOne() == false&#39;, we have:</span>
 4285 |     | <span class='neutral'>//</span>
 4286 |     | <span class='neutral'>//  &#39;k(h - qTarget) == k_indexKernelForward(h - qTarget) :=</span>
 4287 |     | <span class='neutral'>//</span>
 4288 |     | <span class='neutral'>//                                  cForward1 - cForward0</span>
 4289 |     | <span class='neutral'>//                     cForward0 + ----------------------- * (h - qForward0)&#39;.</span>
 4290 |     | <span class='neutral'>//                                  qForward1 - qForward0</span>
 4291 |     | <span class='neutral'>//</span>
 4292 |     | <span class='neutral'>// for every &#39;qBegin &lt; h &lt; qOvershoot&#39; and if &#39;getZeroForOne() == true&#39;, we</span>
 4293 |     | <span class='neutral'>// have:</span>
 4294 |     | <span class='neutral'>//</span>
 4295 |     | <span class='neutral'>//  &#39;k(qTarget - h) == k_indexKernelForward(qTarget - h) :=</span>
 4296 |     | <span class='neutral'>//</span>
 4297 |     | <span class='neutral'>//                                  cForward1 - cForward0</span>
 4298 |     | <span class='neutral'>//                     cForward0 + ----------------------- * (qForward0 - h)&#39;.</span>
 4299 |     | <span class='neutral'>//                                  qForward0 - qForward1</span>
 4300 |     | <span class='neutral'>//</span>
 4301 |     | <span class='neutral'>// for every &#39;qOvershoot &lt; h &lt; qBegin&#39;.</span>
 4302 |     | <span class='neutral'>//</span>
 4303 |     | <span class='neutral'>// At the stage where we search for &#39;qOvershoot&#39;, we have</span>
 4304 |     | <span class='neutral'>//</span>
 4305 |     | <span class='neutral'>//  &#39;qBegin := (</span>
 4306 |     | <span class='neutral'>//               direction == getZeroForOne()</span>
 4307 |     | <span class='neutral'>//             ) ? (</span>
 4308 |     | <span class='neutral'>//               direction ? </span>
 4309 |     | <span class='neutral'>//               max(max(q[indexCurve + 2], qTotal0), qForward0) : </span>
 4310 |     | <span class='neutral'>//               min(min(q[indexCurve + 2], qTotal0), qForward0)</span>
 4311 |     | <span class='neutral'>//             ) : (</span>
 4312 |     | <span class='neutral'>//               direction ? </span>
 4313 |     | <span class='neutral'>//               max(q[indexCurve + 2], qTotal0) : </span>
 4314 |     | <span class='neutral'>//               min(q[indexCurve + 2], qTotal0)</span>
 4315 |     | <span class='neutral'>//             )&#39;,</span>
 4316 |     | <span class='neutral'>//</span>
 4317 |     | <span class='neutral'>// The 62 bytes memory space which is pointed to by &#39;_begin_&#39; hosts the</span>
 4318 |     | <span class='neutral'>// following values:</span>
 4319 |     | <span class='neutral'>//</span>
 4320 |     | <span class='neutral'>//  &#39;_begin_.log() := (2 ** 59) * (16 + qBegin)&#39;,</span>
 4321 |     | <span class='neutral'>//  &#39;_begin_.sqrt(false) := (2 ** 216) * exp(- 8 - qBegin / 2)&#39;,</span>
 4322 |     | <span class='neutral'>//  &#39;_begin_.sqrt(true) := (2 ** 216) * exp(- 8 + qBegin / 2)&#39;.</span>
 4323 |     | <span class='neutral'>//</span>
 4324 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The logarithmic price</span>
 4325 |     | <span class='neutral'>// &#39;_begin_.log()&#39; occupies 64 bits, whereas &#39;_begin_.sqrt(false)&#39; and</span>
 4326 |     | <span class='neutral'>// &#39;_begin_.sqrt(true)&#39; occupy 216 bits each.</span>
 4327 |     | <span class='neutral'>uint16 constant _begin_ = 783;</span>
 4328 |     | <span class='neutral'></span>
 4329 |     | <span class='neutral'>// Let &#39;indexCurve&#39; represent the index of the current phase under exploration.</span>
 4330 |     | <span class='neutral'>// Define:</span>
 4331 |     | <span class='neutral'>//</span>
 4332 |     | <span class='neutral'>//  &#39;qOrigin := q[indexCurve + 1]&#39;,</span>
 4333 |     | <span class='neutral'>//</span>
 4334 |     | <span class='neutral'>//  &#39;qEnd := q[indexCurve]&#39;.</span>
 4335 |     | <span class='neutral'>//</span>
 4336 |     | <span class='neutral'>// If &#39;getDirection() == false&#39;, for every &#39;q[indexCurve + 2] &lt; h &lt; qEnd&#39;, we</span>
 4337 |     | <span class='neutral'>// have:</span>
 4338 |     | <span class='neutral'>//</span>
 4339 |     | <span class='neutral'>//  &#39;w(h) := h - qOrigin&#39;.</span>
 4340 |     | <span class='neutral'>//</span>
 4341 |     | <span class='neutral'>// If &#39;getDirection() == true&#39;, for every &#39;qEnd &lt; h &lt; q[indexCurve + 2]&#39;, we</span>
 4342 |     | <span class='neutral'>// have:</span>
 4343 |     | <span class='neutral'>//</span>
 4344 |     | <span class='neutral'>//  &#39;w(h) := qOrigin - h&#39;.</span>
 4345 |     | <span class='neutral'>//</span>
 4346 |     | <span class='neutral'>// The 62 bytes memory space which is pointed to by &#39;_end_&#39; hosts the following</span>
 4347 |     | <span class='neutral'>// values:</span>
 4348 |     | <span class='neutral'>//</span>
 4349 |     | <span class='neutral'>//  &#39;_end_.log() := (2 ** 59) * (16 + qEnd)&#39;,</span>
 4350 |     | <span class='neutral'>//  &#39;_end_.sqrt(false) := (2 ** 216) * exp(- 8 - qEnd / 2)&#39;,</span>
 4351 |     | <span class='neutral'>//  &#39;_end_.sqrt(true) := (2 ** 216) * exp(- 8 + qEnd / 2)&#39;.</span>
 4352 |     | <span class='neutral'>//</span>
 4353 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The logarithmic price</span>
 4354 |     | <span class='neutral'>// &#39;_end_.log()&#39; occupies 64 bits, whereas &#39;_end_.sqrt(false)&#39; and</span>
 4355 |     | <span class='neutral'>// &#39;_end_.sqrt(true)&#39; occupy 216 bits each.</span>
 4356 |     | <span class='neutral'>uint16 constant _end_ = 845;</span>
 4357 |     | <span class='neutral'></span>
 4358 |     | <span class='neutral'>// Every visit to a liquidity interval as part of a swap involves the movement</span>
 4359 |     | <span class='neutral'>// of price from &#39;pCurrent&#39; to &#39;pTarget&#39;. Define:</span>
 4360 |     | <span class='neutral'>//</span>
 4361 |     | <span class='neutral'>//  &#39;qCurrent := log(pCurrent / pOffset)&#39;,</span>
 4362 |     | <span class='neutral'>//  &#39;qTarget := log(pTarget / pOffset)&#39;,</span>
 4363 |     | <span class='neutral'>//</span>
 4364 |     | <span class='neutral'>// and assume that</span>
 4365 |     | <span class='neutral'>//</span>
 4366 |     | <span class='neutral'>//  &#39;qLower &lt;= qCurrent &lt;= qUpper&#39;,</span>
 4367 |     | <span class='neutral'>//  &#39;qLower &lt;= qTarget &lt;= qUpper&#39;,</span>
 4368 |     | <span class='neutral'>//</span>
 4369 |     | <span class='neutral'>// where &#39;[qLower, qUpper]&#39; represents the current active liquidity interval.</span>
 4370 |     | <span class='neutral'>//</span>
 4371 |     | <span class='neutral'>// At first &#39;qTarget&#39; is an unknown value which will be determined based on one</span>
 4372 |     | <span class='neutral'>// of the followings:</span>
 4373 |     | <span class='neutral'>//</span>
 4374 |     | <span class='neutral'>//  - &#39;qLimitWithinInterval&#39;, which is calculated based on the input</span>
 4375 |     | <span class='neutral'>//    &#39;logPriceLimit&#39; as well as &#39;qLower&#39; and &#39;qUpper&#39;. It is stored in the</span>
 4376 |     | <span class='neutral'>//    memory space which is pointed to by</span>
 4377 |     | <span class='neutral'>//    &#39;_logPriceLimitOffsettedWithinInterval_&#39;.</span>
 4378 |     | <span class='neutral'>//</span>
 4379 |     | <span class='neutral'>//  - &#39;integralLimit&#39;, which is calculated based on the input &#39;amountSpecified&#39;</span>
 4380 |     | <span class='neutral'>//    and is stored in the memory space which is pointed to by</span>
 4381 |     | <span class='neutral'>//    &#39;_integralLimit_&#39;.</span>
 4382 |     | <span class='neutral'>//</span>
 4383 |     | <span class='neutral'>// After determination of &#39;qTarget&#39;, the amounts of &#39;tag0&#39; and &#39;tag1&#39; to be</span>
 4384 |     | <span class='neutral'>// exchanged as a result of the movement within &#39;[qLower, qUpper]&#39; are equal</span>
 4385 |     | <span class='neutral'>// to:</span>
 4386 |     | <span class='neutral'>//</span>
 4387 |     | <span class='neutral'>//                                                         growth</span>
 4388 |     | <span class='neutral'>//  &#39;amount0Partial := sqrtInverseOffset * sharesTotal * ---------- *</span>
 4389 |     | <span class='neutral'>//                                                        2 ** 111</span>
 4390 |     | <span class='neutral'>//</span>
 4391 |     | <span class='neutral'>//                      - 8     / max(qCurrent, qTarget)</span>
 4392 |     | <span class='neutral'>//         1          e        |                         - h / 2</span>
 4393 |     | <span class='neutral'>//   ------------- * ------- * |                       e         k(w(h)) dh&#39;,</span>
 4394 |     | <span class='neutral'>//    outgoingMax       2      |</span>
 4395 |     | <span class='neutral'>//                            / min(qCurrent, qTarget)</span>
 4396 |     | <span class='neutral'>//</span>
 4397 |     | <span class='neutral'>// and</span>
 4398 |     | <span class='neutral'>//                                                  growth</span>
 4399 |     | <span class='neutral'>//  &#39;amount1Partial := sqrtOffset * sharesTotal * ---------- *</span>
 4400 |     | <span class='neutral'>//                                                 2 ** 111</span>
 4401 |     | <span class='neutral'>//</span>
 4402 |     | <span class='neutral'>//                      - 8     / max(qCurrent, qTarget)</span>
 4403 |     | <span class='neutral'>//         1          e        |                         + h / 2</span>
 4404 |     | <span class='neutral'>//   ------------- * ------- * |                       e         k(w(h)) dh&#39;,</span>
 4405 |     | <span class='neutral'>//    outgoingMax       2      |</span>
 4406 |     | <span class='neutral'>//                            / min(qCurrent, qTarget)</span>
 4407 |     | <span class='neutral'>//</span>
 4408 |     | <span class='neutral'>// where the parameters &#39;sqrtInverseOffset&#39;, &#39;sqrtOffset&#39;, &#39;sharesTotal&#39;,</span>
 4409 |     | <span class='neutral'>// &#39;growth&#39;, and &#39;outgoingMax&#39; remain fixed throughout the movement from</span>
 4410 |     | <span class='neutral'>// &#39;qCurrent&#39; to &#39;qTarget&#39;.</span>
 4411 |     | <span class='neutral'>//</span>
 4412 |     | <span class='neutral'>// In search for &#39;qTarget&#39;, we first need to enumerate the pieces of &#39;k(w(.))&#39;,</span>
 4413 |     | <span class='neutral'>// one by one, until we discover the piece to which &#39;qTarget&#39; belongs. While </span>
 4414 |     | <span class='neutral'>// enumerating the pieces of &#39;k(w(.))&#39;, one end of the current piece under</span>
 4415 |     | <span class='neutral'>// exploration is &#39;qBegin&#39; and the other end is temporarily referred to as:</span>
 4416 |     | <span class='neutral'>//</span>
 4417 |     | <span class='neutral'>//  &#39;qTarget := (</span>
 4418 |     | <span class='neutral'>//                direction == getZeroForOne()</span>
 4419 |     | <span class='neutral'>//              ) ? (</span>
 4420 |     | <span class='neutral'>//                direction ? </span>
 4421 |     | <span class='neutral'>//                max(max(qEnd, qTotal1), qLimitWithinInterval) : </span>
 4422 |     | <span class='neutral'>//                min(min(qEnd, qTotal1), qLimitWithinInterval)</span>
 4423 |     | <span class='neutral'>//              ) : (</span>
 4424 |     | <span class='neutral'>//                direction ? </span>
 4425 |     | <span class='neutral'>//                max(qEnd, qTotal1) : </span>
 4426 |     | <span class='neutral'>//                min(qEnd, qTotal1)</span>
 4427 |     | <span class='neutral'>//              )&#39;.</span>
 4428 |     | <span class='neutral'>//</span>
 4429 |     | <span class='neutral'>// After the correct piece is determined, we perform a numerical search via</span>
 4430 |     | <span class='neutral'>// either of the methods &#39;searchOutgoingTarget&#39; or &#39;searchIncomingTarget&#39; in</span>
 4431 |     | <span class='neutral'>// &#39;Interval.sol&#39; in order to pinpoint the precise value of &#39;qTarget&#39;.</span>
 4432 |     | <span class='neutral'>//</span>
 4433 |     | <span class='neutral'>// At every step of searching for the piece to which &#39;qTarget&#39; belongs, if </span>
 4434 |     | <span class='neutral'>// &#39;getDirection() == false&#39;, we have:</span>
 4435 |     | <span class='neutral'>//</span>
 4436 |     | <span class='neutral'>//  &#39;k(w(h)) == k(h - qOrigin) == k_indexKernelTotal(h - qOrigin) :=</span>
 4437 |     | <span class='neutral'>//</span>
 4438 |     | <span class='neutral'>//                         cTotal1 - cTotal0</span>
 4439 |     | <span class='neutral'>//              cTotal0 + ------------------- * (h - qTotal0)&#39;.</span>
 4440 |     | <span class='neutral'>//                         qTotal1 - qTotal0</span>
 4441 |     | <span class='neutral'>//</span>
 4442 |     | <span class='neutral'>// for every &#39;qBegin &lt; h &lt; qTarget&#39; and if &#39;getDirection() == true&#39;, we have:</span>
 4443 |     | <span class='neutral'>//</span>
 4444 |     | <span class='neutral'>//  &#39;k(w(h)) == k(qOrigin - h) == k_indexKernelTotal(qOrigin - h) :=</span>
 4445 |     | <span class='neutral'>//</span>
 4446 |     | <span class='neutral'>//                         cTotal1 - cTotal0</span>
 4447 |     | <span class='neutral'>//              cTotal0 + ------------------- * (qTotal0 - h)&#39;.</span>
 4448 |     | <span class='neutral'>//                         qTotal0 - qTotal1</span>
 4449 |     | <span class='neutral'>//</span>
 4450 |     | <span class='neutral'>// for every &#39;qTarget &lt; h &lt; qBegin&#39;.</span>
 4451 |     | <span class='neutral'>//</span>
 4452 |     | <span class='neutral'>// The 62 bytes memory space which is pointed to by &#39;_target_&#39; hosts the</span>
 4453 |     | <span class='neutral'>// following values:</span>
 4454 |     | <span class='neutral'>//</span>
 4455 |     | <span class='neutral'>//  &#39;_target_.log() := (2 ** 59) * (16 + qTarget)&#39;,</span>
 4456 |     | <span class='neutral'>//  &#39;_target_.sqrt(false) := (2 ** 216) * exp(- 8 - qTarget / 2)&#39;,</span>
 4457 |     | <span class='neutral'>//  &#39;_target_.sqrt(true) := (2 ** 216) * exp(- 8 + qTarget / 2)&#39;.</span>
 4458 |     | <span class='neutral'>//</span>
 4459 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The logarithmic price</span>
 4460 |     | <span class='neutral'>// &#39;_target_.log()&#39; occupies 64 bits, whereas &#39;_target_.sqrt(false)&#39; and</span>
 4461 |     | <span class='neutral'>// &#39;_target_.sqrt(true)&#39; occupy 216 bits each.</span>
 4462 |     | <span class='neutral'>uint16 constant _target_ = 907;</span>
 4463 |     | <span class='neutral'></span>
 4464 |     | <span class='neutral'>// Assume that we are in the process of doing a swap within an interval for</span>
 4465 |     | <span class='neutral'>// which &#39;qTarget&#39; as well as both &#39;amount0Partial&#39; and &#39;amount1Partial&#39; are</span>
 4466 |     | <span class='neutral'>// determined. Let &#39;[qLower, pUpper]&#39; represent the active liquidity interval</span>
 4467 |     | <span class='neutral'>// and define:</span>
 4468 |     | <span class='neutral'>//</span>
 4469 |     | <span class='neutral'>// Now we need to update the curve in preparation for the next swap. Before</span>
 4470 |     | <span class='neutral'>// doing so, define:</span>
 4471 |     | <span class='neutral'>//</span>
 4472 |     | <span class='neutral'>//                                - 8     / qUpper</span>
 4473 |     | <span class='neutral'>//    integral0Incremented      e        |    - h / 2</span>
 4474 |     | <span class='neutral'>//  &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;,</span>
 4475 |     | <span class='neutral'>//          2 ** 216              2      |</span>
 4476 |     | <span class='neutral'>//                                      / qTarget</span>
 4477 |     | <span class='neutral'>//</span>
 4478 |     | <span class='neutral'>//                                - 8     / qTarget</span>
 4479 |     | <span class='neutral'>//    integral1Incremented      e        |    + h / 2</span>
 4480 |     | <span class='neutral'>//  &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;.</span>
 4481 |     | <span class='neutral'>//          2 ** 216              2      |</span>
 4482 |     | <span class='neutral'>//                                      / qLower</span>
 4483 |     | <span class='neutral'>//</span>
 4484 |     | <span class='neutral'>// Then we have:</span>
 4485 |     | <span class='neutral'>//</span>
 4486 |     | <span class='neutral'>//                                                                   growth</span>
 4487 |     | <span class='neutral'>//  &#39;totalReserveOfTag0Before := sqrtInverseOffset * sharesTotal * ---------- * </span>
 4488 |     | <span class='neutral'>//                                                                  2 ** 111</span>
 4489 |     | <span class='neutral'>//    integral0Incremented</span>
 4490 |     | <span class='neutral'>//   ----------------------&#39;</span>
 4491 |     | <span class='neutral'>//        outgoingMax</span>
 4492 |     | <span class='neutral'>//</span>
 4493 |     | <span class='neutral'>//                                                            growth</span>
 4494 |     | <span class='neutral'>//  &#39;totalReserveOfTag1Before := sqrtOffset * sharesTotal * ---------- * </span>
 4495 |     | <span class='neutral'>//                                                           2 ** 111</span>
 4496 |     | <span class='neutral'>//    integral1Incremented</span>
 4497 |     | <span class='neutral'>//   ----------------------&#39;</span>
 4498 |     | <span class='neutral'>//        outgoingMax</span>
 4499 |     | <span class='neutral'>//</span>
 4500 |     | <span class='neutral'>// Now, assume that the curve sequence is updated and the function &#39;w&#39; is</span>
 4501 |     | <span class='neutral'>// transformed into a new function &#39;wAmended&#39; which is constructed based on the</span>
 4502 |     | <span class='neutral'>// updated curve sequence. Then, we can similarly define:</span>
 4503 |     | <span class='neutral'>//</span>
 4504 |     | <span class='neutral'>//                            - 8     / qUpper</span>
 4505 |     | <span class='neutral'>//    integral0Amended      e        |    - h / 2</span>
 4506 |     | <span class='neutral'>//  &#39;------------------ := ------- * |  e         k(wAmended(h)) dh&#39;,</span>
 4507 |     | <span class='neutral'>//        2 ** 216            2      |</span>
 4508 |     | <span class='neutral'>//                                  / qTarget</span>
 4509 |     | <span class='neutral'>//</span>
 4510 |     | <span class='neutral'>//                            - 8     / qTarget</span>
 4511 |     | <span class='neutral'>//    integral1Amended      e        |    + h / 2</span>
 4512 |     | <span class='neutral'>//  &#39;------------------ := ------- * |  e         k(wAmended(h)) dh&#39;.</span>
 4513 |     | <span class='neutral'>//        2 ** 216            2      |</span>
 4514 |     | <span class='neutral'>//                                  / qLower</span>
 4515 |     | <span class='neutral'>//</span>
 4516 |     | <span class='neutral'>// Then we have:</span>
 4517 |     | <span class='neutral'>//</span>
 4518 |     | <span class='neutral'>//  &#39;totalReserveOfTag0After := sqrtInverseOffset * sharesTotal *</span>
 4519 |     | <span class='neutral'>//</span>
 4520 |     | <span class='neutral'>//    growthAmended     integral0Amended</span>
 4521 |     | <span class='neutral'>//   --------------- * ------------------&#39;</span>
 4522 |     | <span class='neutral'>//      2 ** 111          outgoingMax</span>
 4523 |     | <span class='neutral'>//</span>
 4524 |     | <span class='neutral'>//  &#39;totalReserveOfTag1After := sqrtOffset * sharesTotal * </span>
 4525 |     | <span class='neutral'>//</span>
 4526 |     | <span class='neutral'>//    growthAmended     integral1Amended</span>
 4527 |     | <span class='neutral'>//   --------------- * ------------------&#39;</span>
 4528 |     | <span class='neutral'>//      2 ** 111          outgoingMax</span>
 4529 |     | <span class='neutral'>//</span>
 4530 |     | <span class='neutral'>// Now, we need to make sure that the reserve amounts before and after the</span>
 4531 |     | <span class='neutral'>// curve update are the same, which means that:</span>
 4532 |     | <span class='neutral'>//</span>
 4533 |     | <span class='neutral'>//  &#39;totalReserveOfTag0Before == totalReserveOfTag0After&#39;</span>
 4534 |     | <span class='neutral'>//  &#39;totalReserveOfTag1Before == totalReserveOfTag1After&#39;</span>
 4535 |     | <span class='neutral'>//</span>
 4536 |     | <span class='neutral'>// This leads to the following two equations:</span>
 4537 |     | <span class='neutral'>// </span>
 4538 |     | <span class='neutral'>//       growth            integral0Amended</span>
 4539 |     | <span class='neutral'>//  &#39;--------------- == ----------------------&#39;</span>
 4540 |     | <span class='neutral'>//    growthAmended      integral0Incremented</span>
 4541 |     | <span class='neutral'>// </span>
 4542 |     | <span class='neutral'>//       growth            integral1Amended</span>
 4543 |     | <span class='neutral'>//  &#39;--------------- == ----------------------&#39;</span>
 4544 |     | <span class='neutral'>//    growthAmended      integral1Incremented</span>
 4545 |     | <span class='neutral'>//</span>
 4546 |     | <span class='neutral'>// Hence, we must have:</span>
 4547 |     | <span class='neutral'>//</span>
 4548 |     | <span class='neutral'>//      integral0Amended          integral1Amended</span>
 4549 |     | <span class='neutral'>//  &#39;---------------------- == ----------------------&#39;</span>
 4550 |     | <span class='neutral'>//    integral0Incremented      integral1Incremented</span>
 4551 |     | <span class='neutral'>//</span>
 4552 |     | <span class='neutral'>// which means that:</span>
 4553 |     | <span class='neutral'>//</span>
 4554 |     | <span class='neutral'>//      / qUpper                          / qTarget</span>
 4555 |     | <span class='neutral'>//     |   - h/2                         |   + h/2</span>
 4556 |     | <span class='neutral'>//     |  e      k(wAmended(h)) dh       |  e      k(wAmended(h)) dh</span>
 4557 |     | <span class='neutral'>//     |                                 |</span>
 4558 |     | <span class='neutral'>//    / qTarget                         / qLower</span>
 4559 |     | <span class='neutral'>//  &#39;------------------------------ == ------------------------------&#39;.</span>
 4560 |     | <span class='neutral'>//         / qUpper                          / qTarget</span>
 4561 |     | <span class='neutral'>//        |    - h/2                        |    + h/2</span>
 4562 |     | <span class='neutral'>//        |  e       k(w(h)) dh             |  e       k(w(h)) dh</span>
 4563 |     | <span class='neutral'>//        |                                 |</span>
 4564 |     | <span class='neutral'>//       / qTarget                         / qLower</span>
 4565 |     | <span class='neutral'>//</span>
 4566 |     | <span class='neutral'>// As a result, we should update the curve in such a way that the above</span>
 4567 |     | <span class='neutral'>// equality is satisfied.</span>
 4568 |     | <span class='neutral'>//</span>
 4569 |     | <span class='neutral'>// To that end, once &#39;qOvershoot&#39; and both &#39;amount0Partial&#39; and</span>
 4570 |     | <span class='neutral'>// &#39;amount1Partial&#39; are determined, the curve sequence is amended with</span>
 4571 |     | <span class='neutral'>// &#39;qOvershoot&#39; and then &#39;qTarget&#39;.</span>
 4572 |     | <span class='neutral'>//</span>
 4573 |     | <span class='neutral'>// If &#39;getZeroForOne() == false&#39; then &#39;qTarget &lt;= qOvershoot&#39; and if</span>
 4574 |     | <span class='neutral'>// &#39;getZeroForOne() == true&#39; then &#39;qOvershoot &lt;= qTarget&#39;. Assume that</span>
 4575 |     | <span class='neutral'>// &#39;wAmended&#39; is constructed from the amended curve sequence. &#39;qOvershoot&#39; is</span>
 4576 |     | <span class='neutral'>// calculated in such a way that the above equality holds for the amended</span>
 4577 |     | <span class='neutral'>// curve. The process of searching for &#39;qOvershoot&#39; is further explained at</span>
 4578 |     | <span class='neutral'>// the beginning of this section.</span>
 4579 |     | <span class='neutral'>//</span>
 4580 |     | <span class='neutral'>// The 62 bytes memory space which is pointed to by &#39;_overshoot_&#39; hosts the</span>
 4581 |     | <span class='neutral'>// following values:</span>
 4582 |     | <span class='neutral'>//</span>
 4583 |     | <span class='neutral'>//  &#39;_overshoot_.log() := (2 ** 59) * (16 + qOvershoot)&#39;,</span>
 4584 |     | <span class='neutral'>//  &#39;_overshoot_.sqrt(false) := (2 ** 216) * exp(- 8 - qOvershoot / 2)&#39;,</span>
 4585 |     | <span class='neutral'>//  &#39;_overshoot_.sqrt(true) := (2 ** 216) * exp(- 8 + qOvershoot / 2)&#39;.</span>
 4586 |     | <span class='neutral'>//</span>
 4587 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The logarithmic price</span>
 4588 |     | <span class='neutral'>// &#39;_overshoot_.log()&#39; occupies 64 bits, whereas &#39;_overshoot_.sqrt(false)&#39; and</span>
 4589 |     | <span class='neutral'>// &#39;_overshoot_.sqrt(true)&#39; occupy 216 bits each.</span>
 4590 |     | <span class='neutral'>uint16 constant _overshoot_ = 969;</span>
 4591 |     | <span class='neutral'></span>
 4592 |     | <span class='neutral'>// At every step of searching for &#39;qTarget&#39;, the range</span>
 4593 |     | <span class='neutral'>//</span>
 4594 |     | <span class='neutral'>//  &#39;min(qBegin, qTarget) &lt; h &lt; max(qBegin, qTarget)&#39;</span>
 4595 |     | <span class='neutral'>//</span>
 4596 |     | <span class='neutral'>// represents a piece of the liquidity distribution function &#39;k(w(.))&#39; in which</span>
 4597 |     | <span class='neutral'>// &#39;k(w(.))&#39; is linear. More precisely, if &#39;getDirection() == false&#39;, we have:</span>
 4598 |     | <span class='neutral'>//</span>
 4599 |     | <span class='neutral'>//  &#39;k(w(h)) == k(h - qOrigin) == k_indexKernelTotal(h - qOrigin) :=</span>
 4600 |     | <span class='neutral'>//</span>
 4601 |     | <span class='neutral'>//                         cTotal1 - cTotal0</span>
 4602 |     | <span class='neutral'>//              cTotal0 + ------------------- * (h - qTotal0)&#39;.</span>
 4603 |     | <span class='neutral'>//                         qTotal1 - qTotal0</span>
 4604 |     | <span class='neutral'>//</span>
 4605 |     | <span class='neutral'>// for every &#39;qBegin &lt; h &lt; qTarget&#39; and if &#39;getDirection() == true&#39;, we have:</span>
 4606 |     | <span class='neutral'>//</span>
 4607 |     | <span class='neutral'>//  &#39;k(w(h)) == k(qOrigin - h) == k_indexKernelTotal(qOrigin - h) :=</span>
 4608 |     | <span class='neutral'>//</span>
 4609 |     | <span class='neutral'>//                         cTotal1 - cTotal0</span>
 4610 |     | <span class='neutral'>//              cTotal0 + ------------------- * (qTotal0 - h)&#39;.</span>
 4611 |     | <span class='neutral'>//                         qTotal0 - qTotal1</span>
 4612 |     | <span class='neutral'>//</span>
 4613 |     | <span class='neutral'>// for every &#39;qTarget &lt; h &lt; qBegin&#39;, where:</span>
 4614 |     | <span class='neutral'>//</span>
 4615 |     | <span class='neutral'>//  &#39;cTotal0 := c[indexKernelTotal - 1]&#39;,</span>
 4616 |     | <span class='neutral'>//</span>
 4617 |     | <span class='neutral'>//  &#39;qTotal0 := direction ? </span>
 4618 |     | <span class='neutral'>//              qOrigin - b[indexKernelTotal - 1] : </span>
 4619 |     | <span class='neutral'>//              qOrigin + b[indexKernelTotal - 1]&#39;,</span>
 4620 |     | <span class='neutral'>//</span>
 4621 |     | <span class='neutral'>//  &#39;cTotal1 := c[indexKernelTotal]&#39;,</span>
 4622 |     | <span class='neutral'>//</span>
 4623 |     | <span class='neutral'>//  &#39;qTotal1 := direction ? </span>
 4624 |     | <span class='neutral'>//              qOrigin - b[indexKernelTotal] : </span>
 4625 |     | <span class='neutral'>//              qOrigin + b[indexKernelTotal]&#39;.</span>
 4626 |     | <span class='neutral'>//</span>
 4627 |     | <span class='neutral'>// The pair &#39;(cTotal0, qTotal0)&#39; is stored in the memory space which is pointed</span>
 4628 |     | <span class='neutral'>// to by &#39;_total0_&#39; and similarly, the pair &#39;(cTotal1, qTotal1)&#39; is stored in</span>
 4629 |     | <span class='neutral'>// the memory space which is pointed to by &#39;_total1_&#39;.</span>
 4630 |     | <span class='neutral'>//</span>
 4631 |     | <span class='neutral'>// The 64 bytes memory space which is pointed to by &#39;_total0_&#39; hosts the</span>
 4632 |     | <span class='neutral'>// following values:</span>
 4633 |     | <span class='neutral'>//</span>
 4634 |     | <span class='neutral'>//  &#39;_total0_.height() := (2 ** 15) * cTotal0&#39;,</span>
 4635 |     | <span class='neutral'>//  &#39;_total0_.log() := (2 ** 59) * (16 + qTotal0)&#39;,</span>
 4636 |     | <span class='neutral'>//  &#39;_total0_.sqrt(false) := (2 ** 216) * exp(- 8 - qTotal0 / 2)&#39;,</span>
 4637 |     | <span class='neutral'>//  &#39;_total0_.sqrt(true) := (2 ** 216) * exp(- 8 + qTotal0 / 2)&#39;.</span>
 4638 |     | <span class='neutral'>//</span>
 4639 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The vertical coordinate</span>
 4640 |     | <span class='neutral'>// &#39;_total0_.height()&#39; occupies 16 bits, the logarithmic price &#39;_total0_.log()&#39;</span>
 4641 |     | <span class='neutral'>// occupies 64 bits, whereas &#39;_total0_.sqrt(false)&#39; and &#39;_total0_.sqrt(true)&#39;</span>
 4642 |     | <span class='neutral'>// occupy 216 bits each.</span>
 4643 |     | <span class='neutral'>//</span>
 4644 |     | <span class='neutral'>// The 64 bytes memory space which is pointed to by &#39;_total1_&#39; hosts the</span>
 4645 |     | <span class='neutral'>// following values:</span>
 4646 |     | <span class='neutral'>//</span>
 4647 |     | <span class='neutral'>//  &#39;_total1_.height() := (2 ** 15) * cTotal1&#39;,</span>
 4648 |     | <span class='neutral'>//  &#39;_total1_.log() := (2 ** 59) * (16 + qTotal1)&#39;,</span>
 4649 |     | <span class='neutral'>//  &#39;_total1_.sqrt(false) := (2 ** 216) * exp(- 8 - qTotal1 / 2)&#39;,</span>
 4650 |     | <span class='neutral'>//  &#39;_total1_.sqrt(true) := (2 ** 216) * exp(- 8 + qTotal1 / 2)&#39;.</span>
 4651 |     | <span class='neutral'>//</span>
 4652 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The vertical coordinate</span>
 4653 |     | <span class='neutral'>// &#39;_total1_.height()&#39; occupies 16 bits, the logarithmic price &#39;_total1_.log()&#39;</span>
 4654 |     | <span class='neutral'>// occupies 64 bits, whereas &#39;_total1_.sqrt(false)&#39; and &#39;_total1_.sqrt(true)&#39;</span>
 4655 |     | <span class='neutral'>// occupy 216 bits each.</span>
 4656 |     | <span class='neutral'>uint16 constant _total0_ = 1033;</span>
 4657 |     | <span class='neutral'>uint16 constant _total1_ = 1097;</span>
 4658 |     | <span class='neutral'></span>
 4659 |     | <span class='neutral'>// At every step of searching for &#39;qOvershoot&#39;, the range</span>
 4660 |     | <span class='neutral'>//</span>
 4661 |     | <span class='neutral'>//  &#39;min(qBegin, qOvershoot) &lt; h &lt; max(qBegin, qOvershoot)&#39;</span>
 4662 |     | <span class='neutral'>//</span>
 4663 |     | <span class='neutral'>// represents a piece of &#39;k(|. - qTarget|)&#39;. If &#39;getZeroForOne() == false&#39;,</span>
 4664 |     | <span class='neutral'>// then we have:</span>
 4665 |     | <span class='neutral'>//</span>
 4666 |     | <span class='neutral'>//  &#39;k(h - qTarget) == k_indexKernelForward(h - qTarget) :=</span>
 4667 |     | <span class='neutral'>//</span>
 4668 |     | <span class='neutral'>//                                  cForward1 - cForward0</span>
 4669 |     | <span class='neutral'>//                     cForward0 + ----------------------- * (h - qForward0)&#39;,</span>
 4670 |     | <span class='neutral'>//                                  qForward1 - qForward0</span>
 4671 |     | <span class='neutral'>//</span>
 4672 |     | <span class='neutral'>// for every &#39;qBegin &lt; h &lt; qOvershoot&#39; and if &#39;getZeroForOne() == true&#39;, then</span>
 4673 |     | <span class='neutral'>// we have:</span>
 4674 |     | <span class='neutral'>//</span>
 4675 |     | <span class='neutral'>//  &#39;k(qTarget - h) == k_indexKernelForward(qTarget - h) :=</span>
 4676 |     | <span class='neutral'>//</span>
 4677 |     | <span class='neutral'>//                                  cForward1 - cForward0</span>
 4678 |     | <span class='neutral'>//                     cForward0 + ----------------------- * (qForward0 - h)&#39;,</span>
 4679 |     | <span class='neutral'>//                                  qForward0 - qForward1</span>
 4680 |     | <span class='neutral'>//</span>
 4681 |     | <span class='neutral'>// for every &#39;qOvershoot &lt; h &lt; qBegin&#39; where</span>
 4682 |     | <span class='neutral'>//</span>
 4683 |     | <span class='neutral'>//  &#39;cForward0 := c[indexKernelForward - 1]&#39;,</span>
 4684 |     | <span class='neutral'>//</span>
 4685 |     | <span class='neutral'>//  &#39;qForward0 := getZeroForOne() ? </span>
 4686 |     | <span class='neutral'>//                qTarget - b[indexKernelForward - 1] : </span>
 4687 |     | <span class='neutral'>//                qTarget + b[indexKernelForward - 1]&#39;,</span>
 4688 |     | <span class='neutral'>//</span>
 4689 |     | <span class='neutral'>//  &#39;cForward1 := c[indexKernelForward]&#39;,</span>
 4690 |     | <span class='neutral'>//</span>
 4691 |     | <span class='neutral'>//  &#39;qForward1 := getZeroForOne() ? </span>
 4692 |     | <span class='neutral'>//                qTarget - b[indexKernelForward] : </span>
 4693 |     | <span class='neutral'>//                qTarget + b[indexKernelForward]&#39;.</span>
 4694 |     | <span class='neutral'>//</span>
 4695 |     | <span class='neutral'>// The pair &#39;(cForward0, qForward0)&#39; is stored in the memory space which is</span>
 4696 |     | <span class='neutral'>// pointed to by &#39;_forward0_&#39; and similarly, the pair &#39;(cForward1, qForward1)&#39;</span>
 4697 |     | <span class='neutral'>// is stored in the memory space which is pointed to by &#39;_forward1_&#39;.</span>
 4698 |     | <span class='neutral'>//</span>
 4699 |     | <span class='neutral'>// The 64 bytes memory space which is pointed to by &#39;_forward0_&#39; hosts the</span>
 4700 |     | <span class='neutral'>// following values:</span>
 4701 |     | <span class='neutral'>//</span>
 4702 |     | <span class='neutral'>//  &#39;_forward0_.height() := (2 ** 15) * cForward0&#39;,</span>
 4703 |     | <span class='neutral'>//  &#39;_forward0_.log() := (2 ** 59) * (16 + qForward0)&#39;,</span>
 4704 |     | <span class='neutral'>//  &#39;_forward0_.sqrt(false) := (2 ** 216) * exp(- 8 - qForward0 / 2)&#39;,</span>
 4705 |     | <span class='neutral'>//  &#39;_forward0_.sqrt(true) := (2 ** 216) * exp(- 8 + qForward0 / 2)&#39;.</span>
 4706 |     | <span class='neutral'>//</span>
 4707 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The vertical coordinate</span>
 4708 |     | <span class='neutral'>// &#39;_forward0_.height()&#39; occupies 16 bits, the logarithmic price</span>
 4709 |     | <span class='neutral'>// &#39;_forward0_.log()&#39; occupies 64 bits, whereas &#39;_forward0_.sqrt(false)&#39; and</span>
 4710 |     | <span class='neutral'>// &#39;_forward0_.sqrt(true)&#39; occupy 216 bits each.</span>
 4711 |     | <span class='neutral'>//</span>
 4712 |     | <span class='neutral'>// The 64 bytes memory space which is pointed to by &#39;_forward1_&#39; hosts the</span>
 4713 |     | <span class='neutral'>// following values:</span>
 4714 |     | <span class='neutral'>//</span>
 4715 |     | <span class='neutral'>//  &#39;_forward1_.height() := (2 ** 15) * cForward1&#39;,</span>
 4716 |     | <span class='neutral'>//  &#39;_forward1_.log() := (2 ** 59) * (16 + qForward1)&#39;,</span>
 4717 |     | <span class='neutral'>//  &#39;_forward1_.sqrt(false) := (2 ** 216) * exp(- 8 - qForward1 / 2)&#39;,</span>
 4718 |     | <span class='neutral'>//  &#39;_forward1_.sqrt(true) := (2 ** 216) * exp(- 8 + qForward1 / 2)&#39;.</span>
 4719 |     | <span class='neutral'>//</span>
 4720 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The vertical coordinate</span>
 4721 |     | <span class='neutral'>// &#39;_forward1_.height()&#39; occupies 16 bits, the logarithmic price</span>
 4722 |     | <span class='neutral'>// &#39;_forward1_.log()&#39; occupies 64 bits, whereas &#39;_forward1_.sqrt(false)&#39; and</span>
 4723 |     | <span class='neutral'>// &#39;_forward1_.sqrt(true)&#39; occupy 216 bits each.</span>
 4724 |     | <span class='neutral'>uint16 constant _forward0_ = 1161;</span>
 4725 |     | <span class='neutral'>uint16 constant _forward1_ = 1225;</span>
 4726 |     | <span class='neutral'></span>
 4727 |     | <span class='neutral'>// While searching for &#39;qTarget&#39;, the integral &#39;incomingCurrentToTarget&#39; is</span>
 4728 |     | <span class='neutral'>// calculated. This integral is defined as follows:</span>
 4729 |     | <span class='neutral'>//</span>
 4730 |     | <span class='neutral'>//                                   - 8</span>
 4731 |     | <span class='neutral'>//    incomingCurrentToTarget      e</span>
 4732 |     | <span class='neutral'>//  &#39;------------------------- := ------- * (</span>
 4733 |     | <span class='neutral'>//           2 ** 216                2</span>
 4734 |     | <span class='neutral'>//</span>
 4735 |     | <span class='neutral'>//                         / qCurrent                 / qTarget</span>
 4736 |     | <span class='neutral'>//                        |    - h / 2               |    + h / 2</span>
 4737 |     | <span class='neutral'>//     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh</span>
 4738 |     | <span class='neutral'>//                        |                          |</span>
 4739 |     | <span class='neutral'>//                       / qTarget                  / qCurrent</span>
 4740 |     | <span class='neutral'>//</span>
 4741 |     | <span class='neutral'>//   )&#39;.</span>
 4742 |     | <span class='neutral'>//</span>
 4743 |     | <span class='neutral'>// The pointer below refers to the above integral in &#39;X216&#39; representation</span>
 4744 |     | <span class='neutral'>// which takes up to 27 bytes.</span>
 4745 |     | <span class='neutral'>uint16 constant _incomingCurrentToTarget_ = 1287;</span>
 4746 |     | <span class='neutral'></span>
 4747 |     | <span class='neutral'>// While searching for &#39;qTarget&#39;, the integral &#39;currentToTarget&#39; is calculated.</span>
 4748 |     | <span class='neutral'>// This integral is defined as follows:</span>
 4749 |     | <span class='neutral'>//</span>
 4750 |     | <span class='neutral'>//                           - 8</span>
 4751 |     | <span class='neutral'>//    currentToTarget      e</span>
 4752 |     | <span class='neutral'>//  &#39;----------------- := ------- * (</span>
 4753 |     | <span class='neutral'>//       2 ** 216            2</span>
 4754 |     | <span class='neutral'>//</span>
 4755 |     | <span class='neutral'>//                         / qCurrent                 / qTarget</span>
 4756 |     | <span class='neutral'>//                        |    + h / 2               |    - h / 2</span>
 4757 |     | <span class='neutral'>//     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh</span>
 4758 |     | <span class='neutral'>//                        |                          |</span>
 4759 |     | <span class='neutral'>//                       / qTarget                  / qCurrent</span>
 4760 |     | <span class='neutral'>//</span>
 4761 |     | <span class='neutral'>//   )&#39;</span>
 4762 |     | <span class='neutral'>//</span>
 4763 |     | <span class='neutral'>// The pointer below refers to the above integral in &#39;X216&#39; representation</span>
 4764 |     | <span class='neutral'>// which takes up to 27 bytes.</span>
 4765 |     | <span class='neutral'>uint16 constant _currentToTarget_ = 1314;</span>
 4766 |     | <span class='neutral'></span>
 4767 |     | <span class='neutral'>// While searching for &#39;qTarget&#39; and &#39;qOvershoot&#39;, we need to calculate the</span>
 4768 |     | <span class='neutral'>// following integral:</span>
 4769 |     | <span class='neutral'>//</span>
 4770 |     | <span class='neutral'>//                           - 8</span>
 4771 |     | <span class='neutral'>//    currentToOrigin      e</span>
 4772 |     | <span class='neutral'>//  &#39;----------------- := ------- * (</span>
 4773 |     | <span class='neutral'>//       2 ** 216            2</span>
 4774 |     | <span class='neutral'>//</span>
 4775 |     | <span class='neutral'>//                         / qOrigin                  / qCurrent</span>
 4776 |     | <span class='neutral'>//                        |    - h / 2               |    + h / 2</span>
 4777 |     | <span class='neutral'>//     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh</span>
 4778 |     | <span class='neutral'>//                        |                          |</span>
 4779 |     | <span class='neutral'>//                       / qCurrent                 / qOrigin</span>
 4780 |     | <span class='neutral'>//</span>
 4781 |     | <span class='neutral'>//   )&#39;.</span>
 4782 |     | <span class='neutral'>//</span>
 4783 |     | <span class='neutral'>// &#39;currentToOrigin&#39; is used for the calculation of &#39;overshoot&#39; as discussed in</span>
 4784 |     | <span class='neutral'>// &#39;Interval.sol&#39;.</span>
 4785 |     | <span class='neutral'>//</span>
 4786 |     | <span class='neutral'>// The pointer below refers to the above integral in &#39;X216&#39; representation</span>
 4787 |     | <span class='neutral'>// which takes up to 27 bytes.</span>
 4788 |     | <span class='neutral'>uint16 constant _currentToOrigin_ = 1341;</span>
 4789 |     | <span class='neutral'></span>
 4790 |     | <span class='neutral'>// While searching for &#39;qTarget&#39; and &#39;qOvershoot&#39;, we need to calculate the</span>
 4791 |     | <span class='neutral'>// following integral:</span>
 4792 |     | <span class='neutral'>//</span>
 4793 |     | <span class='neutral'>//                              - 8</span>
 4794 |     | <span class='neutral'>//    currentToOvershoot      e</span>
 4795 |     | <span class='neutral'>//  &#39;-------------------- := ------- * (</span>
 4796 |     | <span class='neutral'>//         2 ** 216             2</span>
 4797 |     | <span class='neutral'>//</span>
 4798 |     | <span class='neutral'>//                         / qCurrent                 / qOvershoot</span>
 4799 |     | <span class='neutral'>//                        |    + h / 2               |    - h / 2</span>
 4800 |     | <span class='neutral'>//     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh</span>
 4801 |     | <span class='neutral'>//                        |                          |</span>
 4802 |     | <span class='neutral'>//                       / qOvershoot               / qCurrent</span>
 4803 |     | <span class='neutral'>//</span>
 4804 |     | <span class='neutral'>//   )&#39;</span>
 4805 |     | <span class='neutral'>//</span>
 4806 |     | <span class='neutral'>// &#39;currentToOvershoot&#39; is used for the calculation of &#39;overshoot&#39; as discussed</span>
 4807 |     | <span class='neutral'>// in &#39;Interval.sol&#39;.</span>
 4808 |     | <span class='neutral'>//</span>
 4809 |     | <span class='neutral'>// The pointer below refers to the above integral in &#39;X216&#39; representation</span>
 4810 |     | <span class='neutral'>// which takes up to 27 bytes.</span>
 4811 |     | <span class='neutral'>uint16 constant _currentToOvershoot_ = 1368;</span>
 4812 |     | <span class='neutral'></span>
 4813 |     | <span class='neutral'>// While searching for &#39;qOvershoot&#39;, we need to calculate the following</span>
 4814 |     | <span class='neutral'>// integral:</span>
 4815 |     | <span class='neutral'>//</span>
 4816 |     | <span class='neutral'>//                             - 8</span>
 4817 |     | <span class='neutral'>//    targetToOvershoot      e</span>
 4818 |     | <span class='neutral'>//  &#39;------------------- := ------- * (</span>
 4819 |     | <span class='neutral'>//         2 ** 216            2</span>
 4820 |     | <span class='neutral'>//</span>
 4821 |     | <span class='neutral'>//     getZeroForOne()</span>
 4822 |     | <span class='neutral'>//</span>
 4823 |     | <span class='neutral'>//         / qTarget</span>
 4824 |     | <span class='neutral'>//        |    + h / 2</span>
 4825 |     | <span class='neutral'>//     ?  |  e         k(qTarget - h) dh</span>
 4826 |     | <span class='neutral'>//        |</span>
 4827 |     | <span class='neutral'>//       / qOvershoot</span>
 4828 |     | <span class='neutral'>//</span>
 4829 |     | <span class='neutral'>//         / qOvershoot</span>
 4830 |     | <span class='neutral'>//        |    - h / 2</span>
 4831 |     | <span class='neutral'>//     :  |  e         k(h - qTarget) dh</span>
 4832 |     | <span class='neutral'>//        |</span>
 4833 |     | <span class='neutral'>//       / qTarget</span>
 4834 |     | <span class='neutral'>//</span>
 4835 |     | <span class='neutral'>//   )&#39;</span>
 4836 |     | <span class='neutral'>//</span>
 4837 |     | <span class='neutral'>// &#39;targetToOvershoot&#39; is used for the calculation of &#39;overshoot&#39; as discussed</span>
 4838 |     | <span class='neutral'>// in &#39;Interval.sol&#39;.</span>
 4839 |     | <span class='neutral'>//</span>
 4840 |     | <span class='neutral'>// The pointer below refers to the above integral in &#39;X216&#39; representation</span>
 4841 |     | <span class='neutral'>// which takes up to 27 bytes.</span>
 4842 |     | <span class='neutral'>uint16 constant _targetToOvershoot_ = 1395;</span>
 4843 |     | <span class='neutral'></span>
 4844 |     | <span class='neutral'>// While searching for &#39;qTarget&#39; and &#39;qOvershoot&#39;, we need to calculate the</span>
 4845 |     | <span class='neutral'>// following integral:</span>
 4846 |     | <span class='neutral'>//</span>
 4847 |     | <span class='neutral'>//                             - 8</span>
 4848 |     | <span class='neutral'>//    originToOvershoot      e</span>
 4849 |     | <span class='neutral'>//  &#39;------------------- := ------- * (</span>
 4850 |     | <span class='neutral'>//        2 ** 216             2</span>
 4851 |     | <span class='neutral'>//</span>
 4852 |     | <span class='neutral'>//     getZeroForOne() ? </span>
 4853 |     | <span class='neutral'>//</span>
 4854 |     | <span class='neutral'>//       / qOrigin</span>
 4855 |     | <span class='neutral'>//      |    + h / 2</span>
 4856 |     | <span class='neutral'>//      |  e         k(qOrigin - h) dh :</span>
 4857 |     | <span class='neutral'>//      |</span>
 4858 |     | <span class='neutral'>//     / qTarget</span>
 4859 |     | <span class='neutral'>//</span>
 4860 |     | <span class='neutral'>//       / qTarget</span>
 4861 |     | <span class='neutral'>//      |    - h / 2</span>
 4862 |     | <span class='neutral'>//      |  e         k(h - qOrigin) dh</span>
 4863 |     | <span class='neutral'>//      |</span>
 4864 |     | <span class='neutral'>//     / qOrigin</span>
 4865 |     | <span class='neutral'>//</span>
 4866 |     | <span class='neutral'>//   )&#39;</span>
 4867 |     | <span class='neutral'>//</span>
 4868 |     | <span class='neutral'>// &#39;originToOvershoot&#39; is used for the calculation of &#39;overshoot&#39; as discussed</span>
 4869 |     | <span class='neutral'>// in &#39;Interval.sol&#39;.</span>
 4870 |     | <span class='neutral'>//</span>
 4871 |     | <span class='neutral'>// The pointer below refers to the above integral in &#39;X216&#39; representation</span>
 4872 |     | <span class='neutral'>// which takes up to 27 bytes.</span>
 4873 |     | <span class='neutral'>uint16 constant _originToOvershoot_ = 1422;</span>
 4874 |     | <span class='neutral'></span>
 4875 |     | <span class='neutral'>uint16 constant _endOfInterval_ = 1449;</span>
 4876 |     | <span class='neutral'></span>
 4877 |     | <span class='neutral'>// Accrued Parameters</span>
 4878 |     | <span class='neutral'>// ----------------------------------------------------------------------------</span>
 4879 |     | <span class='neutral'>// The spaces that are pointed to by the following memory pointers contain</span>
 4880 |     | <span class='neutral'>// information about the accrued growth portions that are owed to the protocol</span>
 4881 |     | <span class='neutral'>// and the pool. After each swap or donate, the interval liquidity grows. A</span>
 4882 |     | <span class='neutral'>// portion of this growth goes to the protocol. A portion of the remaining</span>
 4883 |     | <span class='neutral'>// growth goes to the pool owner. These values are compactly written on</span>
 4884 |     | <span class='neutral'>// protocol&#39;s storage in which they occupy exactly one slot.</span>
 4885 |     | <span class='neutral'>uint16 constant _accruedParams_ = 1449;</span>
 4886 |     | <span class='neutral'></span>
 4887 |     | <span class='neutral'>// This 32 bytes memory space hosts the &#39;X127&#39; representation of &#39;accrued0&#39;</span>
 4888 |     | <span class='neutral'>// where</span>
 4889 |     | <span class='neutral'>//</span>
 4890 |     | <span class='neutral'>//    accrued0</span>
 4891 |     | <span class='neutral'>//  &#39;----------&#39;</span>
 4892 |     | <span class='neutral'>//    2 ** 127</span>
 4893 |     | <span class='neutral'>//</span>
 4894 |     | <span class='neutral'>// is the total unclaimed amount in &#39;tag0&#39; owed to both the protocol and the</span>
 4895 |     | <span class='neutral'>// pool owner.</span>
 4896 |     | <span class='neutral'>uint16 constant _accrued0_ = 1449;</span>
 4897 |     | <span class='neutral'></span>
 4898 |     | <span class='neutral'>// This 32 bytes memory space hosts the &#39;X127&#39; representation of &#39;accrued1&#39;</span>
 4899 |     | <span class='neutral'>// where</span>
 4900 |     | <span class='neutral'>//</span>
 4901 |     | <span class='neutral'>//    accrued1</span>
 4902 |     | <span class='neutral'>//  &#39;----------&#39;</span>
 4903 |     | <span class='neutral'>//    2 ** 127</span>
 4904 |     | <span class='neutral'>//</span>
 4905 |     | <span class='neutral'>// is the total unclaimed amount in &#39;tag1&#39; owed to both the protocol and the</span>
 4906 |     | <span class='neutral'>// pool owner.</span>
 4907 |     | <span class='neutral'>uint16 constant _accrued1_ = 1481;</span>
 4908 |     | <span class='neutral'></span>
 4909 |     | <span class='neutral'>// This 3 bytes memory space hosts the &#39;X23&#39; representation of &#39;poolRatio0&#39;</span>
 4910 |     | <span class='neutral'>// where</span>
 4911 |     | <span class='neutral'>//</span>
 4912 |     | <span class='neutral'>//    poolRatio0     accrued0</span>
 4913 |     | <span class='neutral'>//  &#39;------------ * ----------&#39;</span>
 4914 |     | <span class='neutral'>//     2 ** 23       2 ** 127</span>
 4915 |     | <span class='neutral'>//</span>
 4916 |     | <span class='neutral'>// is the accrued amount in &#39;tag0&#39; owed to the pool and</span>
 4917 |     | <span class='neutral'>//</span>
 4918 |     | <span class='neutral'>//    oneX23 - poolRatio0     accrued0</span>
 4919 |     | <span class='neutral'>//  &#39;--------------------- * ----------&#39;</span>
 4920 |     | <span class='neutral'>//          2 ** 23           2 ** 127</span>
 4921 |     | <span class='neutral'>//</span>
 4922 |     | <span class='neutral'>// is the accrued amount in &#39;tag0&#39; owed to the protocol.</span>
 4923 |     | <span class='neutral'>uint16 constant _poolRatio0_ = 1513;</span>
 4924 |     | <span class='neutral'></span>
 4925 |     | <span class='neutral'>// This 3 bytes memory space hosts the &#39;X23&#39; representation of &#39;poolRatio1&#39;</span>
 4926 |     | <span class='neutral'>// where</span>
 4927 |     | <span class='neutral'>//</span>
 4928 |     | <span class='neutral'>//    poolRatio1     accrued1</span>
 4929 |     | <span class='neutral'>//  &#39;------------ * ----------&#39;</span>
 4930 |     | <span class='neutral'>//     2 ** 23       2 ** 127</span>
 4931 |     | <span class='neutral'>//</span>
 4932 |     | <span class='neutral'>// is the accrued amount in &#39;tag1&#39; owed to the pool and</span>
 4933 |     | <span class='neutral'>//</span>
 4934 |     | <span class='neutral'>//    oneX23 - poolRatio1     accrued1</span>
 4935 |     | <span class='neutral'>//  &#39;--------------------- * ----------&#39;</span>
 4936 |     | <span class='neutral'>//          2 ** 23           2 ** 127</span>
 4937 |     | <span class='neutral'>//</span>
 4938 |     | <span class='neutral'>// is the accrued amount in &#39;tag1&#39; owed to the protocol.</span>
 4939 |     | <span class='neutral'>uint16 constant _poolRatio1_ = 1516;</span>
 4940 |     | <span class='neutral'></span>
 4941 |     | <span class='neutral'>// Pointers</span>
 4942 |     | <span class='neutral'>// ----------------------------------------------------------------------------</span>
 4943 |     | <span class='neutral'>// The following memory pointers give access to data with dynamic size.</span>
 4944 |     | <span class='neutral'>uint16 constant _pointers_ = 1519;</span>
 4945 |     | <span class='neutral'></span>
 4946 |     | <span class='neutral'>// The content of this 32 bytes memory space points to the beginning of the</span>
 4947 |     | <span class='neutral'>// kernel.</span>
 4948 |     | <span class='neutral'>// The memory space starting from &#39;getKernel()&#39; to</span>
 4949 |     | <span class='neutral'>// &#39;getKernel() + 64 * (getKernelLength() - 1)&#39; hosts the kernel breakpoints</span>
 4950 |     | <span class='neutral'>// that are loaded from the bytecode of the storage smart contract (64 bytes</span>
 4951 |     | <span class='neutral'>// for each breakpoint of the kernel function except for &#39;(b[0], c[0])&#39; which</span>
 4952 |     | <span class='neutral'>// is omitted).</span>
 4953 |     | <span class='neutral'>uint16 constant _kernel_ = 1519;</span>
 4954 |     | <span class='neutral'></span>
 4955 |     | <span class='neutral'>// The content of this 32 bytes memory space points to the beginning of the</span>
 4956 |     | <span class='neutral'>// curve sequence. The memory space starting from &#39;getCurve()&#39; to</span>
 4957 |     | <span class='neutral'>// &#39;getCurve() + 8 * getCurveLength()&#39; hosts the curve sequence which is loaded</span>
 4958 |     | <span class='neutral'>// from the protocol&#39;s storage (8 bytes for each member of the curve sequence).</span>
 4959 |     | <span class='neutral'>uint16 constant _curve_ = 1551;</span>
 4960 |     | <span class='neutral'></span>
 4961 |     | <span class='neutral'>// The content of this 32 bytes memory space points to the beginning of</span>
 4962 |     | <span class='neutral'>// &#39;hookData&#39;. The memory space starting from &#39;getHookData()&#39; to</span>
 4963 |     | <span class='neutral'>// &#39;getHookData() + getHookDataByteCount()&#39; hosts &#39;hookData&#39; which is loaded</span>
 4964 |     | <span class='neutral'>// from calldata.</span>
 4965 |     | <span class='neutral'>uint16 constant _hookData_ = 1583;</span>
 4966 |     | <span class='neutral'></span>
 4967 |     | <span class='neutral'>// This 2 bytes memory space hosts the number of breakpoints of the kernel</span>
 4968 |     | <span class='neutral'>// function which is calculated from the size of the storage smart contract.</span>
 4969 |     | <span class='neutral'>uint16 constant _kernelLength_ = 1615;</span>
 4970 |     | <span class='neutral'></span>
 4971 |     | <span class='neutral'>// This 2 bytes memory space hosts the number of members of the curve sequence.</span>
 4972 |     | <span class='neutral'>uint16 constant _curveLength_ = 1617;</span>
 4973 |     | <span class='neutral'></span>
 4974 |     | <span class='neutral'>// This 2 bytes memory space hosts the number of bytes that &#39;hookData&#39;</span>
 4975 |     | <span class='neutral'>// occupies.</span>
 4976 |     | <span class='neutral'>uint16 constant _hookDataByteCount_ = 1619;</span>
 4977 |     | <span class='neutral'></span>
 4978 |     | <span class='neutral'>// Dynamic Parameters</span>
 4979 |     | <span class='neutral'>// ----------------------------------------------------------------------------</span>
 4980 |     | <span class='neutral'>// The following memory pointers are dedicated to dynamic parameters of the</span>
 4981 |     | <span class='neutral'>// pool that may change with each swap. Dynamic parameters are stored in</span>
 4982 |     | <span class='neutral'>// protocol&#39;s storage and take a total of three slots. In the event that</span>
 4983 |     | <span class='neutral'>// &#39;staticParamsStoragePointer&#39; overflows and</span>
 4984 |     | <span class='neutral'>// &#39;staticParamsStoragePointerExtension&#39; is needed, a fourth storage slot is</span>
 4985 |     | <span class='neutral'>// populated, rendering interactions with the pool more expensive.</span>
 4986 |     | <span class='neutral'>uint16 constant _dynamicParams_ = 1621;</span>
 4987 |     | <span class='neutral'></span>
 4988 |     | <span class='neutral'>// The content of this 32 bytes memory space is referred to as</span>
 4989 |     | <span class='neutral'>// &#39;staticParamsStoragePointerExtension&#39; which is closely related to</span>
 4990 |     | <span class='neutral'>// &#39;staticParamsStoragePointer&#39;.</span>
 4991 |     | <span class='neutral'>//</span>
 4992 |     | <span class='neutral'>// If &#39;staticParamsStoragePointer &lt; type(uint16).max&#39;, then</span>
 4993 |     | <span class='neutral'>// &#39;staticParamsStoragePointerExtension&#39; is not written on protocol&#39;s storage</span>
 4994 |     | <span class='neutral'>// and we have:</span>
 4995 |     | <span class='neutral'>//</span>
 4996 |     | <span class='neutral'>//  &#39;staticParamsStoragePointerExtension == staticParamsStoragePointer&#39;</span>
 4997 |     | <span class='neutral'>//</span>
 4998 |     | <span class='neutral'>// If &#39;staticParamsStoragePointer == type(uint16).max&#39;, then</span>
 4999 |     | <span class='neutral'>// &#39;staticParamsStoragePointerExtension&#39; populates a dedicated storage slot</span>
 5000 |     | <span class='neutral'>// whose content can be used to derive the address of the storage smart</span>
 5001 |     | <span class='neutral'>// contract that contains the static parameters and the kernel.</span>
 5002 |     | <span class='neutral'>uint16 constant _staticParamsStoragePointerExtension_ = 1621;</span>
 5003 |     | <span class='neutral'></span>
 5004 |     | <span class='neutral'>// The content of this 2 bytes memory space is used to retrieve the address of</span>
 5005 |     | <span class='neutral'>// the smart contract which holds the pool&#39;s static parameters and the kernel</span>
 5006 |     | <span class='neutral'>// in its bytecode. This value is incremented every time that any of the static</span>
 5007 |     | <span class='neutral'>// parameters are updated or when the kernel is modified. In the event of</span>
 5008 |     | <span class='neutral'>// overflow, this value is set to &#39;type(uint16).max&#39; and the 32 bytes space</span>
 5009 |     | <span class='neutral'>// which is pointed to by &#39;_staticParamsStoragePointerExtension_&#39; is used to</span>
 5010 |     | <span class='neutral'>// store the value from which the address to the storage smart contract is</span>
 5011 |     | <span class='neutral'>// derived.</span>
 5012 |     | <span class='neutral'>uint16 constant _staticParamsStoragePointer_ = 1653;</span>
 5013 |     | <span class='neutral'></span>
 5014 |     | <span class='neutral'>// This 8 bytes memory space hosts &#39;logPriceCurrent&#39; which is the offsetted</span>
 5015 |     | <span class='neutral'>// value of the current log price of the pool in &#39;X59&#39; representation. More</span>
 5016 |     | <span class='neutral'>// precisely,</span>
 5017 |     | <span class='neutral'>//</span>
 5018 |     | <span class='neutral'>//  &#39;logPriceCurrent := (2 ** 59) * (16 + qCurrent)&#39;</span>
 5019 |     | <span class='neutral'>//</span>
 5020 |     | <span class='neutral'>// where </span>
 5021 |     | <span class='neutral'>// </span>
 5022 |     | <span class='neutral'>//  &#39;qCurrent := log(pCurrent / pOffset)&#39;,</span>
 5023 |     | <span class='neutral'>//</span>
 5024 |     | <span class='neutral'>// and &#39;pCurrent&#39; represents the current price of the pool.</span>
 5025 |     | <span class='neutral'>//</span>
 5026 |     | <span class='neutral'>// This value is also used to determine the end of the curve sequence while</span>
 5027 |     | <span class='neutral'>// reading the curve sequence from storage. Because the curve sequence does not</span>
 5028 |     | <span class='neutral'>// have a length slot, but its last member is equal to &#39;logPriceCurrent&#39;.</span>
 5029 |     | <span class='neutral'>uint16 constant _logPriceCurrent_ = 1655;</span>
 5030 |     | <span class='neutral'></span>
 5031 |     | <span class='neutral'>// The total number of shares that are deposited in the current active</span>
 5032 |     | <span class='neutral'>// liquidity interval across all LPs.</span>
 5033 |     | <span class='neutral'>//</span>
 5034 |     | <span class='neutral'>// We keep track of the total share values in all of the liquidity intervals</span>
 5035 |     | <span class='neutral'>// via the mapping &#39;sharesDelta&#39; within protocol&#39;s storage. Let &#39;qBoundary&#39;</span>
 5036 |     | <span class='neutral'>// denote an arbitrary boundary for a liquidity interval, i.e.,</span>
 5037 |     | <span class='neutral'>//</span>
 5038 |     | <span class='neutral'>//  &#39;qBoundary == qLower + j * qSpacing&#39;</span>
 5039 |     | <span class='neutral'>//</span>
 5040 |     | <span class='neutral'>// for some integer &#39;j&#39;. Let &#39;sharesTotalLeft&#39; and &#39;sharesTotalRight&#39; denote</span>
 5041 |     | <span class='neutral'>// the total number of shares within the intervals</span>
 5042 |     | <span class='neutral'>//</span>
 5043 |     | <span class='neutral'>//  &#39;[qBoundary - qSpacing, qBoundary]&#39; and</span>
 5044 |     | <span class='neutral'>//  &#39;[qBoundary, qBoundary + qSpacing]&#39;,</span>
 5045 |     | <span class='neutral'>//</span>
 5046 |     | <span class='neutral'>// respectively. Define:</span>
 5047 |     | <span class='neutral'>//</span>
 5048 |     | <span class='neutral'>//  &#39;sharesDelta[qBoundary] := sharesTotalRight - sharesTotalLeft&#39;.</span>
 5049 |     | <span class='neutral'>//</span>
 5050 |     | <span class='neutral'>// In other words, &#39;sharesDelta[qBoundary]&#39; is defined as the difference</span>
 5051 |     | <span class='neutral'>// between the total number of shares within the two liquidity intervals that</span>
 5052 |     | <span class='neutral'>// contain &#39;qBoundary&#39;.</span>
 5053 |     | <span class='neutral'>uint16 constant _sharesTotal_ = 1663;</span>
 5054 |     | <span class='neutral'></span>
 5055 |     | <span class='neutral'>// With each visit to a liquidity interval or as a result of donations, the</span>
 5056 |     | <span class='neutral'>// amount of liquidity which is allocated to a single LP share increases. We</span>
 5057 |     | <span class='neutral'>// use the parameter &#39;growth&#39; to keep track of liquidity per share for the</span>
 5058 |     | <span class='neutral'>// active interval. &#39;growth&#39; is stored in &#39;X111&#39; format and we always have</span>
 5059 |     | <span class='neutral'>// &#39;oneX111 &lt;= growth &lt;= maxGrowth == 1 &lt;&lt; 127&#39;.</span>
 5060 |     | <span class='neutral'>//</span>
 5061 |     | <span class='neutral'>// Let &#39;pLower&#39; and &#39;pUpper&#39;, respectively, denote the minimum and maximum</span>
 5062 |     | <span class='neutral'>// price in the current active liquidity interval and define</span>
 5063 |     | <span class='neutral'>//</span>
 5064 |     | <span class='neutral'>//  &#39;qLower := log(pLower / pOffset)&#39;,</span>
 5065 |     | <span class='neutral'>//  &#39;qUpper := log(pUpper / pOffset)&#39;.</span>
 5066 |     | <span class='neutral'>//</span>
 5067 |     | <span class='neutral'>// Growth values across inactive intervals are kept track of using the mapping</span>
 5068 |     | <span class='neutral'>// &#39;growthMultiplier&#39; as explained below.</span>
 5069 |     | <span class='neutral'>//</span>
 5070 |     | <span class='neutral'>// For every integer &#39;m &gt;= 1&#39;, let </span>
 5071 |     | <span class='neutral'>// </span>
 5072 |     | <span class='neutral'>//    sqrtInverseOffset     growthMultiplier[qLower + m * qSpacing]</span>
 5073 |     | <span class='neutral'>//  &#39;------------------- * -----------------------------------------&#39;</span>
 5074 |     | <span class='neutral'>//        2 ** 127                         2 ** 208</span>
 5075 |     | <span class='neutral'>//</span>
 5076 |     | <span class='neutral'>// represent the total amount of &#39;tag0&#39; corresponding to a single liquidity</span>
 5077 |     | <span class='neutral'>// provider&#39;s share from &#39;qLower + m * qSpacing&#39; to &#39;+oo&#39; and let</span>
 5078 |     | <span class='neutral'>//</span>
 5079 |     | <span class='neutral'>//    sqrtOffset     growthMultiplier[qUpper - m * qSpacing]</span>
 5080 |     | <span class='neutral'>//  &#39;------------ * -----------------------------------------&#39;</span>
 5081 |     | <span class='neutral'>//     2 ** 127                     2 ** 208</span>
 5082 |     | <span class='neutral'>//</span>
 5083 |     | <span class='neutral'>// represent the total amount of &#39;tag1&#39; corresponding to a single liquidity</span>
 5084 |     | <span class='neutral'>// provider&#39;s share from &#39;-oo&#39; to &#39;qLower&#39;.</span>
 5085 |     | <span class='neutral'>//</span>
 5086 |     | <span class='neutral'>// For every integer &#39;m&#39;, let &#39;growth(m)&#39; denote the &#39;growth&#39; value for the</span>
 5087 |     | <span class='neutral'>// interval</span>
 5088 |     | <span class='neutral'>//</span>
 5089 |     | <span class='neutral'>//  &#39;[qLower + m * qSpacing, qUpper + m * qSpacing]&#39;.</span>
 5090 |     | <span class='neutral'>//</span>
 5091 |     | <span class='neutral'>// Hence, &#39;growth(0)&#39; corresponds to &#39;[qLower, qUpper]&#39; which is stored in</span>
 5092 |     | <span class='neutral'>// the following memory space.</span>
 5093 |     | <span class='neutral'>//</span>
 5094 |     | <span class='neutral'>// According to the above definitions, for every integer &#39;m &gt;= 1&#39;, we have</span>
 5095 |     | <span class='neutral'>//</span>
 5096 |     | <span class='neutral'>//    growthMultiplier[qLower + m * qSpacing]</span>
 5097 |     | <span class='neutral'>//  &#39;----------------------------------------- := </span>
 5098 |     | <span class='neutral'>//                    2 ** 208</span>
 5099 |     | <span class='neutral'>//   ---- +oo</span>
 5100 |     | <span class='neutral'>//   \            growth(+j)      (- qLower - j * qSpacing) / 2</span>
 5101 |     | <span class='neutral'>//   /           ------------ * e                               &#39;.</span>
 5102 |     | <span class='neutral'>//   ---- j = m    2 ** 111</span>
 5103 |     | <span class='neutral'>//</span>
 5104 |     | <span class='neutral'>// and</span>
 5105 |     | <span class='neutral'>//</span>
 5106 |     | <span class='neutral'>//    growthMultiplier[qUpper - m * qSpacing]</span>
 5107 |     | <span class='neutral'>//  &#39;----------------------------------------- := </span>
 5108 |     | <span class='neutral'>//                    2 ** 208</span>
 5109 |     | <span class='neutral'>//   ---- +oo</span>
 5110 |     | <span class='neutral'>//   \            growth(-j)      (+ qUpper - j * qSpacing) / 2</span>
 5111 |     | <span class='neutral'>//   /           ------------ * e                               &#39;.</span>
 5112 |     | <span class='neutral'>//   ---- j = m    2 ** 111</span>
 5113 |     | <span class='neutral'>//</span>
 5114 |     | <span class='neutral'>// The following illustration further elaborates the notion of &#39;growth&#39; and</span>
 5115 |     | <span class='neutral'>// &#39;growthMultiplier&#39;:</span>
 5116 |     | <span class='neutral'>//</span>
 5117 |     | <span class='neutral'>//                                         growthMultiplier[qUpper + qSpacing]</span>
 5118 |     | <span class='neutral'>//                                                                    |--&gt;</span>
 5119 |     | <span class='neutral'>//       growthMultiplier[qLower - qSpacing]                          |</span>
 5120 |     | <span class='neutral'>//           &lt;--|                                                     |</span>
 5121 |     | <span class='neutral'>//              |                        growthMultiplier[qUpper]     |</span>
 5122 |     | <span class='neutral'>//              |                                   |--&gt;              |</span>
 5123 |     | <span class='neutral'>//              |      growthMultiplier[qLower]     |                 |</span>
 5124 |     | <span class='neutral'>//              |              &lt;--|                 |                 |</span>
 5125 |     | <span class='neutral'>//              |                 |     growth      |                 |</span>
 5126 |     | <span class='neutral'>//              |                 |       ==        |                 |</span>
 5127 |     | <span class='neutral'>//              |    growth(-1)   |    growth(0)    |    growth(+1)   |</span>
 5128 |     | <span class='neutral'>//       ... &lt;--+-----------------+-----------------+-----------------+--&gt; ...</span>
 5129 |     | <span class='neutral'>//                                |                 |</span>
 5130 |     | <span class='neutral'>//                              qLower           qUpper</span>
 5131 |     | <span class='neutral'>//</span>
 5132 |     | <span class='neutral'>// In the above figure, &#39;growthMultiplier[qUpper]&#39; and</span>
 5133 |     | <span class='neutral'>// &#39;growthMultiplier[qUpper + qSpacing]&#39; point towards &#39;+oo&#39; as well as every</span>
 5134 |     | <span class='neutral'>// growthMultiplier[qLower + m * qSpacing] for positive integers &#39;m&#39;.</span>
 5135 |     | <span class='neutral'>//</span>
 5136 |     | <span class='neutral'>// On the contrary, &#39;growthMultiplier[qLower]&#39; and</span>
 5137 |     | <span class='neutral'>// &#39;growthMultiplier[qLower - qSpacing]&#39; point towards &#39;-oo&#39; as well as every</span>
 5138 |     | <span class='neutral'>// growthMultiplier[qUpper - m * qSpacing] for positive integers &#39;m&#39;.</span>
 5139 |     | <span class='neutral'>uint16 constant _growth_ = 1679;</span>
 5140 |     | <span class='neutral'></span>
 5141 |     | <span class='neutral'>// Let &#39;pCurrent&#39; and &#39;pUpper&#39; represent the current price and the maximum</span>
 5142 |     | <span class='neutral'>// price of the active liquidity interval, respectively, and define:</span>
 5143 |     | <span class='neutral'>//</span>
 5144 |     | <span class='neutral'>// &#39;qCurrent := log(pCurrent / pOffset)&#39;,</span>
 5145 |     | <span class='neutral'>// &#39;qUpper := log(pUpper / pOffset)&#39;.</span>
 5146 |     | <span class='neutral'>//</span>
 5147 |     | <span class='neutral'>// The memory space which is pointed to by &#39;_integral0_&#39; hosts the following</span>
 5148 |     | <span class='neutral'>// integral in &#39;X216&#39; representation which takes up to 27 bytes:</span>
 5149 |     | <span class='neutral'>//</span>
 5150 |     | <span class='neutral'>//                     - 8     / qUpper</span>
 5151 |     | <span class='neutral'>//    integral0      e        |    - h / 2</span>
 5152 |     | <span class='neutral'>//  &#39;----------- := ------- * |  e         k(w(h)) dh&#39;.</span>
 5153 |     | <span class='neutral'>//    2 ** 216         2      |</span>
 5154 |     | <span class='neutral'>//                           / qCurrent</span>
 5155 |     | <span class='neutral'>//</span>
 5156 |     | <span class='neutral'>// The total reserve of &#39;tag0&#39; in the active liquidity interval can be derived</span>
 5157 |     | <span class='neutral'>// from the following formula:</span>
 5158 |     | <span class='neutral'>//</span>
 5159 |     | <span class='neutral'>//  &#39;totalReserveOfTag0 == sqrtInverseOffset * sharesTotal *</span>
 5160 |     | <span class='neutral'>//</span>
 5161 |     | <span class='neutral'>//                           growth       integral0</span>
 5162 |     | <span class='neutral'>//                         ---------- * -------------</span>
 5163 |     | <span class='neutral'>//                          2 ** 111     outgoingMax</span>
 5164 |     | <span class='neutral'>//</span>
 5165 |     | <span class='neutral'>uint16 constant _integral0_ = 1695;</span>
 5166 |     | <span class='neutral'></span>
 5167 |     | <span class='neutral'>// Let &#39;pCurrent&#39; and &#39;pLower&#39; represent the current price and the minimum</span>
 5168 |     | <span class='neutral'>// price of the active liquidity interval, respectively, and define:</span>
 5169 |     | <span class='neutral'>//</span>
 5170 |     | <span class='neutral'>// &#39;qCurrent := log(pCurrent / pOffset)&#39;,</span>
 5171 |     | <span class='neutral'>// &#39;qLower := log(pLower / pOffset)&#39;.</span>
 5172 |     | <span class='neutral'>//</span>
 5173 |     | <span class='neutral'>// The memory space which is pointed to by &#39;_integral1_&#39; hosts the following</span>
 5174 |     | <span class='neutral'>// integral in &#39;X216&#39; representation which takes up to 27 bytes:</span>
 5175 |     | <span class='neutral'>//</span>
 5176 |     | <span class='neutral'>//                     - 8     / qCurrent</span>
 5177 |     | <span class='neutral'>//    integral1      e        |    + h / 2</span>
 5178 |     | <span class='neutral'>//  &#39;----------- := ------- * |  e         k(w(h)) dh&#39;.</span>
 5179 |     | <span class='neutral'>//    2 ** 216         2      |</span>
 5180 |     | <span class='neutral'>//                           / qLower</span>
 5181 |     | <span class='neutral'>//</span>
 5182 |     | <span class='neutral'>// The total reserve of &#39;tag1&#39; in the active liquidity interval can be derived</span>
 5183 |     | <span class='neutral'>// from the following formula:</span>
 5184 |     | <span class='neutral'>//</span>
 5185 |     | <span class='neutral'>//  &#39;totalReserveOfTag1 == sqrtOffset * sharesTotal *</span>
 5186 |     | <span class='neutral'>//</span>
 5187 |     | <span class='neutral'>//                           growth       integral1</span>
 5188 |     | <span class='neutral'>//                         ---------- * -------------</span>
 5189 |     | <span class='neutral'>//                          2 ** 111     outgoingMax</span>
 5190 |     | <span class='neutral'>//</span>
 5191 |     | <span class='neutral'>uint16 constant _integral1_ = 1722;</span>
 5192 |     | <span class='neutral'></span>
 5193 |     | <span class='neutral'>// For every pool, the static parameters and the kernel are encoded in the</span>
 5194 |     | <span class='neutral'>// source code of a storage smart contract which is deployed using a disposable</span>
 5195 |     | <span class='neutral'>// proxy contract. When deploying a new storage smart contract, its creation</span>
 5196 |     | <span class='neutral'>// code is stored in this 11 bytes memory space with static parameters and</span>
 5197 |     | <span class='neutral'>// kernel appearing immediately after. This way, a chunk of memory can be sent</span>
 5198 |     | <span class='neutral'>// to the proxy in order to deploy the storage smart contract.</span>
 5199 |     | <span class='neutral'>uint16 constant _deploymentCreationCode_ = 1749;</span>
 5200 |     | <span class='neutral'></span>
 5201 |     | <span class='neutral'>// Static Parameters</span>
 5202 |     | <span class='neutral'>// ----------------------------------------------------------------------------</span>
 5203 |     | <span class='neutral'>// The following memory pointers are dedicated to the static parameters of the</span>
 5204 |     | <span class='neutral'>// pool that do not change as frequently as dynamic parameters. They are stored</span>
 5205 |     | <span class='neutral'>// along with the kernel. Hence, everytime the kernel or any of the growth</span>
 5206 |     | <span class='neutral'>// portions are updated, the entire storage smart contract is redeployed.</span>
 5207 |     | <span class='neutral'>uint16 constant _staticParams_ = 1760;</span>
 5208 |     | <span class='neutral'></span>
 5209 |     | <span class='neutral'>// The arithmetically smaller tag to be traded by the pool. This value is</span>
 5210 |     | <span class='neutral'>// immutable. A tag may refer to native, ERC-20, ERC-6909, or ERC-1155 tokens</span>
 5211 |     | <span class='neutral'>// as described in &#39;Tag.sol&#39;.</span>
 5212 |     | <span class='neutral'>uint16 constant _tag0_ = 1760;</span>
 5213 |     | <span class='neutral'></span>
 5214 |     | <span class='neutral'>// The arithmetically larger tag to be traded by the pool. This value is</span>
 5215 |     | <span class='neutral'>// immutable.</span>
 5216 |     | <span class='neutral'>uint16 constant _tag1_ = 1792;</span>
 5217 |     | <span class='neutral'></span>
 5218 |     | <span class='neutral'>// This memory space hosts the value:</span>
 5219 |     | <span class='neutral'>//</span>
 5220 |     | <span class='neutral'>// &#39;sqrtOffset := (2 ** 127) * sqrt(pOffset)&#39;</span>
 5221 |     | <span class='neutral'>//</span>
 5222 |     | <span class='neutral'>// where the natural logarithm of &#39;pOffset&#39; is an &#39;int8&#39; which is encoded from</span>
 5223 |     | <span class='neutral'>// bit 181 to bit 188 of poolId.</span>
 5224 |     | <span class='neutral'>uint16 constant _sqrtOffset_ = 1824;</span>
 5225 |     | <span class='neutral'></span>
 5226 |     | <span class='neutral'>// This memory space hosts the value:</span>
 5227 |     | <span class='neutral'>//</span>
 5228 |     | <span class='neutral'>// &#39;sqrtInverseOffset := (2 ** 127) / sqrt(pOffset)&#39;</span>
 5229 |     | <span class='neutral'>//</span>
 5230 |     | <span class='neutral'>// where the natural logarithm of &#39;pOffset&#39; is an &#39;int8&#39; which is encoded from</span>
 5231 |     | <span class='neutral'>// bit 181 to bit 188 of poolId.</span>
 5232 |     | <span class='neutral'>uint16 constant _sqrtInverseOffset_ = 1856;</span>
 5233 |     | <span class='neutral'></span>
 5234 |     | <span class='neutral'>// Let &#39;pLower&#39; and &#39;pUpper&#39; denote the minimum and maximum price in the active</span>
 5235 |     | <span class='neutral'>// liquidity interval, respectively, and define</span>
 5236 |     | <span class='neutral'>//</span>
 5237 |     | <span class='neutral'>//  &#39;qSpacing := log(pUpper / pLower)&#39;,</span>
 5238 |     | <span class='neutral'>//</span>
 5239 |     | <span class='neutral'>// The 62 bytes memory space which is pointed to by &#39;_spacing_&#39; hosts the</span>
 5240 |     | <span class='neutral'>// following values:</span>
 5241 |     | <span class='neutral'>//</span>
 5242 |     | <span class='neutral'>//  &#39;_spacing_.log() := (2 ** 59) * (16 + qSpacing)&#39;,</span>
 5243 |     | <span class='neutral'>//  &#39;_spacing_.sqrt(false) := (2 ** 216) * exp(- qSpacing / 2)&#39;,</span>
 5244 |     | <span class='neutral'>//  &#39;_spacing_.sqrt(true) := (2 ** 216) * exp(- 16 + qSpacing / 2)&#39;.</span>
 5245 |     | <span class='neutral'>//</span>
 5246 |     | <span class='neutral'>// which can be accessed via &#39;PriceLibrary&#39;. The logarithmic price</span>
 5247 |     | <span class='neutral'>// &#39;_spacing_.log()&#39; occupies 64 bits, whereas &#39;_spacing_.sqrt(false)&#39; and</span>
 5248 |     | <span class='neutral'>// &#39;_spacing_.sqrt(true)&#39; occupy 216 bits each.</span>
 5249 |     | <span class='neutral'>uint16 constant _spacing_ = 1888;</span>
 5250 |     | <span class='neutral'></span>
 5251 |     | <span class='neutral'>// Let &#39;pLower&#39; and &#39;pUpper&#39; denote the minimum and maximum price in the active</span>
 5252 |     | <span class='neutral'>// liquidity interval, respectively, and define</span>
 5253 |     | <span class='neutral'>//</span>
 5254 |     | <span class='neutral'>//  &#39;qUpper := log(pUpper / pOffset)&#39;,</span>
 5255 |     | <span class='neutral'>//  &#39;qLower := log(pLower / pOffset)&#39;,</span>
 5256 |     | <span class='neutral'>//  &#39;qSpacing := log(pUpper / pLower)&#39;.</span>
 5257 |     | <span class='neutral'>//</span>
 5258 |     | <span class='neutral'>// This 27 bytes memory space hosts &#39;outgoingMax&#39; which is a kernel parameter.</span>
 5259 |     | <span class='neutral'>// The &#39;X216&#39; representation of &#39;outgoingMax&#39; is defined as follows:</span>
 5260 |     | <span class='neutral'>//</span>
 5261 |     | <span class='neutral'>//                       - 8     / qSpacing</span>
 5262 |     | <span class='neutral'>//    outgoingMax      e        |    - h / 2</span>
 5263 |     | <span class='neutral'>//  &#39;------------- := ------- * |  e         k(h) dh&#39;.</span>
 5264 |     | <span class='neutral'>//     2 ** 216          2      |</span>
 5265 |     | <span class='neutral'>//                             / 0</span>
 5266 |     | <span class='neutral'>//</span>
 5267 |     | <span class='neutral'>// &#39;outgoingMax&#39; is used frequently for calculating any amount of &#39;tag0&#39; and</span>
 5268 |     | <span class='neutral'>// &#39;tag1&#39;. Because of this, we calculate &#39;outgoingMax&#39; and its modular inverse</span>
 5269 |     | <span class='neutral'>// at the time of initialization or anytime that the kernel is modified and</span>
 5270 |     | <span class='neutral'>// then we store the resulting values among the static parameters.</span>
 5271 |     | <span class='neutral'>//</span>
 5272 |     | <span class='neutral'>// &#39;outgoingMax&#39; can be calculated with the following two equivalent formulas</span>
 5273 |     | <span class='neutral'>// as well:</span>
 5274 |     | <span class='neutral'>//</span>
 5275 |     | <span class='neutral'>//                       - 8 + qLower / 2     / qUpper</span>
 5276 |     | <span class='neutral'>//    outgoingMax      e                     |    - h / 2</span>
 5277 |     | <span class='neutral'>//  &#39;------------- := -------------------- * |  e         k(h - qLower) dh</span>
 5278 |     | <span class='neutral'>//     2 ** 216                 2            |</span>
 5279 |     | <span class='neutral'>//                                          / qLower</span>
 5280 |     | <span class='neutral'>//</span>
 5281 |     | <span class='neutral'>//                       - 8 - qUpper / 2     / qUpper</span>
 5282 |     | <span class='neutral'>//                     e                     |    + h / 2</span>
 5283 |     | <span class='neutral'>//                    -------------------- * |  e         k(qUpper - h) dh&#39;.</span>
 5284 |     | <span class='neutral'>//                              2            |</span>
 5285 |     | <span class='neutral'>//                                          / qLower</span>
 5286 |     | <span class='neutral'>//</span>
 5287 |     | <span class='neutral'>// Notice that the above formulas are independent of the choice for &#39;qLower&#39;</span>
 5288 |     | <span class='neutral'>// and &#39;qUpper&#39;, and they result in the same value as long as </span>
 5289 |     | <span class='neutral'>// &#39;qUpper - qLower == qSpacing&#39;.</span>
 5290 |     | <span class='neutral'>uint16 constant _outgoingMax_ = 1950;</span>
 5291 |     | <span class='neutral'></span>
 5292 |     | <span class='neutral'>// This 32 bytes memory space hosts &#39;outgoingMaxModularInverse&#39; which is the</span>
 5293 |     | <span class='neutral'>// modular inverse of</span>
 5294 |     | <span class='neutral'>//</span>
 5295 |     | <span class='neutral'>//    outgoingMax </span>
 5296 |     | <span class='neutral'>//  &#39;-------------&#39;</span>
 5297 |     | <span class='neutral'>//      2 ** n</span>
 5298 |     | <span class='neutral'>//</span>
 5299 |     | <span class='neutral'>// modulo &#39;2 ** 256&#39;, where &#39;n&#39; is the largest power of &#39;2&#39; that divides</span>
 5300 |     | <span class='neutral'>// &#39;outgoingMax&#39;. This value is calculated at the time of initialization or</span>
 5301 |     | <span class='neutral'>// anytime that the kernel function is modified.</span>
 5302 |     | <span class='neutral'>//</span>
 5303 |     | <span class='neutral'>// Precalculation of &#39;outgoingMaxModularInverse&#39; facilitates division by</span>
 5304 |     | <span class='neutral'>// &#39;outgoingMax&#39; which is done frequently.</span>
 5305 |     | <span class='neutral'>uint16 constant _outgoingMaxModularInverse_ = 1977;</span>
 5306 |     | <span class='neutral'></span>
 5307 |     | <span class='neutral'>// Let &#39;pLower&#39; and &#39;pUpper&#39; denote the minimum and maximum price in the active</span>
 5308 |     | <span class='neutral'>// liquidity interval, respectively, and define</span>
 5309 |     | <span class='neutral'>//</span>
 5310 |     | <span class='neutral'>//  &#39;qUpper := log(pUpper / pOffset)&#39;,</span>
 5311 |     | <span class='neutral'>//  &#39;qLower := log(pLower / pOffset)&#39;,</span>
 5312 |     | <span class='neutral'>//  &#39;qSpacing := log(pUpper / pLower)&#39;.</span>
 5313 |     | <span class='neutral'>//</span>
 5314 |     | <span class='neutral'>// This 27 bytes memory space hosts &#39;outgoingMax&#39; which is a kernel parameter.</span>
 5315 |     | <span class='neutral'>// The &#39;X216&#39; representation of &#39;outgoingMax&#39; is defined as follows:</span>
 5316 |     | <span class='neutral'>//</span>
 5317 |     | <span class='neutral'>//                       - 8 - qSpacing / 2     / qSpacing</span>
 5318 |     | <span class='neutral'>//    incomingMax      e                       |    + h / 2</span>
 5319 |     | <span class='neutral'>//  &#39;------------- := ---------------------- * |  e         k(h) dh&#39;.</span>
 5320 |     | <span class='neutral'>//     2 ** 216                 2              |</span>
 5321 |     | <span class='neutral'>//                                            / 0</span>
 5322 |     | <span class='neutral'>//</span>
 5323 |     | <span class='neutral'>// &#39;incomingMax&#39; is used for calculating the incoming amount as we cross an</span>
 5324 |     | <span class='neutral'>// entire liquidity interval from &#39;qBack&#39; to &#39;qNext&#39;. Because of this, we</span>
 5325 |     | <span class='neutral'>// calculate &#39;incomingMax&#39; at the time of initialization or anytime that the</span>
 5326 |     | <span class='neutral'>// kernel is modified and then we store the resulting value among the static</span>
 5327 |     | <span class='neutral'>// parameters.</span>
 5328 |     | <span class='neutral'>//</span>
 5329 |     | <span class='neutral'>// &#39;incomingMax&#39; can be calculated with the following two equivalent formulas</span>
 5330 |     | <span class='neutral'>// as well:</span>
 5331 |     | <span class='neutral'>//</span>
 5332 |     | <span class='neutral'>//                       - 8 - qUpper / 2     / qUpper</span>
 5333 |     | <span class='neutral'>//    incomingMax      e                     |    + h / 2</span>
 5334 |     | <span class='neutral'>//  &#39;------------- := -------------------- * |  e         k(h - qLower) dh</span>
 5335 |     | <span class='neutral'>//     2 ** 216                 2            |</span>
 5336 |     | <span class='neutral'>//                                          / qLower</span>
 5337 |     | <span class='neutral'>//</span>
 5338 |     | <span class='neutral'>//                       - 8 + qLower / 2     / qUpper</span>
 5339 |     | <span class='neutral'>//                     e                     |    - h / 2</span>
 5340 |     | <span class='neutral'>//                    -------------------- * |  e         k(qUpper - h) dh&#39;.</span>
 5341 |     | <span class='neutral'>//                              2            |</span>
 5342 |     | <span class='neutral'>//                                          / qLower</span>
 5343 |     | <span class='neutral'>//</span>
 5344 |     | <span class='neutral'>// Notice that the above formulas are independent of the choice for &#39;qLower&#39;</span>
 5345 |     | <span class='neutral'>// and &#39;qUpper&#39;, and they result in the same value as long as </span>
 5346 |     | <span class='neutral'>// &#39;qUpper - qLower == qSpacing&#39;.</span>
 5347 |     | <span class='neutral'>uint16 constant _incomingMax_ = 2009;</span>
 5348 |     | <span class='neutral'></span>
 5349 |     | <span class='neutral'>// The content of the 6 bytes memory space which is pointed to by</span>
 5350 |     | <span class='neutral'>// &#39;_poolGrowthPortion_&#39; dictates the portion of the growth that goes to the</span>
 5351 |     | <span class='neutral'>// pool owner followed by the protocol.</span>
 5352 |     | <span class='neutral'>//</span>
 5353 |     | <span class='neutral'>// The content of the 6 bytes memory space which is pointed to by</span>
 5354 |     | <span class='neutral'>// &#39;_maxPoolGrowthPortion_&#39; imposes a cap on the portion of the marginal growth</span>
 5355 |     | <span class='neutral'>// that goes to the pool owner followed by the protocol.</span>
 5356 |     | <span class='neutral'>//</span>
 5357 |     | <span class='neutral'>// The content of the 6 bytes memory space which is pointed to by</span>
 5358 |     | <span class='neutral'>// &#39;_protocolGrowthPortion_&#39; dictates the portion of the growth that goes to</span>
 5359 |     | <span class='neutral'>// the protocol.</span>
 5360 |     | <span class='neutral'>//</span>
 5361 |     | <span class='neutral'>// &#39;maxPoolGrowthPortion&#39; and &#39;protocolGrowthPortion&#39; are set by the protocol</span>
 5362 |     | <span class='neutral'>// slot or the sentinel contract. Any address can invoke a function to sync</span>
 5363 |     | <span class='neutral'>// these two values with the global portions.</span>
 5364 |     | <span class='neutral'>//</span>
 5365 |     | <span class='neutral'>// This value is set by the protocol slot or the sentinel contract.</span>
 5366 |     | <span class='neutral'>// Any address can invoke a function to sync this value with the global</span>
 5367 |     | <span class='neutral'>// portion.</span>
 5368 |     | <span class='neutral'>//</span>
 5369 |     | <span class='neutral'>// Let &#39;[qLower, qUpper]&#39; represent the active liquidity interval. As part of a</span>
 5370 |     | <span class='neutral'>// swap, assume that the price is moved from &#39;qCurrent&#39; to &#39;qTarget&#39; within</span>
 5371 |     | <span class='neutral'>// &#39;[qLower, qUpper]&#39;. Define:</span>
 5372 |     | <span class='neutral'>//</span>
 5373 |     | <span class='neutral'>//                                - 8     / qUpper</span>
 5374 |     | <span class='neutral'>//    integral0Incremented      e        |    - h / 2</span>
 5375 |     | <span class='neutral'>//  &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;,</span>
 5376 |     | <span class='neutral'>//          2 ** 216              2      |</span>
 5377 |     | <span class='neutral'>//                                      / qTarget</span>
 5378 |     | <span class='neutral'>//</span>
 5379 |     | <span class='neutral'>//                                - 8     / qTarget</span>
 5380 |     | <span class='neutral'>//    integral1Incremented      e        |    + h / 2</span>
 5381 |     | <span class='neutral'>//  &#39;---------------------- := ------- * |  e         k(w(h)) dh&#39;.</span>
 5382 |     | <span class='neutral'>//          2 ** 216              2      |</span>
 5383 |     | <span class='neutral'>//                                      / qLower</span>
 5384 |     | <span class='neutral'>//</span>
 5385 |     | <span class='neutral'>// Now, assume that the curve sequence is updated and the function &#39;w&#39; is</span>
 5386 |     | <span class='neutral'>// transformed into a new function &#39;wAmended&#39; which is constructed based on the</span>
 5387 |     | <span class='neutral'>// updated curve sequence. Define:</span>
 5388 |     | <span class='neutral'>//</span>
 5389 |     | <span class='neutral'>//                            - 8     / qUpper</span>
 5390 |     | <span class='neutral'>//    integral0Amended      e        |    - h / 2</span>
 5391 |     | <span class='neutral'>//  &#39;------------------ := ------- * |  e         k(wAmended(h)) dh&#39;,</span>
 5392 |     | <span class='neutral'>//        2 ** 216            2      |</span>
 5393 |     | <span class='neutral'>//                                  / qTarget</span>
 5394 |     | <span class='neutral'>//</span>
 5395 |     | <span class='neutral'>//                            - 8     / qTarget</span>
 5396 |     | <span class='neutral'>//    integral1Amended      e        |    + h / 2</span>
 5397 |     | <span class='neutral'>//  &#39;------------------ := ------- * |  e         k(wAmended(h)) dh&#39;.</span>
 5398 |     | <span class='neutral'>//        2 ** 216            2      |</span>
 5399 |     | <span class='neutral'>//                                  / qLower</span>
 5400 |     | <span class='neutral'>//</span>
 5401 |     | <span class='neutral'>// Then we have:</span>
 5402 |     | <span class='neutral'>//                              integral0Incremented</span>
 5403 |     | <span class='neutral'>//  &#39;growthAmended := growth * ----------------------</span>
 5404 |     | <span class='neutral'>//                                integral0Amended</span>
 5405 |     | <span class='neutral'>//</span>
 5406 |     | <span class='neutral'>//                              integral1Incremented</span>
 5407 |     | <span class='neutral'>//                 == growth * ----------------------&#39;.</span>
 5408 |     | <span class='neutral'>//                                integral1Amended</span>
 5409 |     | <span class='neutral'>//</span>
 5410 |     | <span class='neutral'>// Now, the marginal growth with respect to &#39;tag0&#39; and &#39;tag1&#39; can be defined</span>
 5411 |     | <span class='neutral'>// as:</span>
 5412 |     | <span class='neutral'>//</span>
 5413 |     | <span class='neutral'>//  &#39;marginalGrowthOfTag0 := sqrtInverseOffset * sharesTotal * </span>
 5414 |     | <span class='neutral'>//</span>
 5415 |     | <span class='neutral'>//                            growthAmended - growth     integral0Amended</span>
 5416 |     | <span class='neutral'>//                           ------------------------ * ------------------&#39;,</span>
 5417 |     | <span class='neutral'>//                                    2 ** 111             outgoingMax</span>
 5418 |     | <span class='neutral'>//</span>
 5419 |     | <span class='neutral'>//  &#39;marginalGrowthOfTag1 := sqrtOffset * sharesTotal * </span>
 5420 |     | <span class='neutral'>//</span>
 5421 |     | <span class='neutral'>//                            growthAmended - growth     integral1Amended</span>
 5422 |     | <span class='neutral'>//                           ------------------------ * ------------------&#39;.</span>
 5423 |     | <span class='neutral'>//                                    2 ** 111             outgoingMax</span>
 5424 |     | <span class='neutral'>//</span>
 5425 |     | <span class='neutral'>// Hence, as a result of this swap, the amount of &#39;tag0&#39; that goes to the</span>
 5426 |     | <span class='neutral'>// protocol is equal to:</span>
 5427 |     | <span class='neutral'>//</span>
 5428 |     | <span class='neutral'>//    protocolGrowthPortion</span>
 5429 |     | <span class='neutral'>//  &#39;----------------------- * marginalGrowthOfTag0&#39;</span>
 5430 |     | <span class='neutral'>//           2 ** 47</span>
 5431 |     | <span class='neutral'>//</span>
 5432 |     | <span class='neutral'>// and the amount of &#39;tag1&#39; that goes to the protocol is equal to:</span>
 5433 |     | <span class='neutral'>//</span>
 5434 |     | <span class='neutral'>//    protocolGrowthPortion</span>
 5435 |     | <span class='neutral'>//  &#39;----------------------- * marginalGrowthOfTag1&#39;</span>
 5436 |     | <span class='neutral'>//           2 ** 47</span>
 5437 |     | <span class='neutral'>//</span>
 5438 |     | <span class='neutral'>// Additionally, the amount of &#39;tag0&#39; that goes to the pool owner is equal to:</span>
 5439 |     | <span class='neutral'>//</span>
 5440 |     | <span class='neutral'>//    min(poolGrowthPortion, maxPoolGrowthPortion)</span>
 5441 |     | <span class='neutral'>//  &#39;---------------------------------------------- * </span>
 5442 |     | <span class='neutral'>//                      2 ** 47</span>
 5443 |     | <span class='neutral'>//</span>
 5444 |     | <span class='neutral'>//    oneX47 - protocolGrowthPortion</span>
 5445 |     | <span class='neutral'>//   -------------------------------- * marginalGrowthOfTag0&#39;</span>
 5446 |     | <span class='neutral'>//               2 ** 47</span>
 5447 |     | <span class='neutral'>//</span>
 5448 |     | <span class='neutral'>// and the amount of &#39;tag1&#39; that goes to the pool owner is equal to:</span>
 5449 |     | <span class='neutral'>//</span>
 5450 |     | <span class='neutral'>//    min(poolGrowthPortion, maxPoolGrowthPortion)</span>
 5451 |     | <span class='neutral'>//  &#39;---------------------------------------------- * </span>
 5452 |     | <span class='neutral'>//                      2 ** 47</span>
 5453 |     | <span class='neutral'>//</span>
 5454 |     | <span class='neutral'>//    oneX47 - protocolGrowthPortion</span>
 5455 |     | <span class='neutral'>//   -------------------------------- * marginalGrowthOfTag1&#39;</span>
 5456 |     | <span class='neutral'>//               2 ** 47</span>
 5457 |     | <span class='neutral'>//</span>
 5458 |     | <span class='neutral'>uint16 constant _poolGrowthPortion_ = 2036;</span>
 5459 |     | <span class='neutral'>uint16 constant _maxPoolGrowthPortion_ = 2042;</span>
 5460 |     | <span class='neutral'>uint16 constant _protocolGrowthPortion_ = 2048;</span>
 5461 |     | <span class='neutral'></span>
 5462 |     | <span class='neutral'>// The number of members for the pending kernel. Once a new kernel is</span>
 5463 |     | <span class='neutral'>// introduced, it remains pending until transition to a new liquidity interval.</span>
 5464 |     | <span class='neutral'>// This value is an indicator for whether there exists a pending kernel.</span>
 5465 |     | <span class='neutral'>// This value is used to ensure that a sufficient amount of space is reserved</span>
 5466 |     | <span class='neutral'>// in memory for kernel, in case the pending kernel needs to be activated in</span>
 5467 |     | <span class='neutral'>// the middle of a swap, i.e., read from the new storage smart contract.</span>
 5468 |     | <span class='neutral'>uint16 constant _pendingKernelLength_ = 2054;</span>
 5469 |     | <span class='neutral'></span>
 5470 |     | <span class='unexecuted'>uint16 constant _endOfStaticParams_ = 2056;</span>
 5471 |     | <span class='neutral'></span>
 5472 |     | <span class='neutral'>// Modify Position Parameters</span>
 5473 |     | <span class='neutral'>// ----------------------------------------------------------------------------</span>
 5474 |     | <span class='neutral'>// The following memory pointers host the inputs and the resulting outputs of</span>
 5475 |     | <span class='neutral'>// the method &#39;modifyPosition&#39;. An LP may choose any consecutive range of</span>
 5476 |     | <span class='neutral'>// liquidity intervals to deposit their liquidity. By doing so, the LP acquires</span>
 5477 |     | <span class='neutral'>// a number of shares in every liquidity interval that belongs to the given</span>
 5478 |     | <span class='neutral'>// range. The shares can be used later to withdraw liquidity along with any</span>
 5479 |     | <span class='neutral'>// accumulated growth which is accrued as a result of swap and donate actions.</span>
 5480 |     | <span class='neutral'>uint16 constant _modifyPositionInput_ = 248;</span>
 5481 |     | <span class='neutral'></span>
 5482 |     | <span class='neutral'>// Every LP position is characterized by two prices &#39;pMin&#39; and &#39;pMax&#39;. These</span>
 5483 |     | <span class='neutral'>// two prices, respectively, correspond to the left and the right boundaries of</span>
 5484 |     | <span class='neutral'>// the consecutive range in which the LP intends to deposit or withdraw</span>
 5485 |     | <span class='neutral'>// liquidity. The following two 8 bytes memory spaces, respectively, host:</span>
 5486 |     | <span class='neutral'>//</span>
 5487 |     | <span class='neutral'>//  &#39;(2 ** 59) * (16 + log(pMin / pOffset))&#39;,</span>
 5488 |     | <span class='neutral'>//  &#39;(2 ** 59) * (16 + log(pMax / pOffset))&#39;.</span>
 5489 |     | <span class='neutral'>uint16 constant _logPriceMinOffsetted_ = 248;</span>
 5490 |     | <span class='neutral'>uint16 constant _logPriceMaxOffsetted_ = 256;</span>
 5491 |     | <span class='neutral'></span>
 5492 |     | <span class='neutral'>// This 32 bytes memory space hosts the number of shares to be added (positive)</span>
 5493 |     | <span class='neutral'>// or removed (negative).</span>
 5494 |     | <span class='neutral'>uint16 constant _shares_ = 264;</span>
 5495 |     | <span class='neutral'></span>
 5496 |     | <span class='neutral'>// The following two 32 bytes memory spaces, respectively, host:</span>
 5497 |     | <span class='neutral'>//</span>
 5498 |     | <span class='neutral'>//  &#39;logPriceMin := (2 ** 59) * log(pMin)&#39;,</span>
 5499 |     | <span class='neutral'>//  &#39;logPriceMax := (2 ** 59) * log(pMax)&#39;.</span>
 5500 |     | <span class='neutral'>//</span>
 5501 |     | <span class='neutral'>// Both &#39;logPriceMin&#39; and &#39;logPriceMax&#39; must be equal to the active interval</span>
 5502 |     | <span class='neutral'>// boundaries modulo &#39;qSpacing&#39;.</span>
 5503 |     | <span class='neutral'>uint16 constant _logPriceMin_ = 296;</span>
 5504 |     | <span class='neutral'>uint16 constant _logPriceMax_ = 328;</span>
 5505 |     | <span class='neutral'></span>
 5506 |     | <span class='neutral'>// The amount of &#39;tag0&#39; to be added (positive) or removed (negative) in &#39;X127&#39;</span>
 5507 |     | <span class='neutral'>// representation, as a result of modifyPosition.</span>
 5508 |     | <span class='neutral'>uint16 constant _positionAmount0_ = 360;</span>
 5509 |     | <span class='neutral'>// The amount of &#39;tag1&#39; to be added (positive) or removed (negative) in &#39;X127&#39;</span>
 5510 |     | <span class='neutral'>// representation, as a result of modifyPosition.</span>
 5511 |     | <span class='neutral'>uint16 constant _positionAmount1_ = 392;</span>
 5512 |     | <span class='neutral'></span>
 5513 |     | <span class='neutral'>uint16 constant _endOfModifyPosition_ = 424;</span>
 5514 |     | <span class='neutral'></span>
 5515 |     | <span class='neutral'>////////////////////////////////////////////////////////////////////////////////</span>
 5516 |     | <span class='neutral'>// The remainder of this script contains automatically generated getter and</span>
 5517 |     | <span class='neutral'>// setter functions for the parameters introduced above.</span>
 5518 |     | <span class='neutral'></span>
 5519 |     | <span class='unexecuted'>function getFreeMemoryPointer() pure returns (</span>
 5520 |     | <span class='unexecuted'>  uint256 freeMemoryPointer</span>
 5521 |     | <span class='neutral'>) {</span>
 5522 |     | <span class='unexecuted'>  assembly {</span>
 5523 |     | <span class='neutral'>    freeMemoryPointer := mload(_freeMemoryPointer_)</span>
 5524 |     | <span class='neutral'>  }</span>
 5525 |     | <span class='neutral'>}</span>
 5526 |     | <span class='neutral'></span>
 5527 |     | <span class='unexecuted'>function setFreeMemoryPointer(</span>
 5528 |     | <span class='neutral'>  uint256 freeMemoryPointer</span>
 5529 |     | <span class='neutral'>) pure {</span>
 5530 |     | <span class='unexecuted'>  assembly {</span>
 5531 |     | <span class='neutral'>    mstore(_freeMemoryPointer_, freeMemoryPointer)</span>
 5532 |     | <span class='neutral'>  }</span>
 5533 |     | <span class='neutral'>}</span>
 5534 |     | <span class='neutral'></span>
 5535 |     | <span class='neutral'>function setHookSelector(</span>
 5536 |     | <span class='neutral'>  uint32 hookSelector</span>
 5537 |     | <span class='neutral'>) pure {</span>
 5538 |     | <span class='neutral'>  assembly {</span>
 5539 |     | <span class='neutral'>    mstore(</span>
 5540 |     | <span class='neutral'>      _hookSelector_,</span>
 5541 |     | <span class='neutral'>      or(</span>
 5542 |     | <span class='neutral'>        shl(224, hookSelector),</span>
 5543 |     | <span class='neutral'>        shr(32, mload(add(_hookSelector_, 4)))</span>
 5544 |     | <span class='neutral'>      )</span>
 5545 |     | <span class='neutral'>    )</span>
 5546 |     | <span class='neutral'>  }</span>
 5547 |     | <span class='neutral'>}</span>
 5548 |     | <span class='neutral'></span>
 5549 |     | <span class='neutral'>function setHookInputHeader(</span>
 5550 |     | <span class='neutral'>  uint256 hookInputHeader</span>
 5551 |     | <span class='neutral'>) pure {</span>
 5552 |     | <span class='neutral'>  assembly {</span>
 5553 |     | <span class='neutral'>    mstore(_hookInputHeader_, hookInputHeader)</span>
 5554 |     | <span class='neutral'>  }</span>
 5555 |     | <span class='neutral'>}</span>
 5556 |     | <span class='neutral'></span>
 5557 |     | <span class='unexecuted'>function getHookInputByteCount() pure returns (</span>
 5558 |     | <span class='unexecuted'>  uint256 hookInputByteCount</span>
 5559 |     | <span class='neutral'>) {</span>
 5560 |     | <span class='unexecuted'>  assembly {</span>
 5561 |     | <span class='neutral'>    hookInputByteCount := mload(_hookInputByteCount_)</span>
 5562 |     | <span class='neutral'>  }</span>
 5563 |     | <span class='neutral'>}</span>
 5564 |     | <span class='neutral'></span>
 5565 |     | <span class='unexecuted'>function setHookInputByteCount(</span>
 5566 |     | <span class='neutral'>  uint256 hookInputByteCount</span>
 5567 |     | <span class='neutral'>) pure {</span>
 5568 |     | <span class='unexecuted'>  assembly {</span>
 5569 |     | <span class='neutral'>    mstore(_hookInputByteCount_, hookInputByteCount)</span>
 5570 |     | <span class='neutral'>  }</span>
 5571 |     | <span class='neutral'>}</span>
 5572 |     | <span class='neutral'></span>
 5573 |     | <span class='unexecuted'>function setMsgSender(</span>
 5574 |     | <span class='neutral'>  address msgSender</span>
 5575 |     | <span class='neutral'>) pure {</span>
 5576 |     | <span class='unexecuted'>  assembly {</span>
 5577 |     | <span class='neutral'>    mstore(</span>
 5578 |     | <span class='neutral'>      _msgSender_,</span>
 5579 |     | <span class='neutral'>      or(</span>
 5580 |     | <span class='neutral'>        shl(96, msgSender),</span>
 5581 |     | <span class='neutral'>        shr(160, mload(add(_msgSender_, 20)))</span>
 5582 |     | <span class='neutral'>      )</span>
 5583 |     | <span class='neutral'>    )</span>
 5584 |     | <span class='neutral'>  }</span>
 5585 |     | <span class='neutral'>}</span>
 5586 |     | <span class='neutral'></span>
 5587 |     | <span class='neutral'>function getPoolId() pure returns (</span>
 5588 |     | <span class='neutral'>  uint256 poolId</span>
 5589 |     | <span class='neutral'>) {</span>
 5590 |     | <span class='neutral'>  assembly {</span>
 5591 |     | <span class='neutral'>    poolId := mload(_poolId_)</span>
 5592 |     | <span class='neutral'>  }</span>
 5593 |     | <span class='neutral'>}</span>
 5594 |     | <span class='neutral'></span>
 5595 |     | <span class='unexecuted'>function setPoolId(</span>
 5596 |     | <span class='neutral'>  uint256 poolId</span>
 5597 |     | <span class='neutral'>) pure {</span>
 5598 |     | <span class='unexecuted'>  assembly {</span>
 5599 |     | <span class='neutral'>    mstore(_poolId_, poolId)</span>
 5600 |     | <span class='neutral'>  }</span>
 5601 |     | <span class='neutral'>}</span>
 5602 |     | <span class='neutral'></span>
 5603 |     | <span class='neutral'>function getCrossThreshold() pure returns (</span>
 5604 |     | <span class='neutral'>  uint256 crossThreshold</span>
 5605 |     | <span class='neutral'>) {</span>
 5606 |     | <span class='neutral'>  assembly {</span>
 5607 |     | <span class='neutral'>    crossThreshold := shr(128, mload(_crossThreshold_))</span>
 5608 |     | <span class='neutral'>  }</span>
 5609 |     | <span class='neutral'>}</span>
 5610 |     | <span class='neutral'></span>
 5611 |     | <span class='unexecuted'>function setCrossThreshold(</span>
 5612 |     | <span class='neutral'>  uint256 crossThreshold</span>
 5613 |     | <span class='neutral'>) pure {</span>
 5614 |     | <span class='unexecuted'>  assembly {</span>
 5615 |     | <span class='neutral'>    mstore(</span>
 5616 |     | <span class='neutral'>      _crossThreshold_,</span>
 5617 |     | <span class='neutral'>      or(</span>
 5618 |     | <span class='neutral'>        shl(128, crossThreshold),</span>
 5619 |     | <span class='neutral'>        shr(128, mload(add(_crossThreshold_, 16)))</span>
 5620 |     | <span class='neutral'>      )</span>
 5621 |     | <span class='neutral'>    )</span>
 5622 |     | <span class='neutral'>  }</span>
 5623 |     | <span class='neutral'>}</span>
 5624 |     | <span class='neutral'></span>
 5625 |     | <span class='neutral'>function getAmountSpecified() pure returns (</span>
 5626 |     | <span class='neutral'>  X127 amountSpecified</span>
 5627 |     | <span class='neutral'>) {</span>
 5628 |     | <span class='neutral'>  assembly {</span>
 5629 |     | <span class='neutral'>    amountSpecified := mload(_amountSpecified_)</span>
 5630 |     | <span class='neutral'>  }</span>
 5631 |     | <span class='neutral'>}</span>
 5632 |     | <span class='neutral'></span>
 5633 |     | <span class='unexecuted'>function setAmountSpecified(</span>
 5634 |     | <span class='neutral'>  X127 amountSpecified</span>
 5635 |     | <span class='neutral'>) pure {</span>
 5636 |     | <span class='unexecuted'>  assembly {</span>
 5637 |     | <span class='neutral'>    mstore(_amountSpecified_, amountSpecified)</span>
 5638 |     | <span class='neutral'>  }</span>
 5639 |     | <span class='neutral'>}</span>
 5640 |     | <span class='neutral'></span>
 5641 |     | <span class='neutral'>function getLogPriceLimit() pure returns (</span>
 5642 |     | <span class='neutral'>  X59 logPriceLimit</span>
 5643 |     | <span class='neutral'>) {</span>
 5644 |     | <span class='neutral'>  assembly {</span>
 5645 |     | <span class='neutral'>    logPriceLimit := mload(_logPriceLimit_)</span>
 5646 |     | <span class='neutral'>  }</span>
 5647 |     | <span class='neutral'>}</span>
 5648 |     | <span class='neutral'></span>
 5649 |     | <span class='unexecuted'>function setLogPriceLimit(</span>
 5650 |     | <span class='neutral'>  X59 logPriceLimit</span>
 5651 |     | <span class='neutral'>) pure {</span>
 5652 |     | <span class='unexecuted'>  assembly {</span>
 5653 |     | <span class='neutral'>    mstore(_logPriceLimit_, logPriceLimit)</span>
 5654 |     | <span class='neutral'>  }</span>
 5655 |     | <span class='neutral'>}</span>
 5656 |     | <span class='neutral'></span>
 5657 |     | <span class='neutral'>function getLogPriceLimitOffsetted() pure returns (</span>
 5658 |     | <span class='neutral'>  X59 logPriceLimitOffsetted</span>
 5659 |     | <span class='neutral'>) {</span>
 5660 |     | <span class='neutral'>  assembly {</span>
 5661 |     | <span class='neutral'>    logPriceLimitOffsetted := shr(192, mload(_logPriceLimitOffsetted_))</span>
 5662 |     | <span class='neutral'>  }</span>
 5663 |     | <span class='neutral'>}</span>
 5664 |     | <span class='neutral'></span>
 5665 |     | <span class='neutral'>function setLogPriceLimitOffsetted(</span>
 5666 |     | <span class='neutral'>  X59 logPriceLimitOffsetted</span>
 5667 |     | <span class='neutral'>) pure {</span>
 5668 |     | <span class='neutral'>  assembly {</span>
 5669 |     | <span class='neutral'>    mstore(</span>
 5670 |     | <span class='neutral'>      _logPriceLimitOffsetted_,</span>
 5671 |     | <span class='neutral'>      or(</span>
 5672 |     | <span class='neutral'>        shl(192, logPriceLimitOffsetted),</span>
 5673 |     | <span class='neutral'>        shr(64, mload(add(_logPriceLimitOffsetted_, 8)))</span>
 5674 |     | <span class='neutral'>      )</span>
 5675 |     | <span class='neutral'>    )</span>
 5676 |     | <span class='neutral'>  }</span>
 5677 |     | <span class='neutral'>}</span>
 5678 |     | <span class='neutral'></span>
 5679 |     | <span class='neutral'>function getZeroForOne() pure returns (</span>
 5680 |     | <span class='neutral'>  bool zeroForOne</span>
 5681 |     | <span class='neutral'>) {</span>
 5682 |     | <span class='neutral'>  assembly {</span>
 5683 |     | <span class='neutral'>    zeroForOne := shr(255, mload(_zeroForOne_))</span>
 5684 |     | <span class='neutral'>  }</span>
 5685 |     | <span class='neutral'>}</span>
 5686 |     | <span class='neutral'></span>
 5687 |     | <span class='neutral'>function setZeroForOne(</span>
 5688 |     | <span class='neutral'>  bool zeroForOne</span>
 5689 |     | <span class='neutral'>) pure {</span>
 5690 |     | <span class='neutral'>  assembly {</span>
 5691 |     | <span class='neutral'>    mstore8(_zeroForOne_, mul(0xFF, zeroForOne))</span>
 5692 |     | <span class='neutral'>  }</span>
 5693 |     | <span class='neutral'>}</span>
 5694 |     | <span class='neutral'></span>
 5695 |     | <span class='neutral'>function getExactInput() pure returns (</span>
 5696 |     | <span class='neutral'>  bool exactInput</span>
 5697 |     | <span class='neutral'>) {</span>
 5698 |     | <span class='neutral'>  assembly {</span>
 5699 |     | <span class='neutral'>    exactInput := shr(255, mload(_exactInput_))</span>
 5700 |     | <span class='neutral'>  }</span>
 5701 |     | <span class='neutral'>}</span>
 5702 |     | <span class='neutral'></span>
 5703 |     | <span class='neutral'>function setExactInput(</span>
 5704 |     | <span class='neutral'>  bool exactInput</span>
 5705 |     | <span class='neutral'>) pure {</span>
 5706 |     | <span class='neutral'>  assembly {</span>
 5707 |     | <span class='neutral'>    mstore8(_exactInput_, mul(0xFF, exactInput))</span>
 5708 |     | <span class='neutral'>  }</span>
 5709 |     | <span class='neutral'>}</span>
 5710 |     | <span class='neutral'></span>
 5711 |     | <span class='neutral'>function getIntegralLimit() pure returns (</span>
 5712 |     | <span class='neutral'>  X216 integralLimit</span>
 5713 |     | <span class='neutral'>) {</span>
 5714 |     | <span class='neutral'>  assembly {</span>
 5715 |     | <span class='neutral'>    integralLimit := shr(40, mload(_integralLimit_))</span>
 5716 |     | <span class='neutral'>  }</span>
 5717 |     | <span class='neutral'>}</span>
 5718 |     | <span class='neutral'></span>
 5719 |     | <span class='neutral'>function setIntegralLimit(</span>
 5720 |     | <span class='neutral'>  X216 integralLimit</span>
 5721 |     | <span class='neutral'>) pure {</span>
 5722 |     | <span class='neutral'>  assembly {</span>
 5723 |     | <span class='neutral'>    mstore(</span>
 5724 |     | <span class='neutral'>      _integralLimit_,</span>
 5725 |     | <span class='neutral'>      or(</span>
 5726 |     | <span class='neutral'>        shl(40, integralLimit),</span>
 5727 |     | <span class='neutral'>        shr(216, mload(add(_integralLimit_, 27)))</span>
 5728 |     | <span class='neutral'>      )</span>
 5729 |     | <span class='neutral'>    )</span>
 5730 |     | <span class='neutral'>  }</span>
 5731 |     | <span class='neutral'>}</span>
 5732 |     | <span class='neutral'></span>
 5733 |     | <span class='neutral'>function getIntegralLimitInterval() pure returns (</span>
 5734 |     | <span class='neutral'>  X216 integralLimitInterval</span>
 5735 |     | <span class='neutral'>) {</span>
 5736 |     | <span class='neutral'>  assembly {</span>
 5737 |     | <span class='neutral'>    integralLimitInterval := shr(40, mload(_integralLimitInterval_))</span>
 5738 |     | <span class='neutral'>  }</span>
 5739 |     | <span class='neutral'>}</span>
 5740 |     | <span class='neutral'></span>
 5741 |     | <span class='neutral'>function setIntegralLimitInterval(</span>
 5742 |     | <span class='neutral'>  X216 integralLimitInterval</span>
 5743 |     | <span class='neutral'>) pure {</span>
 5744 |     | <span class='neutral'>  assembly {</span>
 5745 |     | <span class='neutral'>    mstore(</span>
 5746 |     | <span class='neutral'>      _integralLimitInterval_,</span>
 5747 |     | <span class='neutral'>      or(</span>
 5748 |     | <span class='neutral'>        shl(40, integralLimitInterval),</span>
 5749 |     | <span class='neutral'>        shr(216, mload(add(_integralLimitInterval_, 27)))</span>
 5750 |     | <span class='neutral'>      )</span>
 5751 |     | <span class='neutral'>    )</span>
 5752 |     | <span class='neutral'>  }</span>
 5753 |     | <span class='neutral'>}</span>
 5754 |     | <span class='neutral'></span>
 5755 |     | <span class='neutral'>function getAmount0() pure returns (</span>
 5756 |     | <span class='neutral'>  X127 amount0</span>
 5757 |     | <span class='neutral'>) {</span>
 5758 |     | <span class='neutral'>  assembly {</span>
 5759 |     | <span class='neutral'>    amount0 := mload(_amount0_)</span>
 5760 |     | <span class='neutral'>  }</span>
 5761 |     | <span class='neutral'>}</span>
 5762 |     | <span class='neutral'></span>
 5763 |     | <span class='neutral'>function setAmount0(</span>
 5764 |     | <span class='neutral'>  X127 amount0</span>
 5765 |     | <span class='neutral'>) pure {</span>
 5766 |     | <span class='neutral'>  assembly {</span>
 5767 |     | <span class='neutral'>    mstore(_amount0_, amount0)</span>
 5768 |     | <span class='neutral'>  }</span>
 5769 |     | <span class='neutral'>}</span>
 5770 |     | <span class='neutral'></span>
 5771 |     | <span class='neutral'>function getAmount1() pure returns (</span>
 5772 |     | <span class='neutral'>  X127 amount1</span>
 5773 |     | <span class='neutral'>) {</span>
 5774 |     | <span class='neutral'>  assembly {</span>
 5775 |     | <span class='neutral'>    amount1 := mload(_amount1_)</span>
 5776 |     | <span class='neutral'>  }</span>
 5777 |     | <span class='neutral'>}</span>
 5778 |     | <span class='neutral'></span>
 5779 |     | <span class='neutral'>function setAmount1(</span>
 5780 |     | <span class='neutral'>  X127 amount1</span>
 5781 |     | <span class='neutral'>) pure {</span>
 5782 |     | <span class='neutral'>  assembly {</span>
 5783 |     | <span class='neutral'>    mstore(_amount1_, amount1)</span>
 5784 |     | <span class='neutral'>  }</span>
 5785 |     | <span class='neutral'>}</span>
 5786 |     | <span class='neutral'></span>
 5787 |     | <span class='neutral'>function getBackGrowthMultiplier() pure returns (</span>
 5788 |     | <span class='neutral'>  X208 backGrowthMultiplier</span>
 5789 |     | <span class='neutral'>) {</span>
 5790 |     | <span class='neutral'>  assembly {</span>
 5791 |     | <span class='neutral'>    backGrowthMultiplier := mload(_backGrowthMultiplier_)</span>
 5792 |     | <span class='neutral'>  }</span>
 5793 |     | <span class='neutral'>}</span>
 5794 |     | <span class='neutral'></span>
 5795 |     | <span class='neutral'>function setBackGrowthMultiplier(</span>
 5796 |     | <span class='neutral'>  X208 backGrowthMultiplier</span>
 5797 |     | <span class='neutral'>) pure {</span>
 5798 |     | <span class='neutral'>  assembly {</span>
 5799 |     | <span class='neutral'>    mstore(_backGrowthMultiplier_, backGrowthMultiplier)</span>
 5800 |     | <span class='neutral'>  }</span>
 5801 |     | <span class='neutral'>}</span>
 5802 |     | <span class='neutral'></span>
 5803 |     | <span class='neutral'>function getNextGrowthMultiplier() pure returns (</span>
 5804 |     | <span class='neutral'>  X208 nextGrowthMultiplier</span>
 5805 |     | <span class='neutral'>) {</span>
 5806 |     | <span class='neutral'>  assembly {</span>
 5807 |     | <span class='neutral'>    nextGrowthMultiplier := mload(_nextGrowthMultiplier_)</span>
 5808 |     | <span class='neutral'>  }</span>
 5809 |     | <span class='neutral'>}</span>
 5810 |     | <span class='neutral'></span>
 5811 |     | <span class='neutral'>function setNextGrowthMultiplier(</span>
 5812 |     | <span class='neutral'>  X208 nextGrowthMultiplier</span>
 5813 |     | <span class='neutral'>) pure {</span>
 5814 |     | <span class='neutral'>  assembly {</span>
 5815 |     | <span class='neutral'>    mstore(_nextGrowthMultiplier_, nextGrowthMultiplier)</span>
 5816 |     | <span class='neutral'>  }</span>
 5817 |     | <span class='neutral'>}</span>
 5818 |     | <span class='neutral'></span>
 5819 |     | <span class='neutral'>function getDirection() pure returns (</span>
 5820 |     | <span class='neutral'>  bool direction</span>
 5821 |     | <span class='neutral'>) {</span>
 5822 |     | <span class='neutral'>  assembly {</span>
 5823 |     | <span class='neutral'>    direction := shr(255, mload(_direction_))</span>
 5824 |     | <span class='neutral'>  }</span>
 5825 |     | <span class='neutral'>}</span>
 5826 |     | <span class='neutral'></span>
 5827 |     | <span class='neutral'>function setDirection(</span>
 5828 |     | <span class='neutral'>  bool direction</span>
 5829 |     | <span class='neutral'>) pure {</span>
 5830 |     | <span class='neutral'>  assembly {</span>
 5831 |     | <span class='neutral'>    mstore8(_direction_, mul(0xFF, direction))</span>
 5832 |     | <span class='neutral'>  }</span>
 5833 |     | <span class='neutral'>}</span>
 5834 |     | <span class='neutral'></span>
 5835 |     | <span class='neutral'>function getIndexCurve() pure returns (</span>
 5836 |     | <span class='neutral'>  Index indexCurve</span>
 5837 |     | <span class='neutral'>) {</span>
 5838 |     | <span class='neutral'>  assembly {</span>
 5839 |     | <span class='neutral'>    indexCurve := shr(240, mload(_indexCurve_))</span>
 5840 |     | <span class='neutral'>  }</span>
 5841 |     | <span class='neutral'>}</span>
 5842 |     | <span class='neutral'></span>
 5843 |     | <span class='neutral'>function setIndexCurve(</span>
 5844 |     | <span class='neutral'>  Index indexCurve</span>
 5845 |     | <span class='neutral'>) pure {</span>
 5846 |     | <span class='neutral'>  assembly {</span>
 5847 |     | <span class='neutral'>    mstore(</span>
 5848 |     | <span class='neutral'>      _indexCurve_,</span>
 5849 |     | <span class='neutral'>      or(</span>
 5850 |     | <span class='neutral'>        shl(240, indexCurve),</span>
 5851 |     | <span class='neutral'>        shr(16, mload(add(_indexCurve_, 2)))</span>
 5852 |     | <span class='neutral'>      )</span>
 5853 |     | <span class='neutral'>    )</span>
 5854 |     | <span class='neutral'>  }</span>
 5855 |     | <span class='neutral'>}</span>
 5856 |     | <span class='neutral'></span>
 5857 |     | <span class='neutral'>function getLogPriceLimitOffsettedWithinInterval() pure returns (</span>
 5858 |     | <span class='neutral'>  X59 logPriceLimitOffsettedWithinInterval</span>
 5859 |     | <span class='neutral'>) {</span>
 5860 |     | <span class='neutral'>  assembly {</span>
 5861 |     | <span class='neutral'>    logPriceLimitOffsettedWithinInterval := </span>
 5862 |     | <span class='neutral'>      shr(192, mload(_logPriceLimitOffsettedWithinInterval_))</span>
 5863 |     | <span class='neutral'>  }</span>
 5864 |     | <span class='neutral'>}</span>
 5865 |     | <span class='neutral'></span>
 5866 |     | <span class='neutral'>function setLogPriceLimitOffsettedWithinInterval(</span>
 5867 |     | <span class='neutral'>  X59 logPriceLimitOffsettedWithinInterval</span>
 5868 |     | <span class='neutral'>) pure {</span>
 5869 |     | <span class='neutral'>  assembly {</span>
 5870 |     | <span class='neutral'>    mstore(</span>
 5871 |     | <span class='neutral'>      _logPriceLimitOffsettedWithinInterval_,</span>
 5872 |     | <span class='neutral'>      or(</span>
 5873 |     | <span class='neutral'>        shl(192, logPriceLimitOffsettedWithinInterval),</span>
 5874 |     | <span class='neutral'>        shr(64, mload(add(_logPriceLimitOffsettedWithinInterval_, 8)))</span>
 5875 |     | <span class='neutral'>      )</span>
 5876 |     | <span class='neutral'>    )</span>
 5877 |     | <span class='neutral'>  }</span>
 5878 |     | <span class='neutral'>}</span>
 5879 |     | <span class='neutral'></span>
 5880 |     | <span class='neutral'>function getAccrued0() pure returns (</span>
 5881 |     | <span class='neutral'>  X127 accrued0</span>
 5882 |     | <span class='neutral'>) {</span>
 5883 |     | <span class='neutral'>  assembly {</span>
 5884 |     | <span class='neutral'>    accrued0 := mload(_accrued0_)</span>
 5885 |     | <span class='neutral'>  }</span>
 5886 |     | <span class='neutral'>}</span>
 5887 |     | <span class='neutral'></span>
 5888 |     | <span class='neutral'>function setAccrued0(</span>
 5889 |     | <span class='neutral'>  X127 accrued0</span>
 5890 |     | <span class='neutral'>) pure {</span>
 5891 |     | <span class='neutral'>  assembly {</span>
 5892 |     | <span class='neutral'>    mstore(_accrued0_, accrued0)</span>
 5893 |     | <span class='neutral'>  }</span>
 5894 |     | <span class='neutral'>}</span>
 5895 |     | <span class='neutral'></span>
 5896 |     | <span class='neutral'>function getAccrued1() pure returns (</span>
 5897 |     | <span class='neutral'>  X127 accrued1</span>
 5898 |     | <span class='neutral'>) {</span>
 5899 |     | <span class='neutral'>  assembly {</span>
 5900 |     | <span class='neutral'>    accrued1 := mload(_accrued1_)</span>
 5901 |     | <span class='neutral'>  }</span>
 5902 |     | <span class='neutral'>}</span>
 5903 |     | <span class='neutral'></span>
 5904 |     | <span class='neutral'>function setAccrued1(</span>
 5905 |     | <span class='neutral'>  X127 accrued1</span>
 5906 |     | <span class='neutral'>) pure {</span>
 5907 |     | <span class='neutral'>  assembly {</span>
 5908 |     | <span class='neutral'>    mstore(_accrued1_, accrued1)</span>
 5909 |     | <span class='neutral'>  }</span>
 5910 |     | <span class='neutral'>}</span>
 5911 |     | <span class='neutral'></span>
 5912 |     | <span class='neutral'>function getPoolRatio0() pure returns (</span>
 5913 |     | <span class='neutral'>  X23 poolRatio0</span>
 5914 |     | <span class='neutral'>) {</span>
 5915 |     | <span class='neutral'>  assembly {</span>
 5916 |     | <span class='neutral'>    poolRatio0 := shr(232, mload(_poolRatio0_))</span>
 5917 |     | <span class='neutral'>  }</span>
 5918 |     | <span class='neutral'>}</span>
 5919 |     | <span class='neutral'></span>
 5920 |     | <span class='neutral'>function setPoolRatio0(</span>
 5921 |     | <span class='neutral'>  X23 poolRatio0</span>
 5922 |     | <span class='neutral'>) pure {</span>
 5923 |     | <span class='neutral'>  assembly {</span>
 5924 |     | <span class='neutral'>    mstore(</span>
 5925 |     | <span class='neutral'>      _poolRatio0_,</span>
 5926 |     | <span class='neutral'>      or(</span>
 5927 |     | <span class='neutral'>        shl(232, poolRatio0),</span>
 5928 |     | <span class='neutral'>        shr(24, mload(add(_poolRatio0_, 3)))</span>
 5929 |     | <span class='neutral'>      )</span>
 5930 |     | <span class='neutral'>    )</span>
 5931 |     | <span class='neutral'>  }</span>
 5932 |     | <span class='neutral'>}</span>
 5933 |     | <span class='neutral'></span>
 5934 |     | <span class='neutral'>function getPoolRatio1() pure returns (</span>
 5935 |     | <span class='neutral'>  X23 poolRatio1</span>
 5936 |     | <span class='neutral'>) {</span>
 5937 |     | <span class='neutral'>  assembly {</span>
 5938 |     | <span class='neutral'>    poolRatio1 := shr(232, mload(_poolRatio1_))</span>
 5939 |     | <span class='neutral'>  }</span>
 5940 |     | <span class='neutral'>}</span>
 5941 |     | <span class='neutral'></span>
 5942 |     | <span class='neutral'>function setPoolRatio1(</span>
 5943 |     | <span class='neutral'>  X23 poolRatio1</span>
 5944 |     | <span class='neutral'>) pure {</span>
 5945 |     | <span class='neutral'>  assembly {</span>
 5946 |     | <span class='neutral'>    mstore(</span>
 5947 |     | <span class='neutral'>      _poolRatio1_,</span>
 5948 |     | <span class='neutral'>      or(</span>
 5949 |     | <span class='neutral'>        shl(232, poolRatio1),</span>
 5950 |     | <span class='neutral'>        shr(24, mload(add(_poolRatio1_, 3)))</span>
 5951 |     | <span class='neutral'>      )</span>
 5952 |     | <span class='neutral'>    )</span>
 5953 |     | <span class='neutral'>  }</span>
 5954 |     | <span class='neutral'>}</span>
 5955 |     | <span class='neutral'></span>
 5956 |     | <span class='neutral'>function getKernel() pure returns (</span>
 5957 |     | <span class='neutral'>  Kernel kernel</span>
 5958 |     | <span class='neutral'>) {</span>
 5959 |     | <span class='neutral'>  assembly {</span>
 5960 |     | <span class='neutral'>    kernel := mload(_kernel_)</span>
 5961 |     | <span class='neutral'>  }</span>
 5962 |     | <span class='neutral'>}</span>
 5963 |     | <span class='neutral'></span>
 5964 |     | <span class='unexecuted'>function setKernel(</span>
 5965 |     | <span class='neutral'>  Kernel kernel</span>
 5966 |     | <span class='neutral'>) pure {</span>
 5967 |     | <span class='unexecuted'>  assembly {</span>
 5968 |     | <span class='neutral'>    mstore(_kernel_, kernel)</span>
 5969 |     | <span class='neutral'>  }</span>
 5970 |     | <span class='neutral'>}</span>
 5971 |     | <span class='neutral'></span>
 5972 |     | <span class='neutral'>function getCurve() pure returns (</span>
 5973 |     | <span class='neutral'>  Curve curve</span>
 5974 |     | <span class='neutral'>) {</span>
 5975 |     | <span class='neutral'>  assembly {</span>
 5976 |     | <span class='neutral'>    curve := mload(_curve_)</span>
 5977 |     | <span class='neutral'>  }</span>
 5978 |     | <span class='neutral'>}</span>
 5979 |     | <span class='neutral'></span>
 5980 |     | <span class='unexecuted'>function setCurve(</span>
 5981 |     | <span class='neutral'>  Curve curve</span>
 5982 |     | <span class='neutral'>) pure {</span>
 5983 |     | <span class='unexecuted'>  assembly {</span>
 5984 |     | <span class='neutral'>    mstore(_curve_, curve)</span>
 5985 |     | <span class='neutral'>  }</span>
 5986 |     | <span class='neutral'>}</span>
 5987 |     | <span class='neutral'></span>
 5988 |     | <span class='neutral'>function getHookData() pure returns (</span>
 5989 |     | <span class='neutral'>  uint256 hookData</span>
 5990 |     | <span class='neutral'>) {</span>
 5991 |     | <span class='neutral'>  assembly {</span>
 5992 |     | <span class='neutral'>    hookData := mload(_hookData_)</span>
 5993 |     | <span class='neutral'>  }</span>
 5994 |     | <span class='neutral'>}</span>
 5995 |     | <span class='neutral'></span>
 5996 |     | <span class='unexecuted'>function setHookData(</span>
 5997 |     | <span class='neutral'>  uint256 hookData</span>
 5998 |     | <span class='neutral'>) pure {</span>
 5999 |     | <span class='unexecuted'>  assembly {</span>
 6000 |     | <span class='neutral'>    mstore(_hookData_, hookData)</span>
 6001 |     | <span class='neutral'>  }</span>
 6002 |     | <span class='neutral'>}</span>
 6003 |     | <span class='neutral'></span>
 6004 |     | <span class='neutral'>function getKernelLength() pure returns (</span>
 6005 |     | <span class='neutral'>  Index kernelLength</span>
 6006 |     | <span class='neutral'>) {</span>
 6007 |     | <span class='neutral'>  assembly {</span>
 6008 |     | <span class='neutral'>    kernelLength := shr(240, mload(_kernelLength_))</span>
 6009 |     | <span class='neutral'>  }</span>
 6010 |     | <span class='neutral'>}</span>
 6011 |     | <span class='neutral'></span>
 6012 |     | <span class='neutral'>function setKernelLength(</span>
 6013 |     | <span class='neutral'>  Index kernelLength</span>
 6014 |     | <span class='neutral'>) pure {</span>
 6015 |     | <span class='neutral'>  assembly {</span>
 6016 |     | <span class='neutral'>    mstore(</span>
 6017 |     | <span class='neutral'>      _kernelLength_,</span>
 6018 |     | <span class='neutral'>      or(</span>
 6019 |     | <span class='neutral'>        shl(240, kernelLength),</span>
 6020 |     | <span class='neutral'>        shr(16, mload(add(_kernelLength_, 2)))</span>
 6021 |     | <span class='neutral'>      )</span>
 6022 |     | <span class='neutral'>    )</span>
 6023 |     | <span class='neutral'>  }</span>
 6024 |     | <span class='neutral'>}</span>
 6025 |     | <span class='neutral'></span>
 6026 |     | <span class='neutral'>function getCurveLength() pure returns (</span>
 6027 |     | <span class='neutral'>  Index curveLength</span>
 6028 |     | <span class='neutral'>) {</span>
 6029 |     | <span class='neutral'>  assembly {</span>
 6030 |     | <span class='neutral'>    curveLength := shr(240, mload(_curveLength_))</span>
 6031 |     | <span class='neutral'>  }</span>
 6032 |     | <span class='neutral'>}</span>
 6033 |     | <span class='neutral'></span>
 6034 |     | <span class='neutral'>function setCurveLength(</span>
 6035 |     | <span class='neutral'>  Index curveLength</span>
 6036 |     | <span class='neutral'>) pure {</span>
 6037 |     | <span class='neutral'>  assembly {</span>
 6038 |     | <span class='neutral'>    mstore(</span>
 6039 |     | <span class='neutral'>      _curveLength_,</span>
 6040 |     | <span class='neutral'>      or(</span>
 6041 |     | <span class='neutral'>        shl(240, curveLength),</span>
 6042 |     | <span class='neutral'>        shr(16, mload(add(_curveLength_, 2)))</span>
 6043 |     | <span class='neutral'>      )</span>
 6044 |     | <span class='neutral'>    )</span>
 6045 |     | <span class='neutral'>  }</span>
 6046 |     | <span class='neutral'>}</span>
 6047 |     | <span class='neutral'></span>
 6048 |     | <span class='neutral'>function getHookDataByteCount() pure returns (</span>
 6049 |     | <span class='neutral'>  uint16 hookDataByteCount</span>
 6050 |     | <span class='neutral'>) {</span>
 6051 |     | <span class='neutral'>  assembly {</span>
 6052 |     | <span class='neutral'>    hookDataByteCount := shr(240, mload(_hookDataByteCount_))</span>
 6053 |     | <span class='neutral'>  }</span>
 6054 |     | <span class='neutral'>}</span>
 6055 |     | <span class='neutral'></span>
 6056 |     | <span class='unexecuted'>function setHookDataByteCount(</span>
 6057 |     | <span class='neutral'>  uint16 hookDataByteCount</span>
 6058 |     | <span class='neutral'>) pure {</span>
 6059 |     | <span class='unexecuted'>  assembly {</span>
 6060 |     | <span class='neutral'>    mstore(</span>
 6061 |     | <span class='neutral'>      _hookDataByteCount_,</span>
 6062 |     | <span class='neutral'>      or(</span>
 6063 |     | <span class='neutral'>        shl(240, hookDataByteCount),</span>
 6064 |     | <span class='neutral'>        shr(16, mload(add(_hookDataByteCount_, 2)))</span>
 6065 |     | <span class='neutral'>      )</span>
 6066 |     | <span class='neutral'>    )</span>
 6067 |     | <span class='neutral'>  }</span>
 6068 |     | <span class='neutral'>}</span>
 6069 |     | <span class='neutral'></span>
 6070 |     | <span class='neutral'>function getStaticParamsStoragePointerExtension() pure returns (</span>
 6071 |     | <span class='neutral'>  uint256 staticParamsStoragePointerExtension</span>
 6072 |     | <span class='neutral'>) {</span>
 6073 |     | <span class='neutral'>  assembly {</span>
 6074 |     | <span class='neutral'>    staticParamsStoragePointerExtension := </span>
 6075 |     | <span class='neutral'>      mload(_staticParamsStoragePointerExtension_)</span>
 6076 |     | <span class='neutral'>  }</span>
 6077 |     | <span class='neutral'>}</span>
 6078 |     | <span class='neutral'></span>
 6079 |     | <span class='neutral'>function setStaticParamsStoragePointerExtension(</span>
 6080 |     | <span class='neutral'>  uint256 staticParamsStoragePointerExtension</span>
 6081 |     | <span class='neutral'>) pure {</span>
 6082 |     | <span class='neutral'>  assembly {</span>
 6083 |     | <span class='neutral'>    mstore(</span>
 6084 |     | <span class='neutral'>      _staticParamsStoragePointerExtension_,</span>
 6085 |     | <span class='neutral'>      staticParamsStoragePointerExtension</span>
 6086 |     | <span class='neutral'>    )</span>
 6087 |     | <span class='neutral'>  }</span>
 6088 |     | <span class='neutral'>}</span>
 6089 |     | <span class='neutral'></span>
 6090 |     | <span class='neutral'>function getGrowth() pure returns (</span>
 6091 |     | <span class='neutral'>  X111 growth</span>
 6092 |     | <span class='neutral'>) {</span>
 6093 |     | <span class='neutral'>  assembly {</span>
 6094 |     | <span class='neutral'>    growth := shr(128, mload(_growth_))</span>
 6095 |     | <span class='neutral'>  }</span>
 6096 |     | <span class='neutral'>}</span>
 6097 |     | <span class='neutral'></span>
 6098 |     | <span class='neutral'>function setGrowth(</span>
 6099 |     | <span class='neutral'>  X111 growth</span>
 6100 |     | <span class='neutral'>) pure {</span>
 6101 |     | <span class='neutral'>  assembly {</span>
 6102 |     | <span class='neutral'>    mstore(</span>
 6103 |     | <span class='neutral'>      _growth_,</span>
 6104 |     | <span class='neutral'>      or(</span>
 6105 |     | <span class='neutral'>        shl(128, growth),</span>
 6106 |     | <span class='neutral'>        shr(128, mload(add(_growth_, 16)))</span>
 6107 |     | <span class='neutral'>      )</span>
 6108 |     | <span class='neutral'>    )</span>
 6109 |     | <span class='neutral'>  }</span>
 6110 |     | <span class='neutral'>}</span>
 6111 |     | <span class='neutral'></span>
 6112 |     | <span class='neutral'>function getIntegral0() pure returns (</span>
 6113 |     | <span class='neutral'>  X216 integral0</span>
 6114 |     | <span class='neutral'>) {</span>
 6115 |     | <span class='neutral'>  assembly {</span>
 6116 |     | <span class='neutral'>    integral0 := shr(40, mload(_integral0_))</span>
 6117 |     | <span class='neutral'>  }</span>
 6118 |     | <span class='neutral'>}</span>
 6119 |     | <span class='neutral'></span>
 6120 |     | <span class='neutral'>function setIntegral0(</span>
 6121 |     | <span class='neutral'>  X216 integral0</span>
 6122 |     | <span class='neutral'>) pure {</span>
 6123 |     | <span class='neutral'>  assembly {</span>
 6124 |     | <span class='neutral'>    mstore(</span>
 6125 |     | <span class='neutral'>      _integral0_,</span>
 6126 |     | <span class='neutral'>      or(</span>
 6127 |     | <span class='neutral'>        shl(40, integral0),</span>
 6128 |     | <span class='neutral'>        shr(216, mload(add(_integral0_, 27)))</span>
 6129 |     | <span class='neutral'>      )</span>
 6130 |     | <span class='neutral'>    )</span>
 6131 |     | <span class='neutral'>  }</span>
 6132 |     | <span class='neutral'>}</span>
 6133 |     | <span class='neutral'></span>
 6134 |     | <span class='neutral'>function getIntegral1() pure returns (</span>
 6135 |     | <span class='neutral'>  X216 integral1</span>
 6136 |     | <span class='neutral'>) {</span>
 6137 |     | <span class='neutral'>  assembly {</span>
 6138 |     | <span class='neutral'>    integral1 := shr(40, mload(_integral1_))</span>
 6139 |     | <span class='neutral'>  }</span>
 6140 |     | <span class='neutral'>}</span>
 6141 |     | <span class='neutral'></span>
 6142 |     | <span class='neutral'>function setIntegral1(</span>
 6143 |     | <span class='neutral'>  X216 integral1</span>
 6144 |     | <span class='neutral'>) pure {</span>
 6145 |     | <span class='neutral'>  assembly {</span>
 6146 |     | <span class='neutral'>    mstore(</span>
 6147 |     | <span class='neutral'>      _integral1_,</span>
 6148 |     | <span class='neutral'>      or(</span>
 6149 |     | <span class='neutral'>        shl(40, integral1),</span>
 6150 |     | <span class='neutral'>        shr(216, mload(add(_integral1_, 27)))</span>
 6151 |     | <span class='neutral'>      )</span>
 6152 |     | <span class='neutral'>    )</span>
 6153 |     | <span class='neutral'>  }</span>
 6154 |     | <span class='neutral'>}</span>
 6155 |     | <span class='neutral'></span>
 6156 |     | <span class='neutral'>function getSharesTotal() pure returns (</span>
 6157 |     | <span class='neutral'>  uint256 sharesTotal</span>
 6158 |     | <span class='neutral'>) {</span>
 6159 |     | <span class='neutral'>  assembly {</span>
 6160 |     | <span class='neutral'>    sharesTotal := shr(128, mload(_sharesTotal_))</span>
 6161 |     | <span class='neutral'>  }</span>
 6162 |     | <span class='neutral'>}</span>
 6163 |     | <span class='neutral'></span>
 6164 |     | <span class='neutral'>function setSharesTotal(</span>
 6165 |     | <span class='neutral'>  uint256 sharesTotal</span>
 6166 |     | <span class='neutral'>) pure {</span>
 6167 |     | <span class='neutral'>  assembly {</span>
 6168 |     | <span class='neutral'>    mstore(</span>
 6169 |     | <span class='neutral'>      _sharesTotal_,</span>
 6170 |     | <span class='neutral'>      or(</span>
 6171 |     | <span class='neutral'>        shl(128, sharesTotal),</span>
 6172 |     | <span class='neutral'>        shr(128, mload(add(_sharesTotal_, 16)))</span>
 6173 |     | <span class='neutral'>      )</span>
 6174 |     | <span class='neutral'>    )</span>
 6175 |     | <span class='neutral'>  }</span>
 6176 |     | <span class='neutral'>}</span>
 6177 |     | <span class='neutral'></span>
 6178 |     | <span class='neutral'>function getStaticParamsStoragePointer() pure returns (</span>
 6179 |     | <span class='neutral'>  uint16 staticParamsStoragePointer</span>
 6180 |     | <span class='neutral'>) {</span>
 6181 |     | <span class='neutral'>  assembly {</span>
 6182 |     | <span class='neutral'>    staticParamsStoragePointer := shr(240, mload(_staticParamsStoragePointer_))</span>
 6183 |     | <span class='neutral'>  }</span>
 6184 |     | <span class='neutral'>}</span>
 6185 |     | <span class='neutral'></span>
 6186 |     | <span class='neutral'>function setStaticParamsStoragePointer(</span>
 6187 |     | <span class='neutral'>  uint16 staticParamsStoragePointer</span>
 6188 |     | <span class='neutral'>) pure {</span>
 6189 |     | <span class='neutral'>  assembly {</span>
 6190 |     | <span class='neutral'>    mstore(</span>
 6191 |     | <span class='neutral'>      _staticParamsStoragePointer_,</span>
 6192 |     | <span class='neutral'>      or(</span>
 6193 |     | <span class='neutral'>        shl(240, staticParamsStoragePointer),</span>
 6194 |     | <span class='neutral'>        shr(16, mload(add(_staticParamsStoragePointer_, 2)))</span>
 6195 |     | <span class='neutral'>      )</span>
 6196 |     | <span class='neutral'>    )</span>
 6197 |     | <span class='neutral'>  }</span>
 6198 |     | <span class='neutral'>}</span>
 6199 |     | <span class='neutral'></span>
 6200 |     | <span class='neutral'>function getLogPriceCurrent() pure returns (</span>
 6201 |     | <span class='neutral'>  X59 logPriceCurrent</span>
 6202 |     | <span class='neutral'>) {</span>
 6203 |     | <span class='neutral'>  assembly {</span>
 6204 |     | <span class='neutral'>    logPriceCurrent := shr(192, mload(_logPriceCurrent_))</span>
 6205 |     | <span class='neutral'>  }</span>
 6206 |     | <span class='neutral'>}</span>
 6207 |     | <span class='neutral'></span>
 6208 |     | <span class='neutral'>function setLogPriceCurrent(</span>
 6209 |     | <span class='neutral'>  X59 logPriceCurrent</span>
 6210 |     | <span class='neutral'>) pure {</span>
 6211 |     | <span class='neutral'>  assembly {</span>
 6212 |     | <span class='neutral'>    mstore(</span>
 6213 |     | <span class='neutral'>      _logPriceCurrent_,</span>
 6214 |     | <span class='neutral'>      or(</span>
 6215 |     | <span class='neutral'>        shl(192, logPriceCurrent),</span>
 6216 |     | <span class='neutral'>        shr(64, mload(add(_logPriceCurrent_, 8)))</span>
 6217 |     | <span class='neutral'>      )</span>
 6218 |     | <span class='neutral'>    )</span>
 6219 |     | <span class='neutral'>  }</span>
 6220 |     | <span class='neutral'>}</span>
 6221 |     | <span class='neutral'></span>
 6222 |     | <span class='neutral'>function setDeploymentCreationCode(</span>
 6223 |     | <span class='neutral'>  uint256 deploymentCreationCode</span>
 6224 |     | <span class='neutral'>) pure {</span>
 6225 |     | <span class='neutral'>  assembly {</span>
 6226 |     | <span class='neutral'>    mstore(</span>
 6227 |     | <span class='neutral'>      _deploymentCreationCode_,</span>
 6228 |     | <span class='neutral'>      or(</span>
 6229 |     | <span class='neutral'>        shl(168, deploymentCreationCode),</span>
 6230 |     | <span class='neutral'>        shr(88, mload(add(_deploymentCreationCode_, 11)))</span>
 6231 |     | <span class='neutral'>      )</span>
 6232 |     | <span class='neutral'>    )</span>
 6233 |     | <span class='neutral'>  }</span>
 6234 |     | <span class='neutral'>}</span>
 6235 |     | <span class='neutral'></span>
 6236 |     | <span class='neutral'>function getTag0() pure returns (</span>
 6237 |     | <span class='neutral'>  Tag tag0</span>
 6238 |     | <span class='neutral'>) {</span>
 6239 |     | <span class='neutral'>  assembly {</span>
 6240 |     | <span class='neutral'>    tag0 := mload(_tag0_)</span>
 6241 |     | <span class='neutral'>  }</span>
 6242 |     | <span class='neutral'>}</span>
 6243 |     | <span class='neutral'></span>
 6244 |     | <span class='unexecuted'>function setTag0(</span>
 6245 |     | <span class='neutral'>  Tag tag0</span>
 6246 |     | <span class='neutral'>) pure {</span>
 6247 |     | <span class='unexecuted'>  assembly {</span>
 6248 |     | <span class='neutral'>    mstore(_tag0_, tag0)</span>
 6249 |     | <span class='neutral'>  }</span>
 6250 |     | <span class='neutral'>}</span>
 6251 |     | <span class='neutral'></span>
 6252 |     | <span class='neutral'>function getTag1() pure returns (</span>
 6253 |     | <span class='neutral'>  Tag tag1</span>
 6254 |     | <span class='neutral'>) {</span>
 6255 |     | <span class='neutral'>  assembly {</span>
 6256 |     | <span class='neutral'>    tag1 := mload(_tag1_)</span>
 6257 |     | <span class='neutral'>  }</span>
 6258 |     | <span class='neutral'>}</span>
 6259 |     | <span class='neutral'></span>
 6260 |     | <span class='unexecuted'>function setTag1(</span>
 6261 |     | <span class='neutral'>  Tag tag1</span>
 6262 |     | <span class='neutral'>) pure {</span>
 6263 |     | <span class='unexecuted'>  assembly {</span>
 6264 |     | <span class='neutral'>    mstore(_tag1_, tag1)</span>
 6265 |     | <span class='neutral'>  }</span>
 6266 |     | <span class='neutral'>}</span>
 6267 |     | <span class='neutral'></span>
 6268 |     | <span class='neutral'>function getSqrtOffset() pure returns (</span>
 6269 |     | <span class='neutral'>  X127 sqrtOffset</span>
 6270 |     | <span class='neutral'>) {</span>
 6271 |     | <span class='neutral'>  assembly {</span>
 6272 |     | <span class='neutral'>    sqrtOffset := mload(_sqrtOffset_)</span>
 6273 |     | <span class='neutral'>  }</span>
 6274 |     | <span class='neutral'>}</span>
 6275 |     | <span class='neutral'></span>
 6276 |     | <span class='unexecuted'>function setSqrtOffset(</span>
 6277 |     | <span class='neutral'>  X127 sqrtOffset</span>
 6278 |     | <span class='neutral'>) pure {</span>
 6279 |     | <span class='unexecuted'>  assembly {</span>
 6280 |     | <span class='neutral'>    mstore(_sqrtOffset_, sqrtOffset)</span>
 6281 |     | <span class='neutral'>  }</span>
 6282 |     | <span class='neutral'>}</span>
 6283 |     | <span class='neutral'></span>
 6284 |     | <span class='neutral'>function getSqrtInverseOffset() pure returns (</span>
 6285 |     | <span class='neutral'>  X127 sqrtInverseOffset</span>
 6286 |     | <span class='neutral'>) {</span>
 6287 |     | <span class='neutral'>  assembly {</span>
 6288 |     | <span class='neutral'>    sqrtInverseOffset := mload(_sqrtInverseOffset_)</span>
 6289 |     | <span class='neutral'>  }</span>
 6290 |     | <span class='neutral'>}</span>
 6291 |     | <span class='neutral'></span>
 6292 |     | <span class='unexecuted'>function setSqrtInverseOffset(</span>
 6293 |     | <span class='neutral'>  X127 sqrtInverseOffset</span>
 6294 |     | <span class='neutral'>) pure {</span>
 6295 |     | <span class='unexecuted'>  assembly {</span>
 6296 |     | <span class='neutral'>    mstore(_sqrtInverseOffset_, sqrtInverseOffset)</span>
 6297 |     | <span class='neutral'>  }</span>
 6298 |     | <span class='neutral'>}</span>
 6299 |     | <span class='neutral'></span>
 6300 |     | <span class='neutral'>function getOutgoingMax() pure returns (</span>
 6301 |     | <span class='neutral'>  X216 outgoingMax</span>
 6302 |     | <span class='neutral'>) {</span>
 6303 |     | <span class='neutral'>  assembly {</span>
 6304 |     | <span class='neutral'>    outgoingMax := shr(40, mload(_outgoingMax_))</span>
 6305 |     | <span class='neutral'>  }</span>
 6306 |     | <span class='neutral'>}</span>
 6307 |     | <span class='neutral'></span>
 6308 |     | <span class='neutral'>function setOutgoingMax(</span>
 6309 |     | <span class='neutral'>  X216 outgoingMax</span>
 6310 |     | <span class='neutral'>) pure {</span>
 6311 |     | <span class='neutral'>  assembly {</span>
 6312 |     | <span class='neutral'>    mstore(</span>
 6313 |     | <span class='neutral'>      _outgoingMax_,</span>
 6314 |     | <span class='neutral'>      or(</span>
 6315 |     | <span class='neutral'>        shl(40, outgoingMax),</span>
 6316 |     | <span class='neutral'>        shr(216, mload(add(_outgoingMax_, 27)))</span>
 6317 |     | <span class='neutral'>      )</span>
 6318 |     | <span class='neutral'>    )</span>
 6319 |     | <span class='neutral'>  }</span>
 6320 |     | <span class='neutral'>}</span>
 6321 |     | <span class='neutral'></span>
 6322 |     | <span class='neutral'>function getOutgoingMaxModularInverse() pure returns (</span>
 6323 |     | <span class='neutral'>  uint256 outgoingMaxModularInverse</span>
 6324 |     | <span class='neutral'>) {</span>
 6325 |     | <span class='neutral'>  assembly {</span>
 6326 |     | <span class='neutral'>    outgoingMaxModularInverse := mload(_outgoingMaxModularInverse_)</span>
 6327 |     | <span class='neutral'>  }</span>
 6328 |     | <span class='neutral'>}</span>
 6329 |     | <span class='neutral'></span>
 6330 |     | <span class='neutral'>function setOutgoingMaxModularInverse(</span>
 6331 |     | <span class='neutral'>  uint256 outgoingMaxModularInverse</span>
 6332 |     | <span class='neutral'>) pure {</span>
 6333 |     | <span class='neutral'>  assembly {</span>
 6334 |     | <span class='neutral'>    mstore(_outgoingMaxModularInverse_, outgoingMaxModularInverse)</span>
 6335 |     | <span class='neutral'>  }</span>
 6336 |     | <span class='neutral'>}</span>
 6337 |     | <span class='neutral'></span>
 6338 |     | <span class='neutral'>function getIncomingMax() pure returns (</span>
 6339 |     | <span class='neutral'>  X216 incomingMax</span>
 6340 |     | <span class='neutral'>) {</span>
 6341 |     | <span class='neutral'>  assembly {</span>
 6342 |     | <span class='neutral'>    incomingMax := shr(40, mload(_incomingMax_))</span>
 6343 |     | <span class='neutral'>  }</span>
 6344 |     | <span class='neutral'>}</span>
 6345 |     | <span class='neutral'></span>
 6346 |     | <span class='neutral'>function setIncomingMax(</span>
 6347 |     | <span class='neutral'>  X216 incomingMax</span>
 6348 |     | <span class='neutral'>) pure {</span>
 6349 |     | <span class='neutral'>  assembly {</span>
 6350 |     | <span class='neutral'>    mstore(</span>
 6351 |     | <span class='neutral'>      _incomingMax_,</span>
 6352 |     | <span class='neutral'>      or(</span>
 6353 |     | <span class='neutral'>        shl(40, incomingMax),</span>
 6354 |     | <span class='neutral'>        shr(216, mload(add(_incomingMax_, 27)))</span>
 6355 |     | <span class='neutral'>      )</span>
 6356 |     | <span class='neutral'>    )</span>
 6357 |     | <span class='neutral'>  }</span>
 6358 |     | <span class='neutral'>}</span>
 6359 |     | <span class='neutral'></span>
 6360 |     | <span class='neutral'>function getPoolGrowthPortion() pure returns (</span>
 6361 |     | <span class='neutral'>  X47 poolGrowthPortion</span>
 6362 |     | <span class='neutral'>) {</span>
 6363 |     | <span class='neutral'>  assembly {</span>
 6364 |     | <span class='neutral'>    poolGrowthPortion := shr(208, mload(_poolGrowthPortion_))</span>
 6365 |     | <span class='neutral'>  }</span>
 6366 |     | <span class='neutral'>}</span>
 6367 |     | <span class='neutral'></span>
 6368 |     | <span class='unexecuted'>function setPoolGrowthPortion(</span>
 6369 |     | <span class='neutral'>  X47 poolGrowthPortion</span>
 6370 |     | <span class='neutral'>) pure {</span>
 6371 |     | <span class='unexecuted'>  assembly {</span>
 6372 |     | <span class='neutral'>    mstore(</span>
 6373 |     | <span class='neutral'>      _poolGrowthPortion_,</span>
 6374 |     | <span class='neutral'>      or(</span>
 6375 |     | <span class='neutral'>        shl(208, poolGrowthPortion),</span>
 6376 |     | <span class='neutral'>        shr(48, mload(add(_poolGrowthPortion_, 6)))</span>
 6377 |     | <span class='neutral'>      )</span>
 6378 |     | <span class='neutral'>    )</span>
 6379 |     | <span class='neutral'>  }</span>
 6380 |     | <span class='neutral'>}</span>
 6381 |     | <span class='neutral'></span>
 6382 |     | <span class='neutral'>function getMaxPoolGrowthPortion() pure returns (</span>
 6383 |     | <span class='neutral'>  X47 maxPoolGrowthPortion</span>
 6384 |     | <span class='neutral'>) {</span>
 6385 |     | <span class='neutral'>  assembly {</span>
 6386 |     | <span class='neutral'>    maxPoolGrowthPortion := shr(208, mload(_maxPoolGrowthPortion_))</span>
 6387 |     | <span class='neutral'>  }</span>
 6388 |     | <span class='neutral'>}</span>
 6389 |     | <span class='neutral'></span>
 6390 |     | <span class='neutral'>function setMaxPoolGrowthPortion(</span>
 6391 |     | <span class='neutral'>  X47 maxPoolGrowthPortion</span>
 6392 |     | <span class='neutral'>) pure {</span>
 6393 |     | <span class='neutral'>  assembly {</span>
 6394 |     | <span class='neutral'>    mstore(</span>
 6395 |     | <span class='neutral'>      _maxPoolGrowthPortion_,</span>
 6396 |     | <span class='neutral'>      or(</span>
 6397 |     | <span class='neutral'>        shl(208, maxPoolGrowthPortion),</span>
 6398 |     | <span class='neutral'>        shr(48, mload(add(_maxPoolGrowthPortion_, 6)))</span>
 6399 |     | <span class='neutral'>      )</span>
 6400 |     | <span class='neutral'>    )</span>
 6401 |     | <span class='neutral'>  }</span>
 6402 |     | <span class='neutral'>}</span>
 6403 |     | <span class='neutral'></span>
 6404 |     | <span class='neutral'>function getProtocolGrowthPortion() pure returns (</span>
 6405 |     | <span class='neutral'>  X47 protocolGrowthPortion</span>
 6406 |     | <span class='neutral'>) {</span>
 6407 |     | <span class='neutral'>  assembly {</span>
 6408 |     | <span class='neutral'>    protocolGrowthPortion := shr(208, mload(_protocolGrowthPortion_))</span>
 6409 |     | <span class='neutral'>  }</span>
 6410 |     | <span class='neutral'>}</span>
 6411 |     | <span class='neutral'></span>
 6412 |     | <span class='neutral'>function setProtocolGrowthPortion(</span>
 6413 |     | <span class='neutral'>  X47 protocolGrowthPortion</span>
 6414 |     | <span class='neutral'>) pure {</span>
 6415 |     | <span class='neutral'>  assembly {</span>
 6416 |     | <span class='neutral'>    mstore(</span>
 6417 |     | <span class='neutral'>      _protocolGrowthPortion_,</span>
 6418 |     | <span class='neutral'>      or(</span>
 6419 |     | <span class='neutral'>        shl(208, protocolGrowthPortion),</span>
 6420 |     | <span class='neutral'>        shr(48, mload(add(_protocolGrowthPortion_, 6)))</span>
 6421 |     | <span class='neutral'>      )</span>
 6422 |     | <span class='neutral'>    )</span>
 6423 |     | <span class='neutral'>  }</span>
 6424 |     | <span class='neutral'>}</span>
 6425 |     | <span class='neutral'></span>
 6426 |     | <span class='neutral'>function getPendingKernelLength() pure returns (</span>
 6427 |     | <span class='neutral'>  Index pendingKernelLength</span>
 6428 |     | <span class='neutral'>) {</span>
 6429 |     | <span class='neutral'>  assembly {</span>
 6430 |     | <span class='neutral'>    pendingKernelLength := shr(240, mload(_pendingKernelLength_))</span>
 6431 |     | <span class='neutral'>  }</span>
 6432 |     | <span class='neutral'>}</span>
 6433 |     | <span class='neutral'></span>
 6434 |     | <span class='neutral'>function setPendingKernelLength(</span>
 6435 |     | <span class='neutral'>  Index pendingKernelLength</span>
 6436 |     | <span class='neutral'>) pure {</span>
 6437 |     | <span class='neutral'>  assembly {</span>
 6438 |     | <span class='neutral'>    mstore(</span>
 6439 |     | <span class='neutral'>      _pendingKernelLength_,</span>
 6440 |     | <span class='neutral'>      or(</span>
 6441 |     | <span class='neutral'>        shl(240, pendingKernelLength),</span>
 6442 |     | <span class='neutral'>        shr(16, mload(add(_pendingKernelLength_, 2)))</span>
 6443 |     | <span class='neutral'>      )</span>
 6444 |     | <span class='neutral'>    )</span>
 6445 |     | <span class='neutral'>  }</span>
 6446 |     | <span class='neutral'>}</span>
 6447 |     | <span class='neutral'></span>
 6448 |     | <span class='neutral'>function getLogPriceMinOffsetted() pure returns (</span>
 6449 |     | <span class='neutral'>  X59 logPriceMinOffsetted</span>
 6450 |     | <span class='neutral'>) {</span>
 6451 |     | <span class='neutral'>  assembly {</span>
 6452 |     | <span class='neutral'>    logPriceMinOffsetted := shr(192, mload(_logPriceMinOffsetted_))</span>
 6453 |     | <span class='neutral'>  }</span>
 6454 |     | <span class='neutral'>}</span>
 6455 |     | <span class='neutral'></span>
 6456 |     | <span class='unexecuted'>function setLogPriceMinOffsetted(</span>
 6457 |     | <span class='neutral'>  X59 logPriceMinOffsetted</span>
 6458 |     | <span class='neutral'>) pure {</span>
 6459 |     | <span class='unexecuted'>  assembly {</span>
 6460 |     | <span class='neutral'>    mstore(</span>
 6461 |     | <span class='neutral'>      _logPriceMinOffsetted_,</span>
 6462 |     | <span class='neutral'>      or(</span>
 6463 |     | <span class='neutral'>        shl(192, logPriceMinOffsetted),</span>
 6464 |     | <span class='neutral'>        shr(64, mload(add(_logPriceMinOffsetted_, 8)))</span>
 6465 |     | <span class='neutral'>      )</span>
 6466 |     | <span class='neutral'>    )</span>
 6467 |     | <span class='neutral'>  }</span>
 6468 |     | <span class='neutral'>}</span>
 6469 |     | <span class='neutral'></span>
 6470 |     | <span class='neutral'>function getLogPriceMaxOffsetted() pure returns (</span>
 6471 |     | <span class='neutral'>  X59 logPriceMaxOffsetted</span>
 6472 |     | <span class='neutral'>) {</span>
 6473 |     | <span class='neutral'>  assembly {</span>
 6474 |     | <span class='neutral'>    logPriceMaxOffsetted := shr(192, mload(_logPriceMaxOffsetted_))</span>
 6475 |     | <span class='neutral'>  }</span>
 6476 |     | <span class='neutral'>}</span>
 6477 |     | <span class='neutral'></span>
 6478 |     | <span class='unexecuted'>function setLogPriceMaxOffsetted(</span>
 6479 |     | <span class='neutral'>  X59 logPriceMaxOffsetted</span>
 6480 |     | <span class='neutral'>) pure {</span>
 6481 |     | <span class='unexecuted'>  assembly {</span>
 6482 |     | <span class='neutral'>    mstore(</span>
 6483 |     | <span class='neutral'>      _logPriceMaxOffsetted_,</span>
 6484 |     | <span class='neutral'>      or(</span>
 6485 |     | <span class='neutral'>        shl(192, logPriceMaxOffsetted),</span>
 6486 |     | <span class='neutral'>        shr(64, mload(add(_logPriceMaxOffsetted_, 8)))</span>
 6487 |     | <span class='neutral'>      )</span>
 6488 |     | <span class='neutral'>    )</span>
 6489 |     | <span class='neutral'>  }</span>
 6490 |     | <span class='neutral'>}</span>
 6491 |     | <span class='neutral'></span>
 6492 |     | <span class='neutral'>function getShares() pure returns (</span>
 6493 |     | <span class='neutral'>  int256 shares</span>
 6494 |     | <span class='neutral'>) {</span>
 6495 |     | <span class='neutral'>  assembly {</span>
 6496 |     | <span class='neutral'>    shares := mload(_shares_)</span>
 6497 |     | <span class='neutral'>  }</span>
 6498 |     | <span class='neutral'>}</span>
 6499 |     | <span class='neutral'></span>
 6500 |     | <span class='unexecuted'>function setShares(</span>
 6501 |     | <span class='neutral'>  int256 shares</span>
 6502 |     | <span class='neutral'>) pure {</span>
 6503 |     | <span class='unexecuted'>  assembly {</span>
 6504 |     | <span class='neutral'>    mstore(_shares_, shares)</span>
 6505 |     | <span class='neutral'>  }</span>
 6506 |     | <span class='neutral'>}</span>
 6507 |     | <span class='neutral'></span>
 6508 |     | <span class='neutral'>function getLogPriceMin() pure returns (</span>
 6509 |     | <span class='neutral'>  X59 logPriceMin</span>
 6510 |     | <span class='neutral'>) {</span>
 6511 |     | <span class='neutral'>  assembly {</span>
 6512 |     | <span class='neutral'>    logPriceMin := mload(_logPriceMin_)</span>
 6513 |     | <span class='neutral'>  }</span>
 6514 |     | <span class='neutral'>}</span>
 6515 |     | <span class='neutral'></span>
 6516 |     | <span class='unexecuted'>function setLogPriceMin(</span>
 6517 |     | <span class='neutral'>  X59 logPriceMin</span>
 6518 |     | <span class='neutral'>) pure {</span>
 6519 |     | <span class='unexecuted'>  assembly {</span>
 6520 |     | <span class='neutral'>    mstore(_logPriceMin_, logPriceMin)</span>
 6521 |     | <span class='neutral'>  }</span>
 6522 |     | <span class='neutral'>}</span>
 6523 |     | <span class='neutral'></span>
 6524 |     | <span class='neutral'>function getLogPriceMax() pure returns (</span>
 6525 |     | <span class='neutral'>  X59 logPriceMax</span>
 6526 |     | <span class='neutral'>) {</span>
 6527 |     | <span class='neutral'>  assembly {</span>
 6528 |     | <span class='neutral'>    logPriceMax := mload(_logPriceMax_)</span>
 6529 |     | <span class='neutral'>  }</span>
 6530 |     | <span class='neutral'>}</span>
 6531 |     | <span class='neutral'></span>
 6532 |     | <span class='unexecuted'>function setLogPriceMax(</span>
 6533 |     | <span class='neutral'>  X59 logPriceMax</span>
 6534 |     | <span class='neutral'>) pure {</span>
 6535 |     | <span class='unexecuted'>  assembly {</span>
 6536 |     | <span class='neutral'>    mstore(_logPriceMax_, logPriceMax)</span>
 6537 |     | <span class='neutral'>  }</span>
 6538 |     | <span class='neutral'>}</span>
 6539 |     | <span class='neutral'></span>
 6540 |     | <span class='neutral'>function getPositionAmount0() pure returns (</span>
 6541 |     | <span class='neutral'>  int256 positionAmount0</span>
 6542 |     | <span class='neutral'>) {</span>
 6543 |     | <span class='neutral'>  assembly {</span>
 6544 |     | <span class='neutral'>    positionAmount0 := mload(_positionAmount0_)</span>
 6545 |     | <span class='neutral'>  }</span>
 6546 |     | <span class='neutral'>}</span>
 6547 |     | <span class='neutral'></span>
 6548 |     | <span class='neutral'>function setPositionAmount0(</span>
 6549 |     | <span class='neutral'>  int256 positionAmount0</span>
 6550 |     | <span class='neutral'>) pure {</span>
 6551 |     | <span class='neutral'>  assembly {</span>
 6552 |     | <span class='neutral'>    mstore(_positionAmount0_, positionAmount0)</span>
 6553 |     | <span class='neutral'>  }</span>
 6554 |     | <span class='neutral'>}</span>
 6555 |     | <span class='neutral'></span>
 6556 |     | <span class='neutral'>function getPositionAmount1() pure returns (</span>
 6557 |     | <span class='neutral'>  int256 positionAmount1</span>
 6558 |     | <span class='neutral'>) {</span>
 6559 |     | <span class='neutral'>  assembly {</span>
 6560 |     | <span class='neutral'>    positionAmount1 := mload(_positionAmount1_)</span>
 6561 |     | <span class='neutral'>  }</span>
 6562 |     | <span class='neutral'>}</span>
 6563 |     | <span class='neutral'></span>
 6564 |     | <span class='neutral'>function setPositionAmount1(</span>
 6565 |     | <span class='neutral'>  int256 positionAmount1</span>
 6566 |     | <span class='neutral'>) pure {</span>
 6567 |     | <span class='neutral'>  assembly {</span>
 6568 |     | <span class='neutral'>    mstore(_positionAmount1_, positionAmount1)</span>
 6569 |     | <span class='neutral'>  }</span>
 6570 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/PoolId.sol</b>
<code>
  1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {X59} from &quot;./X59.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @notice Extracts &#39;(2 ** 59) * log(pOffset)&#39; from poolId.</span>
  7 |     | <span class='unexecuted'>function getLogOffsetFromPoolId(</span>
  8 |     | <span class='neutral'>  uint256 poolId</span>
  9 |     | <span class='neutral'>) pure returns (</span>
 10 |     | <span class='unexecuted'>  X59 logOffset</span>
 11 |     | <span class='neutral'>) {</span>
 12 |     | <span class='unexecuted'>  assembly {</span>
 13 |     | <span class='neutral'>    // Bits 181 to 188 of poolId represent an 8-bit integer in two&#39;s</span>
 14 |     | <span class='neutral'>    // complement which is equal to the natural logarithm of &#39;pOffset&#39;. We</span>
 15 |     | <span class='neutral'>    // extract this value and convert it to an &#39;int256&#39; by extending its sign</span>
 16 |     | <span class='neutral'>    // bit. Next, we multiply it by &#39;2 ** 59&#39; to obtain &#39;log(pOffset)&#39; in &#39;X59&#39;</span>
 17 |     | <span class='neutral'>    // representation.</span>
 18 |     | <span class='neutral'>    logOffset := mul(shl(59, 1), signextend(0, shr(180, poolId)))</span>
 19 |     | <span class='neutral'>  }</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>/// @notice Derives &#39;poolId&#39; based on the following rule:</span>
 23 |     | <span class='neutral'>///</span>
 24 |     | <span class='neutral'>/// &#39;poolId = unsaltedPoolId + (</span>
 25 |     | <span class='neutral'>///     keccak256(abi.encodePacked(msg.sender, unsaltedPoolId)) &lt;&lt; 188</span>
 26 |     | <span class='neutral'>///  )&#39;</span>
 27 |     | <span class='neutral'>///</span>
 28 |     | <span class='unexecuted'>function derivePoolId(</span>
 29 |     | <span class='neutral'>  uint256 unsaltedPoolId</span>
 30 |     | <span class='neutral'>) view returns (</span>
 31 |     | <span class='unexecuted'>  uint256 poolId</span>
 32 |     | <span class='neutral'>) {</span>
 33 |     | <span class='unexecuted'>  assembly {</span>
 34 |     | <span class='neutral'>    mstore(0, shl(96, caller()))</span>
 35 |     | <span class='neutral'>    mstore(20, unsaltedPoolId)</span>
 36 |     | <span class='neutral'>    poolId := add(unsaltedPoolId, shl(188, keccak256(0, 52)))</span>
 37 |     | <span class='neutral'>  }</span>
 38 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/Price.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {X15} from &quot;./X15.sol&quot;;</span>
   5 |     | <span class='neutral'>import {X59} from &quot;./X59.sol&quot;;</span>
   6 |     | <span class='neutral'>import {X216} from &quot;./X216.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='unexecuted'>library PriceLibrary {</span>
   9 |     | <span class='neutral'>  using PriceLibrary for uint256;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>  /// @notice Stores a given price in a given memory location with the </span>
  12 |     | <span class='neutral'>  /// following layout:</span>
  13 |     | <span class='neutral'>  ///</span>
  14 |     | <span class='neutral'>  ///  pointer</span>
  15 |     | <span class='neutral'>  ///     |</span>
  16 |     | <span class='neutral'>  ///     +--------+---------------------------+---------------------------+</span>
  17 |     | <span class='neutral'>  ///     | 8 byte |          27 byte          |          27 byte          |</span>
  18 |     | <span class='neutral'>  ///     +--------+---------------------------+---------------------------+</span>
  19 |     | <span class='neutral'>  ///     |        |                           |</span>
  20 |     | <span class='neutral'>  ///     |        |                            \</span>
  21 |     | <span class='neutral'>  ///     |        |                             sqrtInversePrice</span>
  22 |     | <span class='neutral'>  ///     |         \</span>
  23 |     | <span class='neutral'>  ///     |          sqrtPrice</span>
  24 |     | <span class='neutral'>  ///      \</span>
  25 |     | <span class='neutral'>  ///       logPrice</span>
  26 |     | <span class='neutral'>  ///</span>
  27 |     | <span class='neutral'>  /// &#39;pointer&#39; should not be less than &#39;32&#39;.</span>
  28 |     | <span class='neutral'>  /// &#39;logPrice&#39; should be non-negative and less than &#39;2 ** 64&#39;.</span>
  29 |     | <span class='neutral'>  /// &#39;sqrtPrice&#39; should be non-negative and less than &#39;oneX216&#39;.</span>
  30 |     | <span class='neutral'>  /// &#39;sqrtInversePrice&#39; should be non-negative and less than &#39;oneX216&#39;.</span>
  31 |     | <span class='neutral'>  function storePrice(</span>
  32 |     | <span class='neutral'>    uint256 pointer,</span>
  33 |     | <span class='neutral'>    X59 logPrice,</span>
  34 |     | <span class='neutral'>    X216 sqrtPrice,</span>
  35 |     | <span class='neutral'>    X216 sqrtInversePrice</span>
  36 |     | <span class='neutral'>  ) internal pure {</span>
  37 |     | <span class='neutral'>    assembly {</span>
  38 |     | <span class='neutral'>      // The preceding slot is cached so that it can be restored after we place</span>
  39 |     | <span class='neutral'>      // all values in their appropriate memory locations.</span>
  40 |     | <span class='neutral'>      // The subtraction is safe because of the input requirement on &#39;pointer&#39;.</span>
  41 |     | <span class='neutral'>      let precedingPointer := sub(pointer, 32)</span>
  42 |     | <span class='neutral'>      let precedingSlot := mload(precedingPointer)</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>      // We move &#39;64 + 216 + 216&#39; bits forward to reach the following location:</span>
  45 |     | <span class='neutral'>      //</span>
  46 |     | <span class='neutral'>      //                                                          pointer + 62</span>
  47 |     | <span class='neutral'>      //                                                                  \</span>
  48 |     | <span class='neutral'>      //                                                                   |</span>
  49 |     | <span class='neutral'>      //  +--------+---------------------------+---------------------------+</span>
  50 |     | <span class='neutral'>      //  | 8 byte |          27 byte          |          27 byte          |</span>
  51 |     | <span class='neutral'>      //  +--------+---------------------------+---------------------------+</span>
  52 |     | <span class='neutral'>      //  |        |                           |</span>
  53 |     | <span class='neutral'>      //  |        |                            \</span>
  54 |     | <span class='neutral'>      //  |        |                             sqrtInversePrice</span>
  55 |     | <span class='neutral'>      //  |         \</span>
  56 |     | <span class='neutral'>      //  |          sqrtPrice</span>
  57 |     | <span class='neutral'>      //   \</span>
  58 |     | <span class='neutral'>      //    logPrice</span>
  59 |     | <span class='neutral'>      //</span>
  60 |     | <span class='neutral'>      // Then we move &#39;256&#39; bits backward to point to the beginning of the slot</span>
  61 |     | <span class='neutral'>      // whose least significant &#39;216&#39; bits are supposed to host</span>
  62 |     | <span class='neutral'>      // &#39;sqrtInversePrice&#39;.</span>
  63 |     | <span class='neutral'>      //</span>
  64 |     | <span class='neutral'>      // &#39;64 + 216 + 216 - 256&#39; bits == &#39;30&#39; bytes.</span>
  65 |     | <span class='neutral'>      mstore(add(pointer, 30), sqrtInversePrice)</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>      // We move &#39;64 + 216&#39; bits forward to reach the following location:</span>
  68 |     | <span class='neutral'>      //</span>
  69 |     | <span class='neutral'>      //                                  pointer + 35</span>
  70 |     | <span class='neutral'>      //                                       |</span>
  71 |     | <span class='neutral'>      //  +--------+---------------------------+---------------------------+</span>
  72 |     | <span class='neutral'>      //  | 8 byte |          27 byte          |          27 byte          |</span>
  73 |     | <span class='neutral'>      //  +--------+---------------------------+---------------------------+</span>
  74 |     | <span class='neutral'>      //  |        |                           |</span>
  75 |     | <span class='neutral'>      //  |        |                            \</span>
  76 |     | <span class='neutral'>      //  |        |                             sqrtInversePrice</span>
  77 |     | <span class='neutral'>      //  |         \</span>
  78 |     | <span class='neutral'>      //  |          sqrtPrice</span>
  79 |     | <span class='neutral'>      //   \</span>
  80 |     | <span class='neutral'>      //    logPrice</span>
  81 |     | <span class='neutral'>      //</span>
  82 |     | <span class='neutral'>      // Then we move &#39;256&#39; bits backward to point to the beginning of the slot</span>
  83 |     | <span class='neutral'>      // whose least significant &#39;216&#39; bits are supposed to host &#39;sqrtPrice&#39;.</span>
  84 |     | <span class='neutral'>      //</span>
  85 |     | <span class='neutral'>      // &#39;64 + 216 - 256&#39; bits == &#39;3&#39; bytes.</span>
  86 |     | <span class='neutral'>      mstore(add(pointer, 3), sqrtPrice)</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>      // We move &#39;64&#39; bits forward to reach the following location:</span>
  89 |     | <span class='neutral'>      //</span>
  90 |     | <span class='neutral'>      //      pointer + 8</span>
  91 |     | <span class='neutral'>      //           |</span>
  92 |     | <span class='neutral'>      //  +--------+---------------------------+---------------------------+</span>
  93 |     | <span class='neutral'>      //  | 8 byte |          27 byte          |          27 byte          |</span>
  94 |     | <span class='neutral'>      //  +--------+---------------------------+---------------------------+</span>
  95 |     | <span class='neutral'>      //  |        |                           |</span>
  96 |     | <span class='neutral'>      //  |        |                            \</span>
  97 |     | <span class='neutral'>      //  |        |                             sqrtInversePrice</span>
  98 |     | <span class='neutral'>      //  |         \</span>
  99 |     | <span class='neutral'>      //  |          sqrtPrice</span>
 100 |     | <span class='neutral'>      //   \</span>
 101 |     | <span class='neutral'>      //    logPrice</span>
 102 |     | <span class='neutral'>      //</span>
 103 |     | <span class='neutral'>      // Then we move &#39;256&#39; bits backward to point to the beginning of the slot</span>
 104 |     | <span class='neutral'>      // whose least significant &#39;64&#39; bits are supposed to host &#39;logPrice&#39;.</span>
 105 |     | <span class='neutral'>      //</span>
 106 |     | <span class='neutral'>      // &#39;64 - 256&#39; bits == &#39;-24&#39; bytes.</span>
 107 |     | <span class='neutral'>      //</span>
 108 |     | <span class='neutral'>      // The subtraction is safe because of the input requirement on &#39;pointer&#39;.</span>
 109 |     | <span class='neutral'>      mstore(sub(pointer, 24), logPrice)</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>      // The preceding slot is restored.</span>
 112 |     | <span class='neutral'>      mstore(precedingPointer, precedingSlot)</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'>  }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>  /// @notice Calculates the sqrt and sqrtInverse of a given logPrice and</span>
 117 |     | <span class='neutral'>  /// stores everything in the given memory location with the following</span>
 118 |     | <span class='neutral'>  /// layout:</span>
 119 |     | <span class='neutral'>  ///</span>
 120 |     | <span class='neutral'>  ///  pointer</span>
 121 |     | <span class='neutral'>  ///     |</span>
 122 |     | <span class='neutral'>  ///     +--------+---------------------------+---------------------------+</span>
 123 |     | <span class='neutral'>  ///     | 8 byte |          27 byte          |          27 byte          |</span>
 124 |     | <span class='neutral'>  ///     +--------+---------------------------+---------------------------+</span>
 125 |     | <span class='neutral'>  ///     |        |                           |</span>
 126 |     | <span class='neutral'>  ///     |        |                            \</span>
 127 |     | <span class='neutral'>  ///     |        |                             sqrtInversePrice</span>
 128 |     | <span class='neutral'>  ///     |         \</span>
 129 |     | <span class='neutral'>  ///     |          sqrtPrice</span>
 130 |     | <span class='neutral'>  ///      \</span>
 131 |     | <span class='neutral'>  ///       logPrice</span>
 132 |     | <span class='neutral'>  ///</span>
 133 |     | <span class='neutral'>  /// &#39;pointer&#39; should not be less than &#39;32&#39; and &#39;pointer + 30&#39; should not</span>
 134 |     | <span class='neutral'>  /// overflow.</span>
 135 |     | <span class='neutral'>  ///</span>
 136 |     | <span class='neutral'>  /// &#39;logPrice&#39; should be greater than 0 and less than (2 ** 64).</span>
 137 |     | <span class='neutral'>  function storePrice(</span>
 138 |     | <span class='neutral'>    uint256 pointer,</span>
 139 |     | <span class='neutral'>    X59 logPrice</span>
 140 |     | <span class='neutral'>  ) internal pure {</span>
 141 |     | <span class='neutral'>    // The requirements of &#39;exp&#39; are satisfied here because </span>
 142 |     | <span class='neutral'>    // &#39;0 &lt; logPrice &lt; 2 ** 64&#39;.</span>
 143 |     | <span class='neutral'>    (X216 sqrtPrice, X216 sqrtInversePrice) = logPrice.exp();</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>    // The requirements of &#39;storePrice&#39; are satisfied here, because of the</span>
 146 |     | <span class='neutral'>    // input requirement on &#39;pointer&#39; and because both outputs of &#39;exp&#39; are</span>
 147 |     | <span class='neutral'>    // less than &#39;oneX216&#39;:</span>
 148 |     | <span class='neutral'>    //</span>
 149 |     | <span class='neutral'>    // &#39;0 &lt; logPrice&#39; -&gt; &#39;(2 ** 216) * exp(- logPrice / (2 ** 60)) &lt; 2 ** 216&#39;</span>
 150 |     | <span class='neutral'>    //</span>
 151 |     | <span class='neutral'>    // &#39;logPrice &lt; 2 ** 64&#39; -&gt; </span>
 152 |     | <span class='neutral'>    // &#39;(2 ** 216) * exp(- 16 + logPrice / (2 ** 60)) &lt; 2 ** 216&#39;</span>
 153 |     | <span class='neutral'>    //</span>
 154 |     | <span class='neutral'>    pointer.storePrice(logPrice, sqrtPrice, sqrtInversePrice);</span>
 155 |     | <span class='neutral'>  }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>  /// @notice Stores a given price in a given memory location with the</span>
 158 |     | <span class='neutral'>  /// following layout:</span>
 159 |     | <span class='neutral'>  ///</span>
 160 |     | <span class='neutral'>  ///   pointer</span>
 161 |     | <span class='neutral'>  ///      |</span>
 162 |     | <span class='neutral'>  ///   +--+--------+---------------------------+---------------------------+</span>
 163 |     | <span class='neutral'>  ///   |  | 8 byte |          27 byte          |          27 byte          |</span>
 164 |     | <span class='neutral'>  ///   +--+--------+---------------------------+---------------------------+</span>
 165 |     | <span class='neutral'>  ///   |  |        |                           |</span>
 166 |     | <span class='neutral'>  ///   |  |        |                            \</span>
 167 |     | <span class='neutral'>  ///   |  |        |                             sqrtInversePrice</span>
 168 |     | <span class='neutral'>  ///   |  |         \</span>
 169 |     | <span class='neutral'>  ///   |  |          sqrtPrice</span>
 170 |     | <span class='neutral'>  ///   |   \</span>
 171 |     | <span class='neutral'>  ///   |    logPrice</span>
 172 |     | <span class='neutral'>  ///    \</span>
 173 |     | <span class='neutral'>  ///     heightPrice</span>
 174 |     | <span class='neutral'>  ///</span>
 175 |     | <span class='neutral'>  /// &#39;pointer&#39; should not be less than &#39;34&#39;.</span>
 176 |     | <span class='neutral'>  /// &#39;heightPrice&#39; should be less than or equal to &#39;oneX15&#39;.</span>
 177 |     | <span class='neutral'>  /// &#39;logPrice&#39; should be non-negative and less than (2 ** 64).</span>
 178 |     | <span class='neutral'>  /// &#39;sqrtPrice&#39; should be non-negative and less than &#39;oneX216&#39;.</span>
 179 |     | <span class='neutral'>  /// &#39;sqrtInversePrice&#39; should be non-negative and less than &#39;oneX216&#39;.</span>
 180 |     | <span class='neutral'>  function storePrice(</span>
 181 |     | <span class='neutral'>    uint256 pointer,</span>
 182 |     | <span class='neutral'>    X15 heightPrice,</span>
 183 |     | <span class='neutral'>    X59 logPrice,</span>
 184 |     | <span class='neutral'>    X216 sqrtPrice,</span>
 185 |     | <span class='neutral'>    X216 sqrtInversePrice</span>
 186 |     | <span class='neutral'>  ) internal pure {</span>
 187 |     | <span class='neutral'>    assembly {</span>
 188 |     | <span class='neutral'>      // The preceding slot is cached so that it can be restored after we place</span>
 189 |     | <span class='neutral'>      // all values in their appropriate memory location.</span>
 190 |     | <span class='neutral'>      // The subtraction is safe because of the input requirement on &#39;pointer&#39;.</span>
 191 |     | <span class='neutral'>      let precedingPointer := sub(pointer, 34)</span>
 192 |     | <span class='neutral'>      let precedingSlot := mload(precedingPointer)</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>      // We move &#39;64 + 216 + 216&#39; bits forward to reach the following location:</span>
 195 |     | <span class='neutral'>      //</span>
 196 |     | <span class='neutral'>      //                                                          pointer + 62</span>
 197 |     | <span class='neutral'>      //                                                                     \</span>
 198 |     | <span class='neutral'>      //                                                                      |</span>
 199 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 200 |     | <span class='neutral'>      //  |  | 8 byte |          27 byte          |          27 byte          |</span>
 201 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 202 |     | <span class='neutral'>      //  |  |        |                           |</span>
 203 |     | <span class='neutral'>      //  |  |        |                            \</span>
 204 |     | <span class='neutral'>      //  |  |        |                             sqrtInversePrice</span>
 205 |     | <span class='neutral'>      //  |  |         \</span>
 206 |     | <span class='neutral'>      //  |  |          sqrtPrice</span>
 207 |     | <span class='neutral'>      //  |   \</span>
 208 |     | <span class='neutral'>      //  |    logPrice</span>
 209 |     | <span class='neutral'>      //   \</span>
 210 |     | <span class='neutral'>      //    heightPrice</span>
 211 |     | <span class='neutral'>      //</span>
 212 |     | <span class='neutral'>      // Then we move &#39;256&#39; bits backward to point to the beginning of the slot</span>
 213 |     | <span class='neutral'>      // whose least significant &#39;216&#39; bits are supposed to host</span>
 214 |     | <span class='neutral'>      // &#39;sqrtInversePrice&#39;.</span>
 215 |     | <span class='neutral'>      //</span>
 216 |     | <span class='neutral'>      // &#39;64 + 216 + 216 - 256&#39; bits == &#39;30&#39; bytes.</span>
 217 |     | <span class='neutral'>      mstore(add(pointer, 30), sqrtInversePrice)</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>      // We move &#39;64 + 216&#39; bits forward to reach the following location:</span>
 220 |     | <span class='neutral'>      //</span>
 221 |     | <span class='neutral'>      //                                  pointer + 35</span>
 222 |     | <span class='neutral'>      //                                         \</span>
 223 |     | <span class='neutral'>      //                                          |</span>
 224 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 225 |     | <span class='neutral'>      //  |  | 8 byte |          27 byte          |          27 byte          |</span>
 226 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 227 |     | <span class='neutral'>      //  |  |        |                           |</span>
 228 |     | <span class='neutral'>      //  |  |        |                            \</span>
 229 |     | <span class='neutral'>      //  |  |        |                             sqrtInversePrice</span>
 230 |     | <span class='neutral'>      //  |  |         \</span>
 231 |     | <span class='neutral'>      //  |  |          sqrtPrice</span>
 232 |     | <span class='neutral'>      //  |   \</span>
 233 |     | <span class='neutral'>      //  |    logPrice</span>
 234 |     | <span class='neutral'>      //   \</span>
 235 |     | <span class='neutral'>      //    heightPrice</span>
 236 |     | <span class='neutral'>      //</span>
 237 |     | <span class='neutral'>      // Then we move &#39;256&#39; bits backward to point to the beginning of the slot</span>
 238 |     | <span class='neutral'>      // whose least significant &#39;216&#39; bits are supposed to host &#39;sqrtPrice&#39;.</span>
 239 |     | <span class='neutral'>      //</span>
 240 |     | <span class='neutral'>      // &#39;64 + 216 - 256&#39; bits == &#39;3&#39; bytes.</span>
 241 |     | <span class='neutral'>      mstore(add(pointer, 3), sqrtPrice)</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>      // We move &#39;64&#39; bits forward to reach the following location:</span>
 244 |     | <span class='neutral'>      //</span>
 245 |     | <span class='neutral'>      //      pointer + 8</span>
 246 |     | <span class='neutral'>      //             \</span>
 247 |     | <span class='neutral'>      //              |</span>
 248 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 249 |     | <span class='neutral'>      //  |  | 8 byte |          27 byte          |          27 byte          |</span>
 250 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 251 |     | <span class='neutral'>      //  |  |        |                           |</span>
 252 |     | <span class='neutral'>      //  |  |        |                            \</span>
 253 |     | <span class='neutral'>      //  |  |        |                             sqrtInversePrice</span>
 254 |     | <span class='neutral'>      //  |  |         \</span>
 255 |     | <span class='neutral'>      //  |  |          sqrtPrice</span>
 256 |     | <span class='neutral'>      //  |   \</span>
 257 |     | <span class='neutral'>      //  |    logPrice</span>
 258 |     | <span class='neutral'>      //   \</span>
 259 |     | <span class='neutral'>      //    heightPrice</span>
 260 |     | <span class='neutral'>      //</span>
 261 |     | <span class='neutral'>      // Then we move &#39;256&#39; bits backward to point to the beginning of the slot</span>
 262 |     | <span class='neutral'>      // whose least significant &#39;64&#39; bits are supposed to host &#39;logPrice&#39;.</span>
 263 |     | <span class='neutral'>      //</span>
 264 |     | <span class='neutral'>      // &#39;64 - 256&#39; bits == &#39;-24&#39; bytes.</span>
 265 |     | <span class='neutral'>      // The subtraction is safe because of the input requirement on &#39;pointer&#39;.</span>
 266 |     | <span class='neutral'>      mstore(sub(pointer, 24), logPrice)</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>      // We move &#39;256&#39; bits backward to point to the beginning of the slot</span>
 269 |     | <span class='neutral'>      // whose least significant &#39;16&#39; bits are supposed to host &#39;heightPrice&#39;.</span>
 270 |     | <span class='neutral'>      //</span>
 271 |     | <span class='neutral'>      // &#39;0 - 256&#39; bits == &#39;-32&#39; bytes.</span>
 272 |     | <span class='neutral'>      // The subtraction is safe because of the input requirement on &#39;pointer&#39;.</span>
 273 |     | <span class='neutral'>      mstore(sub(pointer, 32), heightPrice)</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='neutral'>      // The preceding slot is restored.</span>
 276 |     | <span class='neutral'>      mstore(precedingPointer, precedingSlot)</span>
 277 |     | <span class='neutral'>    }</span>
 278 |     | <span class='neutral'>  }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>  /// @notice Returns the height of a price given its memory pointer with the </span>
 281 |     | <span class='neutral'>  /// following layout:</span>
 282 |     | <span class='neutral'>  ///</span>
 283 |     | <span class='neutral'>  ///       pointer</span>
 284 |     | <span class='neutral'>  ///      /</span>
 285 |     | <span class='neutral'>  ///     |</span>
 286 |     | <span class='neutral'>  ///  +--+--------+---------------------------+---------------------------+</span>
 287 |     | <span class='neutral'>  ///  |  | 8 byte |          27 byte          |          27 byte          |</span>
 288 |     | <span class='neutral'>  ///  +--+--------+---------------------------+---------------------------+</span>
 289 |     | <span class='neutral'>  ///  |  |        |                           |</span>
 290 |     | <span class='neutral'>  ///  |  |        |                            \</span>
 291 |     | <span class='neutral'>  ///  |  |        |                             sqrtInversePrice</span>
 292 |     | <span class='neutral'>  ///  |  |         \</span>
 293 |     | <span class='neutral'>  ///  |  |          sqrtPrice</span>
 294 |     | <span class='neutral'>  ///  |   \</span>
 295 |     | <span class='neutral'>  ///  |    logPrice</span>
 296 |     | <span class='neutral'>  ///   \</span>
 297 |     | <span class='neutral'>  ///    heightPrice</span>
 298 |     | <span class='neutral'>  ///</span>
 299 |     | <span class='neutral'>  function height(</span>
 300 |     | <span class='neutral'>    uint256 pointer</span>
 301 |     | <span class='neutral'>  ) internal pure returns (</span>
 302 |     | <span class='neutral'>    X15 value</span>
 303 |     | <span class='neutral'>  ) {</span>
 304 |     | <span class='neutral'>    assembly {</span>
 305 |     | <span class='neutral'>      // We move &#39;2&#39; bytes backward to read the slot whose most significant</span>
 306 |     | <span class='neutral'>      // &#39;16&#39; bits host &#39;height&#39;.</span>
 307 |     | <span class='neutral'>      //</span>
 308 |     | <span class='neutral'>      //    pointer - 2</span>
 309 |     | <span class='neutral'>      //   /</span>
 310 |     | <span class='neutral'>      //  |</span>
 311 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 312 |     | <span class='neutral'>      //  |  | 8 byte |          27 byte          |          27 byte          |</span>
 313 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 314 |     | <span class='neutral'>      //  |  |        |                           |</span>
 315 |     | <span class='neutral'>      //  |  |        |                            \</span>
 316 |     | <span class='neutral'>      //  |  |        |                             sqrtInversePrice</span>
 317 |     | <span class='neutral'>      //  |  |         \</span>
 318 |     | <span class='neutral'>      //  |  |          sqrtPrice</span>
 319 |     | <span class='neutral'>      //  |   \</span>
 320 |     | <span class='neutral'>      //  |    logPrice</span>
 321 |     | <span class='neutral'>      //   \</span>
 322 |     | <span class='neutral'>      //    heightPrice</span>
 323 |     | <span class='neutral'>      //</span>
 324 |     | <span class='neutral'>      // Then we shift the content by &#39;240&#39; bits to the right in order to get</span>
 325 |     | <span class='neutral'>      // &#39;height&#39;.</span>
 326 |     | <span class='neutral'>      //</span>
 327 |     | <span class='neutral'>      // The subtraction is safe, because the pointer refer to a price with</span>
 328 |     | <span class='neutral'>      // height and therefore its value is not less than &#39;2&#39;.</span>
 329 |     | <span class='neutral'>      value := shr(240, mload(sub(pointer, 2)))</span>
 330 |     | <span class='neutral'>    }</span>
 331 |     | <span class='neutral'>  }</span>
 332 |     | <span class='neutral'></span>
 333 |     | <span class='neutral'>  /// @notice Returns the logarithm of a price given its memory pointer with</span>
 334 |     | <span class='neutral'>  /// the following layout:</span>
 335 |     | <span class='neutral'>  ///</span>
 336 |     | <span class='neutral'>  ///       pointer</span>
 337 |     | <span class='neutral'>  ///      /</span>
 338 |     | <span class='neutral'>  ///     |</span>
 339 |     | <span class='neutral'>  ///  +--+--------+---------------------------+---------------------------+</span>
 340 |     | <span class='neutral'>  ///  |  | 8 byte |          27 byte          |          27 byte          |</span>
 341 |     | <span class='neutral'>  ///  +--+--------+---------------------------+---------------------------+</span>
 342 |     | <span class='neutral'>  ///  |  |        |                           |</span>
 343 |     | <span class='neutral'>  ///  |  |        |                            \</span>
 344 |     | <span class='neutral'>  ///  |  |        |                             sqrtInversePrice</span>
 345 |     | <span class='neutral'>  ///  |  |         \</span>
 346 |     | <span class='neutral'>  ///  |  |          sqrtPrice</span>
 347 |     | <span class='neutral'>  ///  |   \</span>
 348 |     | <span class='neutral'>  ///  |    logPrice</span>
 349 |     | <span class='neutral'>  ///   \</span>
 350 |     | <span class='neutral'>  ///    heightPrice</span>
 351 |     | <span class='neutral'>  ///</span>
 352 |     | <span class='neutral'>  function log(</span>
 353 |     | <span class='neutral'>    uint256 pointer</span>
 354 |     | <span class='neutral'>  ) internal pure returns (</span>
 355 |     | <span class='neutral'>    X59 logPrice</span>
 356 |     | <span class='neutral'>  ) {</span>
 357 |     | <span class='neutral'>    assembly {</span>
 358 |     | <span class='neutral'>      // The given pointer refers to the slot whose most significant &#39;64&#39; bits</span>
 359 |     | <span class='neutral'>      // host &#39;logPrice&#39;. We read this slot and then we shift the content by</span>
 360 |     | <span class='neutral'>      // &#39;192&#39; bits to the right in order to get &#39;logPrice&#39;.</span>
 361 |     | <span class='neutral'>      logPrice := shr(192, mload(pointer))</span>
 362 |     | <span class='neutral'>    }</span>
 363 |     | <span class='neutral'>  }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>  /// @notice Returns the &#39;sqrtPrice&#39; or &#39;sqrtInversePrice&#39; given a memory </span>
 366 |     | <span class='neutral'>  /// pointer with the following layout:</span>
 367 |     | <span class='neutral'>  ///</span>
 368 |     | <span class='neutral'>  ///       pointer</span>
 369 |     | <span class='neutral'>  ///      /</span>
 370 |     | <span class='neutral'>  ///     |</span>
 371 |     | <span class='neutral'>  ///  +--+--------+---------------------------+---------------------------+</span>
 372 |     | <span class='neutral'>  ///  |  | 8 byte |          27 byte          |          27 byte          |</span>
 373 |     | <span class='neutral'>  ///  +--+--------+---------------------------+---------------------------+</span>
 374 |     | <span class='neutral'>  ///  |  |        |                           |</span>
 375 |     | <span class='neutral'>  ///  |  |        |                            \</span>
 376 |     | <span class='neutral'>  ///  |  |        |                             sqrtInversePrice</span>
 377 |     | <span class='neutral'>  ///  |  |         \</span>
 378 |     | <span class='neutral'>  ///  |  |          sqrtPrice</span>
 379 |     | <span class='neutral'>  ///  |   \</span>
 380 |     | <span class='neutral'>  ///  |    logPrice</span>
 381 |     | <span class='neutral'>  ///   \</span>
 382 |     | <span class='neutral'>  ///    heightPrice</span>
 383 |     | <span class='neutral'>  ///</span>
 384 |     | <span class='neutral'>  function sqrt(</span>
 385 |     | <span class='neutral'>    uint256 pointer,</span>
 386 |     | <span class='neutral'>    bool inverse</span>
 387 |     | <span class='neutral'>  ) internal pure returns (</span>
 388 |     | <span class='neutral'>    X216 value</span>
 389 |     | <span class='neutral'>  ) {</span>
 390 |     | <span class='neutral'>    assembly {</span>
 391 |     | <span class='neutral'>      // If &#39;inverse == true&#39; then we move &#39;35&#39; bytes forward to read the slot</span>
 392 |     | <span class='neutral'>      // whose most significant &#39;216&#39; bits host &#39;sqrtPriceInverse&#39;.</span>
 393 |     | <span class='neutral'>      //</span>
 394 |     | <span class='neutral'>      //                                  pointer + 35</span>
 395 |     | <span class='neutral'>      //                                         \</span>
 396 |     | <span class='neutral'>      //                                          |</span>
 397 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 398 |     | <span class='neutral'>      //  |  | 8 byte |          27 byte          |          27 byte          |</span>
 399 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 400 |     | <span class='neutral'>      //  |  |        |                           |</span>
 401 |     | <span class='neutral'>      //  |  |        |                            \</span>
 402 |     | <span class='neutral'>      //  |  |        |                             sqrtInversePrice</span>
 403 |     | <span class='neutral'>      //  |  |         \</span>
 404 |     | <span class='neutral'>      //  |  |          sqrtPrice</span>
 405 |     | <span class='neutral'>      //  |   \</span>
 406 |     | <span class='neutral'>      //  |    logPrice</span>
 407 |     | <span class='neutral'>      //   \</span>
 408 |     | <span class='neutral'>      //    heightPrice</span>
 409 |     | <span class='neutral'>      //</span>
 410 |     | <span class='neutral'>      // Then we shift the content by &#39;40&#39; bits to the right in order to get</span>
 411 |     | <span class='neutral'>      // &#39;sqrtPriceInverse&#39;.</span>
 412 |     | <span class='neutral'>      //</span>
 413 |     | <span class='neutral'>      // If &#39;inverse == false&#39; then we move &#39;8&#39; bytes forward to read the slot</span>
 414 |     | <span class='neutral'>      // whose most significant &#39;216&#39; bits host &#39;sqrtPrice&#39;.</span>
 415 |     | <span class='neutral'>      //</span>
 416 |     | <span class='neutral'>      //      pointer + 8</span>
 417 |     | <span class='neutral'>      //             \</span>
 418 |     | <span class='neutral'>      //              |</span>
 419 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 420 |     | <span class='neutral'>      //  |  | 8 byte |          27 byte          |          27 byte          |</span>
 421 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 422 |     | <span class='neutral'>      //  |  |        |                           |</span>
 423 |     | <span class='neutral'>      //  |  |        |                            \</span>
 424 |     | <span class='neutral'>      //  |  |        |                             sqrtInversePrice</span>
 425 |     | <span class='neutral'>      //  |  |         \</span>
 426 |     | <span class='neutral'>      //  |  |          sqrtPrice</span>
 427 |     | <span class='neutral'>      //  |   \</span>
 428 |     | <span class='neutral'>      //  |    logPrice</span>
 429 |     | <span class='neutral'>      //   \</span>
 430 |     | <span class='neutral'>      //    heightPrice</span>
 431 |     | <span class='neutral'>      //</span>
 432 |     | <span class='neutral'>      // Then we shift the content by &#39;40&#39; bits to the right in order to get</span>
 433 |     | <span class='neutral'>      // &#39;sqrtPrice&#39;.</span>
 434 |     | <span class='neutral'>      //</span>
 435 |     | <span class='neutral'>      // The additions and the multiplication are safe because </span>
 436 |     | <span class='neutral'>      // &#39;iszero(inverse)&#39; is a boolean.</span>
 437 |     | <span class='neutral'>      value := shr(</span>
 438 |     | <span class='neutral'>        40,</span>
 439 |     | <span class='neutral'>        mload(</span>
 440 |     | <span class='neutral'>          add(</span>
 441 |     | <span class='neutral'>            sub(35, mul(27, iszero(inverse))), // inverse ? 35 : 8</span>
 442 |     | <span class='neutral'>            pointer</span>
 443 |     | <span class='neutral'>          )</span>
 444 |     | <span class='neutral'>        )</span>
 445 |     | <span class='neutral'>      )</span>
 446 |     | <span class='neutral'>    }</span>
 447 |     | <span class='neutral'>  }</span>
 448 |     | <span class='neutral'></span>
 449 |     | <span class='neutral'>  /// @notice Copies a price from one memory pointer to another each with the </span>
 450 |     | <span class='neutral'>  /// following layout:</span>
 451 |     | <span class='neutral'>  ///</span>
 452 |     | <span class='neutral'>  ///  pointer</span>
 453 |     | <span class='neutral'>  ///     |</span>
 454 |     | <span class='neutral'>  ///     +--------+---------------------------+---------------------------+</span>
 455 |     | <span class='neutral'>  ///     | 8 byte |          27 byte          |          27 byte          |</span>
 456 |     | <span class='neutral'>  ///     +--------+---------------------------+---------------------------+</span>
 457 |     | <span class='neutral'>  ///     |        |                           |</span>
 458 |     | <span class='neutral'>  ///     |        |                            \</span>
 459 |     | <span class='neutral'>  ///     |        |                             sqrtInversePrice</span>
 460 |     | <span class='neutral'>  ///     |         \</span>
 461 |     | <span class='neutral'>  ///     |          sqrtPrice</span>
 462 |     | <span class='neutral'>  ///      \</span>
 463 |     | <span class='neutral'>  ///       logPrice</span>
 464 |     | <span class='neutral'>  ///</span>
 465 |     | <span class='neutral'>  function copyPrice(</span>
 466 |     | <span class='neutral'>    uint256 pointer0,</span>
 467 |     | <span class='neutral'>    uint256 pointer1</span>
 468 |     | <span class='neutral'>  ) internal pure {</span>
 469 |     | <span class='neutral'>    assembly {</span>
 470 |     | <span class='neutral'>      // Each price contains &#39;62&#39; bytes which is copied from one place to the</span>
 471 |     | <span class='neutral'>      // next.</span>
 472 |     | <span class='neutral'>      mcopy(pointer0, pointer1, 62)</span>
 473 |     | <span class='neutral'>    }</span>
 474 |     | <span class='neutral'>  }</span>
 475 |     | <span class='neutral'> </span>
 476 |     | <span class='neutral'>  /// @notice Copies a price with height from one memory pointer to another</span>
 477 |     | <span class='neutral'>  /// each with the following layout:</span>
 478 |     | <span class='neutral'>  ///</span>
 479 |     | <span class='neutral'>  ///       pointer</span>
 480 |     | <span class='neutral'>  ///      /</span>
 481 |     | <span class='neutral'>  ///     |</span>
 482 |     | <span class='neutral'>  ///  +--+--------+---------------------------+---------------------------+</span>
 483 |     | <span class='neutral'>  ///  |  | 8 byte |          27 byte          |          27 byte          |</span>
 484 |     | <span class='neutral'>  ///  +--+--------+---------------------------+---------------------------+</span>
 485 |     | <span class='neutral'>  ///  |  |        |                           |</span>
 486 |     | <span class='neutral'>  ///  |  |        |                            \</span>
 487 |     | <span class='neutral'>  ///  |  |        |                             sqrtInversePrice</span>
 488 |     | <span class='neutral'>  ///  |  |         \</span>
 489 |     | <span class='neutral'>  ///  |  |          sqrtPrice</span>
 490 |     | <span class='neutral'>  ///  |   \</span>
 491 |     | <span class='neutral'>  ///  |    logPrice</span>
 492 |     | <span class='neutral'>  ///   \</span>
 493 |     | <span class='neutral'>  ///    heightPrice</span>
 494 |     | <span class='neutral'>  ///</span>
 495 |     | <span class='neutral'>  function copyPriceWithHeight(</span>
 496 |     | <span class='neutral'>    uint256 pointer0,</span>
 497 |     | <span class='neutral'>    uint256 pointer1</span>
 498 |     | <span class='neutral'>  ) internal pure {</span>
 499 |     | <span class='neutral'>    assembly {</span>
 500 |     | <span class='neutral'>      // Each price contains &#39;64&#39; bytes which is copied from one place to the</span>
 501 |     | <span class='neutral'>      // next. We move two bytes backward to point to the beginning of &#39;height&#39;</span>
 502 |     | <span class='neutral'>      // as opposed to the end of &#39;height&#39;:</span>
 503 |     | <span class='neutral'>      //</span>
 504 |     | <span class='neutral'>      //    pointer</span>
 505 |     | <span class='neutral'>      //   /</span>
 506 |     | <span class='neutral'>      //  |</span>
 507 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 508 |     | <span class='neutral'>      //  |  | 8 byte |          27 byte          |          27 byte          |</span>
 509 |     | <span class='neutral'>      //  +--+--------+---------------------------+---------------------------+</span>
 510 |     | <span class='neutral'>      //  |  |        |                           |</span>
 511 |     | <span class='neutral'>      //  |  |        |                            \</span>
 512 |     | <span class='neutral'>      //  |  |        |                             sqrtInversePrice</span>
 513 |     | <span class='neutral'>      //  |  |         \</span>
 514 |     | <span class='neutral'>      //  |  |          sqrtPrice</span>
 515 |     | <span class='neutral'>      //  |   \</span>
 516 |     | <span class='neutral'>      //  |    logPrice</span>
 517 |     | <span class='neutral'>      //   \</span>
 518 |     | <span class='neutral'>      //    heightPrice</span>
 519 |     | <span class='neutral'>      //</span>
 520 |     | <span class='neutral'>      // The subtractions are safe, because both pointers refer to prices with</span>
 521 |     | <span class='neutral'>      // height and therefore their values are not less than &#39;2&#39;.</span>
 522 |     | <span class='neutral'>      mcopy(sub(pointer0, 2), sub(pointer1, 2), 64)</span>
 523 |     | <span class='neutral'>    }</span>
 524 |     | <span class='neutral'>  }</span>
 525 |     | <span class='neutral'></span>
 526 |     | <span class='neutral'>  /// @notice Given the memory pointer for a pair of prices with height, this</span>
 527 |     | <span class='neutral'>  /// function reads the corresponding horizontal and vertical coordinates.</span>
 528 |     | <span class='neutral'>  /// &#39;pointer&#39; refers to the first price and &#39;pointer + 64&#39; refers to the</span>
 529 |     | <span class='neutral'>  /// second one.</span>
 530 |     | <span class='neutral'>  function segment(</span>
 531 |     | <span class='neutral'>    uint256 pointer</span>
 532 |     | <span class='neutral'>  ) internal pure returns (</span>
 533 |     | <span class='neutral'>    X59 b0,</span>
 534 |     | <span class='neutral'>    X59 b1,</span>
 535 |     | <span class='neutral'>    X15 c0,</span>
 536 |     | <span class='neutral'>    X15 c1</span>
 537 |     | <span class='neutral'>  ) {</span>
 538 |     | <span class='neutral'>    c0 = pointer.height();</span>
 539 |     | <span class='neutral'>    b0 = pointer.log();</span>
 540 |     | <span class='neutral'></span>
 541 |     | <span class='neutral'>    // We move &#39;64&#39; bytes forward to point to the second price.</span>
 542 |     | <span class='neutral'>    unchecked {</span>
 543 |     | <span class='neutral'>      pointer += 64;</span>
 544 |     | <span class='neutral'>    }</span>
 545 |     | <span class='neutral'></span>
 546 |     | <span class='neutral'>    c1 = pointer.height();</span>
 547 |     | <span class='neutral'>    b1 = pointer.log();</span>
 548 |     | <span class='neutral'>  }</span>
 549 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/SentinelCalls.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ISentinel} from &quot;../interfaces/ISentinel.sol&quot;;</span>
   5 |     | <span class='neutral'>import {</span>
   6 |     | <span class='neutral'>  _hookSelector_,</span>
   7 |     | <span class='neutral'>  getHookInputByteCount,</span>
   8 |     | <span class='neutral'>  setHookInputHeader,</span>
   9 |     | <span class='neutral'>  setHookSelector</span>
  10 |     | <span class='neutral'>} from &quot;./Memory.sol&quot;;</span>
  11 |     | <span class='neutral'>import {InvalidSentinelResponse} from &quot;./Errors.sol&quot;;</span>
  12 |     | <span class='neutral'>import {readSentinel} from &quot;./Storage.sol&quot;;</span>
  13 |     | <span class='neutral'>import {X47, maxX47} from &quot;./X47.sol&quot;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>ISentinel constant nullSentinel = ISentinel(address(0));</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>/// @notice Calls protocol&#39;s Sentinel to get &#39;maxPoolGrowthPortion&#39; and </span>
  18 |     | <span class='neutral'>/// &#39;protocolGrowthPortion&#39;.</span>
  19 |     | <span class='neutral'>function invokeSentinelGetGrowthPortions() returns (</span>
  20 |     | <span class='neutral'>  X47 maxPoolGrowthPortion,</span>
  21 |     | <span class='neutral'>  X47 protocolGrowthPortion</span>
  22 |     | <span class='neutral'>) {</span>
  23 |     | <span class='neutral'>  // The outputs &#39;maxPoolGrowthPortion&#39; and &#39;protocolGrowthPortion&#39; are</span>
  24 |     | <span class='neutral'>  // initially set to the invalid value &#39;maxX47&#39;. If the Sentinel contract</span>
  25 |     | <span class='neutral'>  // exists, these two values will be overwritten.</span>
  26 |     | <span class='neutral'>  maxPoolGrowthPortion = maxX47;</span>
  27 |     | <span class='neutral'>  protocolGrowthPortion = maxX47;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>  // The Sentinel contract is read from the protocol&#39;s storage.</span>
  30 |     | <span class='neutral'>  ISentinel sentinel = readSentinel();</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>  // If the Sentinel contract exists, then &#39;ISentinel.getGrowthPortions&#39; is</span>
  33 |     | <span class='neutral'>  // invoked and &#39;maxPoolGrowthPortion&#39; and &#39;protocolGrowthPortion&#39; are</span>
  34 |     | <span class='neutral'>  // overwritten.</span>
  35 |     | <span class='neutral'>  if (sentinel != nullSentinel) {</span>
  36 |     | <span class='neutral'>    // The appropriate selector corresponding to the method to be invoked is</span>
  37 |     | <span class='neutral'>    // placed in memory. &#39;selector&#39; is cast as a &#39;uint32&#39; because the setter</span>
  38 |     | <span class='neutral'>    // function &#39;setHookSelector&#39; uses the least significant 32 bits as opposed</span>
  39 |     | <span class='neutral'>    // the most significant &#39;32&#39; bits.</span>
  40 |     | <span class='neutral'>    setHookSelector(uint32(ISentinel.getGrowthPortions.selector));</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    // An abi offset of &#39;0x20&#39; is placed in memory in order to encode the</span>
  43 |     | <span class='neutral'>    // memory snapshot to be sent to the hook as type &#39;bytes&#39;.</span>
  44 |     | <span class='neutral'>    setHookInputHeader(0x20);</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    // The byte count of the memory snapshot to be sent to the Sentinel</span>
  47 |     | <span class='neutral'>    // contract is loaded from the memory.</span>
  48 |     | <span class='neutral'>    uint256 hookInputByteCount = getHookInputByteCount();</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    assembly {</span>
  51 |     | <span class='neutral'>      // Invokes the &#39;ISentinel.getGrowthPortions&#39; and relays the reason if</span>
  52 |     | <span class='neutral'>      // reverted.</span>
  53 |     | <span class='neutral'>      if iszero(</span>
  54 |     | <span class='neutral'>        // &#39;_hookSelector_&#39; points to the beginning of the calldata to be sent</span>
  55 |     | <span class='neutral'>        // to the Sentinel contract. The total calldata byte count is</span>
  56 |     | <span class='neutral'>        // &#39;hookInputByteCount + 4 + 32 + 32&#39; where &#39;4&#39; accounts for the</span>
  57 |     | <span class='neutral'>        // selector, the first &#39;32&#39; accounts for the abi offset slot which is</span>
  58 |     | <span class='neutral'>        // populated with &#39;0x20&#39;, and the second &#39;32&#39; accounts for the length</span>
  59 |     | <span class='neutral'>        // slot which is populated with &#39;hookInputByteCount&#39;.</span>
  60 |     | <span class='neutral'>        call(</span>
  61 |     | <span class='neutral'>          gas(),</span>
  62 |     | <span class='neutral'>          sentinel,</span>
  63 |     | <span class='neutral'>          0,</span>
  64 |     | <span class='neutral'>          _hookSelector_,</span>
  65 |     | <span class='neutral'>          add(hookInputByteCount, 68),</span>
  66 |     | <span class='neutral'>          0,</span>
  67 |     | <span class='neutral'>          64</span>
  68 |     | <span class='neutral'>        )</span>
  69 |     | <span class='neutral'>      ) {</span>
  70 |     | <span class='neutral'>        // Return data is copied to memory and relayed as a revert message.</span>
  71 |     | <span class='neutral'>        returndatacopy(0, 0, returndatasize())</span>
  72 |     | <span class='neutral'>        revert(0, returndatasize())</span>
  73 |     | <span class='neutral'>      }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>      // The output of &#39;ISentinel.getGrowthPortions&#39; overwrites </span>
  76 |     | <span class='neutral'>      // &#39;maxPoolGrowthPortion&#39; and &#39;protocolGrowthPortion&#39;.</span>
  77 |     | <span class='neutral'>      maxPoolGrowthPortion := mload(0)</span>
  78 |     | <span class='neutral'>      protocolGrowthPortion := mload(32)</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'>  }</span>
  81 |     | <span class='neutral'>}</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>/// @notice Calls protocol&#39;s Sentinel to authorize initialization.</span>
  84 |     | <span class='neutral'>function invokeAuthorizeInitialization() {</span>
  85 |     | <span class='neutral'>  // The Sentinel contract is read from the protocol&#39;s storage.</span>
  86 |     | <span class='neutral'>  ISentinel sentinel = readSentinel();</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>  // If the Sentinel contract exists, then &#39;ISentinel.authorizeInitialization&#39;</span>
  89 |     | <span class='neutral'>  // is invoked to authorize initialization.</span>
  90 |     | <span class='neutral'>  if (sentinel != nullSentinel) {</span>
  91 |     | <span class='neutral'>    // The appropriate selector corresponding to the method to be invoked is</span>
  92 |     | <span class='neutral'>    // placed in memory. &#39;selector&#39; is cast as a &#39;uint32&#39; because the setter</span>
  93 |     | <span class='neutral'>    // function &#39;setHookSelector&#39; uses the least significant 32 bits as opposed</span>
  94 |     | <span class='neutral'>    // the most significant &#39;32&#39; bits.</span>
  95 |     | <span class='neutral'>    setHookSelector(uint32(ISentinel.authorizeInitialization.selector));</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    // An abi offset of &#39;0x20&#39; is placed in memory in order to encode the</span>
  98 |     | <span class='neutral'>    // memory snapshot to be sent to the hook as type &#39;bytes&#39;.</span>
  99 |     | <span class='neutral'>    setHookInputHeader(0x20);</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    // The byte count of the memory snapshot to be sent to the Sentinel</span>
 102 |     | <span class='neutral'>    // contract is loaded from the memory.</span>
 103 |     | <span class='neutral'>    uint256 hookInputByteCount = getHookInputByteCount();</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    bytes4 response;</span>
 106 |     | <span class='neutral'>    assembly {</span>
 107 |     | <span class='neutral'>      // Invokes the method &#39;ISentinel.authorizeInitialization&#39; and relays the</span>
 108 |     | <span class='neutral'>      // reason if reverted.</span>
 109 |     | <span class='neutral'>      if iszero(</span>
 110 |     | <span class='neutral'>        // &#39;_hookSelector_&#39; points to the beginning of the calldata to be sent</span>
 111 |     | <span class='neutral'>        // to the Sentinel contract. The total calldata byte count is</span>
 112 |     | <span class='neutral'>        // &#39;hookInputByteCount + 4 + 32 + 32&#39; where &#39;4&#39; accounts for the</span>
 113 |     | <span class='neutral'>        // selector, the first &#39;32&#39; accounts for the abi offset slot which is</span>
 114 |     | <span class='neutral'>        // populated with &#39;0x20&#39;, and the second &#39;32&#39; accounts for length slot</span>
 115 |     | <span class='neutral'>        // which is populated with &#39;hookInputByteCount&#39;.</span>
 116 |     | <span class='neutral'>        call(</span>
 117 |     | <span class='neutral'>          gas(),</span>
 118 |     | <span class='neutral'>          sentinel,</span>
 119 |     | <span class='neutral'>          0,</span>
 120 |     | <span class='neutral'>          _hookSelector_,</span>
 121 |     | <span class='neutral'>          add(hookInputByteCount, 68),</span>
 122 |     | <span class='neutral'>          0,</span>
 123 |     | <span class='neutral'>          32</span>
 124 |     | <span class='neutral'>        )</span>
 125 |     | <span class='neutral'>      ) {</span>
 126 |     | <span class='neutral'>        // Return data is copied to memory and relayed as a revert message.</span>
 127 |     | <span class='neutral'>        returndatacopy(0, 0, returndatasize())</span>
 128 |     | <span class='neutral'>        revert(0, returndatasize())</span>
 129 |     | <span class='neutral'>      }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>      response := mload(0)</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    // The output of &#39;ISentinel.authorizeInitialization&#39; is examined.</span>
 135 |     | <span class='neutral'>    require(</span>
 136 |     | <span class='neutral'>      response == ISentinel.authorizeInitialization.selector,</span>
 137 |     | <span class='neutral'>      InvalidSentinelResponse(response)</span>
 138 |     | <span class='neutral'>    );</span>
 139 |     | <span class='neutral'>  }</span>
 140 |     | <span class='neutral'>}</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>/// @notice Calls protocol&#39;s Sentinel to authorize modification of pool growth</span>
 143 |     | <span class='neutral'>/// portion.</span>
 144 |     | <span class='neutral'>function invokeAuthorizeModificationOfPoolGrowthPortion() {</span>
 145 |     | <span class='neutral'>  // The Sentinel contract is read from the protocol&#39;s storage.</span>
 146 |     | <span class='neutral'>  ISentinel sentinel = readSentinel();</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>  // If the Sentinel contract exists, then </span>
 149 |     | <span class='neutral'>  // &#39;ISentinel.authorizeModificationOfPoolGrowthPortion&#39;</span>
 150 |     | <span class='neutral'>  // is invoked to authorize initialization.</span>
 151 |     | <span class='neutral'>  if (sentinel != nullSentinel) {</span>
 152 |     | <span class='neutral'>    // The appropriate selector corresponding to the method to be invoked is</span>
 153 |     | <span class='neutral'>    // placed in memory. &#39;selector&#39; is cast as a &#39;uint32&#39; because the setter</span>
 154 |     | <span class='neutral'>    // function &#39;setHookSelector&#39; uses the least significant 32 bits as opposed</span>
 155 |     | <span class='neutral'>    // the most significant &#39;32&#39; bits.</span>
 156 |     | <span class='neutral'>    setHookSelector(</span>
 157 |     | <span class='neutral'>      uint32(ISentinel.authorizeModificationOfPoolGrowthPortion.selector)</span>
 158 |     | <span class='neutral'>    );</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    // An abi offset of &#39;0x20&#39; is placed in memory in order to encode the</span>
 161 |     | <span class='neutral'>    // memory snapshot to be sent to the hook as type &#39;bytes&#39;.</span>
 162 |     | <span class='neutral'>    setHookInputHeader(0x20);</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    // The byte count of the memory snapshot to be sent to the Sentinel</span>
 165 |     | <span class='neutral'>    // contract is loaded from the memory.</span>
 166 |     | <span class='neutral'>    uint256 hookInputByteCount = getHookInputByteCount();</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    bytes4 response;</span>
 169 |     | <span class='neutral'>    assembly {</span>
 170 |     | <span class='neutral'>      // Invokes the method </span>
 171 |     | <span class='neutral'>      // &#39;ISentinel.authorizeModificationOfPoolGrowthPortion&#39; and relays the</span>
 172 |     | <span class='neutral'>      // reason if reverted.</span>
 173 |     | <span class='neutral'>      if iszero(</span>
 174 |     | <span class='neutral'>        // &#39;_hookSelector_&#39; points to the beginning of the calldata to be sent</span>
 175 |     | <span class='neutral'>        // to the Sentinel contract. The total calldata byte count is</span>
 176 |     | <span class='neutral'>        // &#39;hookInputByteCount + 4 + 32 + 32&#39; where &#39;4&#39; accounts for the</span>
 177 |     | <span class='neutral'>        // selector, the first &#39;32&#39; accounts for the abi offset slot which is</span>
 178 |     | <span class='neutral'>        // populated with &#39;0x20&#39;, and the second &#39;32&#39; accounts for length slot</span>
 179 |     | <span class='neutral'>        // which is populated with &#39;hookInputByteCount&#39;.</span>
 180 |     | <span class='neutral'>        call(</span>
 181 |     | <span class='neutral'>          gas(),</span>
 182 |     | <span class='neutral'>          sentinel,</span>
 183 |     | <span class='neutral'>          0,</span>
 184 |     | <span class='neutral'>          _hookSelector_,</span>
 185 |     | <span class='neutral'>          add(hookInputByteCount, 68),</span>
 186 |     | <span class='neutral'>          0,</span>
 187 |     | <span class='neutral'>          32</span>
 188 |     | <span class='neutral'>        )</span>
 189 |     | <span class='neutral'>      ) {</span>
 190 |     | <span class='neutral'>        // Return data is copied to memory and relayed as a revert message.</span>
 191 |     | <span class='neutral'>        returndatacopy(0, 0, returndatasize())</span>
 192 |     | <span class='neutral'>        revert(0, returndatasize())</span>
 193 |     | <span class='neutral'>      }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>      response := mload(0)</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>    // The output of &#39;ISentinel.authorizeModificationOfPoolGrowthPortion&#39; is</span>
 199 |     | <span class='neutral'>    // examined.</span>
 200 |     | <span class='neutral'>    require(</span>
 201 |     | <span class='neutral'>      response == ISentinel.authorizeModificationOfPoolGrowthPortion.selector,</span>
 202 |     | <span class='neutral'>      InvalidSentinelResponse(response)</span>
 203 |     | <span class='neutral'>    );</span>
 204 |     | <span class='neutral'>  }</span>
 205 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/Storage.sol</b>
<code>
    1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
    2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>/// @dev Nofeeswap&#39;s storage layout.</span>
    5 |     | <span class='neutral'></span>
    6 |     | <span class='neutral'>import {</span>
    7 |     | <span class='neutral'>  _hookInputByteCount_,</span>
    8 |     | <span class='neutral'>  _dynamicParams_,</span>
    9 |     | <span class='neutral'>  _staticParams_,</span>
   10 |     | <span class='neutral'>  _endOfStaticParams_,</span>
   11 |     | <span class='neutral'>  _deploymentCreationCode_,</span>
   12 |     | <span class='neutral'>  _spacing_,</span>
   13 |     | <span class='neutral'>  getPoolId,</span>
   14 |     | <span class='neutral'>  getPoolRatio0,</span>
   15 |     | <span class='neutral'>  getPoolRatio1,</span>
   16 |     | <span class='neutral'>  getAccrued0,</span>
   17 |     | <span class='neutral'>  getAccrued1,</span>
   18 |     | <span class='neutral'>  getShares,</span>
   19 |     | <span class='neutral'>  getLogPriceMinOffsetted,</span>
   20 |     | <span class='neutral'>  getLogPriceMaxOffsetted,</span>
   21 |     | <span class='neutral'>  getGrowth,</span>
   22 |     | <span class='neutral'>  getStaticParamsStoragePointer,</span>
   23 |     | <span class='neutral'>  getStaticParamsStoragePointerExtension,</span>
   24 |     | <span class='neutral'>  getCurve,</span>
   25 |     | <span class='neutral'>  getCurveLength,</span>
   26 |     | <span class='neutral'>  getLogPriceCurrent,</span>
   27 |     | <span class='neutral'>  getKernelLength,</span>
   28 |     | <span class='neutral'>  getKernel,</span>
   29 |     | <span class='neutral'>  getPoolGrowthPortion,</span>
   30 |     | <span class='neutral'>  getMaxPoolGrowthPortion,</span>
   31 |     | <span class='neutral'>  getPendingKernelLength,</span>
   32 |     | <span class='neutral'>  setMaxPoolGrowthPortion,</span>
   33 |     | <span class='neutral'>  setProtocolGrowthPortion,</span>
   34 |     | <span class='neutral'>  setPoolRatio0,</span>
   35 |     | <span class='neutral'>  setPoolRatio1,</span>
   36 |     | <span class='neutral'>  setAccrued0,</span>
   37 |     | <span class='neutral'>  setAccrued1,</span>
   38 |     | <span class='neutral'>  setStaticParamsStoragePointer,</span>
   39 |     | <span class='neutral'>  setStaticParamsStoragePointerExtension,</span>
   40 |     | <span class='neutral'>  setCurveLength,</span>
   41 |     | <span class='neutral'>  setDeploymentCreationCode,</span>
   42 |     | <span class='neutral'>  setKernelLength,</span>
   43 |     | <span class='neutral'>  setPoolGrowthPortion,</span>
   44 |     | <span class='neutral'>  setCurve,</span>
   45 |     | <span class='neutral'>  setFreeMemoryPointer,</span>
   46 |     | <span class='neutral'>  setHookInputByteCount</span>
   47 |     | <span class='neutral'>} from &quot;./Memory.sol&quot;;</span>
   48 |     | <span class='neutral'>import {ISentinel} from &quot;../interfaces/ISentinel.sol&quot;;</span>
   49 |     | <span class='neutral'>import {invokeSentinelGetGrowthPortions} from &quot;./SentinelCalls.sol&quot;;</span>
   50 |     | <span class='neutral'>import {PriceLibrary} from &quot;./Price.sol&quot;;</span>
   51 |     | <span class='neutral'>import {Curve} from &quot;./Curve.sol&quot;;</span>
   52 |     | <span class='neutral'>import {Kernel} from &quot;./Kernel.sol&quot;;</span>
   53 |     | <span class='neutral'>import {Index, zeroIndex, oneIndex, twoIndex, max} from &quot;./Index.sol&quot;;</span>
   54 |     | <span class='neutral'>import {Tag} from &quot;./Tag.sol&quot;;</span>
   55 |     | <span class='neutral'>import {X23} from &quot;./X23.sol&quot;;</span>
   56 |     | <span class='neutral'>import {X47, oneX47, min} from &quot;./X47.sol&quot;;</span>
   57 |     | <span class='neutral'>import {X59} from &quot;./X59.sol&quot;;</span>
   58 |     | <span class='neutral'>import {zeroX111} from &quot;./X111.sol&quot;;</span>
   59 |     | <span class='neutral'>import {X127, zeroX127, accruedMax} from &quot;./X127.sol&quot;;</span>
   60 |     | <span class='neutral'>import {X208, zeroX208, exp8X208} from &quot;./X208.sol&quot;;</span>
   61 |     | <span class='neutral'>import {X216, oneX216} from &quot;./X216.sol&quot;;</span>
   62 |     | <span class='neutral'>import {emitTransferEvent} from &quot;./Events.sol&quot;;</span>
   63 |     | <span class='neutral'>import {</span>
   64 |     | <span class='neutral'>  InsufficientPermission,</span>
   65 |     | <span class='neutral'>  AccruedGrowthPortionOverflow,</span>
   66 |     | <span class='neutral'>  SharesGrossOverflow,</span>
   67 |     | <span class='neutral'>  PoolDoesNotExist,</span>
   68 |     | <span class='neutral'>  DeploymentFailed,</span>
   69 |     | <span class='neutral'>  BalanceOverflow,</span>
   70 |     | <span class='neutral'>  InsufficientBalance</span>
   71 |     | <span class='neutral'>} from &quot;./Errors.sol&quot;;</span>
   72 |     | <span class='neutral'></span>
   73 |     | <span class='neutral'>using PriceLibrary for uint16;</span>
   74 |     | <span class='neutral'></span>
   75 |     | <span class='neutral'>/// @notice Writes a single slot on storage.</span>
   76 |     | <span class='neutral'>/// @param storageSlot the slot to be populated.</span>
   77 |     | <span class='neutral'>/// @param value the content.</span>
   78 |     | <span class='neutral'>function writeStorage(uint256 storageSlot, uint256 value) {</span>
   79 |     | <span class='neutral'>  assembly {</span>
   80 |     | <span class='neutral'>    sstore(storageSlot, value)</span>
   81 |     | <span class='neutral'>  }</span>
   82 |     | <span class='neutral'>}</span>
   83 |     | <span class='neutral'></span>
   84 |     | <span class='neutral'>/// @notice Reads a single slot from storage.</span>
   85 |     | <span class='neutral'>/// @param storageSlot the slot to be read.</span>
   86 |     | <span class='neutral'>/// @return value the content.</span>
   87 |     | <span class='unexecuted'>function readStorage(uint256 storageSlot) view returns (uint256 value) {</span>
   88 |     | <span class='unexecuted'>  assembly {</span>
   89 |     | <span class='neutral'>    value := sload(storageSlot)</span>
   90 |     | <span class='neutral'>  }</span>
   91 |     | <span class='neutral'>}</span>
   92 |     | <span class='neutral'></span>
   93 |     | <span class='neutral'>/////////////////////////////////////////////////// Protocol and Sentinel slots</span>
   94 |     | <span class='neutral'></span>
   95 |     | <span class='neutral'>// uint256(keccak256(&quot;protocol&quot;)) - 1</span>
   96 |     | <span class='neutral'>uint256 constant protocolSlot = </span>
   97 |     | <span class='neutral'>  0xFB342FA999FEA16067B1F01BAF96673F31A25F2B1443E6754D93FC40B57E8DF1;</span>
   98 |     | <span class='neutral'></span>
   99 |     | <span class='neutral'>// uint256(keccak256(&quot;sentinel&quot;)) - 1</span>
  100 |     | <span class='neutral'>uint256 constant sentinelSlot = </span>
  101 |     | <span class='neutral'>  0xD0716769B9821201D69D150FACFD6F46F5FD95AC252F6ECCB21B7560A01E078B;</span>
  102 |     | <span class='neutral'></span>
  103 |     | <span class='neutral'>/// @notice Writes &#39;maxPoolGrowthPortion&#39;, &#39;protocolGrowthPortion&#39;, and </span>
  104 |     | <span class='neutral'>/// protocol&#39;s owner in one storage slot.</span>
  105 |     | <span class='neutral'>/// @param protocol the content to be written on &#39;protocolSlot&#39;, i.e.,</span>
  106 |     | <span class='neutral'>///</span>
  107 |     | <span class='neutral'>///   &#39;protocol == (</span>
  108 |     | <span class='neutral'>///      (X47.unwrap(maxPoolGrowthPortion) &lt;&lt; 208) | </span>
  109 |     | <span class='neutral'>///      (X47.unwrap(protocolGrowthPortion) &lt;&lt; 160) | </span>
  110 |     | <span class='neutral'>///      uint256(uint160(owner))</span>
  111 |     | <span class='neutral'>///    )&#39;.</span>
  112 |     | <span class='neutral'>///</span>
  113 |     | <span class='neutral'>function writeProtocol(uint256 protocol) {</span>
  114 |     | <span class='neutral'>  writeStorage(protocolSlot, protocol);</span>
  115 |     | <span class='neutral'>}</span>
  116 |     | <span class='neutral'></span>
  117 |     | <span class='neutral'>/// @notice Reads the content of protocol&#39;s slot.</span>
  118 |     | <span class='neutral'>/// @return protocol The content of protocol&#39;s slot.</span>
  119 |     | <span class='neutral'>function readProtocol() view returns (</span>
  120 |     | <span class='neutral'>  uint256 protocol</span>
  121 |     | <span class='neutral'>) {</span>
  122 |     | <span class='neutral'>  return readStorage(protocolSlot);</span>
  123 |     | <span class='neutral'>}</span>
  124 |     | <span class='neutral'></span>
  125 |     | <span class='neutral'>/// @notice Determines protocol&#39;s owner from the content of protocol&#39;s slot.</span>
  126 |     | <span class='neutral'>/// @param protocol The content of protocol&#39;s slot.</span>
  127 |     | <span class='neutral'>/// @return protocolOwner The protocol owner.</span>
  128 |     | <span class='neutral'>function getProtocolOwner(</span>
  129 |     | <span class='neutral'>  uint256 protocol</span>
  130 |     | <span class='neutral'>) pure returns (</span>
  131 |     | <span class='neutral'>  address protocolOwner</span>
  132 |     | <span class='neutral'>) {</span>
  133 |     | <span class='neutral'>  //</span>
  134 |     | <span class='neutral'>  //            6 bytes                 6 bytes             20 bytes</span>
  135 |     | <span class='neutral'>  //    +----------------------+-----------------------+---------------+</span>
  136 |     | <span class='neutral'>  //    | maxPoolGrowthPortion | protocolGrowthPortion | protocolOwner |</span>
  137 |     | <span class='neutral'>  //    +----------------------+-----------------------+---------------+</span>
  138 |     | <span class='neutral'>  //</span>
  139 |     | <span class='neutral'>  return address(uint160(protocol));</span>
  140 |     | <span class='neutral'>}</span>
  141 |     | <span class='neutral'></span>
  142 |     | <span class='neutral'>/// @notice Determines &#39;maxPoolGrowthPortion&#39; and &#39;protocolGrowthPortion&#39; from</span>
  143 |     | <span class='neutral'>/// the content of protocol&#39;s slot.</span>
  144 |     | <span class='neutral'>/// @param protocol The content of protocol&#39;s slot.</span>
  145 |     | <span class='neutral'>/// @return maxPoolGrowthPortion This value imposes a cap on the portion of the</span>
  146 |     | <span class='neutral'>/// marginal growth that goes to the pool owner followed by the protocol.</span>
  147 |     | <span class='neutral'>/// @return protocolGrowthPortion This value dictates the portion of the growth</span>
  148 |     | <span class='neutral'>/// that goes to the protocol.</span>
  149 |     | <span class='neutral'>function getGrowthPortions(</span>
  150 |     | <span class='neutral'>  uint256 protocol</span>
  151 |     | <span class='neutral'>) pure returns (</span>
  152 |     | <span class='neutral'>  X47 maxPoolGrowthPortion,</span>
  153 |     | <span class='neutral'>  X47 protocolGrowthPortion</span>
  154 |     | <span class='neutral'>) {</span>
  155 |     | <span class='neutral'>  //</span>
  156 |     | <span class='neutral'>  //            6 bytes                 6 bytes             20 bytes</span>
  157 |     | <span class='neutral'>  //    +----------------------+-----------------------+---------------+</span>
  158 |     | <span class='neutral'>  //    | maxPoolGrowthPortion | protocolGrowthPortion | protocolOwner |</span>
  159 |     | <span class='neutral'>  //    +----------------------+-----------------------+---------------+</span>
  160 |     | <span class='neutral'>  //</span>
  161 |     | <span class='neutral'>  assembly {</span>
  162 |     | <span class='neutral'>    maxPoolGrowthPortion := shr(208, protocol)</span>
  163 |     | <span class='neutral'>    protocolGrowthPortion := and(shr(160, protocol), 0xFFFFFFFFFFFF)</span>
  164 |     | <span class='neutral'>  }</span>
  165 |     | <span class='neutral'>}</span>
  166 |     | <span class='neutral'></span>
  167 |     | <span class='neutral'>/// @notice Populates the Sentinel slot.</span>
  168 |     | <span class='neutral'>/// @param sentinel The Sentinel contract to be written on storage.</span>
  169 |     | <span class='neutral'>function writeSentinel(ISentinel sentinel) {</span>
  170 |     | <span class='neutral'>  assembly {</span>
  171 |     | <span class='neutral'>    sstore(sentinelSlot, sentinel)</span>
  172 |     | <span class='neutral'>  }</span>
  173 |     | <span class='neutral'>}</span>
  174 |     | <span class='neutral'></span>
  175 |     | <span class='neutral'>/// @notice Reads the Sentinel slot.</span>
  176 |     | <span class='neutral'>/// @return sentinel The Sentinel contract read from storage.</span>
  177 |     | <span class='neutral'>function readSentinel() view returns (ISentinel sentinel) {</span>
  178 |     | <span class='neutral'>  assembly {</span>
  179 |     | <span class='neutral'>    sentinel := sload(sentinelSlot)</span>
  180 |     | <span class='neutral'>  }</span>
  181 |     | <span class='neutral'>}</span>
  182 |     | <span class='neutral'></span>
  183 |     | <span class='neutral'>/// @notice This function reads &#39;maxPoolGrowthPortion&#39; and </span>
  184 |     | <span class='neutral'>/// &#39;protocolGrowthPortion&#39; from the Sentinel contract or the protocol slot. The</span>
  185 |     | <span class='neutral'>/// Sentinel contract provides the growth portions based on a snapshot of the</span>
  186 |     | <span class='neutral'>/// memory. If the portions are not set for that pool at Sentinel, it returns </span>
  187 |     | <span class='neutral'>/// an infeasible response larger than &#39;oneX47&#39; and then the default value from</span>
  188 |     | <span class='neutral'>/// the protocol slot is read.</span>
  189 |     | <span class='neutral'>function readGrowthPortions() {</span>
  190 |     | <span class='neutral'>  // First, the Sentinel contract is invoked (it it exists).</span>
  191 |     | <span class='neutral'>  (</span>
  192 |     | <span class='neutral'>    X47 maxPoolGrowthPortion,</span>
  193 |     | <span class='neutral'>    X47 protocolGrowthPortion</span>
  194 |     | <span class='neutral'>  ) = invokeSentinelGetGrowthPortions();</span>
  195 |     | <span class='neutral'></span>
  196 |     | <span class='neutral'>  // If any of the two given values are infeasible, then the protocol slot is</span>
  197 |     | <span class='neutral'>  // read and the resulting values from the Sentinel contract are overwritten.</span>
  198 |     | <span class='neutral'>  if (maxPoolGrowthPortion &gt; oneX47 || protocolGrowthPortion &gt; oneX47) {</span>
  199 |     | <span class='neutral'>    // &#39;maxPoolGrowthPortionProtocol&#39; and &#39;protocolGrowthPortionProtocol&#39; are</span>
  200 |     | <span class='neutral'>    // read from the protocol slot.</span>
  201 |     | <span class='neutral'>    (</span>
  202 |     | <span class='neutral'>      X47 maxPoolGrowthPortionProtocol,</span>
  203 |     | <span class='neutral'>      X47 protocolGrowthPortionProtocol</span>
  204 |     | <span class='neutral'>    ) = getGrowthPortions(readProtocol());</span>
  205 |     | <span class='neutral'></span>
  206 |     | <span class='neutral'>    // If &#39;maxPoolGrowthPortion&#39; from the Sentinel contract is infeasible, then</span>
  207 |     | <span class='neutral'>    // &#39;maxPoolGrowthPortionProtocol&#39; is chosen.</span>
  208 |     | <span class='neutral'>    if (maxPoolGrowthPortion &gt; oneX47) {</span>
  209 |     | <span class='neutral'>      maxPoolGrowthPortion = maxPoolGrowthPortionProtocol;</span>
  210 |     | <span class='neutral'>    }</span>
  211 |     | <span class='neutral'></span>
  212 |     | <span class='neutral'>    // If &#39;protocolGrowthPortion&#39; from the Sentinel contract is infeasible,</span>
  213 |     | <span class='neutral'>    // then &#39;protocolGrowthPortionProtocol&#39; is chosen.</span>
  214 |     | <span class='neutral'>    if (protocolGrowthPortion &gt; oneX47) {</span>
  215 |     | <span class='neutral'>      protocolGrowthPortion = protocolGrowthPortionProtocol;</span>
  216 |     | <span class='neutral'>    }</span>
  217 |     | <span class='neutral'>  }</span>
  218 |     | <span class='neutral'></span>
  219 |     | <span class='neutral'>  // The resulting growth portions are set in memory.</span>
  220 |     | <span class='neutral'>  setMaxPoolGrowthPortion(maxPoolGrowthPortion);</span>
  221 |     | <span class='neutral'>  setProtocolGrowthPortion(protocolGrowthPortion);</span>
  222 |     | <span class='neutral'>}</span>
  223 |     | <span class='neutral'></span>
  224 |     | <span class='neutral'>////////////////////////////////////////////////////////// Single balance slots</span>
  225 |     | <span class='neutral'></span>
  226 |     | <span class='neutral'>// uint96(uint256(keccak256(&quot;singleBalance&quot;))) - 1</span>
  227 |     | <span class='neutral'>uint96 constant singleBalanceSlot = 0x3C244899B5FA3E971383AC4B;</span>
  228 |     | <span class='neutral'></span>
  229 |     | <span class='neutral'>/// @notice This function returns the storage slot referring to</span>
  230 |     | <span class='neutral'>/// &#39;balanceOf(owner, tag)&#39;.</span>
  231 |     | <span class='neutral'>/// @param owner Balance owner.</span>
  232 |     | <span class='neutral'>/// @param tag The corresponding tag.</span>
  233 |     | <span class='neutral'>/// @return storageSlot The storage slot containing &#39;balanceOf(owner, tag)&#39;.</span>
  234 |     | <span class='neutral'>function getSingleBalanceSlot(</span>
  235 |     | <span class='neutral'>  address owner,</span>
  236 |     | <span class='neutral'>  Tag tag</span>
  237 |     | <span class='neutral'>) pure returns (</span>
  238 |     | <span class='neutral'>  uint256 storageSlot</span>
  239 |     | <span class='neutral'>) {</span>
  240 |     | <span class='neutral'>  assembly {</span>
  241 |     | <span class='neutral'>    // We populate the first two memory slots from right to left:</span>
  242 |     | <span class='neutral'>    //</span>
  243 |     | <span class='neutral'>    //    0                               32          52                  64</span>
  244 |     | <span class='neutral'>    //    |                               |           |                   |</span>
  245 |     | <span class='neutral'>    //    +-------------------------------+-----------+-------------------+</span>
  246 |     | <span class='neutral'>    //    |              tag              |   owner   | singleBalanceSlot |</span>
  247 |     | <span class='neutral'>    //    +-------------------------------+-----------+-------------------+</span>
  248 |     | <span class='neutral'>    //</span>
  249 |     | <span class='neutral'></span>
  250 |     | <span class='neutral'>    // Populates the least significant 12 bytes of the memory slot 1 (from 52</span>
  251 |     | <span class='neutral'>    // to 64).</span>
  252 |     | <span class='neutral'>    mstore(32, singleBalanceSlot) // 32 = 64 - 32</span>
  253 |     | <span class='neutral'></span>
  254 |     | <span class='neutral'>    // Populates the most significant 20 bytes of the memory slot 1 (from 32 to</span>
  255 |     | <span class='neutral'>    // 52).</span>
  256 |     | <span class='neutral'>    mstore(20, owner) // 20 = 52 - 32</span>
  257 |     | <span class='neutral'></span>
  258 |     | <span class='neutral'>    // Populates the entire memory slot 0.</span>
  259 |     | <span class='neutral'>    mstore(0, tag) // 0 = 32 - 32</span>
  260 |     | <span class='neutral'></span>
  261 |     | <span class='neutral'>    // Calculates the resulting hash.</span>
  262 |     | <span class='neutral'>    storageSlot := keccak256(0, 64)</span>
  263 |     | <span class='neutral'>  }</span>
  264 |     | <span class='neutral'>}</span>
  265 |     | <span class='neutral'></span>
  266 |     | <span class='neutral'>/// @notice Increments a single balance slot.</span>
  267 |     | <span class='neutral'>///</span>
  268 |     | <span class='neutral'>/// &#39;amount&#39; should be less than &#39;2 ** 255&#39;.</span>
  269 |     | <span class='neutral'>///</span>
  270 |     | <span class='neutral'>/// @param owner Balance owner.</span>
  271 |     | <span class='neutral'>/// @param tag The corresponding tag.</span>
  272 |     | <span class='neutral'>/// @param amount The increment amount.</span>
  273 |     | <span class='neutral'>function incrementBalance(</span>
  274 |     | <span class='neutral'>  address owner,</span>
  275 |     | <span class='neutral'>  Tag tag,</span>
  276 |     | <span class='neutral'>  uint256 amount</span>
  277 |     | <span class='neutral'>) {</span>
  278 |     | <span class='neutral'>  uint256 storageSlot = getSingleBalanceSlot(owner, tag);</span>
  279 |     | <span class='neutral'>  unchecked {</span>
  280 |     | <span class='neutral'>    // The addition is safe, because the current content of the &#39;storageSlot&#39;</span>
  281 |     | <span class='neutral'>    // does not exceed &#39;type(uint128).max&#39; and &#39;amount &lt; 2 ** 255&#39;.</span>
  282 |     | <span class='neutral'>    uint256 newBalance = readStorage(storageSlot) + amount;</span>
  283 |     | <span class='neutral'>    require(newBalance &lt;= type(uint128).max, BalanceOverflow(newBalance));</span>
  284 |     | <span class='neutral'>    writeStorage(storageSlot, newBalance);</span>
  285 |     | <span class='neutral'>  }</span>
  286 |     | <span class='neutral'>  emitTransferEvent(msg.sender, address(0), owner, tag, amount);</span>
  287 |     | <span class='neutral'>}</span>
  288 |     | <span class='neutral'></span>
  289 |     | <span class='neutral'>/// @notice Decrements a single balance slot.</span>
  290 |     | <span class='neutral'>///</span>
  291 |     | <span class='neutral'>/// @param owner Balance owner.</span>
  292 |     | <span class='neutral'>/// @param tag The corresponding tag.</span>
  293 |     | <span class='neutral'>/// @param absoluteValue The decrement amount.</span>
  294 |     | <span class='neutral'>function decrementBalance(</span>
  295 |     | <span class='neutral'>  address owner,</span>
  296 |     | <span class='neutral'>  Tag tag,</span>
  297 |     | <span class='neutral'>  uint256 absoluteValue</span>
  298 |     | <span class='neutral'>) {</span>
  299 |     | <span class='neutral'>  uint256 storageSlot = getSingleBalanceSlot(owner, tag);</span>
  300 |     | <span class='neutral'>  uint256 balance = readStorage(storageSlot);</span>
  301 |     | <span class='neutral'>  updateAllowance(owner, tag, absoluteValue);</span>
  302 |     | <span class='neutral'>  require(balance &gt;= absoluteValue, InsufficientBalance(owner, tag));</span>
  303 |     | <span class='neutral'>  unchecked {</span>
  304 |     | <span class='neutral'>    // The subtraction is safe due to the prior check.</span>
  305 |     | <span class='neutral'>    writeStorage(storageSlot, balance - absoluteValue);</span>
  306 |     | <span class='neutral'>  }</span>
  307 |     | <span class='neutral'>  emitTransferEvent(msg.sender, owner, address(0), tag, absoluteValue);</span>
  308 |     | <span class='neutral'>}</span>
  309 |     | <span class='neutral'></span>
  310 |     | <span class='neutral'>////////////////////////////////////////////////////////// Double balance slots</span>
  311 |     | <span class='neutral'></span>
  312 |     | <span class='neutral'>// uint96(uint256(keccak256(&quot;doubleBalance&quot;))) - 1</span>
  313 |     | <span class='neutral'>uint96 constant doubleBalanceSlot = 0xC8F78086C3211E71A328E7F5;</span>
  314 |     | <span class='neutral'></span>
  315 |     | <span class='neutral'>/// @notice This function returns the storage slot pointing to owner&#39;s double</span>
  316 |     | <span class='neutral'>/// balance of tags 0 and 1. This storage slot contains a balance for both</span>
  317 |     | <span class='neutral'>/// tokens which can be used to save gas.</span>
  318 |     | <span class='neutral'>///</span>
  319 |     | <span class='neutral'>/// @param owner Balance owner.</span>
  320 |     | <span class='neutral'>/// @param tag0 The corresponding tag0.</span>
  321 |     | <span class='neutral'>/// @param tag1 The corresponding tag1.</span>
  322 |     | <span class='neutral'>/// @return storageSlot The storage slot containing the double balance of</span>
  323 |     | <span class='neutral'>/// &#39;tag0&#39; and &#39;tag1&#39;.</span>
  324 |     | <span class='neutral'>function getDoubleBalanceSlot(</span>
  325 |     | <span class='neutral'>  address owner,</span>
  326 |     | <span class='neutral'>  Tag tag0,</span>
  327 |     | <span class='neutral'>  Tag tag1</span>
  328 |     | <span class='neutral'>) pure returns (uint256 storageSlot) {</span>
  329 |     | <span class='neutral'>  assembly {</span>
  330 |     | <span class='neutral'>    // We populate the first three memory slots from right to left:</span>
  331 |     | <span class='neutral'>    //</span>
  332 |     | <span class='neutral'>    //    0              32             64              84                  96</span>
  333 |     | <span class='neutral'>    //    |              |              |               |                   |</span>
  334 |     | <span class='neutral'>    //    +--------------+--------------+---------------+-------------------+</span>
  335 |     | <span class='neutral'>    //    |     tag0     |     tag1     |     owner     | doubleBalanceSlot |</span>
  336 |     | <span class='neutral'>    //    +--------------+--------------+---------------+-------------------+</span>
  337 |     | <span class='neutral'>    //</span>
  338 |     | <span class='neutral'>    let freeMemoryPointer := mload(0x40)</span>
  339 |     | <span class='neutral'>    mstore(64, doubleBalanceSlot) // 64 = 96 - 32</span>
  340 |     | <span class='neutral'>    mstore(52, owner) // 52 = 84 - 32</span>
  341 |     | <span class='neutral'>    mstore(32, tag1) // 32 = 64 - 32</span>
  342 |     | <span class='neutral'>    mstore(0, tag0) // 32 = 32 - 32</span>
  343 |     | <span class='neutral'>    storageSlot := keccak256(0, 96)</span>
  344 |     | <span class='neutral'>    mstore(0x40, freeMemoryPointer)</span>
  345 |     | <span class='neutral'>  }</span>
  346 |     | <span class='neutral'>}</span>
  347 |     | <span class='neutral'></span>
  348 |     | <span class='neutral'>/// @notice This function returns the content of the double balance slot which</span>
  349 |     | <span class='neutral'>/// is pointed to by &#39;storageSlot&#39;.</span>
  350 |     | <span class='neutral'>///</span>
  351 |     | <span class='neutral'>/// @param storageSlot The storage slot containing the double balance of &#39;tag0&#39;</span>
  352 |     | <span class='neutral'>/// and &#39;tag1&#39;.</span>
  353 |     | <span class='neutral'>/// @return amount0 The amount of tag0.</span>
  354 |     | <span class='neutral'>/// @return amount1 The amount of tag1.</span>
  355 |     | <span class='neutral'>function readDoubleBalance(</span>
  356 |     | <span class='neutral'>  uint256 storageSlot</span>
  357 |     | <span class='neutral'>) view returns (</span>
  358 |     | <span class='neutral'>  uint256 amount0,</span>
  359 |     | <span class='neutral'>  uint256 amount1</span>
  360 |     | <span class='neutral'>) {</span>
  361 |     | <span class='neutral'>  uint256 pairBalance = readStorage(storageSlot);</span>
  362 |     | <span class='neutral'>  assembly {</span>
  363 |     | <span class='neutral'>    amount0 := and(pairBalance, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)</span>
  364 |     | <span class='neutral'>    amount1 := shr(128, pairBalance)</span>
  365 |     | <span class='neutral'>  }</span>
  366 |     | <span class='neutral'>}</span>
  367 |     | <span class='neutral'></span>
  368 |     | <span class='neutral'>/// @notice This function populates the double balance slot which is pointed to</span>
  369 |     | <span class='neutral'>/// by &#39;storageSlot&#39;.</span>
  370 |     | <span class='neutral'>///</span>
  371 |     | <span class='neutral'>/// @param storageSlot The storage slot to be populated.</span>
  372 |     | <span class='neutral'>/// @param amount0 The amount of tag0.</span>
  373 |     | <span class='neutral'>/// @param amount1 The amount of tag1.</span>
  374 |     | <span class='neutral'>function writeDoubleBalance(</span>
  375 |     | <span class='neutral'>  uint256 storageSlot,</span>
  376 |     | <span class='neutral'>  uint256 amount0,</span>
  377 |     | <span class='neutral'>  uint256 amount1</span>
  378 |     | <span class='neutral'>) {</span>
  379 |     | <span class='neutral'>  require(amount0 &lt;= type(uint128).max, BalanceOverflow(amount0));</span>
  380 |     | <span class='neutral'>  require(amount1 &lt;= type(uint128).max, BalanceOverflow(amount1));</span>
  381 |     | <span class='neutral'>  writeStorage(storageSlot, (amount1 &lt;&lt; 128) | amount0);</span>
  382 |     | <span class='neutral'>}</span>
  383 |     | <span class='neutral'></span>
  384 |     | <span class='neutral'>///////////////////////////////////////////////////////// LP total supply slots</span>
  385 |     | <span class='neutral'></span>
  386 |     | <span class='neutral'>// uint128(uint256(keccak256(&quot;totalSupply&quot;))) - 1</span>
  387 |     | <span class='neutral'>uint128 constant totalSupplySlot = 0x5daca5ccc655360fa5ccacf9c267936c;</span>
  388 |     | <span class='neutral'></span>
  389 |     | <span class='neutral'>/// @notice This function increments/decrements total supply associated with</span>
  390 |     | <span class='neutral'>/// LP positions.</span>
  391 |     | <span class='neutral'>///</span>
  392 |     | <span class='neutral'>/// @param poolId The pool identifier hosting this liquidity position.</span>
  393 |     | <span class='neutral'>/// @param qMin Equal to &#39;(2 ** 59) * (16 + log(pMin / pOffset))&#39;.</span>
  394 |     | <span class='neutral'>/// @param qMax Equal to &#39;(2 ** 59) * (16 + log(pMax / pOffset))&#39;.</span>
  395 |     | <span class='neutral'>/// @param shares The number of shares to be added/subtracted.</span>
  396 |     | <span class='neutral'>function updateTotalSupply(</span>
  397 |     | <span class='neutral'>  uint256 poolId,</span>
  398 |     | <span class='neutral'>  X59 qMin,</span>
  399 |     | <span class='neutral'>  X59 qMax,</span>
  400 |     | <span class='neutral'>  int256 shares</span>
  401 |     | <span class='neutral'>) {</span>
  402 |     | <span class='neutral'>  // We populate the first two memory slots from right to left:</span>
  403 |     | <span class='neutral'>  //</span>
  404 |     | <span class='neutral'>  //    0        32     40     48                64</span>
  405 |     | <span class='neutral'>  //    |        |      |      |                 |</span>
  406 |     | <span class='neutral'>  //    +--------+------+------+-----------------+</span>
  407 |     | <span class='neutral'>  //    | poolId | qMin | qMax | totalSupplySlot |</span>
  408 |     | <span class='neutral'>  //    +--------+------+------+-----------------+</span>
  409 |     | <span class='neutral'>  //</span>
  410 |     | <span class='neutral'>  uint256 storageSlot;</span>
  411 |     | <span class='neutral'>  assembly {</span>
  412 |     | <span class='neutral'>    mstore(32, totalSupplySlot) // 32 = 64 - 32</span>
  413 |     | <span class='neutral'>    mstore(16, qMax) // 16 = 48 - 32</span>
  414 |     | <span class='neutral'>    mstore(8, qMin) // 8 = 40 - 32</span>
  415 |     | <span class='neutral'>    mstore(0, poolId) // 0 = 32 - 32</span>
  416 |     | <span class='neutral'>    storageSlot := keccak256(0, 64)</span>
  417 |     | <span class='neutral'>  }</span>
  418 |     | <span class='neutral'>  uint256 totalSupply = readStorage(storageSlot);</span>
  419 |     | <span class='neutral'>  assembly {</span>
  420 |     | <span class='neutral'>    totalSupply := add(totalSupply, shares)</span>
  421 |     | <span class='neutral'>  }</span>
  422 |     | <span class='neutral'>  require(totalSupply &lt;= type(uint128).max, BalanceOverflow(totalSupply));</span>
  423 |     | <span class='neutral'>  writeStorage(storageSlot, totalSupply);</span>
  424 |     | <span class='neutral'>}</span>
  425 |     | <span class='neutral'></span>
  426 |     | <span class='neutral'>//////////////////////////////////////////////////////////////// Operator slots</span>
  427 |     | <span class='neutral'></span>
  428 |     | <span class='neutral'>// uint96(uint256(keccak256(&quot;isOperator&quot;))) - 1</span>
  429 |     | <span class='neutral'>uint96 constant isOperatorSlot = 0xE442B523D9447037E4923F5B;</span>
  430 |     | <span class='neutral'></span>
  431 |     | <span class='neutral'>/// @notice This function returns the storage slot referring to</span>
  432 |     | <span class='neutral'>/// &#39;isOperator(owner, spender)&#39;.</span>
  433 |     | <span class='neutral'>///</span>
  434 |     | <span class='neutral'>/// @param owner Balance owner.</span>
  435 |     | <span class='neutral'>/// @param spender The spender whose allowance to be read.</span>
  436 |     | <span class='neutral'>/// @return storageSlot The storage slot which records whether the &#39;spender&#39;</span>
  437 |     | <span class='neutral'>/// is an operator for the &#39;owner&#39; or not.</span>
  438 |     | <span class='neutral'>function getIsOperatorSlot(</span>
  439 |     | <span class='neutral'>  address owner,</span>
  440 |     | <span class='neutral'>  address spender</span>
  441 |     | <span class='neutral'>) pure returns (uint256 storageSlot) {</span>
  442 |     | <span class='neutral'>  // We populate the first two memory slots from right to left:</span>
  443 |     | <span class='neutral'>  //</span>
  444 |     | <span class='neutral'>  //    12              32              52               64</span>
  445 |     | <span class='neutral'>  //    |               |               |                |</span>
  446 |     | <span class='neutral'>  //    +---------------+---------------+----------------+</span>
  447 |     | <span class='neutral'>  //    |    spender    |     owner     | isOperatorSlot |</span>
  448 |     | <span class='neutral'>  //    +---------------+---------------+----------------+</span>
  449 |     | <span class='neutral'>  //</span>
  450 |     | <span class='neutral'>  assembly {</span>
  451 |     | <span class='neutral'>    mstore(32, isOperatorSlot) // 32 = 64 - 32</span>
  452 |     | <span class='neutral'>    mstore(20, owner) // 20 = 52 - 32</span>
  453 |     | <span class='neutral'>    mstore(0, spender) // 0 = 32 - 32</span>
  454 |     | <span class='neutral'>    storageSlot := keccak256(12, 52) // 52 = 64 - 12</span>
  455 |     | <span class='neutral'>  }</span>
  456 |     | <span class='neutral'>}</span>
  457 |     | <span class='neutral'></span>
  458 |     | <span class='neutral'>/////////////////////////////////////////////////////////////// Allowance slots</span>
  459 |     | <span class='neutral'></span>
  460 |     | <span class='neutral'>// uint96(uint256(keccak256(&quot;allowance&quot;))) - 1</span>
  461 |     | <span class='neutral'>uint96 constant allowanceSlot = 0x34105B980BA117BD0C29FE0;</span>
  462 |     | <span class='neutral'></span>
  463 |     | <span class='neutral'>/// @notice This function returns the storage slot pointing to</span>
  464 |     | <span class='neutral'>/// &#39;allowance(owner, spender, tag)&#39;.</span>
  465 |     | <span class='neutral'>///</span>
  466 |     | <span class='neutral'>/// @param owner Balance owner.</span>
  467 |     | <span class='neutral'>/// @param spender The spender whose allowance to be read.</span>
  468 |     | <span class='neutral'>/// @param tag The corresponding tag.</span>
  469 |     | <span class='neutral'>/// @return storageSlot The storage slot to be calculated.</span>
  470 |     | <span class='neutral'>function getAllowanceSlot(</span>
  471 |     | <span class='neutral'>  address owner,</span>
  472 |     | <span class='neutral'>  address spender,</span>
  473 |     | <span class='neutral'>  Tag tag</span>
  474 |     | <span class='neutral'>) pure returns (</span>
  475 |     | <span class='neutral'>  uint256 storageSlot</span>
  476 |     | <span class='neutral'>) {</span>
  477 |     | <span class='neutral'>  // We populate the first three memory slots from right to left:</span>
  478 |     | <span class='neutral'>  //</span>
  479 |     | <span class='neutral'>  //    0             32              52              72              84</span>
  480 |     | <span class='neutral'>  //    |             |               |               |               |</span>
  481 |     | <span class='neutral'>  //    +-------------+---------------+---------------+---------------+</span>
  482 |     | <span class='neutral'>  //    |     tag     |    spender    |     owner     | allowanceSlot |</span>
  483 |     | <span class='neutral'>  //    +-------------+---------------+---------------+---------------+</span>
  484 |     | <span class='neutral'>  //</span>
  485 |     | <span class='neutral'>  assembly {</span>
  486 |     | <span class='neutral'>    let freeMemoryPointer := mload(0x40)</span>
  487 |     | <span class='neutral'>    mstore(52, allowanceSlot) // 52 = 84 - 32</span>
  488 |     | <span class='neutral'>    mstore(40, owner) // 40 = 72 - 32</span>
  489 |     | <span class='neutral'>    mstore(20, spender) // 20 = 52 - 32</span>
  490 |     | <span class='neutral'>    mstore(0, tag) // 0 = 32 - 32</span>
  491 |     | <span class='neutral'>    storageSlot := keccak256(0, 84)</span>
  492 |     | <span class='neutral'>    mstore(0x40, freeMemoryPointer)</span>
  493 |     | <span class='neutral'>  }</span>
  494 |     | <span class='neutral'>}</span>
  495 |     | <span class='neutral'></span>
  496 |     | <span class='neutral'>/// @notice This function updates ERC-6909 allowance after each expenditure</span>
  497 |     | <span class='neutral'>/// performed by a spender.</span>
  498 |     | <span class='neutral'>///</span>
  499 |     | <span class='neutral'>/// @param owner Balance owner.</span>
  500 |     | <span class='neutral'>/// @param tag The corresponding tag.</span>
  501 |     | <span class='neutral'>/// @param amount The amount to be decremented from allowance.</span>
  502 |     | <span class='neutral'>function updateAllowance(</span>
  503 |     | <span class='neutral'>  address owner,</span>
  504 |     | <span class='neutral'>  Tag tag,</span>
  505 |     | <span class='neutral'>  uint256 amount</span>
  506 |     | <span class='neutral'>) {</span>
  507 |     | <span class='neutral'>  // If &#39;owner&#39; is equal to &#39;spender&#39;, then we do not need to decrement any</span>
  508 |     | <span class='neutral'>  // allowance value.</span>
  509 |     | <span class='neutral'>  if (owner != msg.sender) {</span>
  510 |     | <span class='neutral'>    // If &#39;owner&#39; is the operator, then we do not need to decrement any</span>
  511 |     | <span class='neutral'>    // allowance value either.</span>
  512 |     | <span class='neutral'>    if (readStorage(getIsOperatorSlot(owner, msg.sender)) == 0) {</span>
  513 |     | <span class='neutral'>      uint256 storageSlot = getAllowanceSlot(owner, msg.sender, tag);</span>
  514 |     | <span class='neutral'>      uint256 senderAllowance = readStorage(storageSlot);</span>
  515 |     | <span class='neutral'>      require(</span>
  516 |     | <span class='neutral'>        senderAllowance &gt;= amount,</span>
  517 |     | <span class='neutral'>        InsufficientPermission(msg.sender, tag)</span>
  518 |     | <span class='neutral'>      );</span>
  519 |     | <span class='neutral'>      if (senderAllowance != type(uint256).max) {</span>
  520 |     | <span class='neutral'>        unchecked {</span>
  521 |     | <span class='neutral'>          // The subtraction is safe due to the prior check.</span>
  522 |     | <span class='neutral'>          writeStorage(storageSlot, senderAllowance - amount);</span>
  523 |     | <span class='neutral'>        }</span>
  524 |     | <span class='neutral'>      }</span>
  525 |     | <span class='neutral'>    }</span>
  526 |     | <span class='neutral'>  }</span>
  527 |     | <span class='neutral'>}</span>
  528 |     | <span class='neutral'></span>
  529 |     | <span class='neutral'>////////////////////////////////////////////////////////////// Pool owner slots</span>
  530 |     | <span class='neutral'></span>
  531 |     | <span class='neutral'>// uint128(uint256(keccak256(&quot;poolOwner&quot;))) - 1</span>
  532 |     | <span class='neutral'>uint128 constant poolOwnerSlot = 0x68E919334073168F7B6F6D0178986A64;</span>
  533 |     | <span class='neutral'></span>
  534 |     | <span class='neutral'>/// @notice This function returns the storage slot referring to the owner of</span>
  535 |     | <span class='neutral'>/// a pool.</span>
  536 |     | <span class='neutral'>///</span>
  537 |     | <span class='neutral'>/// @param poolId The &#39;poolId&#39; whose owner slot to be derived.</span>
  538 |     | <span class='neutral'>/// @return storageSlot The storage slot containing the pool owner.</span>
  539 |     | <span class='neutral'>function getPoolOwnerSlot(</span>
  540 |     | <span class='neutral'>  uint256 poolId</span>
  541 |     | <span class='neutral'>) pure returns (uint256 storageSlot) {</span>
  542 |     | <span class='neutral'>  assembly {</span>
  543 |     | <span class='neutral'>    // We populate the first two memory slots from right to left:</span>
  544 |     | <span class='neutral'>    //</span>
  545 |     | <span class='neutral'>    //    0              32              48</span>
  546 |     | <span class='neutral'>    //    |              |               |</span>
  547 |     | <span class='neutral'>    //    +--------------+---------------+</span>
  548 |     | <span class='neutral'>    //    |    poolId    | poolOwnerSlot |</span>
  549 |     | <span class='neutral'>    //    +--------------+---------------+</span>
  550 |     | <span class='neutral'>    //</span>
  551 |     | <span class='neutral'>    mstore(16, poolOwnerSlot) // 16 = 48 - 32</span>
  552 |     | <span class='neutral'>    mstore(0, poolId)</span>
  553 |     | <span class='neutral'>    storageSlot := keccak256(0, 48)</span>
  554 |     | <span class='neutral'>  }</span>
  555 |     | <span class='neutral'>}</span>
  556 |     | <span class='neutral'></span>
  557 |     | <span class='neutral'>/// @notice Returns the owner of a given pool.</span>
  558 |     | <span class='neutral'>///</span>
  559 |     | <span class='neutral'>/// @param storageSlot The storage slot containing the pool owner.</span>
  560 |     | <span class='neutral'>/// @return poolOwner The pool owner to be returned.</span>
  561 |     | <span class='neutral'>function readPoolOwner(</span>
  562 |     | <span class='neutral'>  uint256 storageSlot</span>
  563 |     | <span class='neutral'>) view returns (address poolOwner) {</span>
  564 |     | <span class='neutral'>  return address(uint160(readStorage(storageSlot)));</span>
  565 |     | <span class='neutral'>}</span>
  566 |     | <span class='neutral'></span>
  567 |     | <span class='neutral'>/// @notice Writes the owner of a given pool on storage.</span>
  568 |     | <span class='neutral'>///</span>
  569 |     | <span class='neutral'>/// @param storageSlot The storage slot to be populated.</span>
  570 |     | <span class='neutral'>/// @param poolOwner The pool owner to be written on the &#39;storageSlot&#39;.</span>
  571 |     | <span class='neutral'>function writePoolOwner(</span>
  572 |     | <span class='neutral'>  uint256 storageSlot,</span>
  573 |     | <span class='neutral'>  address poolOwner</span>
  574 |     | <span class='neutral'>) {</span>
  575 |     | <span class='neutral'>  writeStorage(storageSlot, uint256(uint160(poolOwner)));</span>
  576 |     | <span class='neutral'>}</span>
  577 |     | <span class='neutral'></span>
  578 |     | <span class='neutral'>////////////////////////////////////////////////////// Accrued parameters slots</span>
  579 |     | <span class='neutral'></span>
  580 |     | <span class='neutral'>// uint128(uint256(keccak256(&quot;accruedParams&quot;))) - 1</span>
  581 |     | <span class='neutral'>uint128 constant accruedParamsSlot = 0x5E1C6265E3E30CEA650443FB20EF1EF9;</span>
  582 |     | <span class='neutral'></span>
  583 |     | <span class='neutral'>/// @notice This function returns the storage slot containing to the pool&#39;s</span>
  584 |     | <span class='neutral'>/// accrued growth portions.</span>
  585 |     | <span class='neutral'>///</span>
  586 |     | <span class='neutral'>/// @param poolId The &#39;poolId&#39; whose owner slot to be derived.</span>
  587 |     | <span class='neutral'>/// @return storageSlot The storage slot containing the pool owner.</span>
  588 |     | <span class='neutral'>function getAccruedParamsSlot(</span>
  589 |     | <span class='neutral'>  uint256 poolId</span>
  590 |     | <span class='neutral'>) pure returns (uint256 storageSlot) {</span>
  591 |     | <span class='neutral'>  assembly {</span>
  592 |     | <span class='neutral'>    // We populate the first two memory slots from right to left:</span>
  593 |     | <span class='neutral'>    //</span>
  594 |     | <span class='neutral'>    //    0              32                  48</span>
  595 |     | <span class='neutral'>    //    |              |                   |</span>
  596 |     | <span class='neutral'>    //    +--------------+-------------------+</span>
  597 |     | <span class='neutral'>    //    |    poolId    | accruedParamsSlot |</span>
  598 |     | <span class='neutral'>    //    +--------------+-------------------+</span>
  599 |     | <span class='neutral'>    //</span>
  600 |     | <span class='neutral'>    mstore(16, accruedParamsSlot) // 16 = 48 - 32</span>
  601 |     | <span class='neutral'>    mstore(0, poolId)</span>
  602 |     | <span class='neutral'>    storageSlot := keccak256(0, 48)</span>
  603 |     | <span class='neutral'>  }</span>
  604 |     | <span class='neutral'>}</span>
  605 |     | <span class='neutral'></span>
  606 |     | <span class='neutral'>/// @notice This function reads the pool&#39;s accrued growth portions from storage</span>
  607 |     | <span class='neutral'>/// and sets them in the appropriate memory locations:</span>
  608 |     | <span class='neutral'>///</span>
  609 |     | <span class='neutral'>/// poolRatio0 (24 bits): the ratio of accrued value0 belonging to the pool.</span>
  610 |     | <span class='neutral'>/// poolRatio1 (24 bits): the ratio of accrued value1 belonging to the pool.</span>
  611 |     | <span class='neutral'>/// accrued0 (104 bits): total accrued in tag0 owed to both pool and protocol.</span>
  612 |     | <span class='neutral'>/// accrued1 (104 bits): total accrued in tag1 owed to both pool and protocol.</span>
  613 |     | <span class='neutral'>///</span>
  614 |     | <span class='neutral'>/// The above values are encoded tightly in the following order:</span>
  615 |     | <span class='neutral'>///</span>
  616 |     | <span class='neutral'>///         3 bytes          3 bytes          13 bytes         13 bytes</span>
  617 |     | <span class='neutral'>///    +----------------+----------------+----------------+----------------+</span>
  618 |     | <span class='neutral'>///    |   poolRatio1   |   poolRatio0   |    accrued1    |    accrued0    |</span>
  619 |     | <span class='neutral'>///    +----------------+----------------+----------------+----------------+</span>
  620 |     | <span class='neutral'>///</span>
  621 |     | <span class='neutral'>function readAccruedParams() view {</span>
  622 |     | <span class='neutral'>  X23 poolRatio0;</span>
  623 |     | <span class='neutral'>  X23 poolRatio1;</span>
  624 |     | <span class='neutral'>  X127 accrued0;</span>
  625 |     | <span class='neutral'>  X127 accrued1;</span>
  626 |     | <span class='neutral'>  uint256 accruedSlot = readStorage(getAccruedParamsSlot(getPoolId()));</span>
  627 |     | <span class='neutral'>  assembly {</span>
  628 |     | <span class='neutral'>    poolRatio0 := and(shr(208, accruedSlot), 0xFFFFFF)</span>
  629 |     | <span class='neutral'>    poolRatio1 := shr(232, accruedSlot)</span>
  630 |     | <span class='neutral'>    accrued0 := shl(127, and(accruedSlot, 0xFFFFFFFFFFFFFFFFFFFFFFFFFF))</span>
  631 |     | <span class='neutral'>    accrued1 := shl(23, and(</span>
  632 |     | <span class='neutral'>      accruedSlot,</span>
  633 |     | <span class='neutral'>      shl(104, 0xFFFFFFFFFFFFFFFFFFFFFFFFFF)</span>
  634 |     | <span class='neutral'>    ))</span>
  635 |     | <span class='neutral'>  }</span>
  636 |     | <span class='neutral'>  setPoolRatio0(poolRatio0);</span>
  637 |     | <span class='neutral'>  setPoolRatio1(poolRatio1);</span>
  638 |     | <span class='neutral'>  setAccrued0(accrued0);</span>
  639 |     | <span class='neutral'>  setAccrued1(accrued1);</span>
  640 |     | <span class='neutral'>}</span>
  641 |     | <span class='neutral'></span>
  642 |     | <span class='neutral'>/// @notice This function writes pool&#39;s accrued growth portions to storage from</span>
  643 |     | <span class='neutral'>/// memory.</span>
  644 |     | <span class='neutral'>function writeAccruedParams() {</span>
  645 |     | <span class='neutral'>  X127 accrued0 = getAccrued0();</span>
  646 |     | <span class='neutral'>  require(accrued0 &gt;= zeroX127, AccruedGrowthPortionOverflow(accrued0));</span>
  647 |     | <span class='neutral'>  require(accrued0 &lt;= accruedMax, AccruedGrowthPortionOverflow(accrued0));</span>
  648 |     | <span class='neutral'></span>
  649 |     | <span class='neutral'>  X127 accrued1 = getAccrued1();</span>
  650 |     | <span class='neutral'>  require(accrued1 &gt;= zeroX127, AccruedGrowthPortionOverflow(accrued1));</span>
  651 |     | <span class='neutral'>  require(accrued1 &lt;= accruedMax, AccruedGrowthPortionOverflow(accrued1));</span>
  652 |     | <span class='neutral'></span>
  653 |     | <span class='neutral'>  X23 poolRatio0 = getPoolRatio0();</span>
  654 |     | <span class='neutral'>  X23 poolRatio1 = getPoolRatio1();</span>
  655 |     | <span class='neutral'></span>
  656 |     | <span class='neutral'>  uint256 accruedSlot = getAccruedParamsSlot(getPoolId());</span>
  657 |     | <span class='neutral'>  uint256 accrued;</span>
  658 |     | <span class='neutral'>  assembly {</span>
  659 |     | <span class='neutral'>    accrued := or(</span>
  660 |     | <span class='neutral'>      or(shl(232, poolRatio1), shl(208, poolRatio0)),</span>
  661 |     | <span class='neutral'>      or(shl(104, shr(127, accrued1)), shr(127, accrued0))</span>
  662 |     | <span class='neutral'>    )</span>
  663 |     | <span class='neutral'>  }</span>
  664 |     | <span class='neutral'>  writeStorage(accruedSlot, accrued);</span>
  665 |     | <span class='neutral'>}</span>
  666 |     | <span class='neutral'></span>
  667 |     | <span class='neutral'>/////////////////////////////////////////////////////// Growth multiplier slots</span>
  668 |     | <span class='neutral'></span>
  669 |     | <span class='neutral'>// uint64(uint256(keccak256(&quot;growthMultiplier&quot;))) - 1</span>
  670 |     | <span class='neutral'>uint64 constant growthMultiplierSlot = 0x1447E579411C2C93;</span>
  671 |     | <span class='neutral'></span>
  672 |     | <span class='neutral'>/// @notice This function returns the storage slot containing the pool&#39;s growth</span>
  673 |     | <span class='neutral'>/// multiplier at the given interval boundary, i.e.,</span>
  674 |     | <span class='neutral'>/// &#39;growthMultiplier[qBoundary]&#39;.</span>
  675 |     | <span class='neutral'>///</span>
  676 |     | <span class='neutral'>/// @param poolId The corresponding poolId.</span>
  677 |     | <span class='neutral'>/// @param qBoundary The interval boundary whose corresponding growth</span>
  678 |     | <span class='neutral'>/// multiplier slot is to be derived.</span>
  679 |     | <span class='neutral'>/// @return storageSlot The storage slot containing the growth multiplier.</span>
  680 |     | <span class='neutral'>function getGrowthMultiplierSlot(</span>
  681 |     | <span class='neutral'>  uint256 poolId,</span>
  682 |     | <span class='neutral'>  X59 qBoundary</span>
  683 |     | <span class='neutral'>) pure returns (uint256 storageSlot) {</span>
  684 |     | <span class='neutral'>  assembly {</span>
  685 |     | <span class='neutral'>    // We populate the first two memory slots from right to left:</span>
  686 |     | <span class='neutral'>    //</span>
  687 |     | <span class='neutral'>    //    0                32                   40                     48</span>
  688 |     | <span class='neutral'>    //    |                |                    |                      |</span>
  689 |     | <span class='neutral'>    //    +----------------+--------------------+----------------------+</span>
  690 |     | <span class='neutral'>    //    |     poolId     |      qBoundary     | growthMultiplierSlot |</span>
  691 |     | <span class='neutral'>    //    +----------------+--------------------+----------------------+</span>
  692 |     | <span class='neutral'>    //</span>
  693 |     | <span class='neutral'>    mstore(16, growthMultiplierSlot) // 16 = 48 - 32</span>
  694 |     | <span class='neutral'>    mstore(8, qBoundary) // 8 = 40 - 32</span>
  695 |     | <span class='neutral'>    mstore(0, poolId) // 0 = 32 - 32</span>
  696 |     | <span class='neutral'>    storageSlot := keccak256(0, 48)</span>
  697 |     | <span class='neutral'>  }</span>
  698 |     | <span class='neutral'>}</span>
  699 |     | <span class='neutral'></span>
  700 |     | <span class='neutral'>/// @notice Reads the growth multiplier from &#39;storageSlot&#39;.</span>
  701 |     | <span class='neutral'>///</span>
  702 |     | <span class='neutral'>/// @param storageSlot The storage slot hosting the growth multiplier.</span>
  703 |     | <span class='neutral'>/// @return growthMultiplier The growth multiplier to be returned.</span>
  704 |     | <span class='neutral'>function readGrowthMultiplier(</span>
  705 |     | <span class='neutral'>  uint256 storageSlot</span>
  706 |     | <span class='neutral'>) view returns (</span>
  707 |     | <span class='neutral'>  X208 growthMultiplier</span>
  708 |     | <span class='neutral'>) {</span>
  709 |     | <span class='neutral'>  assembly {</span>
  710 |     | <span class='neutral'>    growthMultiplier := sload(storageSlot)</span>
  711 |     | <span class='neutral'>  }</span>
  712 |     | <span class='neutral'>}</span>
  713 |     | <span class='neutral'></span>
  714 |     | <span class='neutral'>/// @notice This function calculates the following default value of</span>
  715 |     | <span class='neutral'>/// &#39;growthMultiplier[qBoundary]&#39; for a given spaced &#39;qBoundary&#39; with the</span>
  716 |     | <span class='neutral'>/// assumption that &quot;qUpper &lt;= qBoundary&quot;:</span>
  717 |     | <span class='neutral'>///</span>
  718 |     | <span class='neutral'>///                                     +oo</span>
  719 |     | <span class='neutral'>///                                    -----</span>
  720 |     | <span class='neutral'>///    growthMultiplier[qBoundary]     \       - (qBoundary + j * qSpacing) / 2</span>
  721 |     | <span class='neutral'>///  &#39;----------------------------- == /     e</span>
  722 |     | <span class='neutral'>///              2 ** 208              -----</span>
  723 |     | <span class='neutral'>///                                    j = 0</span>
  724 |     | <span class='neutral'>///</span>
  725 |     | <span class='neutral'>///       - qBoundary / 2</span>
  726 |     | <span class='neutral'>///     e</span>
  727 |     | <span class='neutral'>///   ---------------------- ==</span>
  728 |     | <span class='neutral'>///          - qSpacing / 2</span>
  729 |     | <span class='neutral'>///    1 - e</span>
  730 |     | <span class='neutral'>///</span>
  731 |     | <span class='neutral'>///                                - 8 - qBoundary / 2</span>
  732 |     | <span class='neutral'>///     + 8         (2 ** 216) * e</span>
  733 |     | <span class='neutral'>///   e     * -------------------------------------------- ==</span>
  734 |     | <span class='neutral'>///                                        - qSpacing / 2</span>
  735 |     | <span class='neutral'>///            (2 ** 216) - (2 ** 216) * e</span>
  736 |     | <span class='neutral'>///</span>
  737 |     | <span class='neutral'>///                                - 8 - qBoundary / 2</span>
  738 |     | <span class='neutral'>///    exp8X208     (2 ** 216) * e</span>
  739 |     | <span class='neutral'>///   ---------- * ------------------------------------ &#39;.</span>
  740 |     | <span class='neutral'>///    2 ** 208      oneX216 - _spacing_.sqrt(false)</span>
  741 |     | <span class='neutral'>///</span>
  742 |     | <span class='neutral'>/// This is because the boundary is touched for the first time and the growth </span>
  743 |     | <span class='neutral'>/// for every single interval on its right side is equal to &#39;1&#39;.</span>
  744 |     | <span class='neutral'>///</span>
  745 |     | <span class='neutral'>/// &#39;qBoundary&#39; should be positive and less than &#39;2 ** 64&#39;.</span>
  746 |     | <span class='neutral'>///</span>
  747 |     | <span class='neutral'>/// @param qBoundary The interval boundary whose corresponding growth</span>
  748 |     | <span class='neutral'>/// multiplier is to be derived.</span>
  749 |     | <span class='neutral'>/// @return growthMultiplier The growth multiplier to be returned.</span>
  750 |     | <span class='neutral'>function calculateGrowthMultiplier0(</span>
  751 |     | <span class='neutral'>  X59 qBoundary</span>
  752 |     | <span class='neutral'>) pure returns (</span>
  753 |     | <span class='neutral'>  X208 growthMultiplier</span>
  754 |     | <span class='neutral'>) {</span>
  755 |     | <span class='neutral'>  // The requirements of &#39;exp&#39; are satisfied here due to the input </span>
  756 |     | <span class='neutral'>  // requirement of the present function.</span>
  757 |     | <span class='neutral'>  (X216 sqrtPrice, ) = qBoundary.exp();</span>
  758 |     | <span class='neutral'></span>
  759 |     | <span class='neutral'>  // &#39;mulDiv&#39; is safe because both the &#39;numerator&#39; and &#39;denominator&#39; are</span>
  760 |     | <span class='neutral'>  // nonnegative and also, the output does not exceed 256-bits. More</span>
  761 |     | <span class='neutral'>  // precisely:</span>
  762 |     | <span class='neutral'>  //</span>
  763 |     | <span class='neutral'>  //                     - qBoundary / 2</span>
  764 |     | <span class='neutral'>  //                   e</span>
  765 |     | <span class='neutral'>  //   &#39;(2 ** 208) * ---------------------- ==</span>
  766 |     | <span class='neutral'>  //                        - qSpacing / 2</span>
  767 |     | <span class='neutral'>  //                  1 - e</span>
  768 |     | <span class='neutral'>  //</span>
  769 |     | <span class='neutral'>  //                                  + 8</span>
  770 |     | <span class='neutral'>  //                                e</span>
  771 |     | <span class='neutral'>  //    (2 ** 208) * ----------------------------------- &lt; 2 ** 256&#39;</span>
  772 |     | <span class='neutral'>  //                        - minLogSpacing / (2 ** 60)</span>
  773 |     | <span class='neutral'>  //                  1 - e</span>
  774 |     | <span class='neutral'>  //</span>
  775 |     | <span class='neutral'>  growthMultiplier = exp8X208.mulDiv(</span>
  776 |     | <span class='neutral'>    sqrtPrice,</span>
  777 |     | <span class='neutral'>    oneX216 - _spacing_.sqrt(false)</span>
  778 |     | <span class='neutral'>  );</span>
  779 |     | <span class='neutral'>}</span>
  780 |     | <span class='neutral'></span>
  781 |     | <span class='neutral'>/// @notice This function calculates the following default value of</span>
  782 |     | <span class='neutral'>/// &#39;growthMultiplier[qBoundary]&#39; for a given spaced &#39;qBoundary&#39; with the</span>
  783 |     | <span class='neutral'>/// assumption that &quot;qBoundary &lt;= qLower&quot;:</span>
  784 |     | <span class='neutral'>///</span>
  785 |     | <span class='neutral'>///                                     +oo</span>
  786 |     | <span class='neutral'>///                                    -----</span>
  787 |     | <span class='neutral'>///    growthMultiplier[qBoundary]     \       + (qBoundary - j * qSpacing) / 2</span>
  788 |     | <span class='neutral'>///  &#39;----------------------------- == /     e</span>
  789 |     | <span class='neutral'>///              2 ** 208              -----</span>
  790 |     | <span class='neutral'>///                                    j = 0</span>
  791 |     | <span class='neutral'>///</span>
  792 |     | <span class='neutral'>///       + qBoundary / 2</span>
  793 |     | <span class='neutral'>///     e</span>
  794 |     | <span class='neutral'>///   ---------------------- ==</span>
  795 |     | <span class='neutral'>///          - qSpacing / 2</span>
  796 |     | <span class='neutral'>///    1 - e</span>
  797 |     | <span class='neutral'>///</span>
  798 |     | <span class='neutral'>///                                - 8 + qBoundary / 2</span>
  799 |     | <span class='neutral'>///     + 8         (2 ** 216) * e</span>
  800 |     | <span class='neutral'>///   e     * -------------------------------------------- ==</span>
  801 |     | <span class='neutral'>///                                        - qSpacing / 2</span>
  802 |     | <span class='neutral'>///            (2 ** 216) - (2 ** 216) * e</span>
  803 |     | <span class='neutral'>///</span>
  804 |     | <span class='neutral'>///                                - 8 + qBoundary / 2</span>
  805 |     | <span class='neutral'>///    exp8X208     (2 ** 216) * e</span>
  806 |     | <span class='neutral'>///   ---------- * ------------------------------------ &#39;.</span>
  807 |     | <span class='neutral'>///    2 ** 208      oneX216 - _spacing_.sqrt(false)</span>
  808 |     | <span class='neutral'>///</span>
  809 |     | <span class='neutral'>/// This is because the boundary is touched for the first time and the growth </span>
  810 |     | <span class='neutral'>/// for every single interval on its right side is equal to &#39;1&#39;.</span>
  811 |     | <span class='neutral'>/// </span>
  812 |     | <span class='neutral'>/// &#39;qBoundary&#39; should be positive and less than &#39;2 ** 64&#39;.</span>
  813 |     | <span class='neutral'>///</span>
  814 |     | <span class='neutral'>/// @param qBoundary The interval boundary whose corresponding growth</span>
  815 |     | <span class='neutral'>/// multiplier is to be derived.</span>
  816 |     | <span class='neutral'>/// @return growthMultiplier The growth multiplier to be returned.</span>
  817 |     | <span class='neutral'>function calculateGrowthMultiplier1(</span>
  818 |     | <span class='neutral'>  X59 qBoundary</span>
  819 |     | <span class='neutral'>) pure returns (</span>
  820 |     | <span class='neutral'>  X208 growthMultiplier</span>
  821 |     | <span class='neutral'>) {</span>
  822 |     | <span class='neutral'>  // The requirements of &#39;exp&#39; are satisfied here due to the input </span>
  823 |     | <span class='neutral'>  // requirement of the present function.</span>
  824 |     | <span class='neutral'>  (, X216 sqrtInversePrice) = qBoundary.exp();</span>
  825 |     | <span class='neutral'></span>
  826 |     | <span class='neutral'>  // &#39;mulDiv&#39; is safe because both the &#39;numerator&#39; and &#39;denominator&#39; are</span>
  827 |     | <span class='neutral'>  // nonnegative and also, the output does not exceed 256-bits. More</span>
  828 |     | <span class='neutral'>  // precisely:</span>
  829 |     | <span class='neutral'>  //</span>
  830 |     | <span class='neutral'>  //                     + qBoundary / 2</span>
  831 |     | <span class='neutral'>  //                   e</span>
  832 |     | <span class='neutral'>  //   &#39;(2 ** 208) * ---------------------- ==</span>
  833 |     | <span class='neutral'>  //                        - qSpacing / 2</span>
  834 |     | <span class='neutral'>  //                  1 - e</span>
  835 |     | <span class='neutral'>  //</span>
  836 |     | <span class='neutral'>  //                                  + 8</span>
  837 |     | <span class='neutral'>  //                                e</span>
  838 |     | <span class='neutral'>  //    (2 ** 208) * ----------------------------------- &lt; 2 ** 256&#39;</span>
  839 |     | <span class='neutral'>  //                        - minLogSpacing / (2 ** 60)</span>
  840 |     | <span class='neutral'>  //                  1 - e</span>
  841 |     | <span class='neutral'>  //</span>
  842 |     | <span class='neutral'>  growthMultiplier = exp8X208.mulDiv(</span>
  843 |     | <span class='neutral'>    sqrtInversePrice,</span>
  844 |     | <span class='neutral'>    oneX216 - _spacing_.sqrt(false)</span>
  845 |     | <span class='neutral'>  );</span>
  846 |     | <span class='neutral'>}</span>
  847 |     | <span class='neutral'></span>
  848 |     | <span class='neutral'>/// @notice This function returns &#39;growthMultiplier[qBoundary]&#39; for a given</span>
  849 |     | <span class='neutral'>/// spaced &#39;qBoundary&#39; with the assumption that &quot;qUpper &lt;= qBoundary&quot;. If </span>
  850 |     | <span class='neutral'>/// &#39;growthMultiplier[qBoundary]&#39; is never set on storage, the function returns</span>
  851 |     | <span class='neutral'>/// the default value.</span>
  852 |     | <span class='neutral'>///</span>
  853 |     | <span class='neutral'>/// &#39;qBoundary&#39; should be positive and less than &#39;2 ** 64&#39;.</span>
  854 |     | <span class='neutral'>///</span>
  855 |     | <span class='neutral'>/// @param qBoundary The interval boundary whose corresponding growth</span>
  856 |     | <span class='neutral'>/// multiplier is to be derived.</span>
  857 |     | <span class='neutral'>/// @return growthMultiplier The growth multiplier to be returned.</span>
  858 |     | <span class='neutral'>function readGrowthMultiplier0(</span>
  859 |     | <span class='neutral'>  X59 qBoundary</span>
  860 |     | <span class='neutral'>) returns (</span>
  861 |     | <span class='neutral'>  X208 growthMultiplier</span>
  862 |     | <span class='neutral'>) {</span>
  863 |     | <span class='neutral'>  // The storage slot containing &#39;growthMultiplier[qBoundary]&#39; is derived.</span>
  864 |     | <span class='neutral'>  uint256 storageSlot = getGrowthMultiplierSlot(getPoolId(), qBoundary);</span>
  865 |     | <span class='neutral'></span>
  866 |     | <span class='neutral'>  // &#39;growthMultiplier[qBoundary]&#39; is read from storage.</span>
  867 |     | <span class='neutral'>  growthMultiplier = readGrowthMultiplier(storageSlot);</span>
  868 |     | <span class='neutral'></span>
  869 |     | <span class='neutral'>  // If &#39;growthMultiplier[qBoundary]&#39; is not set before, then it should be</span>
  870 |     | <span class='neutral'>  // calculated, written on storage and returned.</span>
  871 |     | <span class='neutral'>  if (growthMultiplier == zeroX208) {</span>
  872 |     | <span class='neutral'>    // The default value for &#39;growthMultiplier[qBoundary]&#39; is calculated.</span>
  873 |     | <span class='neutral'>    growthMultiplier = calculateGrowthMultiplier0(qBoundary);</span>
  874 |     | <span class='neutral'></span>
  875 |     | <span class='neutral'>    // The calculation for &#39;growthMultiplier[qBoundary]&#39; is written on storage.</span>
  876 |     | <span class='neutral'>    writeGrowthMultiplier(storageSlot, growthMultiplier);</span>
  877 |     | <span class='neutral'>  }</span>
  878 |     | <span class='neutral'>}</span>
  879 |     | <span class='neutral'></span>
  880 |     | <span class='neutral'>/// @notice This function returns &#39;growthMultiplier[qBoundary]&#39; for a given</span>
  881 |     | <span class='neutral'>/// spaced &#39;qBoundary&#39; with the assumption that &quot;qBoundary &lt;= qLower&quot;. If </span>
  882 |     | <span class='neutral'>/// &#39;growthMultiplier[qBoundary]&#39; is never set on storage, the function returns</span>
  883 |     | <span class='neutral'>/// the default value.</span>
  884 |     | <span class='neutral'>///</span>
  885 |     | <span class='neutral'>/// &#39;qBoundary&#39; should be positive and less than &#39;2 ** 64&#39;.</span>
  886 |     | <span class='neutral'>///</span>
  887 |     | <span class='neutral'>/// @param qBoundary The interval boundary whose corresponding growth</span>
  888 |     | <span class='neutral'>/// multiplier is to be derived.</span>
  889 |     | <span class='neutral'>/// @return growthMultiplier The growth multiplier to be returned.</span>
  890 |     | <span class='neutral'>function readGrowthMultiplier1(</span>
  891 |     | <span class='neutral'>  X59 qBoundary</span>
  892 |     | <span class='neutral'>) returns (</span>
  893 |     | <span class='neutral'>  X208 growthMultiplier</span>
  894 |     | <span class='neutral'>) {</span>
  895 |     | <span class='neutral'>  // The storage slot containing &#39;growthMultiplier[qBoundary]&#39; is derived.</span>
  896 |     | <span class='neutral'>  uint256 storageSlot = getGrowthMultiplierSlot(getPoolId(), qBoundary);</span>
  897 |     | <span class='neutral'></span>
  898 |     | <span class='neutral'>  // &#39;growthMultiplier[qBoundary]&#39; is read from storage.</span>
  899 |     | <span class='neutral'>  growthMultiplier = readGrowthMultiplier(storageSlot);</span>
  900 |     | <span class='neutral'></span>
  901 |     | <span class='neutral'>  // If &#39;growthMultiplier[qBoundary]&#39; is not set before, then it should be</span>
  902 |     | <span class='neutral'>  // calculated, written on storage and returned.</span>
  903 |     | <span class='neutral'>  if (growthMultiplier == zeroX208) {</span>
  904 |     | <span class='neutral'>    // The default value for &#39;growthMultiplier[qBoundary]&#39; is calculated.</span>
  905 |     | <span class='neutral'>    growthMultiplier = calculateGrowthMultiplier1(qBoundary);</span>
  906 |     | <span class='neutral'></span>
  907 |     | <span class='neutral'>    // The calculated for &#39;growthMultiplier[qBoundary]&#39; is written on storage.</span>
  908 |     | <span class='neutral'>    writeGrowthMultiplier(storageSlot, growthMultiplier);</span>
  909 |     | <span class='neutral'>  }</span>
  910 |     | <span class='neutral'>}</span>
  911 |     | <span class='neutral'></span>
  912 |     | <span class='neutral'>/// @notice This function writes the given &#39;growthMultiplier&#39; in the given</span>
  913 |     | <span class='neutral'>///  &#39;storageSlot&#39;.</span>
  914 |     | <span class='neutral'>///</span>
  915 |     | <span class='neutral'>/// @param storageSlot The storage slot on which the growth multiplier is</span>
  916 |     | <span class='neutral'>/// written.</span>
  917 |     | <span class='neutral'>/// @param growthMultiplier The growth multiplier to be written.</span>
  918 |     | <span class='neutral'>function writeGrowthMultiplier(</span>
  919 |     | <span class='neutral'>  uint256 storageSlot,</span>
  920 |     | <span class='neutral'>  X208 growthMultiplier</span>
  921 |     | <span class='neutral'>) {</span>
  922 |     | <span class='neutral'>  assembly {</span>
  923 |     | <span class='neutral'>    sstore(storageSlot, growthMultiplier)</span>
  924 |     | <span class='neutral'>  }</span>
  925 |     | <span class='neutral'>}</span>
  926 |     | <span class='neutral'></span>
  927 |     | <span class='neutral'>/// @notice This function writes &#39;growthMultiplier&#39; values for the boundaries</span>
  928 |     | <span class='neutral'>/// of the first active interval.</span>
  929 |     | <span class='neutral'>///</span>
  930 |     | <span class='neutral'>/// @param qLower The left boundary of the active liquidity interval</span>
  931 |     | <span class='neutral'>/// @param qUpper The right boundary of the active liquidity interval</span>
  932 |     | <span class='neutral'>///</span>
  933 |     | <span class='neutral'>/// &#39;qLower&#39; and &#39;qUpper&#39; should be positive and less than &#39;2 ** 64&#39;.</span>
  934 |     | <span class='neutral'>///</span>
  935 |     | <span class='neutral'>function writeGrowthMultipliers(</span>
  936 |     | <span class='neutral'>  X59 qLower,</span>
  937 |     | <span class='neutral'>  X59 qUpper</span>
  938 |     | <span class='neutral'>) {</span>
  939 |     | <span class='neutral'>  uint256 poolId = getPoolId();</span>
  940 |     | <span class='neutral'></span>
  941 |     | <span class='neutral'>  // The default value for &#39;growthMultiplier[qLower]&#39; is calculated and written</span>
  942 |     | <span class='neutral'>  // in the appropriate storage slot.</span>
  943 |     | <span class='neutral'>  writeGrowthMultiplier(</span>
  944 |     | <span class='neutral'>    getGrowthMultiplierSlot(poolId, qLower),</span>
  945 |     | <span class='neutral'>    calculateGrowthMultiplier1(qLower)</span>
  946 |     | <span class='neutral'>  );</span>
  947 |     | <span class='neutral'></span>
  948 |     | <span class='neutral'>  // The default value for &#39;growthMultiplier[qUpper]&#39; is calculated and written</span>
  949 |     | <span class='neutral'>  // in the appropriate storage slot.</span>
  950 |     | <span class='neutral'>  writeGrowthMultiplier(</span>
  951 |     | <span class='neutral'>    getGrowthMultiplierSlot(poolId, qUpper),</span>
  952 |     | <span class='neutral'>    calculateGrowthMultiplier0(qUpper)</span>
  953 |     | <span class='neutral'>  );</span>
  954 |     | <span class='neutral'>}</span>
  955 |     | <span class='neutral'></span>
  956 |     | <span class='neutral'>////////////////////////////////////////////////////////////////// Shares slots</span>
  957 |     | <span class='neutral'></span>
  958 |     | <span class='neutral'>// uint128(uint256(keccak256(&quot;sharesGross&quot;))) - 1</span>
  959 |     | <span class='neutral'>uint128 constant sharesGrossSlot = 0xA20D6232B6352D00ABC0D966E2BCFB8A;</span>
  960 |     | <span class='neutral'></span>
  961 |     | <span class='neutral'>/// @notice This function returns the storage slot hosting the total number of</span>
  962 |     | <span class='neutral'>/// shares across every single interval of a pool.</span>
  963 |     | <span class='neutral'>///</span>
  964 |     | <span class='neutral'>/// @param poolId The &#39;poolId&#39; whose owner slot to be derived.</span>
  965 |     | <span class='neutral'>/// @return storageSlot The storage slot containing the pool owner.</span>
  966 |     | <span class='neutral'>function getSharesGrossSlot(</span>
  967 |     | <span class='neutral'>  uint256 poolId</span>
  968 |     | <span class='neutral'>) pure returns (</span>
  969 |     | <span class='neutral'>  uint256 storageSlot</span>
  970 |     | <span class='neutral'>) {</span>
  971 |     | <span class='neutral'>  assembly {</span>
  972 |     | <span class='neutral'>    // We populate the first two memory slots from right to left:</span>
  973 |     | <span class='neutral'>    //</span>
  974 |     | <span class='neutral'>    //    0                32                         48</span>
  975 |     | <span class='neutral'>    //    |                |                          |</span>
  976 |     | <span class='neutral'>    //    +----------------+--------------------------+</span>
  977 |     | <span class='neutral'>    //    |     poolId     |      sharesGrossSlot     |</span>
  978 |     | <span class='neutral'>    //    +----------------+--------------------------+</span>
  979 |     | <span class='neutral'>    //</span>
  980 |     | <span class='neutral'>    mstore(16, sharesGrossSlot)</span>
  981 |     | <span class='neutral'>    mstore(0, poolId)</span>
  982 |     | <span class='neutral'>    storageSlot := keccak256(0, 48)</span>
  983 |     | <span class='neutral'>  }</span>
  984 |     | <span class='neutral'>}</span>
  985 |     | <span class='neutral'></span>
  986 |     | <span class='neutral'>// uint64(uint256(keccak256(&quot;sharesDelta&quot;))) - 1</span>
  987 |     | <span class='neutral'>uint64 constant sharesDeltaSlot = 0xD7CB7A927A838D41;</span>
  988 |     | <span class='neutral'></span>
  989 |     | <span class='neutral'>/// @notice This function returns the storage slot containing the pool&#39;s shares</span>
  990 |     | <span class='neutral'>/// delta at the given interval boundary, i.e., &#39;sharesDelta[qBoundary]&#39;.</span>
  991 |     | <span class='neutral'>///</span>
  992 |     | <span class='neutral'>/// @param poolId The corresponding poolId.</span>
  993 |     | <span class='neutral'>/// @param qBoundary The interval boundary whose corresponding shares delta</span>
  994 |     | <span class='neutral'>/// slot is to be derived.</span>
  995 |     | <span class='neutral'>/// @return storageSlot The storage slot containing the shares delta.</span>
  996 |     | <span class='neutral'>function getSharesDeltaSlot(</span>
  997 |     | <span class='neutral'>  uint256 poolId,</span>
  998 |     | <span class='neutral'>  X59 qBoundary</span>
  999 |     | <span class='neutral'>) pure returns (</span>
 1000 |     | <span class='neutral'>  uint256 storageSlot</span>
 1001 |     | <span class='neutral'>) {</span>
 1002 |     | <span class='neutral'>  assembly {</span>
 1003 |     | <span class='neutral'>    // We populate the first two memory slots from right to left:</span>
 1004 |     | <span class='neutral'>    //</span>
 1005 |     | <span class='neutral'>    //    0                32                   40                48</span>
 1006 |     | <span class='neutral'>    //    |                |                    |                 |</span>
 1007 |     | <span class='neutral'>    //    +----------------+--------------------+-----------------+</span>
 1008 |     | <span class='neutral'>    //    |     poolId     |      qBoundary     | sharesDeltaSlot |</span>
 1009 |     | <span class='neutral'>    //    +----------------+--------------------+-----------------+</span>
 1010 |     | <span class='neutral'>    //</span>
 1011 |     | <span class='neutral'>    mstore(16, sharesDeltaSlot)</span>
 1012 |     | <span class='neutral'>    mstore(8, qBoundary)</span>
 1013 |     | <span class='neutral'>    mstore(0, poolId)</span>
 1014 |     | <span class='neutral'>    storageSlot := keccak256(0, 48)</span>
 1015 |     | <span class='neutral'>  }</span>
 1016 |     | <span class='neutral'>}</span>
 1017 |     | <span class='neutral'></span>
 1018 |     | <span class='neutral'>/// @notice Reads shares delta from &#39;storageSlot&#39;.</span>
 1019 |     | <span class='neutral'>///</span>
 1020 |     | <span class='neutral'>/// @param storageSlot The storage slot hosting the shares delta.</span>
 1021 |     | <span class='neutral'>/// @return sharesDelta The shares delta to be returned.</span>
 1022 |     | <span class='neutral'>function readSharesDelta(</span>
 1023 |     | <span class='neutral'>  uint256 storageSlot</span>
 1024 |     | <span class='neutral'>) view returns (</span>
 1025 |     | <span class='neutral'>  int256 sharesDelta</span>
 1026 |     | <span class='neutral'>) {</span>
 1027 |     | <span class='neutral'>  assembly {</span>
 1028 |     | <span class='neutral'>    sharesDelta := sload(storageSlot)</span>
 1029 |     | <span class='neutral'>  }</span>
 1030 |     | <span class='neutral'>}</span>
 1031 |     | <span class='neutral'></span>
 1032 |     | <span class='neutral'>/// @notice Gets the number of shares to be deposited/withdrawn as a result of</span>
 1033 |     | <span class='neutral'>/// modifying a position from memory and adjusting &#39;sharesDelta&#39; values in</span>
 1034 |     | <span class='neutral'>/// storage accordingly.</span>
 1035 |     | <span class='neutral'>function modifySharesDelta() {</span>
 1036 |     | <span class='neutral'>  // &#39;poolId&#39; and the number of shares to be added/subtracted are loaded from</span>
 1037 |     | <span class='neutral'>  // the memory.</span>
 1038 |     | <span class='neutral'>  uint256 poolId = getPoolId();</span>
 1039 |     | <span class='neutral'>  int256 shares = getShares();</span>
 1040 |     | <span class='neutral'></span>
 1041 |     | <span class='neutral'>  // &#39;sharesDelta[logPriceMinOffsetted]&#39; is adjusted.</span>
 1042 |     | <span class='neutral'>  X59 logPriceMinOffsetted = getLogPriceMinOffsetted();</span>
 1043 |     | <span class='neutral'>  uint256 storageSlot = getSharesDeltaSlot(poolId, logPriceMinOffsetted);</span>
 1044 |     | <span class='neutral'>  assembly {</span>
 1045 |     | <span class='neutral'>    sstore(storageSlot, add(sload(storageSlot), shares))</span>
 1046 |     | <span class='neutral'>  }</span>
 1047 |     | <span class='neutral'></span>
 1048 |     | <span class='neutral'>  // &#39;sharesDelta[logPriceMaxOffsetted]&#39; is adjusted.</span>
 1049 |     | <span class='neutral'>  X59 logPriceMaxOffsetted = getLogPriceMaxOffsetted();</span>
 1050 |     | <span class='neutral'>  storageSlot = getSharesDeltaSlot(poolId, logPriceMaxOffsetted);</span>
 1051 |     | <span class='neutral'>  assembly {</span>
 1052 |     | <span class='neutral'>    sstore(storageSlot, sub(sload(storageSlot), shares))</span>
 1053 |     | <span class='neutral'>  }</span>
 1054 |     | <span class='neutral'></span>
 1055 |     | <span class='neutral'>  // The total number of shares across all intervals may never exceed</span>
 1056 |     | <span class='neutral'>  // &#39;type(int128).max&#39;. This is verified next.</span>
 1057 |     | <span class='neutral'>  int256 sharesGross;</span>
 1058 |     | <span class='neutral'>  storageSlot = getSharesGrossSlot(poolId);</span>
 1059 |     | <span class='neutral'>  X59 qSpacing = _spacing_.log();</span>
 1060 |     | <span class='neutral'>  assembly {</span>
 1061 |     | <span class='neutral'>    sharesGross := add(</span>
 1062 |     | <span class='neutral'>      sload(storageSlot),</span>
 1063 |     | <span class='neutral'>      //</span>
 1064 |     | <span class='neutral'>      //             logPriceMaxOffsetted - logPriceMinOffsetted</span>
 1065 |     | <span class='neutral'>      //  &#39;shares * ---------------------------------------------&#39;</span>
 1066 |     | <span class='neutral'>      //                               qSpacing</span>
 1067 |     | <span class='neutral'>      mul(</span>
 1068 |     | <span class='neutral'>        // &#39;qSpacing&#39; is non-zero. Hence, division is safe.</span>
 1069 |     | <span class='neutral'>        div(sub(logPriceMaxOffsetted, logPriceMinOffsetted), qSpacing),</span>
 1070 |     | <span class='neutral'>        shares</span>
 1071 |     | <span class='neutral'>      )</span>
 1072 |     | <span class='neutral'>    )</span>
 1073 |     | <span class='neutral'>    sstore(storageSlot, sharesGross)</span>
 1074 |     | <span class='neutral'>  }</span>
 1075 |     | <span class='neutral'></span>
 1076 |     | <span class='neutral'>  require(sharesGross &lt;= type(int128).max, SharesGrossOverflow(sharesGross));</span>
 1077 |     | <span class='neutral'>}</span>
 1078 |     | <span class='neutral'></span>
 1079 |     | <span class='neutral'>//////////////////////////////////////////////////////////// Dynamic parameters</span>
 1080 |     | <span class='neutral'></span>
 1081 |     | <span class='neutral'>// uint128(uint256(keccak256(&quot;dynamicParams&quot;))) - 1</span>
 1082 |     | <span class='neutral'>uint128 constant dynamicParamsSlot = 0x6890D047AD8C870137858A70716B2C6B;</span>
 1083 |     | <span class='neutral'></span>
 1084 |     | <span class='neutral'>/// @notice This function returns the storage slot hosting the dynamic</span>
 1085 |     | <span class='neutral'>/// parameters of a pool.</span>
 1086 |     | <span class='neutral'>///</span>
 1087 |     | <span class='neutral'>/// @param poolId The &#39;poolId&#39; whose owner slot to be derived.</span>
 1088 |     | <span class='neutral'>/// @return storageSlot The storage slot containing the pool owner.</span>
 1089 |     | <span class='unexecuted'>function getDynamicParamsSlot(</span>
 1090 |     | <span class='neutral'>  uint256 poolId</span>
 1091 |     | <span class='neutral'>) pure returns (</span>
 1092 |     | <span class='unexecuted'>  uint256 storageSlot</span>
 1093 |     | <span class='neutral'>) {</span>
 1094 |     | <span class='unexecuted'>  assembly {</span>
 1095 |     | <span class='neutral'>    // We populate the first two memory slots from right to left:</span>
 1096 |     | <span class='neutral'>    //</span>
 1097 |     | <span class='neutral'>    //    0                32                  48</span>
 1098 |     | <span class='neutral'>    //    |                |                   |</span>
 1099 |     | <span class='neutral'>    //    +----------------+-------------------+</span>
 1100 |     | <span class='neutral'>    //    |     poolId     | dynamicParamsSlot |</span>
 1101 |     | <span class='neutral'>    //    +----------------+-------------------+</span>
 1102 |     | <span class='neutral'>    //</span>
 1103 |     | <span class='neutral'>    mstore(16, dynamicParamsSlot)</span>
 1104 |     | <span class='neutral'>    mstore(0, poolId)</span>
 1105 |     | <span class='neutral'>    storageSlot := keccak256(0, 48)</span>
 1106 |     | <span class='neutral'>  }</span>
 1107 |     | <span class='neutral'>}</span>
 1108 |     | <span class='neutral'></span>
 1109 |     | <span class='neutral'>/// @notice This function reads pool&#39;s dynamic parameters from storage and sets</span>
 1110 |     | <span class='neutral'>/// them in appropriate memory locations.</span>
 1111 |     | <span class='neutral'>function readDynamicParams() view {</span>
 1112 |     | <span class='neutral'>  // The storage slot hosting the dynamic parameters of the pool is derived.</span>
 1113 |     | <span class='neutral'>  uint256 storageSlot = getDynamicParamsSlot(getPoolId());</span>
 1114 |     | <span class='neutral'></span>
 1115 |     | <span class='neutral'>  // Dynamic parameters are read from storage and stored in memory.</span>
 1116 |     | <span class='neutral'>  assembly {</span>
 1117 |     | <span class='neutral'>    mstore(add(_dynamicParams_, 32), sload(storageSlot))</span>
 1118 |     | <span class='neutral'>    mstore(add(_dynamicParams_, 64), sload(add(storageSlot, 1)))</span>
 1119 |     | <span class='neutral'>    mstore(add(_dynamicParams_, 96), sload(add(storageSlot, 2)))</span>
 1120 |     | <span class='neutral'>  }</span>
 1121 |     | <span class='neutral'></span>
 1122 |     | <span class='neutral'>  // For an existing pool, &#39;growth&#39; is always greater than or equal to</span>
 1123 |     | <span class='neutral'>  // &#39;oneX111&#39;. Hence, &#39;getGrowth() == zeroX111&#39; indicates that the pool does</span>
 1124 |     | <span class='neutral'>  // not exist.</span>
 1125 |     | <span class='neutral'>  require(getGrowth() != zeroX111, PoolDoesNotExist(getPoolId()));</span>
 1126 |     | <span class='neutral'></span>
 1127 |     | <span class='neutral'>  // &#39;staticParamsStoragePointer == type(uint16).max&#39; indicates that the</span>
 1128 |     | <span class='neutral'>  // storage pointer for static parameters has overflowed and the storage slot</span>
 1129 |     | <span class='neutral'>  // for &#39;staticParamsStoragePointerExtension&#39; needs to be read.</span>
 1130 |     | <span class='neutral'>  uint16 staticParamsStoragePointer = getStaticParamsStoragePointer();</span>
 1131 |     | <span class='neutral'>  if (staticParamsStoragePointer == type(uint16).max) {</span>
 1132 |     | <span class='neutral'>    assembly {</span>
 1133 |     | <span class='neutral'>      mstore(_dynamicParams_, sload(sub(storageSlot, 1)))</span>
 1134 |     | <span class='neutral'>    } </span>
 1135 |     | <span class='neutral'>  } else {</span>
 1136 |     | <span class='neutral'>    setStaticParamsStoragePointerExtension(</span>
 1137 |     | <span class='neutral'>      uint256(staticParamsStoragePointer)</span>
 1138 |     | <span class='neutral'>    );</span>
 1139 |     | <span class='neutral'>  }</span>
 1140 |     | <span class='neutral'>}</span>
 1141 |     | <span class='neutral'></span>
 1142 |     | <span class='neutral'>/// @notice This function loads pool&#39;s dynamic parameters from the memory and</span>
 1143 |     | <span class='neutral'>/// writes them on storage.</span>
 1144 |     | <span class='neutral'>function writeDynamicParams() {</span>
 1145 |     | <span class='neutral'>  // The storage slot hosting the dynamic parameters of the pool is derived.</span>
 1146 |     | <span class='neutral'>  uint256 storageSlot = getDynamicParamsSlot(getPoolId());</span>
 1147 |     | <span class='neutral'></span>
 1148 |     | <span class='neutral'>  // &#39;staticParamsStoragePointer &gt;= type(uint16).max&#39; indicates that the</span>
 1149 |     | <span class='neutral'>  // storage pointer for static parameters has overflowed and the storage slot</span>
 1150 |     | <span class='neutral'>  // for &#39;staticParamsStoragePointerExtension&#39; needs to be used.</span>
 1151 |     | <span class='neutral'>  if (getStaticParamsStoragePointerExtension() &gt;= type(uint16).max) {</span>
 1152 |     | <span class='neutral'>    assembly {</span>
 1153 |     | <span class='neutral'>      sstore(sub(storageSlot, 1), mload(_dynamicParams_))</span>
 1154 |     | <span class='neutral'>    }</span>
 1155 |     | <span class='neutral'>    setStaticParamsStoragePointer(type(uint16).max);</span>
 1156 |     | <span class='neutral'>  } else {</span>
 1157 |     | <span class='neutral'>    setStaticParamsStoragePointer(</span>
 1158 |     | <span class='neutral'>      uint16(getStaticParamsStoragePointerExtension())</span>
 1159 |     | <span class='neutral'>    );</span>
 1160 |     | <span class='neutral'>  }</span>
 1161 |     | <span class='neutral'></span>
 1162 |     | <span class='neutral'>  // Next, the dynamic parameters are loaded from the memory and written on </span>
 1163 |     | <span class='neutral'>  // storage.</span>
 1164 |     | <span class='neutral'>  assembly {</span>
 1165 |     | <span class='neutral'>    sstore(storageSlot, mload(add(_dynamicParams_, 32)))</span>
 1166 |     | <span class='neutral'>    sstore(add(storageSlot, 1), mload(add(_dynamicParams_, 64)))</span>
 1167 |     | <span class='neutral'>    sstore(add(storageSlot, 2), mload(add(_dynamicParams_, 96)))</span>
 1168 |     | <span class='neutral'>  }</span>
 1169 |     | <span class='neutral'>}</span>
 1170 |     | <span class='neutral'></span>
 1171 |     | <span class='neutral'>/////////////////////////////////////////////////////////////////// Curve slots</span>
 1172 |     | <span class='neutral'></span>
 1173 |     | <span class='neutral'>// uint128(uint256(keccak256(&quot;curve&quot;))) - 1</span>
 1174 |     | <span class='neutral'>uint128 constant curveSlot = 0x3B2D91718DFB37F9969A1B0670A83E70;</span>
 1175 |     | <span class='neutral'></span>
 1176 |     | <span class='neutral'>/// @notice This function returns the storage slot hosting the curve sequence</span>
 1177 |     | <span class='neutral'>/// of a pool.</span>
 1178 |     | <span class='neutral'>///</span>
 1179 |     | <span class='neutral'>/// @param poolId The &#39;poolId&#39; whose owner slot to be derived.</span>
 1180 |     | <span class='neutral'>/// @return storageSlot The storage slot containing the pool owner.</span>
 1181 |     | <span class='neutral'>function getCurveSlot(</span>
 1182 |     | <span class='neutral'>  uint256 poolId</span>
 1183 |     | <span class='neutral'>) pure returns (</span>
 1184 |     | <span class='neutral'>  uint256 storageSlot</span>
 1185 |     | <span class='neutral'>) {</span>
 1186 |     | <span class='neutral'>  assembly {</span>
 1187 |     | <span class='neutral'>    // We populate the first two memory slots from right to left:</span>
 1188 |     | <span class='neutral'>    //</span>
 1189 |     | <span class='neutral'>    //    0                32                  48</span>
 1190 |     | <span class='neutral'>    //    |                |                   |</span>
 1191 |     | <span class='neutral'>    //    +----------------+-------------------+</span>
 1192 |     | <span class='neutral'>    //    |     poolId     |     curveSlot     |</span>
 1193 |     | <span class='neutral'>    //    +----------------+-------------------+</span>
 1194 |     | <span class='neutral'>    //</span>
 1195 |     | <span class='neutral'>    mstore(16, curveSlot)</span>
 1196 |     | <span class='neutral'>    mstore(0, poolId)</span>
 1197 |     | <span class='neutral'>    storageSlot := keccak256(0, 48)</span>
 1198 |     | <span class='neutral'>  }</span>
 1199 |     | <span class='neutral'>}</span>
 1200 |     | <span class='neutral'></span>
 1201 |     | <span class='neutral'>/// @notice Reads &#39;qLower&#39; and &#39;qUpper&#39; boundaries of the current interval from</span>
 1202 |     | <span class='neutral'>/// storage.</span>
 1203 |     | <span class='neutral'>///</span>
 1204 |     | <span class='neutral'>/// @return qLower The left boundary of the active liquidity interval</span>
 1205 |     | <span class='neutral'>/// @return qUpper The right boundary of the active liquidity interval</span>
 1206 |     | <span class='neutral'>function readBoundaries() view returns (</span>
 1207 |     | <span class='neutral'>  X59 qLower,</span>
 1208 |     | <span class='neutral'>  X59 qUpper</span>
 1209 |     | <span class='neutral'>) {</span>
 1210 |     | <span class='neutral'>  // Reads the first slot of the curve sequence from storage.</span>
 1211 |     | <span class='neutral'>  uint256 firstSlot = readStorage(getCurveSlot(getPoolId()));</span>
 1212 |     | <span class='neutral'>  </span>
 1213 |     | <span class='neutral'>  Curve curve = getCurve();</span>
 1214 |     | <span class='neutral'>  setCurveLength(twoIndex);</span>
 1215 |     | <span class='neutral'>  </span>
 1216 |     | <span class='neutral'>  assembly {</span>
 1217 |     | <span class='neutral'>    mstore(curve, firstSlot)</span>
 1218 |     | <span class='neutral'>  }</span>
 1219 |     | <span class='neutral'>  </span>
 1220 |     | <span class='neutral'>  qLower = curve.member(zeroIndex);</span>
 1221 |     | <span class='neutral'>  qUpper = curve.member(oneIndex);</span>
 1222 |     | <span class='neutral'>  (qLower, qUpper) = qLower &lt; qUpper ? (qLower, qUpper) : (qUpper, qLower);</span>
 1223 |     | <span class='neutral'>}</span>
 1224 |     | <span class='neutral'></span>
 1225 |     | <span class='neutral'>/// @notice Reads the entire curve from storage and stores it in memory.</span>
 1226 |     | <span class='neutral'>function readCurve() view returns (Index curveLength) {</span>
 1227 |     | <span class='neutral'>  // Reads the first slot of the curve sequence from storage.</span>
 1228 |     | <span class='neutral'>  uint256 storageSlot = getCurveSlot(getPoolId());</span>
 1229 |     | <span class='neutral'></span>
 1230 |     | <span class='neutral'>  // The memory pointer referring to the first member of the curve sequence is</span>
 1231 |     | <span class='neutral'>  // loaded from the memory.</span>
 1232 |     | <span class='neutral'>  Curve memoryPointer = getCurve();</span>
 1233 |     | <span class='neutral'></span>
 1234 |     | <span class='neutral'>  // Let &#39;l&#39; denote the number of members in the curve sequence. Since, we</span>
 1235 |     | <span class='neutral'>  // already know &#39;qCurrent&#39; from dynamic parameters, we can determine &#39;l&#39;</span>
 1236 |     | <span class='neutral'>  // without having to load an entire length slot! In other words, we keep</span>
 1237 |     | <span class='neutral'>  // reading members of the curve sequence from protocol&#39;s storage (four</span>
 1238 |     | <span class='neutral'>  // members per slot) until we encounter &#39;qCurrent&#39; which is already known</span>
 1239 |     | <span class='neutral'>  // from dynamic parameters. Then, &#39;l&#39; can be determined based on the position</span>
 1240 |     | <span class='neutral'>  // of &#39;qCurrent&#39; in the curve sequence.</span>
 1241 |     | <span class='neutral'>  X59 qCurrent = getLogPriceCurrent();</span>
 1242 |     | <span class='neutral'></span>
 1243 |     | <span class='neutral'>  assembly {</span>
 1244 |     | <span class='neutral'>    let value</span>
 1245 |     | <span class='neutral'></span>
 1246 |     | <span class='neutral'>    // The loop is broken whenever we encounter &#39;qCurrent&#39;.</span>
 1247 |     | <span class='neutral'>    for {} 0x1 {} {</span>
 1248 |     | <span class='neutral'>      value := sload(storageSlot)</span>
 1249 |     | <span class='neutral'></span>
 1250 |     | <span class='neutral'>      // Examines if the most significant 64 bits are equal to &#39;qCurrent&#39;.</span>
 1251 |     | <span class='neutral'>      let member := shr(192, value)</span>
 1252 |     | <span class='neutral'>      if eq(member, qCurrent) {</span>
 1253 |     | <span class='neutral'>        curveLength := add(curveLength, 1)</span>
 1254 |     | <span class='neutral'>        value := shl(192, member)</span>
 1255 |     | <span class='neutral'>        break</span>
 1256 |     | <span class='neutral'>      }</span>
 1257 |     | <span class='neutral'></span>
 1258 |     | <span class='neutral'>      // Examines if the second most significant 64 bits are equal to</span>
 1259 |     | <span class='neutral'>      // &#39;qCurrent&#39;.</span>
 1260 |     | <span class='neutral'>      member := shr(128, value)</span>
 1261 |     | <span class='neutral'>      if eq(and(member, 0xFFFFFFFFFFFFFFFF), qCurrent) {</span>
 1262 |     | <span class='neutral'>        curveLength := add(curveLength, 2)</span>
 1263 |     | <span class='neutral'>        value := shl(128, member)</span>
 1264 |     | <span class='neutral'>        break</span>
 1265 |     | <span class='neutral'>      }</span>
 1266 |     | <span class='neutral'></span>
 1267 |     | <span class='neutral'>      // Examines if the third most significant 64 bits are equal to</span>
 1268 |     | <span class='neutral'>      // &#39;qCurrent&#39;.</span>
 1269 |     | <span class='neutral'>      member := shr(64, value)</span>
 1270 |     | <span class='neutral'>      if eq(and(member, 0xFFFFFFFFFFFFFFFF), qCurrent) {</span>
 1271 |     | <span class='neutral'>        curveLength := add(curveLength, 3)</span>
 1272 |     | <span class='neutral'>        value := shl(64, member)</span>
 1273 |     | <span class='neutral'>        break</span>
 1274 |     | <span class='neutral'>      }</span>
 1275 |     | <span class='neutral'></span>
 1276 |     | <span class='neutral'>      curveLength := add(curveLength, 4)</span>
 1277 |     | <span class='neutral'></span>
 1278 |     | <span class='neutral'>      // Examines if the least significant 64 bits are equal to</span>
 1279 |     | <span class='neutral'>      // &#39;qCurrent&#39;.</span>
 1280 |     | <span class='neutral'>      if eq(and(value, 0xFFFFFFFFFFFFFFFF), qCurrent) {</span>
 1281 |     | <span class='neutral'>        break</span>
 1282 |     | <span class='neutral'>      }</span>
 1283 |     | <span class='neutral'></span>
 1284 |     | <span class='neutral'>      // &#39;value&#39; is stored in memory.</span>
 1285 |     | <span class='neutral'>      mstore(memoryPointer, value)</span>
 1286 |     | <span class='neutral'></span>
 1287 |     | <span class='neutral'>      // &#39;storageSlot&#39; is incremented.</span>
 1288 |     | <span class='neutral'>      storageSlot := add(storageSlot, 1)</span>
 1289 |     | <span class='neutral'></span>
 1290 |     | <span class='neutral'>      // &#39;memoryPointer&#39; is incremented by 32 bytes.</span>
 1291 |     | <span class='neutral'>      memoryPointer := add(memoryPointer, 32)</span>
 1292 |     | <span class='neutral'>    }</span>
 1293 |     | <span class='neutral'></span>
 1294 |     | <span class='neutral'>    // &#39;value&#39; is stored in memory.</span>
 1295 |     | <span class='neutral'>    mstore(memoryPointer, value)</span>
 1296 |     | <span class='neutral'>  }</span>
 1297 |     | <span class='neutral'>}</span>
 1298 |     | <span class='neutral'></span>
 1299 |     | <span class='neutral'>/// @notice Writes the current curve sequence on storage.</span>
 1300 |     | <span class='neutral'>function writeCurve() {</span>
 1301 |     | <span class='neutral'>  // Reads the first slot of the curve sequence from storage.</span>
 1302 |     | <span class='neutral'>  uint256 storageSlot = getCurveSlot(getPoolId());</span>
 1303 |     | <span class='neutral'></span>
 1304 |     | <span class='neutral'>  // The memory pointer referring to the first member of the curve sequence is</span>
 1305 |     | <span class='neutral'>  // loaded from the memory.</span>
 1306 |     | <span class='neutral'>  Curve memoryPointer = getCurve();</span>
 1307 |     | <span class='neutral'></span>
 1308 |     | <span class='neutral'>  // The length of the current curve squence in memory is loaded.</span>
 1309 |     | <span class='neutral'>  Index curveLength = getCurveLength();</span>
 1310 |     | <span class='neutral'></span>
 1311 |     | <span class='neutral'>  assembly {</span>
 1312 |     | <span class='neutral'>    // The last storage slot for the curve sequence is read derived.</span>
 1313 |     | <span class='neutral'>    let finalSlot := add(storageSlot, shr(2, sub(curveLength, 1)))</span>
 1314 |     | <span class='neutral'></span>
 1315 |     | <span class='neutral'>    // The first slot of the curve sequence is loaded from memory and written</span>
 1316 |     | <span class='neutral'>    // on storage.</span>
 1317 |     | <span class='neutral'>    sstore(storageSlot, mload(memoryPointer))</span>
 1318 |     | <span class='neutral'></span>
 1319 |     | <span class='neutral'>    // This loop continues until we encounter &#39;finalSlot&#39;.</span>
 1320 |     | <span class='neutral'>    for {} lt(storageSlot, finalSlot) {} {</span>
 1321 |     | <span class='neutral'>      // &#39;storageSlot&#39; is incremented.</span>
 1322 |     | <span class='neutral'>      storageSlot := add(storageSlot, 1)</span>
 1323 |     | <span class='neutral'></span>
 1324 |     | <span class='neutral'>      // &#39;memoryPointer&#39; is incremented by 32 bytes.</span>
 1325 |     | <span class='neutral'>      memoryPointer := add(memoryPointer, 32)</span>
 1326 |     | <span class='neutral'></span>
 1327 |     | <span class='neutral'>      // The slot of the curve sequence which is pointed to by &#39;memoryPointer&#39;</span>
 1328 |     | <span class='neutral'>      // is loaded from the memory and is written on storage.</span>
 1329 |     | <span class='neutral'>      sstore(storageSlot, mload(memoryPointer))</span>
 1330 |     | <span class='neutral'>    }</span>
 1331 |     | <span class='neutral'>  }</span>
 1332 |     | <span class='neutral'>}</span>
 1333 |     | <span class='neutral'></span>
 1334 |     | <span class='neutral'>////////////////////////////////////////// Static parameters and kernel storage</span>
 1335 |     | <span class='neutral'></span>
 1336 |     | <span class='neutral'>/// @notice This function deploys a storage contract whose bytecode contains</span>
 1337 |     | <span class='neutral'>/// the pool&#39;s static parameters.</span>
 1338 |     | <span class='neutral'>///</span>
 1339 |     | <span class='neutral'>/// @param storagePointer The pointer which is used to derive the address of</span>
 1340 |     | <span class='neutral'>/// the storage smart contract.</span>
 1341 |     | <span class='neutral'>function writeStaticParams(uint256 storagePointer) {</span>
 1342 |     | <span class='neutral'>  uint256 poolId = getPoolId();</span>
 1343 |     | <span class='neutral'>  address proxy;</span>
 1344 |     | <span class='neutral'>  assembly {</span>
 1345 |     | <span class='neutral'>    // The 32-byte storage pointer is derived by hashing the following 64</span>
 1346 |     | <span class='neutral'>    // bytes:</span>
 1347 |     | <span class='neutral'>    mstore(0, poolId)</span>
 1348 |     | <span class='neutral'>    mstore(32, storagePointer)</span>
 1349 |     | <span class='neutral'>    storagePointer := keccak256(0, 64)</span>
 1350 |     | <span class='neutral'></span>
 1351 |     | <span class='neutral'>    // Static parameters are stored in a &#39;storage contract&#39; which is deployed</span>
 1352 |     | <span class='neutral'>    // by a disposable &#39;proxy contract&#39;. First the &#39;proxy contract&#39; is</span>
 1353 |     | <span class='neutral'>    // deployed.</span>
 1354 |     | <span class='neutral'>    mstore(0x00, PROXY_CREATION_CODE)</span>
 1355 |     | <span class='neutral'>    proxy := create2(0, 0x10, 0x10, storagePointer)</span>
 1356 |     | <span class='neutral'>  }</span>
 1357 |     | <span class='neutral'></span>
 1358 |     | <span class='neutral'>  require(proxy != address(0), DeploymentFailed());</span>
 1359 |     | <span class='neutral'></span>
 1360 |     | <span class='neutral'>  // The total number of bytes to be written.</span>
 1361 |     | <span class='neutral'>  Index length = getKernelLength();</span>
 1362 |     | <span class='neutral'>  uint256 deploymentCreationCode;</span>
 1363 |     | <span class='neutral'>  assembly {</span>
 1364 |     | <span class='neutral'>    length := add(</span>
 1365 |     | <span class='neutral'>      sub(_endOfStaticParams_, _staticParams_), // Length of static parameters.</span>
 1366 |     | <span class='neutral'>      shl(6, sub(length, 1)) // Length of kernel.</span>
 1367 |     | <span class='neutral'>    )</span>
 1368 |     | <span class='neutral'>    // &#39;1&#39; is added to include the &#39;00&#39; padding bytes. Due the &#39;1019&#39; limit on</span>
 1369 |     | <span class='neutral'>    // the size of kernel, the addition is always safe.</span>
 1370 |     | <span class='neutral'>    deploymentCreationCode := or(DEPLOYMENT_CODE, shl(64, add(length, 1)))</span>
 1371 |     | <span class='neutral'>  }</span>
 1372 |     | <span class='neutral'>  setDeploymentCreationCode(deploymentCreationCode);</span>
 1373 |     | <span class='neutral'></span>
 1374 |     | <span class='neutral'>  // Data is written from memory to a new contract via the proxy.</span>
 1375 |     | <span class='neutral'>  bool success;</span>
 1376 |     | <span class='neutral'>  assembly {</span>
 1377 |     | <span class='neutral'>    success := call(</span>
 1378 |     | <span class='neutral'>      gas(),</span>
 1379 |     | <span class='neutral'>      proxy,</span>
 1380 |     | <span class='neutral'>      0,</span>
 1381 |     | <span class='neutral'>      _deploymentCreationCode_,</span>
 1382 |     | <span class='neutral'>      add(length, 11), // Because &#39;DEPLOYMENT_CODE&#39; is 11 bytes.</span>
 1383 |     | <span class='neutral'>      0,</span>
 1384 |     | <span class='neutral'>      0</span>
 1385 |     | <span class='neutral'>    )</span>
 1386 |     | <span class='neutral'>  }</span>
 1387 |     | <span class='neutral'></span>
 1388 |     | <span class='neutral'>  require(success, DeploymentFailed());</span>
 1389 |     | <span class='neutral'>}</span>
 1390 |     | <span class='neutral'></span>
 1391 |     | <span class='neutral'>/// @notice This function calculates the address of the storage contract</span>
 1392 |     | <span class='neutral'>/// containing static parameters and kernel.</span>
 1393 |     | <span class='neutral'>///</span>
 1394 |     | <span class='neutral'>/// @param storagePointer The pointer which is used to derive the address of</span>
 1395 |     | <span class='neutral'>/// the storage smart contract.</span>
 1396 |     | <span class='neutral'>/// @return storageAddress The address of the storage contract whose bytecode</span>
 1397 |     | <span class='neutral'>/// comprises static parameters and kernel.</span>
 1398 |     | <span class='neutral'>function getStaticParamsStorageAddress(</span>
 1399 |     | <span class='neutral'>  uint256 storagePointer</span>
 1400 |     | <span class='neutral'>) view returns (</span>
 1401 |     | <span class='neutral'>  address storageAddress</span>
 1402 |     | <span class='neutral'>) {</span>
 1403 |     | <span class='neutral'>  address nofeeswap;</span>
 1404 |     | <span class='neutral'>  assembly {</span>
 1405 |     | <span class='neutral'>    nofeeswap := address()</span>
 1406 |     | <span class='neutral'>  }</span>
 1407 |     | <span class='neutral'>  return getStaticParamsStorageAddress(</span>
 1408 |     | <span class='neutral'>    nofeeswap,</span>
 1409 |     | <span class='neutral'>    getPoolId(),</span>
 1410 |     | <span class='neutral'>    storagePointer</span>
 1411 |     | <span class='neutral'>  );</span>
 1412 |     | <span class='neutral'>}</span>
 1413 |     | <span class='neutral'></span>
 1414 |     | <span class='neutral'>/// @notice This function calculates the address of the storage contract</span>
 1415 |     | <span class='neutral'>/// containing static parameters and kernel.</span>
 1416 |     | <span class='neutral'>///</span>
 1417 |     | <span class='neutral'>/// @param nofeeswap The protocol&#39;s address.</span>
 1418 |     | <span class='neutral'>/// @param poolId The corresponding &#39;poolId&#39;.</span>
 1419 |     | <span class='neutral'>/// @param storagePointer The pointer which is used to derive the address of</span>
 1420 |     | <span class='neutral'>/// the storage smart contract.</span>
 1421 |     | <span class='neutral'>/// @return storageAddress The address of the storage contract whose bytecode</span>
 1422 |     | <span class='neutral'>/// comprises static parameters and kernel.</span>
 1423 |     | <span class='neutral'>function getStaticParamsStorageAddress(</span>
 1424 |     | <span class='neutral'>  address nofeeswap,</span>
 1425 |     | <span class='neutral'>  uint256 poolId,</span>
 1426 |     | <span class='neutral'>  uint256 storagePointer</span>
 1427 |     | <span class='neutral'>) pure returns (</span>
 1428 |     | <span class='neutral'>  address storageAddress</span>
 1429 |     | <span class='neutral'>) {</span>
 1430 |     | <span class='neutral'>  assembly {</span>
 1431 |     | <span class='neutral'>    // The 32-byte storage pointer is derived by hashing the following 64:</span>
 1432 |     | <span class='neutral'>    mstore(0, poolId)</span>
 1433 |     | <span class='neutral'>    mstore(32, storagePointer)</span>
 1434 |     | <span class='neutral'>    storagePointer := keccak256(0, 64)</span>
 1435 |     | <span class='neutral'></span>
 1436 |     | <span class='neutral'>    // Fetch free memory pointer so that we can use &#39;0x40&#39; as scratch space.</span>
 1437 |     | <span class='neutral'>    let freeMemoryPointer := mload(0x40)</span>
 1438 |     | <span class='neutral'></span>
 1439 |     | <span class='neutral'>    // Pool static parameters are stored in a &#39;storage contract&#39; which is </span>
 1440 |     | <span class='neutral'>    // deployed by a &#39;proxy contract&#39;. First the &#39;proxy contract&#39; address is</span>
 1441 |     | <span class='neutral'>    // derived.</span>
 1442 |     | <span class='neutral'>    // &#39;nofeeswap&#39; address is written in first memory slot along with a &#39;0xff&#39;</span>
 1443 |     | <span class='neutral'>    // prefix. The storage pointer and &#39;PROXY_CREATION_HASH&#39; are written in</span>
 1444 |     | <span class='neutral'>    // the second and third memory slots, respectively.</span>
 1445 |     | <span class='neutral'>    mstore(0x00, nofeeswap)</span>
 1446 |     | <span class='neutral'>    mstore8(0x0b, 0xff)</span>
 1447 |     | <span class='neutral'>    mstore(0x20, storagePointer)</span>
 1448 |     | <span class='neutral'>    mstore(0x40, PROXY_CREATION_HASH)</span>
 1449 |     | <span class='neutral'></span>
 1450 |     | <span class='neutral'>    // This 85 byte hash gives the &#39;proxy contract&#39; address.</span>
 1451 |     | <span class='neutral'>    mstore(0x14, keccak256(0x0b, 0x55))</span>
 1452 |     | <span class='neutral'></span>
 1453 |     | <span class='neutral'>    // Restores &#39;freeMemoryPointer&#39;.</span>
 1454 |     | <span class='neutral'>    mstore(0x40, freeMemoryPointer)</span>
 1455 |     | <span class='neutral'></span>
 1456 |     | <span class='neutral'>    // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of 0x94 ++ proxy ++ 0x01)</span>
 1457 |     | <span class='neutral'>    // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)</span>
 1458 |     | <span class='neutral'>    mstore(0x00, 0xd694)</span>
 1459 |     | <span class='neutral'>    mstore8(0x34, 0x01)</span>
 1460 |     | <span class='neutral'></span>
 1461 |     | <span class='neutral'>    // Gives the &#39;storage contract&#39; address.</span>
 1462 |     | <span class='neutral'>    storageAddress := and(keccak256(0x1e, 0x17), shr(96, not(0)))</span>
 1463 |     | <span class='neutral'>  }</span>
 1464 |     | <span class='neutral'>}</span>
 1465 |     | <span class='neutral'></span>
 1466 |     | <span class='neutral'>/// @notice This function reads pool&#39;s static parameters from storageAddress </span>
 1467 |     | <span class='neutral'>/// and sets them in appropriate memory locations:</span>
 1468 |     | <span class='neutral'>///</span>
 1469 |     | <span class='neutral'>/// @param storageAddress The address of the storage contract whose bytecode</span>
 1470 |     | <span class='neutral'>/// comprises static parameters and kernel.</span>
 1471 |     | <span class='neutral'>function readStaticParams(</span>
 1472 |     | <span class='neutral'>  address storageAddress</span>
 1473 |     | <span class='neutral'>) view {</span>
 1474 |     | <span class='neutral'>  assembly {</span>
 1475 |     | <span class='neutral'>    extcodecopy(</span>
 1476 |     | <span class='neutral'>      storageAddress,</span>
 1477 |     | <span class='neutral'>      _staticParams_,</span>
 1478 |     | <span class='neutral'>      1,</span>
 1479 |     | <span class='neutral'>      sub(_endOfStaticParams_, _staticParams_)</span>
 1480 |     | <span class='neutral'>    )</span>
 1481 |     | <span class='neutral'>  }</span>
 1482 |     | <span class='neutral'>}</span>
 1483 |     | <span class='neutral'></span>
 1484 |     | <span class='neutral'>/// @notice This function reads pool&#39;s static parameters and kernel, and sets</span>
 1485 |     | <span class='neutral'>/// them in appropriate memory locations.</span>
 1486 |     | <span class='neutral'>///</span>
 1487 |     | <span class='neutral'>/// @param storageAddress The address of the storage contract whose bytecode</span>
 1488 |     | <span class='neutral'>/// comprises static parameters and kernel.</span>
 1489 |     | <span class='neutral'>function readStaticParamsAndKernel(</span>
 1490 |     | <span class='neutral'>  address storageAddress</span>
 1491 |     | <span class='neutral'>) view {</span>
 1492 |     | <span class='neutral'>  readStaticParams(storageAddress);</span>
 1493 |     | <span class='neutral'>  Index kernelLength = readKernelLength(storageAddress);</span>
 1494 |     | <span class='neutral'>  setKernelLength(kernelLength);</span>
 1495 |     | <span class='neutral'>  readKernel(getKernel(), storageAddress, kernelLength);</span>
 1496 |     | <span class='neutral'>}</span>
 1497 |     | <span class='neutral'></span>
 1498 |     | <span class='neutral'>/// @notice This function reads kernel length.</span>
 1499 |     | <span class='neutral'>///</span>
 1500 |     | <span class='neutral'>/// @param storageAddress The address of the storage contract whose bytecode</span>
 1501 |     | <span class='neutral'>/// comprises static parameters and kernel.</span>
 1502 |     | <span class='neutral'>/// @return length The number of kernel breakpoints.</span>
 1503 |     | <span class='neutral'>function readKernelLength(</span>
 1504 |     | <span class='neutral'>  address storageAddress</span>
 1505 |     | <span class='neutral'>) view returns (</span>
 1506 |     | <span class='neutral'>  Index length</span>
 1507 |     | <span class='neutral'>) {</span>
 1508 |     | <span class='neutral'>  assembly {</span>
 1509 |     | <span class='neutral'>    // The total number of bytes to be loaded.</span>
 1510 |     | <span class='neutral'>    // Each breakpoint of the kernel is 64 bytes. The first breakpoint is </span>
 1511 |     | <span class='neutral'>    // omitted.</span>
 1512 |     | <span class='neutral'>    length := add(</span>
 1513 |     | <span class='neutral'>      shr(</span>
 1514 |     | <span class='neutral'>        6,</span>
 1515 |     | <span class='neutral'>        sub(</span>
 1516 |     | <span class='neutral'>          sub(extcodesize(storageAddress), 1),</span>
 1517 |     | <span class='neutral'>          sub(_endOfStaticParams_, _staticParams_)</span>
 1518 |     | <span class='neutral'>        )</span>
 1519 |     | <span class='neutral'>      ),</span>
 1520 |     | <span class='neutral'>      1</span>
 1521 |     | <span class='neutral'>    )</span>
 1522 |     | <span class='neutral'>  }</span>
 1523 |     | <span class='neutral'>}</span>
 1524 |     | <span class='neutral'></span>
 1525 |     | <span class='neutral'>/// @notice This function reads kernel from storageAddress and sets it in</span>
 1526 |     | <span class='neutral'>/// the appropriate memory location.</span>
 1527 |     | <span class='neutral'>///</span>
 1528 |     | <span class='neutral'>/// @param kernel The memory pointer referring to the memory space which hosts</span>
 1529 |     | <span class='neutral'>/// the list of kernel breakpoints.</span>
 1530 |     | <span class='neutral'>/// @param storageAddress The address of the storage contract whose bytecode</span>
 1531 |     | <span class='neutral'>/// comprises static parameters and kernel.</span>
 1532 |     | <span class='neutral'>/// @param length The number of kernel breakpoints.</span>
 1533 |     | <span class='neutral'>function readKernel(</span>
 1534 |     | <span class='neutral'>  Kernel kernel,</span>
 1535 |     | <span class='neutral'>  address storageAddress,</span>
 1536 |     | <span class='neutral'>  Index length</span>
 1537 |     | <span class='neutral'>) view {</span>
 1538 |     | <span class='neutral'>  assembly {</span>
 1539 |     | <span class='neutral'>    // Data is loaded from the &#39;storageAddress&#39; to memory.</span>
 1540 |     | <span class='neutral'>    extcodecopy(</span>
 1541 |     | <span class='neutral'>      storageAddress,</span>
 1542 |     | <span class='neutral'>      kernel,</span>
 1543 |     | <span class='neutral'>      add(1, sub(_endOfStaticParams_, _staticParams_)),</span>
 1544 |     | <span class='neutral'>      shl(6, sub(length, 1))</span>
 1545 |     | <span class='neutral'>    )</span>
 1546 |     | <span class='neutral'>  }</span>
 1547 |     | <span class='neutral'>}</span>
 1548 |     | <span class='neutral'></span>
 1549 |     | <span class='neutral'>/// @notice Reads pool data and sets it in the appropriate memory location.</span>
 1550 |     | <span class='neutral'>function readPoolData() view {</span>
 1551 |     | <span class='neutral'>  readDynamicParams();</span>
 1552 |     | <span class='neutral'></span>
 1553 |     | <span class='neutral'>  // The address of the storage contract whose bytecode comprises static</span>
 1554 |     | <span class='neutral'>  // parameters and kernel.</span>
 1555 |     | <span class='neutral'>  address storageAddress = getStaticParamsStorageAddress(</span>
 1556 |     | <span class='neutral'>    getStaticParamsStoragePointerExtension()</span>
 1557 |     | <span class='neutral'>  );</span>
 1558 |     | <span class='neutral'></span>
 1559 |     | <span class='neutral'>  // Static paremters are read from the storage contract.</span>
 1560 |     | <span class='neutral'>  readStaticParams(storageAddress);</span>
 1561 |     | <span class='neutral'></span>
 1562 |     | <span class='neutral'>  // &#39;poolGrowthPortion&#39; is capped by &#39;maxPoolGrowthPortion&#39;.</span>
 1563 |     | <span class='neutral'>  setPoolGrowthPortion(</span>
 1564 |     | <span class='neutral'>    min(getPoolGrowthPortion(), getMaxPoolGrowthPortion())</span>
 1565 |     | <span class='neutral'>  );</span>
 1566 |     | <span class='neutral'></span>
 1567 |     | <span class='neutral'>  // The length of the kernel is determined.</span>
 1568 |     | <span class='neutral'>  Index length = readKernelLength(storageAddress);</span>
 1569 |     | <span class='neutral'>  setKernelLength(length);</span>
 1570 |     | <span class='neutral'></span>
 1571 |     | <span class='neutral'>  // Kernel breakpoints are read from the storage contract and stored in</span>
 1572 |     | <span class='neutral'>  // memory.</span>
 1573 |     | <span class='neutral'>  Kernel kernel = getKernel();</span>
 1574 |     | <span class='neutral'>  readKernel(kernel, storageAddress, length);</span>
 1575 |     | <span class='neutral'></span>
 1576 |     | <span class='neutral'>  // If needed, additional space is reserved in memory for the pending kernel.</span>
 1577 |     | <span class='neutral'>  length = max(length, getPendingKernelLength());</span>
 1578 |     | <span class='neutral'></span>
 1579 |     | <span class='neutral'>  // The memory pointer for the curve sequence is derived.</span>
 1580 |     | <span class='neutral'>  Curve curve;</span>
 1581 |     | <span class='neutral'>  assembly {</span>
 1582 |     | <span class='neutral'>    curve := add(kernel, shl(6, sub(length, 1)))</span>
 1583 |     | <span class='neutral'>  }</span>
 1584 |     | <span class='neutral'>  setCurve(curve);</span>
 1585 |     | <span class='neutral'></span>
 1586 |     | <span class='neutral'>  // The curve sequence is read from storage and placed in memory.</span>
 1587 |     | <span class='neutral'>  length = readCurve();</span>
 1588 |     | <span class='neutral'>  setCurveLength(length);</span>
 1589 |     | <span class='neutral'></span>
 1590 |     | <span class='neutral'>  // The free memory pointer is set next.</span>
 1591 |     | <span class='neutral'>  uint256 freeMemoryPointer;</span>
 1592 |     | <span class='neutral'>  assembly {</span>
 1593 |     | <span class='neutral'>    freeMemoryPointer := add(</span>
 1594 |     | <span class='neutral'>      curve,</span>
 1595 |     | <span class='neutral'>      shl(5, add(shr(2, sub(length, 1)), 2))</span>
 1596 |     | <span class='neutral'>    )</span>
 1597 |     | <span class='neutral'>  }</span>
 1598 |     | <span class='neutral'>  setFreeMemoryPointer(freeMemoryPointer);</span>
 1599 |     | <span class='neutral'></span>
 1600 |     | <span class='neutral'>  // The byte count for the memory snapshot given to the hook contract is</span>
 1601 |     | <span class='neutral'>  // derived next.</span>
 1602 |     | <span class='neutral'>  uint256 hookInputByteCount;</span>
 1603 |     | <span class='neutral'>  assembly {</span>
 1604 |     | <span class='neutral'>    hookInputByteCount := </span>
 1605 |     | <span class='neutral'>      sub(sub(freeMemoryPointer, _hookInputByteCount_), 32)</span>
 1606 |     | <span class='neutral'>  }</span>
 1607 |     | <span class='neutral'>  setHookInputByteCount(hookInputByteCount);</span>
 1608 |     | <span class='neutral'>}</span>
 1609 |     | <span class='neutral'></span>
 1610 |     | <span class='neutral'>// Modified from Philogy </span>
 1611 |     | <span class='neutral'>// &lt;https://github.com/Philogy/sstore3/blob/main/src/SSTORE3_L.sol&gt;</span>
 1612 |     | <span class='neutral'>// Modified from Solady </span>
 1613 |     | <span class='neutral'>// &lt;https://github.com/Vectorized/solady/blob/main/src/utils/CREATE3.sol&gt;</span>
 1614 |     | <span class='neutral'></span>
 1615 |     | <span class='neutral'>// The proxy bytecode.</span>
 1616 |     | <span class='neutral'>uint256 constant PROXY_CREATION_CODE = 0x67363D3D37363D3DF03D5260086018F3;</span>
 1617 |     | <span class='neutral'>// &#39;keccak256(PROXY_CREATION_CODE)&#39;.</span>
 1618 |     | <span class='neutral'>bytes32 constant PROXY_CREATION_HASH = </span>
 1619 |     | <span class='neutral'>  0xF779EDCBDC615C777A4CB2BEE1BF733055AA41FF7247837D0CD548565F65D034;</span>
 1620 |     | <span class='neutral'>// -------------------------------------------------------------------+</span>
 1621 |     | <span class='neutral'>// Opcode      | Mnemonic         | Stack        | Memory             |</span>
 1622 |     | <span class='neutral'>// -------------------------------------------------------------------|</span>
 1623 |     | <span class='neutral'>// 36          | CALLDATASIZE     | cds          |                    |</span>
 1624 |     | <span class='neutral'>// 3d          | RETURNDATASIZE   | 0 cds        |                    |</span>
 1625 |     | <span class='neutral'>// 3d          | RETURNDATASIZE   | 0 0 cds      |                    |</span>
 1626 |     | <span class='neutral'>// 37          | CALLDATACOPY     |              | [0..cds): calldata |</span>
 1627 |     | <span class='neutral'>// 36          | CALLDATASIZE     | cds          | [0..cds): calldata |</span>
 1628 |     | <span class='neutral'>// 3d          | RETURNDATASIZE   | 0 cds        | [0..cds): calldata |</span>
 1629 |     | <span class='neutral'>// 3d          | RETURNDATASIZE   | 0 0 cds      | [0..cds): calldata |</span>
 1630 |     | <span class='neutral'>// f0          | CREATE           | newContract  | [0..cds): calldata |</span>
 1631 |     | <span class='neutral'>// -------------------------------------------------------------------|</span>
 1632 |     | <span class='neutral'>// Opcode      | Mnemonic         | Stack        | Memory             |</span>
 1633 |     | <span class='neutral'>// -------------------------------------------------------------------|</span>
 1634 |     | <span class='neutral'>// 67 bytecode | PUSH8 bytecode   | bytecode     |                    |</span>
 1635 |     | <span class='neutral'>// 3d          | RETURNDATASIZE   | 0 bytecode   |                    |</span>
 1636 |     | <span class='neutral'>// 52          | MSTORE           |              | [0..8): bytecode   |</span>
 1637 |     | <span class='neutral'>// 60 0x08     | PUSH1 0x08       | 0x08         | [0..8): bytecode   |</span>
 1638 |     | <span class='neutral'>// 60 0x18     | PUSH1 0x18       | 0x18 0x08    | [0..8): bytecode   |</span>
 1639 |     | <span class='neutral'>// f3          | RETURN           |              | [0..8): bytecode   |</span>
 1640 |     | <span class='neutral'>// -------------------------------------------------------------------+</span>
 1641 |     | <span class='neutral'></span>
 1642 |     | <span class='neutral'></span>
 1643 |     | <span class='neutral'>uint256 constant DEPLOYMENT_CODE = 0x61000080600a3d393df300;</span>
 1644 |     | <span class='neutral'>// ------------------------------------------------------------------------+</span>
 1645 |     | <span class='neutral'>//                                                                         |</span>
 1646 |     | <span class='neutral'>// STORE DEPLOY START (11 bytes)                                           |</span>
 1647 |     | <span class='neutral'>//                                                                         |</span>
 1648 |     | <span class='neutral'>// ----+------------+------------------+--------------+--------------------+</span>
 1649 |     | <span class='neutral'>// PC  | Opcode     | Mnemonic         | Stack        | Memory             |</span>
 1650 |     | <span class='neutral'>// ----+------------+------------------+--------------+--------------------+</span>
 1651 |     | <span class='neutral'>//                                                                         |</span>
 1652 |     | <span class='neutral'>// ::::::::::: Deploy code (10 bytes). ::::::::::::::::::::::::::::::::::: |</span>
 1653 |     | <span class='neutral'>// 0x0 | 61 ????    | PUSH2 length     | len          | -                  |</span>
 1654 |     | <span class='neutral'>// 0x3 | 80         | DUP1             | len len      | -                  |</span>
 1655 |     | <span class='neutral'>// 0x4 | 60 0a      | PUSH1 0x0a       | 10 len len   | -                  |</span>
 1656 |     | <span class='neutral'>// 0x6 | 3d         | RETURNDATASIZE   | 0 10 len len | [0..len): runtime  |</span>
 1657 |     | <span class='neutral'>// 0x7 | 39         | CODECOPY         | len          | [24..32): runtime  |</span>
 1658 |     | <span class='neutral'>// 0x8 | 3d         | RETURNDATASIZE   | 0 len        | [24..32): runtime  |</span>
 1659 |     | <span class='neutral'>// 0x9 | f3         | RETURN           |              | [24..32): runtime  |</span>
 1660 |     | <span class='neutral'>//                                                                         |</span>
 1661 |     | <span class='neutral'>// ::::::::::: Padding (1 byte). ::::::::::::::::::::::::::::::::::::::::: |</span>
 1662 |     | <span class='neutral'>// 0x0 | 00         | STOP             |              | [24..32): runtime  |</span>
 1663 |     | <span class='neutral'>// ----+------------+------------------+--------------+--------------------+</span>

</code>
<br />

<b>/home/training/contracts/utilities/Tag.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {X59} from &quot;./X59.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>// Type &#39;Tag&#39; may refer to any of the followings:</span>
   7 |     | <span class='neutral'>//</span>
   8 |     | <span class='neutral'>// - Native token corresponding to &#39;Tag.wrap(0)&#39;.</span>
   9 |     | <span class='neutral'>//</span>
  10 |     | <span class='neutral'>// - An ERC-20 address, i.e., &#39;Tag.wrap(uint256(uint160(tokenAddress)))&#39;.</span>
  11 |     | <span class='neutral'>//</span>
  12 |     | <span class='neutral'>// - An ERC-1155 token whose value is determined by hashing token address and</span>
  13 |     | <span class='neutral'>// token ID, i.e., </span>
  14 |     | <span class='neutral'>// &#39;Tag.wrap(uint256(keccak256(abi.encodePacked(tokenAddress, tokenId))))&#39;.</span>
  15 |     | <span class='neutral'>//</span>
  16 |     | <span class='neutral'>// - An ERC-6909 token whose value is determined by hashing token address and</span>
  17 |     | <span class='neutral'>// token ID, i.e., </span>
  18 |     | <span class='neutral'>// &#39;Tag.wrap(uint256(keccak256(abi.encodePacked(tokenAddress, tokenId))))&#39;.</span>
  19 |     | <span class='neutral'>//</span>
  20 |     | <span class='neutral'>// - A nofeeswap position whose value is determined by hashing, poolId and</span>
  21 |     | <span class='neutral'>// min/max position boundaries, i.e., </span>
  22 |     | <span class='neutral'>// &#39;Tag.wrap(uint256(keccak256(abi.encodePacked(</span>
  23 |     | <span class='neutral'>//    poolId,</span>
  24 |     | <span class='neutral'>//    qMin,</span>
  25 |     | <span class='neutral'>//    qMax</span>
  26 |     | <span class='neutral'>//  ))))&#39;.</span>
  27 |     | <span class='neutral'>//</span>
  28 |     | <span class='neutral'>type Tag is uint256;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>Tag constant native = Tag.wrap(0);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>using {equals as ==, notEqual as !=} for Tag global;</span>
  33 |     | <span class='neutral'>using {lessThan as &lt;, greaterThan as &gt;} for Tag global;</span>
  34 |     | <span class='neutral'>using {</span>
  35 |     | <span class='neutral'>  lessThanOrEqualTo as &lt;=,</span>
  36 |     | <span class='neutral'>  greaterThanOrEqualTo as &gt;=</span>
  37 |     | <span class='neutral'>} for Tag global;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>function equals(</span>
  40 |     | <span class='neutral'>  Tag value0,</span>
  41 |     | <span class='neutral'>  Tag value1</span>
  42 |     | <span class='neutral'>) pure returns (</span>
  43 |     | <span class='neutral'>  bool result</span>
  44 |     | <span class='neutral'>) {</span>
  45 |     | <span class='neutral'>  assembly {</span>
  46 |     | <span class='neutral'>    result := eq(value0, value1)</span>
  47 |     | <span class='neutral'>  }</span>
  48 |     | <span class='neutral'>}</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>function notEqual(</span>
  51 |     | <span class='neutral'>  Tag value0,</span>
  52 |     | <span class='neutral'>  Tag value1</span>
  53 |     | <span class='neutral'>) pure returns (</span>
  54 |     | <span class='neutral'>  bool result</span>
  55 |     | <span class='neutral'>) {</span>
  56 |     | <span class='neutral'>  return !(value0 == value1);</span>
  57 |     | <span class='neutral'>}</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>function lessThan(</span>
  60 |     | <span class='neutral'>  Tag value0,</span>
  61 |     | <span class='neutral'>  Tag value1</span>
  62 |     | <span class='neutral'>) pure returns (</span>
  63 |     | <span class='neutral'>  bool result</span>
  64 |     | <span class='neutral'>) {</span>
  65 |     | <span class='neutral'>  assembly {</span>
  66 |     | <span class='neutral'>    result := lt(value0, value1)</span>
  67 |     | <span class='neutral'>  }</span>
  68 |     | <span class='neutral'>}</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>function greaterThan(</span>
  71 |     | <span class='neutral'>  Tag value0,</span>
  72 |     | <span class='neutral'>  Tag value1</span>
  73 |     | <span class='neutral'>) pure returns (</span>
  74 |     | <span class='unexecuted'>  bool result</span>
  75 |     | <span class='neutral'>) {</span>
  76 |     | <span class='unexecuted'>  assembly {</span>
  77 |     | <span class='neutral'>    result := gt(value0, value1)</span>
  78 |     | <span class='neutral'>  }</span>
  79 |     | <span class='neutral'>}</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>function lessThanOrEqualTo(</span>
  82 |     | <span class='neutral'>  Tag value0,</span>
  83 |     | <span class='neutral'>  Tag value1</span>
  84 |     | <span class='neutral'>) pure returns (</span>
  85 |     | <span class='neutral'>  bool result</span>
  86 |     | <span class='neutral'>) {</span>
  87 |     | <span class='neutral'>  return !(value0 &gt; value1);</span>
  88 |     | <span class='neutral'>}</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>function greaterThanOrEqualTo(</span>
  91 |     | <span class='neutral'>  Tag value0,</span>
  92 |     | <span class='neutral'>  Tag value1</span>
  93 |     | <span class='neutral'>) pure returns (</span>
  94 |     | <span class='neutral'>  bool result</span>
  95 |     | <span class='neutral'>) {</span>
  96 |     | <span class='neutral'>  return !(value0 &lt; value1);</span>
  97 |     | <span class='neutral'>}</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>library TagLibrary {</span>
 100 |     | <span class='neutral'>  /// @notice Generates a tag given an ERC-20 address.</span>
 101 |     | <span class='neutral'>  /// @param tokenAddress The given ERC-20 address to be transformed to the</span>
 102 |     | <span class='neutral'>  /// type &#39;tag&#39;.</span>
 103 |     | <span class='neutral'>  function tag(</span>
 104 |     | <span class='neutral'>    address tokenAddress</span>
 105 |     | <span class='neutral'>  ) internal pure returns (</span>
 106 |     | <span class='neutral'>    Tag tokenTag</span>
 107 |     | <span class='neutral'>  ) {</span>
 108 |     | <span class='neutral'>    assembly {</span>
 109 |     | <span class='neutral'>      tokenTag := and(tokenAddress, sub(shl(160, 1), 1))</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'>  }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>  /// @notice Generates a tag given a multi-token address and tokenId.</span>
 114 |     | <span class='neutral'>  /// @param tokenAddress The given multi-token address to be transformed to</span>
 115 |     | <span class='neutral'>  /// the type &#39;tag&#39;.</span>
 116 |     | <span class='neutral'>  /// @param tokenId The given multi-token id to be used to generate &#39;tag&#39;.</span>
 117 |     | <span class='neutral'>  function tag(</span>
 118 |     | <span class='neutral'>    address tokenAddress,</span>
 119 |     | <span class='neutral'>    uint256 tokenId</span>
 120 |     | <span class='neutral'>  ) internal pure returns (</span>
 121 |     | <span class='neutral'>    Tag tokenTag</span>
 122 |     | <span class='neutral'>  ) {</span>
 123 |     | <span class='neutral'>    assembly {</span>
 124 |     | <span class='neutral'>      mstore(20, tokenAddress)</span>
 125 |     | <span class='neutral'>      mstore(0, tokenId)</span>
 126 |     | <span class='neutral'>      tokenTag := keccak256(0, 52)</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'>  }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>  /// @notice Generates a tag given a nofeeswap liquidity position.</span>
 131 |     | <span class='neutral'>  /// @param poolId The pool identifier hosting this liquidity position.</span>
 132 |     | <span class='neutral'>  /// @param qMin Equal to &#39;(2 ** 59) * log(pMin)&#39; where &#39;pMin&#39; is the left</span>
 133 |     | <span class='neutral'>  /// position boundary.</span>
 134 |     | <span class='neutral'>  /// @param qMax Equal to &#39;(2 ** 59) * log(pMax)&#39; where &#39;pMax&#39; is the right</span>
 135 |     | <span class='neutral'>  /// position boundary.</span>
 136 |     | <span class='neutral'>  function tag(</span>
 137 |     | <span class='neutral'>    uint256 poolId,</span>
 138 |     | <span class='neutral'>    X59 qMin,</span>
 139 |     | <span class='neutral'>    X59 qMax</span>
 140 |     | <span class='neutral'>  ) internal pure returns (</span>
 141 |     | <span class='neutral'>    Tag positionTag</span>
 142 |     | <span class='neutral'>  ) {</span>
 143 |     | <span class='neutral'>    assembly {</span>
 144 |     | <span class='neutral'>      // Cache the free memory pointer so that the third memory slot can be</span>
 145 |     | <span class='neutral'>      // used for hashing.</span>
 146 |     | <span class='neutral'>      let freeMemoryPointer := mload(0x40)</span>
 147 |     | <span class='neutral'>      mstore(64, qMax)</span>
 148 |     | <span class='neutral'>      mstore(32, qMin)</span>
 149 |     | <span class='neutral'>      mstore(0, poolId)</span>
 150 |     | <span class='neutral'>      positionTag := keccak256(0, 96)</span>
 151 |     | <span class='neutral'>      // The &#39;freeMemoryPointer&#39; is restored.</span>
 152 |     | <span class='neutral'>      mstore(0x40, freeMemoryPointer)</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'>  }</span>
 155 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/X111.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {X208} from &quot;./X208.sol&quot;;</span>
   5 |     | <span class='neutral'>import {X216} from &quot;./X216.sol&quot;;</span>
   6 |     | <span class='neutral'>import {FullMathLibrary} from &quot;./FullMath.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// Type &#39;X111&#39; is dedicated to growth and liquidity values.</span>
   9 |     | <span class='neutral'>type X111 is int256;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>using X111Library for X111 global;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>X111 constant zeroX111 = X111.wrap(0);</span>
  14 |     | <span class='neutral'>X111 constant oneX111 = X111.wrap(1 &lt;&lt; 111);</span>
  15 |     | <span class='neutral'>X111 constant maxGrowth = X111.wrap(1 &lt;&lt; 127);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>using {equals as ==, notEqual as !=} for X111 global;</span>
  18 |     | <span class='neutral'>using {lessThan as &lt;, greaterThan as &gt;} for X111 global;</span>
  19 |     | <span class='neutral'>using {</span>
  20 |     | <span class='neutral'>  lessThanOrEqualTo as &lt;=,</span>
  21 |     | <span class='neutral'>  greaterThanOrEqualTo as &gt;=</span>
  22 |     | <span class='neutral'>} for X111 global;</span>
  23 |     | <span class='neutral'>using {add as +, sub as -} for X111 global;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>function equals(</span>
  26 |     | <span class='neutral'>  X111 value0,</span>
  27 |     | <span class='neutral'>  X111 value1</span>
  28 |     | <span class='neutral'>) pure returns (</span>
  29 |     | <span class='neutral'>  bool result</span>
  30 |     | <span class='neutral'>) {</span>
  31 |     | <span class='neutral'>  assembly {</span>
  32 |     | <span class='neutral'>    result := eq(value0, value1)</span>
  33 |     | <span class='neutral'>  }</span>
  34 |     | <span class='neutral'>}</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>function notEqual(</span>
  37 |     | <span class='neutral'>  X111 value0,</span>
  38 |     | <span class='neutral'>  X111 value1</span>
  39 |     | <span class='neutral'>) pure returns (</span>
  40 |     | <span class='neutral'>  bool result</span>
  41 |     | <span class='neutral'>) {</span>
  42 |     | <span class='neutral'>  return !(value0 == value1);</span>
  43 |     | <span class='neutral'>}</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>function lessThan(</span>
  46 |     | <span class='neutral'>  X111 value0,</span>
  47 |     | <span class='neutral'>  X111 value1</span>
  48 |     | <span class='neutral'>) pure returns (</span>
  49 |     | <span class='neutral'>  bool result</span>
  50 |     | <span class='neutral'>) {</span>
  51 |     | <span class='neutral'>  assembly {</span>
  52 |     | <span class='neutral'>    result := slt(value0, value1)</span>
  53 |     | <span class='neutral'>  }</span>
  54 |     | <span class='neutral'>}</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>function greaterThan(</span>
  57 |     | <span class='neutral'>  X111 value0,</span>
  58 |     | <span class='neutral'>  X111 value1</span>
  59 |     | <span class='neutral'>) pure returns (</span>
  60 |     | <span class='neutral'>  bool result</span>
  61 |     | <span class='neutral'>) {</span>
  62 |     | <span class='neutral'>  assembly {</span>
  63 |     | <span class='neutral'>    result := sgt(value0, value1)</span>
  64 |     | <span class='neutral'>  }</span>
  65 |     | <span class='neutral'>}</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>function lessThanOrEqualTo(</span>
  68 |     | <span class='neutral'>  X111 value0,</span>
  69 |     | <span class='neutral'>  X111 value1</span>
  70 |     | <span class='neutral'>) pure returns (</span>
  71 |     | <span class='neutral'>  bool result</span>
  72 |     | <span class='neutral'>) {</span>
  73 |     | <span class='neutral'>  return !(value0 &gt; value1);</span>
  74 |     | <span class='neutral'>}</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>function greaterThanOrEqualTo(</span>
  77 |     | <span class='neutral'>  X111 value0,</span>
  78 |     | <span class='neutral'>  X111 value1</span>
  79 |     | <span class='neutral'>) pure returns (</span>
  80 |     | <span class='neutral'>  bool result</span>
  81 |     | <span class='neutral'>) {</span>
  82 |     | <span class='neutral'>  return !(value0 &lt; value1);</span>
  83 |     | <span class='neutral'>}</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
  86 |     | <span class='neutral'>function add(</span>
  87 |     | <span class='neutral'>  X111 value0,</span>
  88 |     | <span class='neutral'>  X111 value1</span>
  89 |     | <span class='neutral'>) pure returns (</span>
  90 |     | <span class='neutral'>  X111 result</span>
  91 |     | <span class='neutral'>) {</span>
  92 |     | <span class='neutral'>  assembly {</span>
  93 |     | <span class='neutral'>    result := add(value0, value1)</span>
  94 |     | <span class='neutral'>  }</span>
  95 |     | <span class='neutral'>}</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
  98 |     | <span class='neutral'>function sub(</span>
  99 |     | <span class='neutral'>  X111 value0,</span>
 100 |     | <span class='neutral'>  X111 value1</span>
 101 |     | <span class='neutral'>) pure returns (</span>
 102 |     | <span class='neutral'>  X111 result</span>
 103 |     | <span class='neutral'>) {</span>
 104 |     | <span class='neutral'>  assembly {</span>
 105 |     | <span class='neutral'>    result := sub(value0, value1)</span>
 106 |     | <span class='neutral'>  }</span>
 107 |     | <span class='neutral'>}</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>function min(</span>
 110 |     | <span class='neutral'>  X111 value0,</span>
 111 |     | <span class='neutral'>  X111 value1</span>
 112 |     | <span class='neutral'>) pure returns (</span>
 113 |     | <span class='neutral'>  X111 result</span>
 114 |     | <span class='neutral'>) {</span>
 115 |     | <span class='neutral'>  return (value0 &lt; value1) ? value0 : value1;</span>
 116 |     | <span class='neutral'>}</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>function max(</span>
 119 |     | <span class='neutral'>  X111 value0,</span>
 120 |     | <span class='neutral'>  X111 value1</span>
 121 |     | <span class='neutral'>) pure returns (</span>
 122 |     | <span class='neutral'>  X111 result</span>
 123 |     | <span class='neutral'>) {</span>
 124 |     | <span class='neutral'>  return (value0 &lt; value1) ? value1 : value0;</span>
 125 |     | <span class='neutral'>}</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='unexecuted'>library X111Library {</span>
 128 |     | <span class='neutral'>  /// @notice Calculates &#39;liquidity == growth * shares&#39;.</span>
 129 |     | <span class='neutral'>  /// &#39;growth&#39; should not be less than &#39;oneX111&#39;.</span>
 130 |     | <span class='neutral'>  /// &#39;growth&#39; should be less than or equal to &#39;1 &lt;&lt; 127&#39;.</span>
 131 |     | <span class='neutral'>  /// &#39;shares&#39; should be less than &#39;1 &lt;&lt; 127&#39;</span>
 132 |     | <span class='neutral'>  function times(</span>
 133 |     | <span class='neutral'>    X111 growth,</span>
 134 |     | <span class='neutral'>    uint256 shares</span>
 135 |     | <span class='neutral'>  ) internal pure returns (</span>
 136 |     | <span class='neutral'>    X111 liquidity</span>
 137 |     | <span class='neutral'>  ) {</span>
 138 |     | <span class='neutral'>    assembly {</span>
 139 |     | <span class='neutral'>      // Multiplication is safe because of the input requirements.</span>
 140 |     | <span class='neutral'>      liquidity := mul(growth, shares)</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'>  }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>  /// @notice Calculates &#39;liquidity == growth * shares&#39;.</span>
 145 |     | <span class='neutral'>  /// &#39;growth&#39; should not be less than &#39;oneX111&#39;.</span>
 146 |     | <span class='neutral'>  /// &#39;growth&#39; should be less than or equal to &#39;1 &lt;&lt; 127&#39;.</span>
 147 |     | <span class='neutral'>  /// &#39;shares&#39; should be greater than &#39;- (1 &lt;&lt; 127)&#39;.</span>
 148 |     | <span class='neutral'>  /// &#39;shares&#39; should be less than &#39;1 &lt;&lt; 127&#39;.</span>
 149 |     | <span class='neutral'>  function times(</span>
 150 |     | <span class='neutral'>    X111 growth,</span>
 151 |     | <span class='neutral'>    int256 shares</span>
 152 |     | <span class='neutral'>  ) internal pure returns (</span>
 153 |     | <span class='neutral'>    X111 liquidity</span>
 154 |     | <span class='neutral'>  ) {</span>
 155 |     | <span class='neutral'>    assembly {</span>
 156 |     | <span class='neutral'>      // Multiplication is safe because of the input requirements.</span>
 157 |     | <span class='neutral'>      liquidity := mul(growth, shares)</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'>  }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>  /// @notice Calculates</span>
 162 |     | <span class='neutral'>  /// &#39;(value * multiplier) / ((2 ** 119) * exp(-8))&#39;</span>
 163 |     | <span class='neutral'>  /// &#39;growth&#39; should not be less than &#39;oneX111&#39;.</span>
 164 |     | <span class='neutral'>  /// &#39;growth&#39; should be less than or equal to &#39;1 &lt;&lt; 127&#39;.</span>
 165 |     | <span class='neutral'>  /// &#39;multiplier&#39; should be non-negative and less than &#39;oneX216&#39;.</span>
 166 |     | <span class='neutral'>  function mulDivByExpInv8(</span>
 167 |     | <span class='neutral'>    X111 growth,</span>
 168 |     | <span class='neutral'>    X216 multiplier</span>
 169 |     | <span class='neutral'>  ) internal pure returns (</span>
 170 |     | <span class='neutral'>    X208 product</span>
 171 |     | <span class='neutral'>  ) {</span>
 172 |     | <span class='neutral'>    // Both castings are safe because</span>
 173 |     | <span class='neutral'>    // &#39;growth &gt;= oneX111&#39; and &#39;multiplier &gt;= zeroX216&#39;</span>
 174 |     | <span class='neutral'>    ( ,  , uint256 q2) = FullMathLibrary.mul768(</span>
 175 |     | <span class='neutral'>      // (2 ** 244) * exp(8)</span>
 176 |     | <span class='neutral'>      0xBA4F53EA38636F85F007042540AE8EF33225E9A7AB4F4473A86D4A8FDD1A5B82,</span>
 177 |     | <span class='neutral'>      // The shift is safe because &#39;oneX111 &lt;= growth &lt;= (1 &lt;&lt; 127)&#39;</span>
 178 |     | <span class='neutral'>      uint256(X111.unwrap(growth)) &lt;&lt; 110,</span>
 179 |     | <span class='neutral'>      // The shift is safe because &#39;0 &lt;= multiplier &lt;= oneX216&#39;</span>
 180 |     | <span class='neutral'>      uint256(X216.unwrap(multiplier)) &lt;&lt; 39</span>
 181 |     | <span class='neutral'>    );</span>
 182 |     | <span class='neutral'>    product = X208.wrap(q2);</span>
 183 |     | <span class='neutral'>  }</span>
 184 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/X127.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {X23} from &quot;./X23.sol&quot;;</span>
   5 |     | <span class='neutral'>import {X216} from &quot;./X216.sol&quot;;</span>
   6 |     | <span class='neutral'>import {SafeAddFailed} from &quot;./Errors.sol&quot;;</span>
   7 |     | <span class='neutral'>import {FullMathLibrary} from &quot;./FullMath.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>// Type &#39;X127&#39; is used for &#39;sqrtOffset&#39;, &#39;sqrtInverseOffset&#39;, and token</span>
  10 |     | <span class='neutral'>// amounts.</span>
  11 |     | <span class='neutral'>type X127 is int256;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>using X127Library for X127 global;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>X127 constant oneX127 = X127.wrap(1 &lt;&lt; 127);</span>
  16 |     | <span class='neutral'>X127 constant zeroX127 = X127.wrap(0);</span>
  17 |     | <span class='neutral'>X127 constant epsilonX127 = X127.wrap(1);</span>
  18 |     | <span class='neutral'>// 104 = 231 - 127 digits of non-decimal</span>
  19 |     | <span class='neutral'>X127 constant accruedMax = X127.wrap((1 &lt;&lt; 231) - 1);</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>using {equals as ==, notEquals as !=} for X127 global;</span>
  22 |     | <span class='neutral'>using {lessThan as &lt;, greaterThan as &gt;} for X127 global;</span>
  23 |     | <span class='neutral'>using {</span>
  24 |     | <span class='neutral'>  lessThanOrEqualTo as &lt;=,</span>
  25 |     | <span class='neutral'>  greaterThanOrEqualTo as &gt;=</span>
  26 |     | <span class='neutral'>} for X127 global;</span>
  27 |     | <span class='neutral'>using {add as +, sub as -, safeAdd as &amp;} for X127 global;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>function equals(</span>
  30 |     | <span class='neutral'>  X127 value0,</span>
  31 |     | <span class='neutral'>  X127 value1</span>
  32 |     | <span class='neutral'>) pure returns (</span>
  33 |     | <span class='neutral'>  bool result</span>
  34 |     | <span class='neutral'>) {</span>
  35 |     | <span class='neutral'>  assembly {</span>
  36 |     | <span class='neutral'>    result := eq(value0, value1)</span>
  37 |     | <span class='neutral'>  }</span>
  38 |     | <span class='neutral'>}</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>function notEquals(</span>
  41 |     | <span class='neutral'>  X127 value0,</span>
  42 |     | <span class='neutral'>  X127 value1</span>
  43 |     | <span class='neutral'>) pure returns (</span>
  44 |     | <span class='neutral'>  bool result</span>
  45 |     | <span class='neutral'>) {</span>
  46 |     | <span class='neutral'>  return !(value0 == value1);</span>
  47 |     | <span class='neutral'>}</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>function lessThan(</span>
  50 |     | <span class='neutral'>  X127 value0,</span>
  51 |     | <span class='neutral'>  X127 value1</span>
  52 |     | <span class='neutral'>) pure returns (</span>
  53 |     | <span class='neutral'>  bool result</span>
  54 |     | <span class='neutral'>) {</span>
  55 |     | <span class='neutral'>  assembly {</span>
  56 |     | <span class='neutral'>    result := slt(value0, value1)</span>
  57 |     | <span class='neutral'>  }</span>
  58 |     | <span class='neutral'>}</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>function greaterThan(</span>
  61 |     | <span class='neutral'>  X127 value0,</span>
  62 |     | <span class='neutral'>  X127 value1</span>
  63 |     | <span class='neutral'>) pure returns (</span>
  64 |     | <span class='neutral'>  bool result</span>
  65 |     | <span class='neutral'>) {</span>
  66 |     | <span class='neutral'>  assembly {</span>
  67 |     | <span class='neutral'>    result := sgt(value0, value1)</span>
  68 |     | <span class='neutral'>  }</span>
  69 |     | <span class='neutral'>}</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>function lessThanOrEqualTo(</span>
  72 |     | <span class='neutral'>  X127 value0,</span>
  73 |     | <span class='neutral'>  X127 value1</span>
  74 |     | <span class='neutral'>) pure returns (</span>
  75 |     | <span class='neutral'>  bool result</span>
  76 |     | <span class='neutral'>) {</span>
  77 |     | <span class='neutral'>  return !(value0 &gt; value1);</span>
  78 |     | <span class='neutral'>}</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>function greaterThanOrEqualTo(</span>
  81 |     | <span class='neutral'>  X127 value0,</span>
  82 |     | <span class='neutral'>  X127 value1</span>
  83 |     | <span class='neutral'>) pure returns (</span>
  84 |     | <span class='neutral'>  bool result</span>
  85 |     | <span class='neutral'>) {</span>
  86 |     | <span class='neutral'>  return !(value0 &lt; value1);</span>
  87 |     | <span class='neutral'>}</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
  90 |     | <span class='neutral'>function add(</span>
  91 |     | <span class='neutral'>  X127 value0,</span>
  92 |     | <span class='neutral'>  X127 value1</span>
  93 |     | <span class='neutral'>) pure returns (</span>
  94 |     | <span class='neutral'>  X127 result</span>
  95 |     | <span class='neutral'>) {</span>
  96 |     | <span class='neutral'>  assembly {</span>
  97 |     | <span class='neutral'>    result := add(value0, value1)</span>
  98 |     | <span class='neutral'>  }</span>
  99 |     | <span class='neutral'>}</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
 102 |     | <span class='neutral'>function sub(</span>
 103 |     | <span class='neutral'>  X127 value0,</span>
 104 |     | <span class='neutral'>  X127 value1</span>
 105 |     | <span class='neutral'>) pure returns (</span>
 106 |     | <span class='neutral'>  X127 result</span>
 107 |     | <span class='neutral'>) {</span>
 108 |     | <span class='neutral'>  assembly {</span>
 109 |     | <span class='neutral'>    result := sub(value0, value1)</span>
 110 |     | <span class='neutral'>  }</span>
 111 |     | <span class='neutral'>}</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>// Throws in case of overflow/underflow.</span>
 114 |     | <span class='neutral'>function safeAdd(</span>
 115 |     | <span class='neutral'>  X127 value0,</span>
 116 |     | <span class='neutral'>  X127 value1</span>
 117 |     | <span class='neutral'>) pure returns (</span>
 118 |     | <span class='neutral'>  X127 result</span>
 119 |     | <span class='neutral'>) {</span>
 120 |     | <span class='neutral'>  // We first add the two values unsafely and then examine the result.</span>
 121 |     | <span class='neutral'>  result = value0 + value1;</span>
 122 |     | <span class='neutral'>  </span>
 123 |     | <span class='neutral'>  // The following requirement is satisfied if and only if &#39;result&#39; does not</span>
 124 |     | <span class='neutral'>  // overflow or underflow. Because,</span>
 125 |     | <span class='neutral'>  // - overflow implies that both &#39;value0&#39; and &#39;value1&#39; are positive but</span>
 126 |     | <span class='neutral'>  // &#39;result&#39; is negative which contradicts the following requirement.</span>
 127 |     | <span class='neutral'>  // - underflow implies that both &#39;value0&#39; and &#39;value1&#39; are negative but</span>
 128 |     | <span class='neutral'>  // &#39;result&#39; is positive which contradicts the following requirement as well.</span>
 129 |     | <span class='neutral'>  // - Lastly, in case of no overflow/underflow, the following requirement is</span>
 130 |     | <span class='neutral'>  // trivial.</span>
 131 |     | <span class='neutral'>  require(</span>
 132 |     | <span class='neutral'>    (value1 &gt;= zeroX127) == (result &gt;= value0),</span>
 133 |     | <span class='neutral'>    SafeAddFailed(value0, value1)</span>
 134 |     | <span class='neutral'>  );</span>
 135 |     | <span class='neutral'>}</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>function min(</span>
 138 |     | <span class='neutral'>  X127 value0,</span>
 139 |     | <span class='neutral'>  X127 value1</span>
 140 |     | <span class='neutral'>) pure returns (</span>
 141 |     | <span class='neutral'>  X127 result</span>
 142 |     | <span class='neutral'>) {</span>
 143 |     | <span class='neutral'>  return (value0 &lt; value1) ? value0 : value1;</span>
 144 |     | <span class='neutral'>}</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>function max(</span>
 147 |     | <span class='neutral'>  X127 value0,</span>
 148 |     | <span class='neutral'>  X127 value1</span>
 149 |     | <span class='neutral'>) pure returns (</span>
 150 |     | <span class='neutral'>  X127 result</span>
 151 |     | <span class='neutral'>) {</span>
 152 |     | <span class='neutral'>  return (value0 &lt; value1) ? value1 : value0;</span>
 153 |     | <span class='neutral'>}</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='unexecuted'>library X127Library {</span>
 156 |     | <span class='neutral'>  /// @notice Calculates &#39;value * multiplier / (2 ** 23)&#39;</span>
 157 |     | <span class='neutral'>  /// &#39;value&#39; should be non-negative.</span>
 158 |     | <span class='neutral'>  /// &#39;value * multiplier&#39; should be less than &#39;2 ** 256&#39;.</span>
 159 |     | <span class='neutral'>  function times(</span>
 160 |     | <span class='neutral'>    X127 value,</span>
 161 |     | <span class='neutral'>    X23 multiplier</span>
 162 |     | <span class='neutral'>  ) internal pure returns (</span>
 163 |     | <span class='neutral'>    X127 product</span>
 164 |     | <span class='neutral'>  ) {</span>
 165 |     | <span class='neutral'>    // The multiplication is safe because of the input requirement.</span>
 166 |     | <span class='neutral'>    assembly {</span>
 167 |     | <span class='neutral'>      product := shr(23, mul(value, multiplier))</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'>  }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>  /// @notice Calculates &#39;(value * numerator) / denominator&#39;</span>
 172 |     | <span class='neutral'>  /// Overflow and division by zero should be avoided externally.</span>
 173 |     | <span class='neutral'>  /// All input values should be non-negative.</span>
 174 |     | <span class='neutral'>  function mulDiv(</span>
 175 |     | <span class='neutral'>    X127 value,</span>
 176 |     | <span class='neutral'>    X216 numerator,</span>
 177 |     | <span class='neutral'>    X216 denominator</span>
 178 |     | <span class='neutral'>  ) internal pure returns (</span>
 179 |     | <span class='neutral'>    X127 result</span>
 180 |     | <span class='neutral'>  ) {</span>
 181 |     | <span class='neutral'>    result = X127.wrap(</span>
 182 |     | <span class='neutral'>      // Casting to &#39;int256&#39; is safe because overflow is handled externally.</span>
 183 |     | <span class='neutral'>      int256(</span>
 184 |     | <span class='neutral'>        // The three castings are safe because of the input requirement.</span>
 185 |     | <span class='neutral'>        // The requirements of &#39;mulDiv&#39; are met because overflow is handled</span>
 186 |     | <span class='neutral'>        // externally.</span>
 187 |     | <span class='neutral'>        FullMathLibrary.mulDiv(</span>
 188 |     | <span class='neutral'>          uint256(X127.unwrap(value)),</span>
 189 |     | <span class='neutral'>          uint256(X216.unwrap(numerator)),</span>
 190 |     | <span class='neutral'>          uint256(X216.unwrap(denominator))</span>
 191 |     | <span class='neutral'>        )</span>
 192 |     | <span class='neutral'>      )</span>
 193 |     | <span class='neutral'>    );</span>
 194 |     | <span class='neutral'>  }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>  /// @notice Transforms type X127 to the integer &#39;value / (2 ** 127)&#39; while</span>
 197 |     | <span class='neutral'>  /// maintaining the sign. Rounds towards negative infinity.</span>
 198 |     | <span class='neutral'>  function toInteger(</span>
 199 |     | <span class='neutral'>    X127 value</span>
 200 |     | <span class='neutral'>  ) internal pure returns (</span>
 201 |     | <span class='neutral'>    int256 result</span>
 202 |     | <span class='neutral'>  ) {</span>
 203 |     | <span class='neutral'>    assembly {</span>
 204 |     | <span class='neutral'>      result := sar(127, value)</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'>  }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>  /// @notice Transforms type X127 to the integer &#39;value / (2 ** 127)&#39; while</span>
 209 |     | <span class='neutral'>  /// maintaining the sign.</span>
 210 |     | <span class='neutral'>  /// Rounds towards positive infinity.</span>
 211 |     | <span class='neutral'>  /// &#39;value&#39; should be greater than &#39;- 2 ** 255&#39;.</span>
 212 |     | <span class='neutral'>  function toIntegerRoundUp(</span>
 213 |     | <span class='neutral'>    X127 value</span>
 214 |     | <span class='neutral'>  ) internal pure returns (</span>
 215 |     | <span class='neutral'>    int256 result</span>
 216 |     | <span class='neutral'>  ) {</span>
 217 |     | <span class='neutral'>    // The inner subtraction is safe because &#39;value &gt; - 2 ** 255&#39;.</span>
 218 |     | <span class='neutral'>    // The outer subtraction is safe because </span>
 219 |     | <span class='neutral'>    // &#39;- 2 ** 128 &lt; (0 - value) / (2 ** 127) &lt; 2 ** 128&#39;</span>
 220 |     | <span class='neutral'>    assembly {</span>
 221 |     | <span class='neutral'>      result := sub(0, sar(127, sub(0, value)))</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'>  }</span>
 224 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/X15.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// Type &#39;X15&#39; is dedicated to the vertical coordinates of the kernel</span>
   5 |     | <span class='neutral'>// breakpoints. The distribution of liquidity within every interval is governed</span>
   6 |     | <span class='neutral'>// by a piecewise linear kernel function. The kernel function is characterized</span>
   7 |     | <span class='neutral'>// by a list of breakpoints given by the pool owner. The vertical coordinate of</span>
   8 |     | <span class='neutral'>// each breakpoint is a number within the interval [0, 1] which is stored in</span>
   9 |     | <span class='neutral'>// &#39;X15&#39; format, with &#39;2 ** 15&#39; representing 1.</span>
  10 |     | <span class='neutral'>type X15 is uint256;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>X15 constant zeroX15 = X15.wrap(0);</span>
  13 |     | <span class='neutral'>X15 constant oneX15 = X15.wrap(1 &lt;&lt; 15);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>using {equals as ==, notEqual as !=} for X15 global;</span>
  16 |     | <span class='neutral'>using {lessThan as &lt;, greaterThan as &gt;} for X15 global;</span>
  17 |     | <span class='neutral'>using {</span>
  18 |     | <span class='neutral'>  lessThanOrEqualTo as &lt;=,</span>
  19 |     | <span class='neutral'>  greaterThanOrEqualTo as &gt;=</span>
  20 |     | <span class='neutral'>} for X15 global;</span>
  21 |     | <span class='neutral'>using {add as +, sub as -} for X15 global;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>function equals(</span>
  24 |     | <span class='neutral'>  X15 value0,</span>
  25 |     | <span class='neutral'>  X15 value1</span>
  26 |     | <span class='neutral'>) pure returns (</span>
  27 |     | <span class='neutral'>  bool result</span>
  28 |     | <span class='neutral'>) {</span>
  29 |     | <span class='neutral'>  assembly {</span>
  30 |     | <span class='neutral'>    result := eq(value0, value1)</span>
  31 |     | <span class='neutral'>  }</span>
  32 |     | <span class='neutral'>}</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>function notEqual(</span>
  35 |     | <span class='neutral'>  X15 value0,</span>
  36 |     | <span class='neutral'>  X15 value1</span>
  37 |     | <span class='neutral'>) pure returns (</span>
  38 |     | <span class='neutral'>  bool result</span>
  39 |     | <span class='neutral'>) {</span>
  40 |     | <span class='neutral'>  return !(value0 == value1);</span>
  41 |     | <span class='neutral'>}</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>function lessThan(</span>
  44 |     | <span class='neutral'>  X15 value0,</span>
  45 |     | <span class='neutral'>  X15 value1</span>
  46 |     | <span class='neutral'>) pure returns (</span>
  47 |     | <span class='neutral'>  bool result</span>
  48 |     | <span class='neutral'>) {</span>
  49 |     | <span class='neutral'>  assembly {</span>
  50 |     | <span class='neutral'>    result := lt(value0, value1)</span>
  51 |     | <span class='neutral'>  }</span>
  52 |     | <span class='neutral'>}</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>function greaterThan(</span>
  55 |     | <span class='neutral'>  X15 value0,</span>
  56 |     | <span class='neutral'>  X15 value1</span>
  57 |     | <span class='neutral'>) pure returns (</span>
  58 |     | <span class='neutral'>  bool result</span>
  59 |     | <span class='neutral'>) {</span>
  60 |     | <span class='neutral'>  assembly {</span>
  61 |     | <span class='neutral'>    result := gt(value0, value1)</span>
  62 |     | <span class='neutral'>  }</span>
  63 |     | <span class='neutral'>}</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>function lessThanOrEqualTo(</span>
  66 |     | <span class='neutral'>  X15 value0,</span>
  67 |     | <span class='neutral'>  X15 value1</span>
  68 |     | <span class='neutral'>) pure returns (</span>
  69 |     | <span class='neutral'>  bool result</span>
  70 |     | <span class='neutral'>) {</span>
  71 |     | <span class='neutral'>  return !(value0 &gt; value1);</span>
  72 |     | <span class='neutral'>}</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>function greaterThanOrEqualTo(</span>
  75 |     | <span class='neutral'>  X15 value0,</span>
  76 |     | <span class='neutral'>  X15 value1</span>
  77 |     | <span class='neutral'>) pure returns (</span>
  78 |     | <span class='neutral'>  bool result</span>
  79 |     | <span class='neutral'>) {</span>
  80 |     | <span class='neutral'>  return !(value0 &lt; value1);</span>
  81 |     | <span class='neutral'>}</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>// Overflow should be avoided externally.</span>
  84 |     | <span class='neutral'>function add(</span>
  85 |     | <span class='neutral'>  X15 value0,</span>
  86 |     | <span class='neutral'>  X15 value1</span>
  87 |     | <span class='neutral'>) pure returns (</span>
  88 |     | <span class='neutral'>  X15 result</span>
  89 |     | <span class='neutral'>) {</span>
  90 |     | <span class='neutral'>  assembly {</span>
  91 |     | <span class='neutral'>    result := add(value0, value1)</span>
  92 |     | <span class='neutral'>  }</span>
  93 |     | <span class='neutral'>}</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>// Underflow should be avoided externally.</span>
  96 |     | <span class='neutral'>function sub(</span>
  97 |     | <span class='neutral'>  X15 value0,</span>
  98 |     | <span class='neutral'>  X15 value1</span>
  99 |     | <span class='neutral'>) pure returns (</span>
 100 |     | <span class='neutral'>  X15 result</span>
 101 |     | <span class='neutral'>) {</span>
 102 |     | <span class='neutral'>  assembly {</span>
 103 |     | <span class='neutral'>    result := sub(value0, value1)</span>
 104 |     | <span class='neutral'>  }</span>
 105 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/X208.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {X111} from &quot;./X111.sol&quot;;</span>
   5 |     | <span class='neutral'>import {X216} from &quot;./X216.sol&quot;;</span>
   6 |     | <span class='neutral'>import {FullMathLibrary} from &quot;./FullMath.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// Type &#39;X208&#39; is dedicated to growth multipliers.</span>
   9 |     | <span class='neutral'>type X208 is uint256;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>using X208Library for X208 global;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>X208 constant zeroX208 = X208.wrap(0);</span>
  14 |     | <span class='neutral'>// (2 ** 208) * exp(+8)</span>
  15 |     | <span class='neutral'>X208 constant exp8X208 = X208.wrap(</span>
  16 |     | <span class='neutral'>  0x000000000BA4F53EA38636F85F007042540AE8EF33225E9A7AB4F4473A86D4A8</span>
  17 |     | <span class='neutral'>);</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>using {equals as ==, notEquals as !=} for X208 global;</span>
  20 |     | <span class='neutral'>using {lessThan as &lt;, greaterThan as &gt;} for X208 global;</span>
  21 |     | <span class='neutral'>using {</span>
  22 |     | <span class='neutral'>  lessThanOrEqualTo as &lt;=,</span>
  23 |     | <span class='neutral'>  greaterThanOrEqualTo as &gt;=</span>
  24 |     | <span class='neutral'>} for X208 global;</span>
  25 |     | <span class='neutral'>using {add as +, sub as -} for X208 global;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>function equals(</span>
  28 |     | <span class='neutral'>  X208 value0,</span>
  29 |     | <span class='neutral'>  X208 value1</span>
  30 |     | <span class='neutral'>) pure returns (</span>
  31 |     | <span class='neutral'>  bool result</span>
  32 |     | <span class='neutral'>) {</span>
  33 |     | <span class='neutral'>  assembly {</span>
  34 |     | <span class='neutral'>    result := eq(value0, value1)</span>
  35 |     | <span class='neutral'>  }</span>
  36 |     | <span class='neutral'>}</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>function notEquals(</span>
  39 |     | <span class='neutral'>  X208 value0,</span>
  40 |     | <span class='neutral'>  X208 value1</span>
  41 |     | <span class='neutral'>) pure returns (</span>
  42 |     | <span class='neutral'>  bool result</span>
  43 |     | <span class='neutral'>) {</span>
  44 |     | <span class='neutral'>  return !(value0 == value1);</span>
  45 |     | <span class='neutral'>}</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>function lessThan(</span>
  48 |     | <span class='neutral'>  X208 value0,</span>
  49 |     | <span class='neutral'>  X208 value1</span>
  50 |     | <span class='neutral'>) pure returns (</span>
  51 |     | <span class='neutral'>  bool result</span>
  52 |     | <span class='neutral'>) {</span>
  53 |     | <span class='neutral'>  assembly {</span>
  54 |     | <span class='neutral'>    result := lt(value0, value1)</span>
  55 |     | <span class='neutral'>  }</span>
  56 |     | <span class='neutral'>}</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>function greaterThan(</span>
  59 |     | <span class='neutral'>  X208 value0,</span>
  60 |     | <span class='neutral'>  X208 value1</span>
  61 |     | <span class='neutral'>) pure returns (</span>
  62 |     | <span class='neutral'>  bool result</span>
  63 |     | <span class='neutral'>) {</span>
  64 |     | <span class='neutral'>  assembly {</span>
  65 |     | <span class='neutral'>    result := gt(value0, value1)</span>
  66 |     | <span class='neutral'>  }</span>
  67 |     | <span class='neutral'>}</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>function lessThanOrEqualTo(</span>
  70 |     | <span class='neutral'>  X208 value0,</span>
  71 |     | <span class='neutral'>  X208 value1</span>
  72 |     | <span class='neutral'>) pure returns (</span>
  73 |     | <span class='neutral'>  bool result</span>
  74 |     | <span class='neutral'>) {</span>
  75 |     | <span class='neutral'>  return !(value0 &gt; value1);</span>
  76 |     | <span class='neutral'>}</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>function greaterThanOrEqualTo(</span>
  79 |     | <span class='neutral'>  X208 value0,</span>
  80 |     | <span class='neutral'>  X208 value1</span>
  81 |     | <span class='neutral'>) pure returns (</span>
  82 |     | <span class='neutral'>  bool result</span>
  83 |     | <span class='neutral'>) {</span>
  84 |     | <span class='neutral'>  return !(value0 &lt; value1);</span>
  85 |     | <span class='neutral'>}</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>// Overflow should be avoided externally.</span>
  88 |     | <span class='neutral'>function add(</span>
  89 |     | <span class='neutral'>  X208 value0,</span>
  90 |     | <span class='neutral'>  X208 value1</span>
  91 |     | <span class='neutral'>) pure returns (</span>
  92 |     | <span class='neutral'>  X208 result</span>
  93 |     | <span class='neutral'>) {</span>
  94 |     | <span class='neutral'>  assembly {</span>
  95 |     | <span class='neutral'>    result := add(value0, value1)</span>
  96 |     | <span class='neutral'>  }</span>
  97 |     | <span class='neutral'>}</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>// Underflow should be avoided externally.</span>
 100 |     | <span class='neutral'>function sub(</span>
 101 |     | <span class='neutral'>  X208 value0,</span>
 102 |     | <span class='neutral'>  X208 value1</span>
 103 |     | <span class='neutral'>) pure returns (</span>
 104 |     | <span class='neutral'>  X208 result</span>
 105 |     | <span class='neutral'>) {</span>
 106 |     | <span class='neutral'>  assembly {</span>
 107 |     | <span class='neutral'>    result := sub(value0, value1)</span>
 108 |     | <span class='neutral'>  }</span>
 109 |     | <span class='neutral'>}</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>library X208Library {</span>
 112 |     | <span class='neutral'>  /// @notice Calculates &#39;(value * numerator) / denominator&#39;</span>
 113 |     | <span class='neutral'>  /// Overflow and division by zero should be avoided externally.</span>
 114 |     | <span class='neutral'>  /// &#39;numerator&#39; and &#39;denominator&#39; values should be non-negative.</span>
 115 |     | <span class='neutral'>  function mulDiv(</span>
 116 |     | <span class='neutral'>    X208 value,</span>
 117 |     | <span class='neutral'>    X216 numerator,</span>
 118 |     | <span class='neutral'>    X216 denominator</span>
 119 |     | <span class='neutral'>  ) internal pure returns (</span>
 120 |     | <span class='neutral'>    X208 result</span>
 121 |     | <span class='neutral'>  ) {</span>
 122 |     | <span class='neutral'>    // Both castings are safe because of the non-negative requirement on both</span>
 123 |     | <span class='neutral'>    // &#39;numerator&#39; and &#39;denominator&#39;.</span>
 124 |     | <span class='neutral'>    result = X208.wrap(</span>
 125 |     | <span class='neutral'>      FullMathLibrary.mulDiv(</span>
 126 |     | <span class='neutral'>        X208.unwrap(value),</span>
 127 |     | <span class='neutral'>        uint256(X216.unwrap(numerator)),</span>
 128 |     | <span class='neutral'>        uint256(X216.unwrap(denominator))</span>
 129 |     | <span class='neutral'>      )</span>
 130 |     | <span class='neutral'>    );</span>
 131 |     | <span class='neutral'>  }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>  /// @notice Calculates</span>
 134 |     | <span class='neutral'>  /// &#39;(value * multiplier) / ((2 ** 313) * exp(-8))&#39;</span>
 135 |     | <span class='neutral'>  /// &#39;multiplier&#39; should be non-negative.</span>
 136 |     | <span class='neutral'>  function mulDivByExpInv8(</span>
 137 |     | <span class='neutral'>    X208 value,</span>
 138 |     | <span class='neutral'>    X216 multiplier</span>
 139 |     | <span class='neutral'>  ) internal pure returns (</span>
 140 |     | <span class='neutral'>    X111 product</span>
 141 |     | <span class='neutral'>  ) {</span>
 142 |     | <span class='neutral'>    ( ,  , uint256 q2) = FullMathLibrary.mul768(</span>
 143 |     | <span class='neutral'>      // (2 ** 244) * exp(8)</span>
 144 |     | <span class='neutral'>      0xBA4F53EA38636F85F007042540AE8EF33225E9A7AB4F4473A86D4A8FDD1A5B82,</span>
 145 |     | <span class='neutral'>      X208.unwrap(value),</span>
 146 |     | <span class='neutral'>      // Casting is safe because of the non-negative requirement on</span>
 147 |     | <span class='neutral'>      // &#39;multiplier&#39;.</span>
 148 |     | <span class='neutral'>      uint256(X216.unwrap(multiplier))</span>
 149 |     | <span class='neutral'>    );</span>
 150 |     | <span class='neutral'>    unchecked {</span>
 151 |     | <span class='neutral'>      // Casting is safe because &#39;q2 &gt;&gt; 45&#39; never exceeds &#39;type(int256).max&#39;.</span>
 152 |     | <span class='neutral'>      // &#39;45 == 244 + 208 + 216 - 512 - 111&#39;</span>
 153 |     | <span class='neutral'>      product = X111.wrap(int256(q2 &gt;&gt; 45));</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'>  }</span>
 156 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/X216.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {FullMathLibrary} from &quot;./FullMath.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>// Type &#39;X216&#39; is dedicated to integrals and sqrt of price values.</span>
   7 |     | <span class='neutral'>type X216 is int256;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>using X216Library for X216 global;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>X216 constant oneX216 = X216.wrap(1 &lt;&lt; 216);</span>
  12 |     | <span class='neutral'>X216 constant zeroX216 = X216.wrap(0);</span>
  13 |     | <span class='neutral'>X216 constant epsilonX216 = X216.wrap(1);</span>
  14 |     | <span class='neutral'>// (2 ** 216) * exp(-8)</span>
  15 |     | <span class='neutral'>X216 constant expInverse8X216 = X216.wrap(</span>
  16 |     | <span class='neutral'>  0x00000000000015FC21041027ACBBFCD46780FEE71EAD23FBCB7F4A81E58767EF</span>
  17 |     | <span class='neutral'>);</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>using {equals as ==, notEquals as !=} for X216 global;</span>
  20 |     | <span class='neutral'>using {lessThan as &lt;, greaterThan as &gt;} for X216 global;</span>
  21 |     | <span class='neutral'>using {</span>
  22 |     | <span class='neutral'>  lessThanOrEqualTo as &lt;=,</span>
  23 |     | <span class='neutral'>  greaterThanOrEqualTo as &gt;=</span>
  24 |     | <span class='neutral'>} for X216 global;</span>
  25 |     | <span class='neutral'>using {add as +, sub as -} for X216 global;</span>
  26 |     | <span class='neutral'>using {mul as *, cheapMul as &amp;} for X216 global;</span>
  27 |     | <span class='neutral'>using {mulDivByExpInv8 as %, mulDivByExpInv16 as ^} for X216 global;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>function equals(</span>
  30 |     | <span class='neutral'>  X216 value0,</span>
  31 |     | <span class='neutral'>  X216 value1</span>
  32 |     | <span class='neutral'>) pure returns (</span>
  33 |     | <span class='neutral'>  bool result</span>
  34 |     | <span class='neutral'>) {</span>
  35 |     | <span class='neutral'>  assembly {</span>
  36 |     | <span class='neutral'>    result := eq(value0, value1)</span>
  37 |     | <span class='neutral'>  }</span>
  38 |     | <span class='neutral'>}</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>function notEquals(</span>
  41 |     | <span class='neutral'>  X216 value0,</span>
  42 |     | <span class='neutral'>  X216 value1</span>
  43 |     | <span class='neutral'>) pure returns (</span>
  44 |     | <span class='neutral'>  bool result</span>
  45 |     | <span class='neutral'>) {</span>
  46 |     | <span class='neutral'>  return !(value0 == value1);</span>
  47 |     | <span class='neutral'>}</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>function lessThan(</span>
  50 |     | <span class='neutral'>  X216 value0,</span>
  51 |     | <span class='neutral'>  X216 value1</span>
  52 |     | <span class='neutral'>) pure returns (</span>
  53 |     | <span class='neutral'>  bool result</span>
  54 |     | <span class='neutral'>) {</span>
  55 |     | <span class='neutral'>  assembly {</span>
  56 |     | <span class='neutral'>    result := slt(value0, value1)</span>
  57 |     | <span class='neutral'>  }</span>
  58 |     | <span class='neutral'>}</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>function greaterThan(</span>
  61 |     | <span class='neutral'>  X216 value0,</span>
  62 |     | <span class='neutral'>  X216 value1</span>
  63 |     | <span class='neutral'>) pure returns (</span>
  64 |     | <span class='neutral'>  bool result</span>
  65 |     | <span class='neutral'>) {</span>
  66 |     | <span class='neutral'>  assembly {</span>
  67 |     | <span class='neutral'>    result := sgt(value0, value1)</span>
  68 |     | <span class='neutral'>  }</span>
  69 |     | <span class='neutral'>}</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>function lessThanOrEqualTo(</span>
  72 |     | <span class='neutral'>  X216 value0,</span>
  73 |     | <span class='neutral'>  X216 value1</span>
  74 |     | <span class='neutral'>) pure returns (</span>
  75 |     | <span class='neutral'>  bool result</span>
  76 |     | <span class='neutral'>) {</span>
  77 |     | <span class='neutral'>  return !(value0 &gt; value1);</span>
  78 |     | <span class='neutral'>}</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>function greaterThanOrEqualTo(</span>
  81 |     | <span class='neutral'>  X216 value0,</span>
  82 |     | <span class='neutral'>  X216 value1</span>
  83 |     | <span class='neutral'>) pure returns (</span>
  84 |     | <span class='neutral'>  bool result</span>
  85 |     | <span class='neutral'>) {</span>
  86 |     | <span class='neutral'>  return !(value0 &lt; value1);</span>
  87 |     | <span class='neutral'>}</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
  90 |     | <span class='neutral'>function add(</span>
  91 |     | <span class='neutral'>  X216 value0,</span>
  92 |     | <span class='neutral'>  X216 value1</span>
  93 |     | <span class='neutral'>) pure returns (</span>
  94 |     | <span class='neutral'>  X216 result</span>
  95 |     | <span class='neutral'>) {</span>
  96 |     | <span class='neutral'>  assembly {</span>
  97 |     | <span class='neutral'>    result := add(value0, value1)</span>
  98 |     | <span class='neutral'>  }</span>
  99 |     | <span class='neutral'>}</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
 102 |     | <span class='neutral'>function sub(</span>
 103 |     | <span class='neutral'>  X216 value0,</span>
 104 |     | <span class='neutral'>  X216 value1</span>
 105 |     | <span class='neutral'>) pure returns (</span>
 106 |     | <span class='neutral'>  X216 result</span>
 107 |     | <span class='neutral'>) {</span>
 108 |     | <span class='neutral'>  assembly {</span>
 109 |     | <span class='neutral'>    result := sub(value0, value1)</span>
 110 |     | <span class='neutral'>  }</span>
 111 |     | <span class='neutral'>}</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>// Calculates &#39;(value0 * value1) / (2 ** 216)&#39;.</span>
 114 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
 115 |     | <span class='neutral'>// Both values should be greater than &#39;- 2 ** 255&#39;.</span>
 116 |     | <span class='neutral'>function mul(</span>
 117 |     | <span class='neutral'>  X216 value0,</span>
 118 |     | <span class='neutral'>  X216 value1</span>
 119 |     | <span class='neutral'>) pure returns (</span>
 120 |     | <span class='neutral'>  X216 result</span>
 121 |     | <span class='neutral'>) {</span>
 122 |     | <span class='neutral'>  // Let &#39;s := value0 * value1 - (2 ** 256 - 1) * p&#39;</span>
 123 |     | <span class='neutral'>  // Let &#39;r := value0 * value1 - (2 ** 216) * q&#39;</span>
 124 |     | <span class='neutral'>  // Then &#39;s - r == (2 ** 216) * q&#39; [modulo &#39;2 ** 256 - 1&#39;]</span>
 125 |     | <span class='neutral'>  // Then &#39;q == (2 ** 40) * (s - r)&#39; [modulo &#39;2 ** 256 - 1&#39;]</span>
 126 |     | <span class='neutral'>  assembly {</span>
 127 |     | <span class='neutral'>    result := mulmod(</span>
 128 |     | <span class='neutral'>      addmod(</span>
 129 |     | <span class='neutral'>        // We account for the additional term &#39;2 ** 256&#39; in two&#39;s complement</span>
 130 |     | <span class='neutral'>        // representation by subtracting &#39;slt(value, 0)&#39;. Because if a two&#39;s</span>
 131 |     | <span class='neutral'>        // complement representation &#39;value&#39; correspond to a negative number,</span>
 132 |     | <span class='neutral'>        // we have:</span>
 133 |     | <span class='neutral'>        //</span>
 134 |     | <span class='neutral'>        // &#39;value - 2 ** 256 == value - 1&#39; [modulo 2 ** 256 - 1]</span>
 135 |     | <span class='neutral'>        //</span>
 136 |     | <span class='neutral'>        // Both subtractions are safe due to the input requirement.</span>
 137 |     | <span class='neutral'>        mulmod(</span>
 138 |     | <span class='neutral'>          sub(value0, slt(value0, 0)),</span>
 139 |     | <span class='neutral'>          sub(value1, slt(value1, 0)),</span>
 140 |     | <span class='neutral'>          not(0)</span>
 141 |     | <span class='neutral'>        ), // s</span>
 142 |     | <span class='neutral'>        // Here, we do not need to account for the additional term &#39;2 ** 256&#39;</span>
 143 |     | <span class='neutral'>        // in two&#39;s complement representation because if a two&#39;s complement</span>
 144 |     | <span class='neutral'>        // representation &#39;value&#39; is negative, we have:</span>
 145 |     | <span class='neutral'>        //</span>
 146 |     | <span class='neutral'>        // &#39;value - 2 ** 256 == value&#39; [modulo 2 ** 216]</span>
 147 |     | <span class='neutral'>        //</span>
 148 |     | <span class='neutral'>        // The subtraction is safe because &#39;2 ** 216 &lt; 2 ** 256 - 1&#39;.</span>
 149 |     | <span class='neutral'>        sub(not(0), mulmod(value0, value1, shl(216, 1))), // 0 - r</span>
 150 |     | <span class='neutral'>        not(0)</span>
 151 |     | <span class='neutral'>      ),</span>
 152 |     | <span class='neutral'>      shl(40, 1),</span>
 153 |     | <span class='neutral'>      not(0)</span>
 154 |     | <span class='neutral'>    )</span>
 155 |     | <span class='neutral'>  }</span>
 156 |     | <span class='neutral'>}</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>// Calculates &#39;(value0 * value1) / (2 ** 216)&#39;.</span>
 159 |     | <span class='neutral'>// &#39;value0&#39; and &#39;value1&#39; should be non-negative and less than &#39;oneX216&#39;.</span>
 160 |     | <span class='neutral'>function cheapMul(</span>
 161 |     | <span class='neutral'>  X216 value0,</span>
 162 |     | <span class='neutral'>  X216 value1</span>
 163 |     | <span class='neutral'>) pure returns (</span>
 164 |     | <span class='neutral'>  X216 result</span>
 165 |     | <span class='neutral'>) {</span>
 166 |     | <span class='neutral'>  // Let &#39;s := value0 * value1 - (2 ** 216 - 1) * p&#39;</span>
 167 |     | <span class='neutral'>  // Let &#39;r := value0 * value1 - (2 ** 216) * q&#39;</span>
 168 |     | <span class='neutral'>  // Then &#39;s - r == q&#39; [modulo &#39;2 ** 216 - 1&#39;]</span>
 169 |     | <span class='neutral'>  // Because of the input requirements, &#39;q&#39; does not exceed &#39;2 ** 216 - 1&#39;</span>
 170 |     | <span class='neutral'>  // which concludes that: &#39;s - r == q&#39;.</span>
 171 |     | <span class='neutral'>  assembly {</span>
 172 |     | <span class='neutral'>    result := addmod(</span>
 173 |     | <span class='neutral'>      mulmod(value0, value1, sub(shl(216, 1), 1)), // s</span>
 174 |     | <span class='neutral'>      // The subtraction is safe because the output of &#39;mulmod&#39; does not exceed</span>
 175 |     | <span class='neutral'>      // &#39;2 ** 216 - 1&#39;.</span>
 176 |     | <span class='neutral'>      sub(sub(shl(216, 1), 1), mulmod(value0, value1, shl(216, 1))), // 0 - r</span>
 177 |     | <span class='neutral'>      sub(shl(216, 1), 1)</span>
 178 |     | <span class='neutral'>    )</span>
 179 |     | <span class='neutral'>  }</span>
 180 |     | <span class='neutral'>}</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>// Calculates &#39;(value0 * value1) / ((2 ** 216) * exp(-8))&#39;.</span>
 183 |     | <span class='neutral'>//</span>
 184 |     | <span class='neutral'>// The following approximation is used: &#39;(2 ** 216) * exp(-8) ~= b / a&#39; where</span>
 185 |     | <span class='neutral'>// &#39;a = 0xF8F6376C44&#39; and </span>
 186 |     | <span class='neutral'>// &#39;b = 0x1561650620DABB6A84B684E2A7E5A47CAA0A0905210083F0E3B551AABF84E9&#39;</span>
 187 |     | <span class='neutral'>//</span>
 188 |     | <span class='neutral'>// Overflow should be avoided externally.</span>
 189 |     | <span class='neutral'>// Both values should be non-negative.</span>
 190 |     | <span class='neutral'>// &#39;value0&#39; should be less than &#39;oneX216&#39;.</span>
 191 |     | <span class='neutral'>function mulDivByExpInv8(</span>
 192 |     | <span class='neutral'>  X216 value0,</span>
 193 |     | <span class='neutral'>  X216 value1</span>
 194 |     | <span class='neutral'>) pure returns (</span>
 195 |     | <span class='neutral'>  X216 result</span>
 196 |     | <span class='neutral'>) {</span>
 197 |     | <span class='neutral'>  // Let &#39;s := value0 * value1 * a - (2 ** 256) * p&#39;</span>
 198 |     | <span class='neutral'>  // Let &#39;r := value0 * value1 * a - b * q&#39;</span>
 199 |     | <span class='neutral'>  // Then &#39;s - r == b * q&#39; [modulo &#39;2 ** 256&#39;]</span>
 200 |     | <span class='neutral'>  assembly {</span>
 201 |     | <span class='neutral'>    // Multiplication is safe because of the input requirement:</span>
 202 |     | <span class='neutral'>    // &#39;0 &lt;= value0 &lt; oneX216&#39;.</span>
 203 |     | <span class='neutral'>    result := mul(value0, 0xF8F6376C44)</span>
 204 |     | <span class='neutral'>    result := mul(</span>
 205 |     | <span class='neutral'>      // s - r</span>
 206 |     | <span class='neutral'>      sub(</span>
 207 |     | <span class='neutral'>        // s</span>
 208 |     | <span class='neutral'>        mul(result, value1),</span>
 209 |     | <span class='neutral'>        // r</span>
 210 |     | <span class='neutral'>        mulmod(</span>
 211 |     | <span class='neutral'>          result,</span>
 212 |     | <span class='neutral'>          value1,</span>
 213 |     | <span class='neutral'>          0x1561650620DABB6A84B684E2A7E5A47CAA0A0905210083F0E3B551AABF84E9 // b</span>
 214 |     | <span class='neutral'>        )</span>
 215 |     | <span class='neutral'>      ),</span>
 216 |     | <span class='neutral'>      // modular inverse of &#39;b&#39; modulo &#39;2 ** 256&#39;</span>
 217 |     | <span class='neutral'>      0x28256938C4923FF15AB260970AA81F81C15E6F5EF3AF38DC210569E77DB19359</span>
 218 |     | <span class='neutral'>    )</span>
 219 |     | <span class='neutral'>  }</span>
 220 |     | <span class='neutral'>}</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>// Calculates &#39;(value0 * value1) / ((2 ** 216) * exp(-16))&#39;.</span>
 223 |     | <span class='neutral'>//</span>
 224 |     | <span class='neutral'>// The following approximation is used: &#39;(2 ** 216) * exp(-16) ~= b / a&#39; where</span>
 225 |     | <span class='neutral'>// &#39;a = 0x27D117D7B * 0x2EC3A856&#39; and </span>
 226 |     | <span class='neutral'>// &#39;b = 0xDBB82F7041B890FE67970A62A3568CC34DF9DCB17CC3A2A6A027850E7E3724F9&#39;</span>
 227 |     | <span class='neutral'>//</span>
 228 |     | <span class='neutral'>// Overflow should be avoided externally.</span>
 229 |     | <span class='neutral'>// Both values should be non-negative.</span>
 230 |     | <span class='neutral'>// &#39;value0&#39; and &#39;value1&#39; should be less than &#39;oneX216&#39;.</span>
 231 |     | <span class='neutral'>function mulDivByExpInv16(</span>
 232 |     | <span class='neutral'>  X216 value0,</span>
 233 |     | <span class='neutral'>  X216 value1</span>
 234 |     | <span class='neutral'>) pure returns (</span>
 235 |     | <span class='neutral'>  X216 result</span>
 236 |     | <span class='neutral'>) {</span>
 237 |     | <span class='neutral'>  // Let &#39;s := value0 * value1 * a - (2 ** 256) * p&#39;</span>
 238 |     | <span class='neutral'>  // Let &#39;r := value0 * value1 * a - b * q&#39;</span>
 239 |     | <span class='neutral'>  // Then &#39;s - r == b * q&#39; [modulo &#39;2 ** 256&#39;]</span>
 240 |     | <span class='neutral'>  assembly {</span>
 241 |     | <span class='neutral'>    // Both of the following multiplications are safe because of the input</span>
 242 |     | <span class='neutral'>    // requirements:</span>
 243 |     | <span class='neutral'>    // &#39;0 &lt;= value0 &lt; oneX216&#39;.</span>
 244 |     | <span class='neutral'>    // &#39;0 &lt;= value1 &lt; oneX216&#39;.</span>
 245 |     | <span class='neutral'>    value0 := mul(value0, 0x27D117D7B)</span>
 246 |     | <span class='neutral'>    value1 := mul(value1, 0x2EC3A856)</span>
 247 |     | <span class='neutral'>    result := mul(</span>
 248 |     | <span class='neutral'>      // s - r</span>
 249 |     | <span class='neutral'>      sub(</span>
 250 |     | <span class='neutral'>        // s</span>
 251 |     | <span class='neutral'>        mul(value0, value1),</span>
 252 |     | <span class='neutral'>        // r</span>
 253 |     | <span class='neutral'>        mulmod(</span>
 254 |     | <span class='neutral'>          value0,</span>
 255 |     | <span class='neutral'>          value1,</span>
 256 |     | <span class='neutral'>          // b</span>
 257 |     | <span class='neutral'>          0xDBB82F7041B890FE67970A62A3568CC34DF9DCB17CC3A2A6A027850E7E3724F9</span>
 258 |     | <span class='neutral'>        )</span>
 259 |     | <span class='neutral'>      ),</span>
 260 |     | <span class='neutral'>      // modular inverse of &#39;b&#39; modulo &#39;2 ** 256&#39;</span>
 261 |     | <span class='neutral'>      0x7F6AF8233BADA11DD406B4458454ED9904D7AF796BE7AA4885B23E25B6985D49</span>
 262 |     | <span class='neutral'>    )</span>
 263 |     | <span class='neutral'>  }</span>
 264 |     | <span class='neutral'>}</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>function min(</span>
 267 |     | <span class='neutral'>  X216 value0,</span>
 268 |     | <span class='neutral'>  X216 value1</span>
 269 |     | <span class='neutral'>) pure returns (</span>
 270 |     | <span class='neutral'>  X216 result</span>
 271 |     | <span class='neutral'>) {</span>
 272 |     | <span class='neutral'>  return (value0 &lt; value1) ? value0 : value1;</span>
 273 |     | <span class='neutral'>}</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='neutral'>function max(</span>
 276 |     | <span class='neutral'>  X216 value0,</span>
 277 |     | <span class='neutral'>  X216 value1</span>
 278 |     | <span class='neutral'>) pure returns (</span>
 279 |     | <span class='neutral'>  X216 result</span>
 280 |     | <span class='neutral'>) {</span>
 281 |     | <span class='neutral'>  return (value0 &lt; value1) ? value1 : value0;</span>
 282 |     | <span class='neutral'>}</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>/// @notice Returns the minimum of two unsigned fractions. &#39;0 / 0&#39; is </span>
 285 |     | <span class='neutral'>/// interpreted as infinity. &#39;which == false&#39; and &#39;which == true&#39; indicate</span>
 286 |     | <span class='neutral'>/// &#39;(numerator0, denominator0)&#39; and &#39;(numerator1, denominator1)&#39;,</span>
 287 |     | <span class='neutral'>/// respectively.</span>
 288 |     | <span class='neutral'>/// All four values should be non-negative.</span>
 289 |     | <span class='neutral'>/// At least one &#39;denominator&#39; should be non-zero.</span>
 290 |     | <span class='neutral'>function minFractions(</span>
 291 |     | <span class='neutral'>  X216 numerator0,</span>
 292 |     | <span class='neutral'>  X216 denominator0,</span>
 293 |     | <span class='neutral'>  X216 numerator1,</span>
 294 |     | <span class='neutral'>  X216 denominator1</span>
 295 |     | <span class='neutral'>) pure returns (</span>
 296 |     | <span class='neutral'>  X216 numerator,</span>
 297 |     | <span class='neutral'>  X216 denominator,</span>
 298 |     | <span class='neutral'>  bool which</span>
 299 |     | <span class='neutral'>) {</span>
 300 |     | <span class='neutral'>  if (numerator0 == zeroX216) {</span>
 301 |     | <span class='neutral'>    if (denominator0 == zeroX216) {</span>
 302 |     | <span class='neutral'>      return (numerator1, denominator1, true);</span>
 303 |     | <span class='neutral'>    }</span>
 304 |     | <span class='neutral'>  }</span>
 305 |     | <span class='neutral'>  // Castings are safe because all four values are non-negative.</span>
 306 |     | <span class='neutral'>  (uint256 lsb0, uint256 msb0) = FullMathLibrary.mul512(</span>
 307 |     | <span class='neutral'>    uint256(X216.unwrap(numerator0)),</span>
 308 |     | <span class='neutral'>    uint256(X216.unwrap(denominator1))</span>
 309 |     | <span class='neutral'>  );</span>
 310 |     | <span class='neutral'>  (uint256 lsb1, uint256 msb1) = FullMathLibrary.mul512(</span>
 311 |     | <span class='neutral'>    uint256(X216.unwrap(numerator1)),</span>
 312 |     | <span class='neutral'>    uint256(X216.unwrap(denominator0))</span>
 313 |     | <span class='neutral'>  );</span>
 314 |     | <span class='neutral'>  (numerator, denominator, which) = </span>
 315 |     | <span class='neutral'>    ((msb1 &gt; msb0) || ((msb1 == msb0) &amp;&amp; (lsb1 &gt;= lsb0))) ? </span>
 316 |     | <span class='neutral'>    (numerator0, denominator0, false) : </span>
 317 |     | <span class='neutral'>    (numerator1, denominator1, true);</span>
 318 |     | <span class='neutral'>}</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='unexecuted'>library X216Library {</span>
 321 |     | <span class='neutral'>  /// @notice Calculates &#39;value * exp(1 / (2 ** 60))&#39;.</span>
 322 |     | <span class='neutral'>  /// Overflow should be avoided externally.</span>
 323 |     | <span class='neutral'>  /// &#39;value&#39; should be non-negative.</span>
 324 |     | <span class='neutral'>  function multiplyByExpEpsilon(</span>
 325 |     | <span class='neutral'>    X216 value</span>
 326 |     | <span class='neutral'>  ) internal pure returns (</span>
 327 |     | <span class='neutral'>    X216 result</span>
 328 |     | <span class='neutral'>  ) {</span>
 329 |     | <span class='neutral'>    // Let &#39;a := floor((2 ** 256) * exp(-1 / (2 ** 60)))&#39;</span>
 330 |     | <span class='neutral'>    // Let &#39;r := (2 ** 256) * value - a * q&#39;</span>
 331 |     | <span class='neutral'>    // Let &#39;b := modularInverse(- a, 2 ** 256)&#39;</span>
 332 |     | <span class='neutral'>    // Then &#39;q == b * r&#39; [modulo &#39;2 ** 256&#39;]</span>
 333 |     | <span class='neutral'>    assembly {</span>
 334 |     | <span class='neutral'>      result := mul(</span>
 335 |     | <span class='neutral'>        // r</span>
 336 |     | <span class='neutral'>        mulmod(</span>
 337 |     | <span class='neutral'>          value,</span>
 338 |     | <span class='neutral'>          // We are subtracting by &#39;a&#39; because &#39;2 ** 256&#39; does not fit, which</span>
 339 |     | <span class='neutral'>          // is okay because the multiplication is done modulo &#39;a&#39;.</span>
 340 |     | <span class='neutral'>          // 2 ** 256 - a</span>
 341 |     | <span class='neutral'>          0xFFFFFFFFFFFFFFF8000000000000002AAAAAAAAAAAAAAA001,</span>
 342 |     | <span class='neutral'>          // a</span>
 343 |     | <span class='neutral'>          0xFFFFFFFFFFFFFFF0000000000000007FFFFFFFFFFFFFFD555555555555555FFF</span>
 344 |     | <span class='neutral'>        ),</span>
 345 |     | <span class='neutral'>        // b</span>
 346 |     | <span class='neutral'>        0xAA3ED2381A8B1241D16168FD77EF989ED2B13BE12B716AA23F35ED0E39556001</span>
 347 |     | <span class='neutral'>      )</span>
 348 |     | <span class='neutral'>    }</span>
 349 |     | <span class='neutral'>  }</span>
 350 |     | <span class='neutral'></span>
 351 |     | <span class='neutral'>  /// @notice Calculates &#39;value / exp(1 / (2 ** 60))&#39;.</span>
 352 |     | <span class='neutral'>  /// &#39;value&#39; should be non-negative.</span>
 353 |     | <span class='neutral'>  function divideByExpEpsilon(</span>
 354 |     | <span class='neutral'>    X216 value</span>
 355 |     | <span class='neutral'>  ) internal pure returns (</span>
 356 |     | <span class='neutral'>    X216 result</span>
 357 |     | <span class='neutral'>  ) {</span>
 358 |     | <span class='neutral'>    assembly {</span>
 359 |     | <span class='neutral'>      // Let &#39;a := floor((2 ** 256 - 1) * exp(-1 / (2 ** 60)))&#39;.</span>
 360 |     | <span class='neutral'>      // Let &#39;s := value * a - q * not(0)&#39;.</span>
 361 |     | <span class='neutral'>      // Let &#39;r := value * a&#39;.</span>
 362 |     | <span class='neutral'>      // Then &#39;s - r == - q * not(0) == q&#39;.</span>
 363 |     | <span class='neutral'>      result := sub(</span>
 364 |     | <span class='neutral'>        // s</span>
 365 |     | <span class='neutral'>        mulmod(</span>
 366 |     | <span class='neutral'>          value,</span>
 367 |     | <span class='neutral'>          // a</span>
 368 |     | <span class='neutral'>          0xFFFFFFFFFFFFFFF0000000000000007FFFFFFFFFFFFFFD555555555555555FFE,</span>
 369 |     | <span class='neutral'>          not(0)</span>
 370 |     | <span class='neutral'>        ),</span>
 371 |     | <span class='neutral'>        // r</span>
 372 |     | <span class='neutral'>        mul(</span>
 373 |     | <span class='neutral'>          value,</span>
 374 |     | <span class='neutral'>          // a</span>
 375 |     | <span class='neutral'>          0xFFFFFFFFFFFFFFF0000000000000007FFFFFFFFFFFFFFD555555555555555FFE</span>
 376 |     | <span class='neutral'>        )</span>
 377 |     | <span class='neutral'>      )</span>
 378 |     | <span class='neutral'>    }</span>
 379 |     | <span class='neutral'>  }</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='neutral'>  /// @notice Calculates &#39;(value * numerator) / denominator&#39;</span>
 382 |     | <span class='neutral'>  /// Overflow and division by zero should be avoided externally.</span>
 383 |     | <span class='neutral'>  /// All input values should be non-negative.</span>
 384 |     | <span class='neutral'>  function mulDiv(</span>
 385 |     | <span class='neutral'>    X216 value,</span>
 386 |     | <span class='neutral'>    X216 numerator,</span>
 387 |     | <span class='neutral'>    X216 denominator</span>
 388 |     | <span class='neutral'>  ) internal pure returns (</span>
 389 |     | <span class='neutral'>    X216 result</span>
 390 |     | <span class='neutral'>  ) {</span>
 391 |     | <span class='neutral'>    result = X216.wrap(</span>
 392 |     | <span class='neutral'>      // Casting is safe because overflow is handled externally.</span>
 393 |     | <span class='neutral'>      int256(</span>
 394 |     | <span class='neutral'>        // All three castings are safe due to the input requirements.</span>
 395 |     | <span class='neutral'>        FullMathLibrary.mulDiv(</span>
 396 |     | <span class='neutral'>          uint256(X216.unwrap(value)),</span>
 397 |     | <span class='neutral'>          uint256(X216.unwrap(numerator)),</span>
 398 |     | <span class='neutral'>          uint256(X216.unwrap(denominator))</span>
 399 |     | <span class='neutral'>        )</span>
 400 |     | <span class='neutral'>      )</span>
 401 |     | <span class='neutral'>    );</span>
 402 |     | <span class='neutral'>  }</span>
 403 |     | <span class='neutral'></span>
 404 |     | <span class='neutral'>  /// @notice Calculates &#39;(value * numerator) / denominator&#39; when </span>
 405 |     | <span class='neutral'>  /// &#39;value * numerator &lt; denominator * (denominator - 1)&#39;.</span>
 406 |     | <span class='neutral'>  /// value should be non-negative</span>
 407 |     | <span class='neutral'>  function cheapMulDiv(</span>
 408 |     | <span class='neutral'>    X216 value,</span>
 409 |     | <span class='neutral'>    uint256 numerator,</span>
 410 |     | <span class='neutral'>    uint256 denominator</span>
 411 |     | <span class='neutral'>  ) internal pure returns (</span>
 412 |     | <span class='neutral'>    X216 result</span>
 413 |     | <span class='neutral'>  ) {</span>
 414 |     | <span class='neutral'>    result = X216.wrap(</span>
 415 |     | <span class='neutral'>      // Casting is safe because overflow is handled externally.</span>
 416 |     | <span class='neutral'>      int256(</span>
 417 |     | <span class='neutral'>        // The requirement of &#39;cheapMulDiv&#39; is met because of the above input</span>
 418 |     | <span class='neutral'>        // requirement.</span>
 419 |     | <span class='neutral'>        FullMathLibrary.cheapMulDiv(</span>
 420 |     | <span class='neutral'>          // Casting is safe due to the input requirement in &#39;value&#39;.</span>
 421 |     | <span class='neutral'>          uint256(X216.unwrap(value)),</span>
 422 |     | <span class='neutral'>          numerator,</span>
 423 |     | <span class='neutral'>          denominator</span>
 424 |     | <span class='neutral'>        )</span>
 425 |     | <span class='neutral'>      )</span>
 426 |     | <span class='neutral'>    );</span>
 427 |     | <span class='neutral'>  }</span>
 428 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/X23.sol</b>
<code>
  1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// Type &#39;X23&#39; is dedicated to pool growth ratios which determine the ratio of</span>
  5 |     | <span class='neutral'>// the accrued growth portions that belong to a pool owner. &#39;oneX23&#39; represents</span>
  6 |     | <span class='neutral'>// 100%.</span>
  7 |     | <span class='neutral'>type X23 is uint256;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>X23 constant zeroX23 = X23.wrap(0);</span>
 10 |     | <span class='neutral'>X23 constant oneX23 = X23.wrap(1 &lt;&lt; 23);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>using {add as +, sub as -} for X23 global;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>// Overflow should be avoided externally.</span>
 15 |     | <span class='neutral'>function add(</span>
 16 |     | <span class='neutral'>  X23 value0,</span>
 17 |     | <span class='neutral'>  X23 value1</span>
 18 |     | <span class='neutral'>) pure returns (</span>
 19 |     | <span class='neutral'>  X23 result</span>
 20 |     | <span class='neutral'>) {</span>
 21 |     | <span class='neutral'>  assembly {</span>
 22 |     | <span class='neutral'>    result := add(value0, value1)</span>
 23 |     | <span class='neutral'>  }</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>// Underflow should be avoided externally.</span>
 27 |     | <span class='neutral'>function sub(</span>
 28 |     | <span class='neutral'>  X23 value0,</span>
 29 |     | <span class='neutral'>  X23 value1</span>
 30 |     | <span class='neutral'>) pure returns (</span>
 31 |     | <span class='neutral'>  X23 result</span>
 32 |     | <span class='neutral'>) {</span>
 33 |     | <span class='neutral'>  assembly {</span>
 34 |     | <span class='neutral'>    result := sub(value0, value1)</span>
 35 |     | <span class='neutral'>  }</span>
 36 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/X47.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// Type &#39;X47&#39; is dedicated to growth portions. Interval liquidity can grow as a</span>
   5 |     | <span class='neutral'>// result of a swap or a donation. A portion of this growth goes to the</span>
   6 |     | <span class='neutral'>// protocol. A portion of the remaining growth goes to the pool owner. These</span>
   7 |     | <span class='neutral'>// portions are stored as &#39;X47&#39; type with &#39;oneX47&#39; representing 100%.</span>
   8 |     | <span class='neutral'>type X47 is uint256;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>X47 constant zeroX47 = X47.wrap(0);</span>
  11 |     | <span class='neutral'>// Largest valid value for growth portions:</span>
  12 |     | <span class='unexecuted'>X47 constant oneX47 = X47.wrap(1 &lt;&lt; 47);</span>
  13 |     | <span class='neutral'>// An invalid value for growth portions which is used as an indicator:</span>
  14 |     | <span class='neutral'>X47 constant maxX47 = X47.wrap(type(uint48).max);</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>using {equals as ==, notEqual as !=} for X47 global;</span>
  17 |     | <span class='neutral'>using {lessThan as &lt;, greaterThan as &gt;} for X47 global;</span>
  18 |     | <span class='neutral'>using {</span>
  19 |     | <span class='neutral'>  lessThanOrEqualTo as &lt;=,</span>
  20 |     | <span class='neutral'>  greaterThanOrEqualTo as &gt;=</span>
  21 |     | <span class='neutral'>} for X47 global;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>function equals(</span>
  24 |     | <span class='neutral'>  X47 value0,</span>
  25 |     | <span class='neutral'>  X47 value1</span>
  26 |     | <span class='neutral'>) pure returns (</span>
  27 |     | <span class='neutral'>  bool result</span>
  28 |     | <span class='neutral'>) {</span>
  29 |     | <span class='neutral'>  assembly {</span>
  30 |     | <span class='neutral'>    result := eq(value0, value1)</span>
  31 |     | <span class='neutral'>  }</span>
  32 |     | <span class='neutral'>}</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>function notEqual(</span>
  35 |     | <span class='neutral'>  X47 value0,</span>
  36 |     | <span class='neutral'>  X47 value1</span>
  37 |     | <span class='neutral'>) pure returns (</span>
  38 |     | <span class='neutral'>  bool result</span>
  39 |     | <span class='neutral'>) {</span>
  40 |     | <span class='neutral'>  return !(value0 == value1);</span>
  41 |     | <span class='neutral'>}</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>function lessThan(</span>
  44 |     | <span class='neutral'>  X47 value0,</span>
  45 |     | <span class='neutral'>  X47 value1</span>
  46 |     | <span class='neutral'>) pure returns (</span>
  47 |     | <span class='neutral'>  bool result</span>
  48 |     | <span class='neutral'>) {</span>
  49 |     | <span class='neutral'>  assembly {</span>
  50 |     | <span class='neutral'>    result := lt(value0, value1)</span>
  51 |     | <span class='neutral'>  }</span>
  52 |     | <span class='neutral'>}</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>function greaterThan(</span>
  55 |     | <span class='neutral'>  X47 value0,</span>
  56 |     | <span class='neutral'>  X47 value1</span>
  57 |     | <span class='neutral'>) pure returns (</span>
  58 |     | <span class='unexecuted'>  bool result</span>
  59 |     | <span class='neutral'>) {</span>
  60 |     | <span class='unexecuted'>  assembly {</span>
  61 |     | <span class='neutral'>    result := gt(value0, value1)</span>
  62 |     | <span class='neutral'>  }</span>
  63 |     | <span class='neutral'>}</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>function lessThanOrEqualTo(</span>
  66 |     | <span class='neutral'>  X47 value0,</span>
  67 |     | <span class='neutral'>  X47 value1</span>
  68 |     | <span class='neutral'>) pure returns (</span>
  69 |     | <span class='unexecuted'>  bool result</span>
  70 |     | <span class='neutral'>) {</span>
  71 |     | <span class='unexecuted'>  return !(value0 &gt; value1);</span>
  72 |     | <span class='neutral'>}</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>function greaterThanOrEqualTo(</span>
  75 |     | <span class='neutral'>  X47 value0,</span>
  76 |     | <span class='neutral'>  X47 value1</span>
  77 |     | <span class='neutral'>) pure returns (</span>
  78 |     | <span class='neutral'>  bool result</span>
  79 |     | <span class='neutral'>) {</span>
  80 |     | <span class='neutral'>  return !(value0 &lt; value1);</span>
  81 |     | <span class='neutral'>}</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>function min(</span>
  84 |     | <span class='neutral'>  X47 value0,</span>
  85 |     | <span class='neutral'>  X47 value1</span>
  86 |     | <span class='neutral'>) pure returns (</span>
  87 |     | <span class='neutral'>  X47 result</span>
  88 |     | <span class='neutral'>) {</span>
  89 |     | <span class='neutral'>  return (value0 &lt; value1) ? value0 : value1;</span>
  90 |     | <span class='neutral'>}</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>function max(</span>
  93 |     | <span class='neutral'>  X47 value0,</span>
  94 |     | <span class='neutral'>  X47 value1</span>
  95 |     | <span class='neutral'>) pure returns (</span>
  96 |     | <span class='neutral'>  X47 result</span>
  97 |     | <span class='neutral'>) {</span>
  98 |     | <span class='neutral'>  return (value0 &lt; value1) ? value1 : value0;</span>
  99 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/X59.sol</b>
<code>
   1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {X15} from &quot;./X15.sol&quot;;</span>
   5 |     | <span class='neutral'>import {X74} from &quot;./X74.sol&quot;;</span>
   6 |     | <span class='neutral'>import {X127} from &quot;./X127.sol&quot;;</span>
   7 |     | <span class='neutral'>import {X216} from &quot;./X216.sol&quot;;</span>
   8 |     | <span class='neutral'>import {FullMathLibrary} from &quot;./FullMath.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>// Type &#39;X59&#39; is dedicated to the natural logarithm of price.</span>
  11 |     | <span class='neutral'>type X59 is int256;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>using X59Library for X59 global;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='unexecuted'>X59 constant zeroX59 = X59.wrap(0);</span>
  16 |     | <span class='neutral'>X59 constant epsilonX59 = X59.wrap(1);</span>
  17 |     | <span class='neutral'>X59 constant oneX59 = X59.wrap(1 &lt;&lt; 59);</span>
  18 |     | <span class='neutral'>X59 constant twoX59 = X59.wrap(2 &lt;&lt; 59);</span>
  19 |     | <span class='neutral'>X59 constant threeX59 = X59.wrap(3 &lt;&lt; 59);</span>
  20 |     | <span class='neutral'>X59 constant fourX59 = X59.wrap(4 &lt;&lt; 59);</span>
  21 |     | <span class='unexecuted'>X59 constant sixteenX59 = X59.wrap(16 &lt;&lt; 59);</span>
  22 |     | <span class='unexecuted'>X59 constant thirtyTwoX59 = X59.wrap(32 &lt;&lt; 59);</span>
  23 |     | <span class='neutral'>X59 constant minLogSpacing = X59.wrap((1 &lt;&lt; 59) &gt;&gt; 19);</span>
  24 |     | <span class='neutral'>X59 constant minLogStep = X59.wrap((1 &lt;&lt; 59) &gt;&gt; 27);</span>
  25 |     | <span class='unexecuted'>X59 constant minLogOffset = X59.wrap(0 - int256(90 &lt;&lt; 59));</span>
  26 |     | <span class='unexecuted'>X59 constant maxLogOffset = X59.wrap(90 &lt;&lt; 59);</span>
  27 |     | <span class='neutral'>X59 constant minX59 = X59.wrap(0 - type(int256).max);</span>
  28 |     | <span class='neutral'>X59 constant maxX59 = X59.wrap(type(int256).max);</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>using {equals as ==, notEqual as !=} for X59 global;</span>
  31 |     | <span class='neutral'>using {lessThan as &lt;, greaterThan as &gt;} for X59 global;</span>
  32 |     | <span class='neutral'>using {</span>
  33 |     | <span class='neutral'>  lessThanOrEqualTo as &lt;=,</span>
  34 |     | <span class='neutral'>  greaterThanOrEqualTo as &gt;=</span>
  35 |     | <span class='neutral'>} for X59 global;</span>
  36 |     | <span class='neutral'>using {add as +, sub as -} for X59 global;</span>
  37 |     | <span class='neutral'>using {mod as %} for X59 global;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>function equals(</span>
  40 |     | <span class='neutral'>  X59 value0,</span>
  41 |     | <span class='neutral'>  X59 value1</span>
  42 |     | <span class='neutral'>) pure returns (</span>
  43 |     | <span class='neutral'>  bool result</span>
  44 |     | <span class='neutral'>) {</span>
  45 |     | <span class='neutral'>  assembly {</span>
  46 |     | <span class='neutral'>    result := eq(value0, value1)</span>
  47 |     | <span class='neutral'>  }</span>
  48 |     | <span class='neutral'>}</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>function notEqual(</span>
  51 |     | <span class='neutral'>  X59 value0,</span>
  52 |     | <span class='neutral'>  X59 value1</span>
  53 |     | <span class='neutral'>) pure returns (</span>
  54 |     | <span class='neutral'>  bool result</span>
  55 |     | <span class='neutral'>) {</span>
  56 |     | <span class='neutral'>  return !(value0 == value1);</span>
  57 |     | <span class='neutral'>}</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>function lessThan(</span>
  60 |     | <span class='neutral'>  X59 value0,</span>
  61 |     | <span class='neutral'>  X59 value1</span>
  62 |     | <span class='neutral'>) pure returns (</span>
  63 |     | <span class='unexecuted'>  bool result</span>
  64 |     | <span class='neutral'>) {</span>
  65 |     | <span class='unexecuted'>  assembly {</span>
  66 |     | <span class='neutral'>    result := slt(value0, value1)</span>
  67 |     | <span class='neutral'>  }</span>
  68 |     | <span class='neutral'>}</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>function greaterThan(</span>
  71 |     | <span class='neutral'>  X59 value0,</span>
  72 |     | <span class='neutral'>  X59 value1</span>
  73 |     | <span class='neutral'>) pure returns (</span>
  74 |     | <span class='unexecuted'>  bool result</span>
  75 |     | <span class='neutral'>) {</span>
  76 |     | <span class='unexecuted'>  assembly {</span>
  77 |     | <span class='neutral'>    result := sgt(value0, value1)</span>
  78 |     | <span class='neutral'>  }</span>
  79 |     | <span class='neutral'>}</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>function lessThanOrEqualTo(</span>
  82 |     | <span class='neutral'>  X59 value0,</span>
  83 |     | <span class='neutral'>  X59 value1</span>
  84 |     | <span class='neutral'>) pure returns (</span>
  85 |     | <span class='neutral'>  bool result</span>
  86 |     | <span class='neutral'>) {</span>
  87 |     | <span class='neutral'>  return !(value0 &gt; value1);</span>
  88 |     | <span class='neutral'>}</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>function greaterThanOrEqualTo(</span>
  91 |     | <span class='neutral'>  X59 value0,</span>
  92 |     | <span class='neutral'>  X59 value1</span>
  93 |     | <span class='neutral'>) pure returns (</span>
  94 |     | <span class='neutral'>  bool result</span>
  95 |     | <span class='neutral'>) {</span>
  96 |     | <span class='neutral'>  return !(value0 &lt; value1);</span>
  97 |     | <span class='neutral'>}</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
 100 |     | <span class='neutral'>function add(</span>
 101 |     | <span class='neutral'>  X59 value0,</span>
 102 |     | <span class='neutral'>  X59 value1</span>
 103 |     | <span class='neutral'>) pure returns (</span>
 104 |     | <span class='neutral'>  X59 result</span>
 105 |     | <span class='neutral'>) {</span>
 106 |     | <span class='neutral'>  assembly {</span>
 107 |     | <span class='neutral'>    result := add(value0, value1)</span>
 108 |     | <span class='neutral'>  }</span>
 109 |     | <span class='neutral'>}</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
 112 |     | <span class='unexecuted'>function sub(</span>
 113 |     | <span class='neutral'>  X59 value0,</span>
 114 |     | <span class='neutral'>  X59 value1</span>
 115 |     | <span class='neutral'>) pure returns (</span>
 116 |     | <span class='unexecuted'>  X59 result</span>
 117 |     | <span class='neutral'>) {</span>
 118 |     | <span class='unexecuted'>  assembly {</span>
 119 |     | <span class='neutral'>    result := sub(value0, value1)</span>
 120 |     | <span class='neutral'>  }</span>
 121 |     | <span class='neutral'>}</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>// &#39;value&#39; should be non-negative.</span>
 124 |     | <span class='neutral'>// &#39;modulus&#39; should be positive.</span>
 125 |     | <span class='neutral'>function mod(</span>
 126 |     | <span class='neutral'>  X59 value,</span>
 127 |     | <span class='neutral'>  X59 modulus</span>
 128 |     | <span class='neutral'>) pure returns (</span>
 129 |     | <span class='neutral'>  X59 result</span>
 130 |     | <span class='neutral'>) {</span>
 131 |     | <span class='neutral'>  assembly {</span>
 132 |     | <span class='neutral'>    result := mod(value, modulus)</span>
 133 |     | <span class='neutral'>  }</span>
 134 |     | <span class='neutral'>}</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>function min(</span>
 137 |     | <span class='neutral'>  X59 value0,</span>
 138 |     | <span class='neutral'>  X59 value1</span>
 139 |     | <span class='neutral'>) pure returns (</span>
 140 |     | <span class='neutral'>  X59 result</span>
 141 |     | <span class='neutral'>) {</span>
 142 |     | <span class='neutral'>  return (value0 &lt; value1) ? value0 : value1;</span>
 143 |     | <span class='neutral'>}</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>function max(</span>
 146 |     | <span class='neutral'>  X59 value0,</span>
 147 |     | <span class='neutral'>  X59 value1</span>
 148 |     | <span class='neutral'>) pure returns (</span>
 149 |     | <span class='neutral'>  X59 result</span>
 150 |     | <span class='neutral'>) {</span>
 151 |     | <span class='neutral'>  return (value0 &lt; value1) ? value1 : value0;</span>
 152 |     | <span class='neutral'>}</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>library X59Library {</span>
 155 |     | <span class='neutral'>  // Overflow should be avoided externally.</span>
 156 |     | <span class='neutral'>  // &#39;value0&#39; should be non-negative.</span>
 157 |     | <span class='neutral'>  function times(</span>
 158 |     | <span class='neutral'>    X59 value0,</span>
 159 |     | <span class='neutral'>    X15 value1</span>
 160 |     | <span class='neutral'>  ) internal pure returns (</span>
 161 |     | <span class='neutral'>    X74 result</span>
 162 |     | <span class='neutral'>  ) {</span>
 163 |     | <span class='neutral'>    assembly {</span>
 164 |     | <span class='neutral'>      result := mul(value0, value1)</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'>  }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>  /// @notice Calculates &#39;(value * numerator) / denominator&#39; when </span>
 169 |     | <span class='neutral'>  /// &#39;value * numerator &lt; denominator * (denominator - 1)&#39;.</span>
 170 |     | <span class='neutral'>  /// The three inputs should be non-negative.</span>
 171 |     | <span class='neutral'>  function cheapMulDiv(</span>
 172 |     | <span class='neutral'>    X59 value,</span>
 173 |     | <span class='neutral'>    X216 numerator,</span>
 174 |     | <span class='neutral'>    X216 denominator</span>
 175 |     | <span class='neutral'>  ) internal pure returns (</span>
 176 |     | <span class='neutral'>    X59 result</span>
 177 |     | <span class='neutral'>  ) {</span>
 178 |     | <span class='neutral'>    // The three castings to &#39;uint256&#39; are safe because of the &#39;non-negative&#39;</span>
 179 |     | <span class='neutral'>    // requirement on input values.</span>
 180 |     | <span class='neutral'>    //</span>
 181 |     | <span class='neutral'>    // The casting to &#39;int256&#39; is safe because</span>
 182 |     | <span class='neutral'>    // &#39;value * numerator / denominator &lt; denominator - 1 &lt;= 2 ** 255 - 2&#39;.</span>
 183 |     | <span class='neutral'>    //</span>
 184 |     | <span class='neutral'>    // The requirement of &#39;cheapMulDiv&#39; are met because of the above input</span>
 185 |     | <span class='neutral'>    // requirement.</span>
 186 |     | <span class='neutral'>    result = X59.wrap(int256(FullMathLibrary.cheapMulDiv(</span>
 187 |     | <span class='neutral'>      uint256(X59.unwrap(value)),</span>
 188 |     | <span class='neutral'>      uint256(X216.unwrap(numerator)),</span>
 189 |     | <span class='neutral'>      uint256(X216.unwrap(denominator))</span>
 190 |     | <span class='neutral'>    )));</span>
 191 |     | <span class='neutral'>  }</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='neutral'>  /// @notice Calculates</span>
 194 |     | <span class='neutral'>  /// &#39;(value * multiplier0 * multiplier1) / ((2 ** (216 + 59)) * exp(-16))&#39;</span>
 195 |     | <span class='neutral'>  /// Overflow should be avoided externally.</span>
 196 |     | <span class='neutral'>  /// All three inputs should be non-negative.</span>
 197 |     | <span class='neutral'>  function mulDivByExpInv16(</span>
 198 |     | <span class='neutral'>    X59 value,</span>
 199 |     | <span class='neutral'>    X216 multiplier0,</span>
 200 |     | <span class='neutral'>    X216 multiplier1</span>
 201 |     | <span class='neutral'>  ) internal pure returns (</span>
 202 |     | <span class='neutral'>    X216 product</span>
 203 |     | <span class='neutral'>  ) {</span>
 204 |     | <span class='neutral'>    assembly {</span>
 205 |     | <span class='neutral'>      // Let &#39;r := value * multiplier0 * multiplier1 </span>
 206 |     | <span class='neutral'>      //         - floor((2 ** 275) * exp(-16)) * q&#39;.</span>
 207 |     | <span class='neutral'>      //</span>
 208 |     | <span class='neutral'>      // Let &#39;s := value * multiplier0 * multiplier1 - (2 ** 256) * p&#39;.</span>
 209 |     | <span class='neutral'>      //</span>
 210 |     | <span class='neutral'>      // Then &#39;s - r == floor((2 ** 275) * exp(-16)) * q&#39; [modulo &#39;2 ** 256&#39;]</span>
 211 |     | <span class='neutral'>      product := mul(</span>
 212 |     | <span class='neutral'>        sub(</span>
 213 |     | <span class='neutral'>          // s</span>
 214 |     | <span class='neutral'>          mul(mul(value, multiplier0), multiplier1),</span>
 215 |     | <span class='neutral'>          // r</span>
 216 |     | <span class='neutral'>          mulmod(</span>
 217 |     | <span class='neutral'>            mulmod(</span>
 218 |     | <span class='neutral'>              value,</span>
 219 |     | <span class='neutral'>              multiplier0,</span>
 220 |     | <span class='neutral'>              // floor((2 ** 275) * exp(-16))</span>
 221 |     | <span class='neutral'>              0xF1AADDD7742E56D32FB9F997447D9E6314DB84884FABAB26BF059AF9BC20B61</span>
 222 |     | <span class='neutral'>            ),</span>
 223 |     | <span class='neutral'>            multiplier1,</span>
 224 |     | <span class='neutral'>            // floor((2 ** 275) * exp(-16))</span>
 225 |     | <span class='neutral'>            0xF1AADDD7742E56D32FB9F997447D9E6314DB84884FABAB26BF059AF9BC20B61</span>
 226 |     | <span class='neutral'>          )</span>
 227 |     | <span class='neutral'>        ),</span>
 228 |     | <span class='neutral'>        // modularInverse(floor((2 ** 275) * exp(-16)), 2 ** 256)</span>
 229 |     | <span class='neutral'>        0xD49C04AF80AF1EA5F98F85886B450A4B264FC14874F9F64143836145A37DD8A1</span>
 230 |     | <span class='neutral'>      )</span>
 231 |     | <span class='neutral'>    }</span>
 232 |     | <span class='neutral'>  }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>  /// @notice Calculates &#39;(2 ** 256) * exp(- x / (2 ** 60))&#39;.</span>
 235 |     | <span class='neutral'>  /// &quot;Pade Approximant&quot; is employed for this purpose:</span>
 236 |     | <span class='neutral'>  /// &#39;exp(- x / (2 ** 60)) ~= ((u(x) - v(x)) / (u(x) + v(x))) ** (2 ** 14)&#39;</span>
 237 |     | <span class='neutral'>  /// where</span>
 238 |     | <span class='neutral'>  ///                x ** 2      x ** 4       x ** 6          x ** 8</span>
 239 |     | <span class='neutral'>  /// &#39;u(x) = 1 + 7 --------- + --------- + ----------- + --------------&#39;</span>
 240 |     | <span class='neutral'>  ///                15&lt;&lt;150     39&lt;&lt;300     6435&lt;&lt;449     2027025&lt;&lt;600</span>
 241 |     | <span class='neutral'>  /// and</span>
 242 |     | <span class='neutral'>  ///            x       x ** 3       x ** 5        x ** 7</span>
 243 |     | <span class='neutral'>  /// &#39;v(x) = ------- + --------- + ---------- + -------------&#39;.</span>
 244 |     | <span class='neutral'>  ///          1&lt;&lt;75     15&lt;&lt;224     585&lt;&lt;374     225225&lt;&lt;523</span>
 245 |     | <span class='neutral'>  ///</span>
 246 |     | <span class='neutral'>  /// This formula can be reproduced via the following Mathematica command:</span>
 247 |     | <span class='neutral'>  /// &#39;PadeApproximant[Exp[- x / (2 ^ 74)], {x, 0, 8}]&#39;.</span>
 248 |     | <span class='neutral'>  ///</span>
 249 |     | <span class='neutral'>  /// Input should be greater than &#39;0&#39; and less than &#39;2 ** 64&#39;.</span>
 250 |     | <span class='neutral'>  function expInverse(</span>
 251 |     | <span class='neutral'>    X59 value</span>
 252 |     | <span class='neutral'>  ) internal pure returns (</span>
 253 |     | <span class='neutral'>    uint256 exponentialInverse</span>
 254 |     | <span class='neutral'>  ) {</span>
 255 |     | <span class='neutral'>    unchecked {</span>
 256 |     | <span class='neutral'>      // Casting is safe because &#39;value&#39; is between &#39;0&#39; and &#39;2 ** 64&#39;.</span>
 257 |     | <span class='neutral'>      uint256 x = uint256(X59.unwrap(value));</span>
 258 |     | <span class='neutral'>      </span>
 259 |     | <span class='neutral'>      // x ** 2</span>
 260 |     | <span class='neutral'>      uint256 x2 = x * x;</span>
 261 |     | <span class='neutral'>      </span>
 262 |     | <span class='neutral'>      // x ** 4</span>
 263 |     | <span class='neutral'>      uint256 x4 = x2 * x2;</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='neutral'>      // (x ** 6) / (2 ** 128)</span>
 266 |     | <span class='neutral'>      uint256 x6;</span>
 267 |     | <span class='neutral'>      assembly {</span>
 268 |     | <span class='neutral'>        // Let &#39;r := x2 * x4 - (2 ** 128) * q&#39;</span>
 269 |     | <span class='neutral'>        // Let &#39;s := x2 * x4 - (2 ** 256 - 1) * p&#39;</span>
 270 |     | <span class='neutral'>        // Then &#39;s - r == (2 ** 128) * q&#39; [modulo &#39;2 ** 256 - 1&#39;]</span>
 271 |     | <span class='neutral'>        // And &#39;q == (2 ** 128) * (s - r)&#39; [modulo &#39;2 ** 256 - 1&#39;]</span>
 272 |     | <span class='neutral'>        // Calculation modulo &#39;2 ** 256 - 1&#39; is safe because:</span>
 273 |     | <span class='neutral'>        // &#39;((2 ** 64 - 1) ** 6) / (2 ** 128) &lt; 2 ** 256 - 1&#39;</span>
 274 |     | <span class='neutral'>        x6 := mulmod(</span>
 275 |     | <span class='neutral'>          // The subtraction is safe because the remainder is greater than or</span>
 276 |     | <span class='neutral'>          // equal to the second one.</span>
 277 |     | <span class='neutral'>          sub(mulmod(x2, x4, not(0)), mulmod(x2, x4, shl(128, 1))),</span>
 278 |     | <span class='neutral'>          shl(128, 1),</span>
 279 |     | <span class='neutral'>          not(0)</span>
 280 |     | <span class='neutral'>        )</span>
 281 |     | <span class='neutral'>      }</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>      // (x ** 8) / (2 ** 256)</span>
 284 |     | <span class='neutral'>      uint256 x8;</span>
 285 |     | <span class='neutral'>      assembly {</span>
 286 |     | <span class='neutral'>        // Let &#39;r := x4 * x4 - (2 ** 256) * q&#39;</span>
 287 |     | <span class='neutral'>        // Let &#39;s := x4 * x4 - (2 ** 256 - 1) * p&#39;</span>
 288 |     | <span class='neutral'>        // Then &#39;s - r == q&#39; [modulo &#39;2 ** 256 - 1&#39;]</span>
 289 |     | <span class='neutral'>        // Calculation modulo &#39;2 ** 256 - 1&#39; is safe because:</span>
 290 |     | <span class='neutral'>        // &#39;((2 ** 64 - 1) ** 8) / (2 ** 256) &lt; 2 ** 256 - 1&#39;</span>
 291 |     | <span class='neutral'>        x8 := sub(mulmod(x4, x4, not(0)), mul(x4, x4))</span>
 292 |     | <span class='neutral'>      }</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>      // (2 ** 254) * u(x)</span>
 295 |     | <span class='neutral'>      // The additions are safe because the first term is &#39;1 &lt;&lt; 254&#39; and none</span>
 296 |     | <span class='neutral'>      // of the other terms exceed &#39;1 &lt;&lt; 250&#39;.</span>
 297 |     | <span class='neutral'>      uint256 a = </span>
 298 |     | <span class='neutral'>        ((x2 * (7 &lt;&lt; 104)) / 15) + </span>
 299 |     | <span class='neutral'>        (x4 / (39 &lt;&lt; 46)) + </span>
 300 |     | <span class='neutral'>        (x6 / (6435 &lt;&lt; 67)) + </span>
 301 |     | <span class='neutral'>        (x8 / (2027025 &lt;&lt; 90)) + </span>
 302 |     | <span class='neutral'>        (1 &lt;&lt; 254);</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='neutral'>      // (2 ** 254) * v(x)</span>
 305 |     | <span class='neutral'>      // The additions are safe because the first term is &#39;1 &lt;&lt; 255&#39; and none</span>
 306 |     | <span class='neutral'>      // of the other terms exceed &#39;1 &lt;&lt; 250&#39;.</span>
 307 |     | <span class='neutral'>      uint256 b = </span>
 308 |     | <span class='neutral'>        ((x2 &lt;&lt; 106) / 15) + </span>
 309 |     | <span class='neutral'>        (x4 / (585 &lt;&lt; 44)) + </span>
 310 |     | <span class='neutral'>        (x6 / (225225 &lt;&lt; 65)) + </span>
 311 |     | <span class='neutral'>        (1 &lt;&lt; 255);</span>
 312 |     | <span class='neutral'>        </span>
 313 |     | <span class='neutral'>      assembly {</span>
 314 |     | <span class='neutral'>        // Here we multiply the result by (x / (2 ** 76)).</span>
 315 |     | <span class='neutral'>        // Let &#39;r := x * b - (2 ** 76) * q&#39;</span>
 316 |     | <span class='neutral'>        // Let &#39;s := x * b - (2 ** 256 - 1) * p&#39;</span>
 317 |     | <span class='neutral'>        // Then &#39;s - r == (2 ** 76) * q&#39; [modulo &#39;2 ** 256 - 1&#39;]</span>
 318 |     | <span class='neutral'>        // And &#39;q == (2 ** 180) * (s - r)&#39; [modulo &#39;2 ** 256 - 1&#39;]</span>
 319 |     | <span class='neutral'>        // Calculation modulo &#39;2 ** 256 - 1&#39; is safe because:</span>
 320 |     | <span class='neutral'>        // &#39;b &lt; 2 ** 256 - 1&#39;</span>
 321 |     | <span class='neutral'>        b := mulmod(</span>
 322 |     | <span class='neutral'>          // The subtraction is safe because the remainder is greater than or</span>
 323 |     | <span class='neutral'>          // equal to the second one.</span>
 324 |     | <span class='neutral'>          sub(mulmod(x, b, not(0)), mulmod(x, b, shl(76, 1))),</span>
 325 |     | <span class='neutral'>          shl(180, 1),</span>
 326 |     | <span class='neutral'>          not(0)</span>
 327 |     | <span class='neutral'>        )</span>
 328 |     | <span class='neutral'>      }</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='neutral'>      // (2 ** 256) * (u(x) - v(x)) / (u(x) + v(x))</span>
 331 |     | <span class='neutral'>      // Since &#39;(2 ** 254) * (a - b) - (a + b) * (a + b - 1)&#39; is a</span>
 332 |     | <span class='neutral'>      // decreasing function with respect to &#39;x&#39;, it suffices to verify</span>
 333 |     | <span class='neutral'>      // that &#39;(2 ** 254) * (a - b) - (a + b) * (a + b - 1) &lt; 0&#39; only for</span>
 334 |     | <span class='neutral'>      // &#39;x == 1&#39; which is true. Hence, the requirement of &#39;cheapMulDiv&#39; is</span>
 335 |     | <span class='neutral'>      // satisfied.</span>
 336 |     | <span class='neutral'>      a = FullMathLibrary.cheapMulDiv(a - b, 1 &lt;&lt; 254, a + b) &lt;&lt; 2;</span>
 337 |     | <span class='neutral'></span>
 338 |     | <span class='neutral'>      // Next, we compute &#39;f(f(f(f(f(f(f(f(f(f(f(f(f(f(a))))))))))))))&#39;</span>
 339 |     | <span class='neutral'>      // where &#39;f(y) = (y ** 2) / (2 ** 256 - 1) ~ (y ** 2) / (2 ** 256)&#39;</span>
 340 |     | <span class='neutral'>      // This is because of the &#39;2 ** 14&#39; term which was discussed before.</span>
 341 |     | <span class='neutral'>      assembly {</span>
 342 |     | <span class='neutral'>        a := sub(</span>
 343 |     | <span class='neutral'>          mulmod(a, a, not(0)), // s := a * a - q * not(0)</span>
 344 |     | <span class='neutral'>          mul(a, a) // r := a * a</span>
 345 |     | <span class='neutral'>        ) // s - r == - q * not(0) == q</span>
 346 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 347 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 348 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 349 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 350 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 351 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 352 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 353 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 354 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 355 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 356 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 357 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 358 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 359 |     | <span class='neutral'>      }</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='neutral'>      return a;</span>
 362 |     | <span class='neutral'>    }</span>
 363 |     | <span class='neutral'>  }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>  /// @notice Transforms natural logarithm of price to square root of price.</span>
 366 |     | <span class='neutral'>  /// @param value The input whose exponential to be calculated.</span>
 367 |     | <span class='neutral'>  /// @return exponentialInverse is &#39;(2 ** 216) * exp(- x / (2 ** 60))&#39;</span>
 368 |     | <span class='neutral'>  /// @return exponentialOverExp16 is &#39;(2 ** 216) * exp(- 16 + x / (2 ** 60))&#39;</span>
 369 |     | <span class='neutral'>  /// Input should be greater than 0 and less than (2 ** 64).</span>
 370 |     | <span class='neutral'>  function exp(</span>
 371 |     | <span class='neutral'>    X59 value</span>
 372 |     | <span class='neutral'>  ) internal pure returns (</span>
 373 |     | <span class='neutral'>    X216 exponentialInverse,</span>
 374 |     | <span class='neutral'>    X216 exponentialOverExp16</span>
 375 |     | <span class='neutral'>  ) {</span>
 376 |     | <span class='neutral'>    // The requirements of &#39;expInverse&#39; are the same as the requirements here.</span>
 377 |     | <span class='neutral'>    uint256 a = expInverse(value);</span>
 378 |     | <span class='neutral'></span>
 379 |     | <span class='neutral'>    // Since &#39;0 &lt; value &lt; 2 ** 64&#39;, we have</span>
 380 |     | <span class='neutral'>    // &#39;(2 ** 256) * exp(-16) &lt; a &lt; (2 ** 256)&#39;, hence</span>
 381 |     | <span class='neutral'>    // &#39;(2 ** 472) * exp(-16) &lt; a * (a - 1)&#39; and the requirements of</span>
 382 |     | <span class='neutral'>    // &#39;cheapMulDiv&#39; are satisfied.</span>
 383 |     | <span class='neutral'>    //</span>
 384 |     | <span class='neutral'>    // Casting to &#39;int256&#39; is safe because the output of &#39;cheapMulDiv&#39; is</span>
 385 |     | <span class='neutral'>    // non-negative and it is less than &#39;oneX216&#39;.</span>
 386 |     | <span class='neutral'>    //</span>
 387 |     | <span class='neutral'>    // So, we can calculate &#39;(2 ** 472) * exp(-16) / a&#39; as follows:</span>
 388 |     | <span class='neutral'>    exponentialOverExp16 = X216.wrap(int256(FullMathLibrary.cheapMulDiv(</span>
 389 |     | <span class='neutral'>      // (2 ** 279) * exp(-16)</span>
 390 |     | <span class='neutral'>      0xF1AADDD7742E56D32FB9F997447D9E6314DB84884FABAB26BF059AF9BC20B609,</span>
 391 |     | <span class='neutral'>      1 &lt;&lt; 193,</span>
 392 |     | <span class='neutral'>      a</span>
 393 |     | <span class='neutral'>    )));</span>
 394 |     | <span class='neutral'></span>
 395 |     | <span class='neutral'>    // Casting to &#39;int256&#39; is safe because &#39;a &gt;&gt; 40&#39; is non-negative and it is</span>
 396 |     | <span class='neutral'>    // less than &#39;oneX216&#39;.</span>
 397 |     | <span class='neutral'>    exponentialInverse = X216.wrap(int256(a &gt;&gt; 40));</span>
 398 |     | <span class='neutral'>  }</span>
 399 |     | <span class='neutral'></span>
 400 |     | <span class='neutral'>  /// @notice Transforms natural logarithm of price to square root of price.</span>
 401 |     | <span class='neutral'>  /// &quot;Pade Approximant&quot; is employed for this purpose:</span>
 402 |     | <span class='neutral'>  /// &#39;exp(- x / (2 ** 60)) ~= ((u(x) - v(x)) / (u(x) + v(x))) ** (2 ** 48)&#39;</span>
 403 |     | <span class='neutral'>  /// where</span>
 404 |     | <span class='neutral'>  ///              x ** 2</span>
 405 |     | <span class='neutral'>  /// &#39;u(x) = 1 + --------&#39;</span>
 406 |     | <span class='neutral'>  ///              3&lt;&lt;218</span>
 407 |     | <span class='neutral'>  /// and</span>
 408 |     | <span class='neutral'>  ///             x</span>
 409 |     | <span class='neutral'>  /// &#39;v(x) = --------&#39;.</span>
 410 |     | <span class='neutral'>  ///          1&lt;&lt;109</span>
 411 |     | <span class='neutral'>  ///</span>
 412 |     | <span class='neutral'>  /// This formula can be reproduced via the following Mathematica command:</span>
 413 |     | <span class='neutral'>  /// &#39;PadeApproximant[Exp[- x / (2 ^ 108)], {x, 0, 2}]&#39;.</span>
 414 |     | <span class='neutral'>  ///</span>
 415 |     | <span class='neutral'>  /// @param value The input whose exponential to be calculated.</span>
 416 |     | <span class='neutral'>  /// @return exponentialInverse is &#39;(2 ** 256) * exp(- x / (2 ** 60))&#39;</span>
 417 |     | <span class='neutral'>  /// Input should be positive and less than &#39;2 * maxLogOffset&#39;.</span>
 418 |     | <span class='unexecuted'>  function expOffset(</span>
 419 |     | <span class='neutral'>    X59 value</span>
 420 |     | <span class='neutral'>  ) internal pure returns (</span>
 421 |     | <span class='unexecuted'>    uint256 exponentialInverse</span>
 422 |     | <span class='neutral'>  ) {</span>
 423 |     | <span class='neutral'>    unchecked {</span>
 424 |     | <span class='neutral'>      // Casting is safe because &#39;value&#39; is between &#39;0&#39; and &#39;2 ** 64&#39;.</span>
 425 |     | <span class='unexecuted'>      uint256 x = uint256(X59.unwrap(value));</span>
 426 |     | <span class='neutral'></span>
 427 |     | <span class='neutral'>      // (2 ** 255) * u(x)</span>
 428 |     | <span class='neutral'>      // The multiplication and addition are safe because &#39;x &lt; 2 ** 64&#39;.</span>
 429 |     | <span class='unexecuted'>      uint256 a = (((x * x) &lt;&lt; 37) / 3) + (1 &lt;&lt; 255);</span>
 430 |     | <span class='neutral'></span>
 431 |     | <span class='neutral'>      // (2 ** 255) * v(x)</span>
 432 |     | <span class='neutral'>      // The shift is safe because &#39;x &lt; 2 ** 64&#39;.</span>
 433 |     | <span class='unexecuted'>      x &lt;&lt;= 146;</span>
 434 |     | <span class='neutral'></span>
 435 |     | <span class='neutral'>      // The requirements of &#39;cheapMulDiv&#39; are satisfied because</span>
 436 |     | <span class='neutral'>      // (a - x) * (2 ** 254) - (a + x) (a + x - 1) is a decreasing function</span>
 437 |     | <span class='neutral'>      // with respect to &#39;x&#39;. Hence, we just need to verify that it is negative</span>
 438 |     | <span class='neutral'>      // for &#39;x == 1&#39; which is true.</span>
 439 |     | <span class='unexecuted'>      a = FullMathLibrary.cheapMulDiv(a - x, 1 &lt;&lt; 254, a + x) &lt;&lt; 2;</span>
 440 |     | <span class='neutral'></span>
 441 |     | <span class='neutral'>      // Next, we apply the function </span>
 442 |     | <span class='neutral'>      // &#39;f(y) = (y ** 2) / (2 ** 256 - 1) ~ (y ** 2) / (2 ** 256)&#39;, 48 times.</span>
 443 |     | <span class='neutral'>      // This is because of the &#39;2 ** 48&#39; term which was discussed before.</span>
 444 |     | <span class='unexecuted'>      assembly {</span>
 445 |     | <span class='neutral'>        a := sub(</span>
 446 |     | <span class='neutral'>          mulmod(a, a, not(0)), // s := a * a - q * not(0)</span>
 447 |     | <span class='neutral'>          mul(a, a) // r := a * a</span>
 448 |     | <span class='neutral'>        ) // s - r == - q * not(0) == q</span>
 449 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 450 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 451 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 452 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 453 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 454 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 455 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 456 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 457 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 458 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 459 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 460 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 461 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 462 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 463 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 464 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 465 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 466 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 467 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 468 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 469 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 470 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 471 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 472 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 473 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 474 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 475 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 476 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 477 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 478 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 479 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 480 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 481 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 482 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 483 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 484 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 485 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 486 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 487 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 488 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 489 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 490 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 491 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 492 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 493 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 494 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 495 |     | <span class='neutral'>        a := sub(mulmod(a, a, not(0)), mul(a, a))</span>
 496 |     | <span class='neutral'>      }</span>
 497 |     | <span class='neutral'></span>
 498 |     | <span class='unexecuted'>      return a;</span>
 499 |     | <span class='neutral'>    }</span>
 500 |     | <span class='neutral'>  }</span>
 501 |     | <span class='neutral'></span>
 502 |     | <span class='neutral'>  /// @notice Transforms natural logarithm of price in two&#39;s complement to</span>
 503 |     | <span class='neutral'>  /// square root of price.</span>
 504 |     | <span class='neutral'>  /// Input should be between &#39;minLogOffset&#39; and &#39;maxLogOffset&#39;.</span>
 505 |     | <span class='neutral'>  /// @param logOffset The input whose exponential to be calculated.</span>
 506 |     | <span class='neutral'>  /// @return sqrtOffset is &#39;(2 ** 127) * exp(logOffset / (2 ** 60))&#39;</span>
 507 |     | <span class='unexecuted'>  function logToSqrtOffset(</span>
 508 |     | <span class='neutral'>    X59 logOffset</span>
 509 |     | <span class='neutral'>  ) internal pure returns (</span>
 510 |     | <span class='unexecuted'>    X127 sqrtOffset</span>
 511 |     | <span class='neutral'>  ) {</span>
 512 |     | <span class='neutral'>    // &#39;(2 ** 256) * exp(- (maxLogOffset - logOffset) / (2 ** 60))&#39;</span>
 513 |     | <span class='neutral'>    // The requirements of &#39;expOffset&#39; are satisfied here because:</span>
 514 |     | <span class='neutral'>    // &#39;minLogOffset &lt; logOffset &lt; maxLogOffset&#39;</span>
 515 |     | <span class='neutral'>    // &#39;0 &lt; maxLogOffset - logOffset &lt; </span>
 516 |     | <span class='neutral'>    //      maxLogOffset - minLogOffset == 2 * maxLogOffset&#39;.</span>
 517 |     | <span class='unexecuted'>    uint256 exponential = (maxLogOffset - logOffset).expOffset();</span>
 518 |     | <span class='neutral'>    // (2 ** (256 + 191)) * exp(- (maxLogOffset - logOffset) / (2 ** 60)) / </span>
 519 |     | <span class='neutral'>    // ((2 ** 320) * exp(-45))</span>
 520 |     | <span class='unexecuted'>    assembly {</span>
 521 |     | <span class='neutral'>      // Let &#39;s := exponential * (2 ** 191) - (2 ** 256) * p&#39;</span>
 522 |     | <span class='neutral'>      // Let &#39;r := exponential * (2 ** 191) - floor((2 ** 320) * exp(-45)) * q&#39;</span>
 523 |     | <span class='neutral'>      // Then &#39;s - r == floor((2 ** 320) * exp(-45)) * q&#39; [modulo &#39;2 ** 256&#39;]</span>
 524 |     | <span class='neutral'>      sqrtOffset := mul(</span>
 525 |     | <span class='neutral'>        // s - r</span>
 526 |     | <span class='neutral'>        sub(</span>
 527 |     | <span class='neutral'>          // s</span>
 528 |     | <span class='neutral'>          mul(exponential, shl(191, 1)), // Because &#39;256 + 191 - 320 == 127&#39;</span>
 529 |     | <span class='neutral'>          // r</span>
 530 |     | <span class='neutral'>          mulmod(</span>
 531 |     | <span class='neutral'>            exponential,</span>
 532 |     | <span class='neutral'>            shl(191, 1),</span>
 533 |     | <span class='neutral'>            // floor((2 ** 320) * exp(-45))</span>
 534 |     | <span class='neutral'>            0x872DB9E8FFA9E7D41F2AAF39897B91E4002E70FCEED391471FAD73D51503772D</span>
 535 |     | <span class='neutral'>          )</span>
 536 |     | <span class='neutral'>        ),</span>
 537 |     | <span class='neutral'>        // modularInverse(floor((2 ** 320) * exp(-45)), 2 ** 256)</span>
 538 |     | <span class='neutral'>        0xCF8E41E6C4D4AA5E9CC597C10CD32EACD30C44F750A8FFDB1A8863DD8F72F0A5</span>
 539 |     | <span class='neutral'>      )</span>
 540 |     | <span class='neutral'>    }</span>
 541 |     | <span class='neutral'>  }</span>
 542 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/contracts/utilities/X74.sol</b>
<code>
  1 |     | <span class='neutral'>// Copyright 2025, NoFeeSwap LLC - All rights reserved.</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {X216} from &quot;./X216.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>// Type &#39;X74&#39; is used as an intermediate type when searching for precise log</span>
  7 |     | <span class='neutral'>// price movement corresponding to the specified outgoing/incoming token </span>
  8 |     | <span class='neutral'>// amounts.</span>
  9 |     | <span class='neutral'>type X74 is int256;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>X74 constant zeroX74 = X74.wrap(0);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>using {equals as ==, notEqual as !=} for X74 global;</span>
 14 |     | <span class='neutral'>using {add as +, sub as -} for X74 global;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>using X74Library for X74 global;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>function equals(</span>
 19 |     | <span class='neutral'>  X74 value0,</span>
 20 |     | <span class='neutral'>  X74 value1</span>
 21 |     | <span class='neutral'>) pure returns (</span>
 22 |     | <span class='neutral'>  bool result</span>
 23 |     | <span class='neutral'>) {</span>
 24 |     | <span class='neutral'>  assembly {</span>
 25 |     | <span class='neutral'>    result := eq(value0, value1)</span>
 26 |     | <span class='neutral'>  }</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>function notEqual(</span>
 30 |     | <span class='neutral'>  X74 value0,</span>
 31 |     | <span class='neutral'>  X74 value1</span>
 32 |     | <span class='neutral'>) pure returns (</span>
 33 |     | <span class='neutral'>  bool result</span>
 34 |     | <span class='neutral'>) {</span>
 35 |     | <span class='neutral'>  return !(value0 == value1);</span>
 36 |     | <span class='neutral'>}</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
 39 |     | <span class='neutral'>function add(</span>
 40 |     | <span class='neutral'>  X74 value0,</span>
 41 |     | <span class='neutral'>  X74 value1</span>
 42 |     | <span class='neutral'>) pure returns (</span>
 43 |     | <span class='neutral'>  X74 result</span>
 44 |     | <span class='neutral'>) {</span>
 45 |     | <span class='neutral'>  assembly {</span>
 46 |     | <span class='neutral'>    result := add(value0, value1)</span>
 47 |     | <span class='neutral'>  }</span>
 48 |     | <span class='neutral'>}</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>// Overflow/underflow should be avoided externally.</span>
 51 |     | <span class='neutral'>function sub(</span>
 52 |     | <span class='neutral'>  X74 value0,</span>
 53 |     | <span class='neutral'>  X74 value1</span>
 54 |     | <span class='neutral'>) pure returns (</span>
 55 |     | <span class='neutral'>  X74 result</span>
 56 |     | <span class='neutral'>) {</span>
 57 |     | <span class='neutral'>  assembly {</span>
 58 |     | <span class='neutral'>    result := sub(value0, value1)</span>
 59 |     | <span class='neutral'>  }</span>
 60 |     | <span class='neutral'>}</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='unexecuted'>library X74Library {</span>
 63 |     | <span class='neutral'>  // Converts type &#39;X74&#39; to &#39;X216&#39;.</span>
 64 |     | <span class='neutral'>  // Overflow should be avoided externally.</span>
 65 |     | <span class='neutral'>  function toX216(</span>
 66 |     | <span class='neutral'>    X74 value</span>
 67 |     | <span class='neutral'>  ) internal pure returns (</span>
 68 |     | <span class='neutral'>    X216 result</span>
 69 |     | <span class='neutral'>  ) {</span>
 70 |     | <span class='neutral'>    assembly {</span>
 71 |     | <span class='neutral'>      // Multiplication is safe because overflow is avoided externally.</span>
 72 |     | <span class='neutral'>      result := mul(shl(142, 1), value)</span>
 73 |     | <span class='neutral'>    }</span>
 74 |     | <span class='neutral'>  }</span>
 75 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/training/echidna/CalldataTest.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.28;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {CalldataWrapper} from &quot;../contracts/helpers/CalldataWrapper.sol&quot;;</span>
   5 |     | <span class='neutral'>import { _endOfStaticParams_, getFreeMemoryPointer } from &quot;../contracts/utilities/Memory.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/// @title Wrapper that exposes raw calldata reading via low-level call</span>
   8 | *   | <span class='executed'>contract CalldataTestWrapper {</span>
   9 |     | <span class='unexecuted'>    CalldataWrapper public target;</span>
  10 |     | <span class='neutral'>    </span>
  11 | *   | <span class='executed'>    constructor() { target = new CalldataWrapper(); }</span>
  12 |     | <span class='neutral'>    </span>
  13 |     | <span class='neutral'>    /// @dev Forwards calldata to internal readModifyPositionInput</span>
  14 |     | <span class='neutral'>    /// Uses assembly to avoid ABI decoding</span>
  15 |     | <span class='unexecuted'>    function forward() external {</span>
  16 |     | <span class='unexecuted'>        assembly {</span>
  17 |     | <span class='neutral'>            calldatacopy(0, 0, calldatasize())</span>
  18 |     | <span class='neutral'>            // Call readModifyPositionInput directly</span>
  19 |     | <span class='neutral'>            pop(call(gas(), address(), 0, 0, calldatasize(), 0, 0))</span>
  20 |     | <span class='neutral'>        }</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'>    </span>
  23 |     | <span class='neutral'>    /// @dev Alternative: reads calldata offset</span>
  24 |     | <span class='unexecuted'>    function readCalldataOffset() external view returns (uint256 result) {</span>
  25 |     | <span class='unexecuted'>        assembly {</span>
  26 |     | <span class='neutral'>            result := calldataload(0)</span>
  27 |     | <span class='neutral'>        }</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'>}</span>
  30 |     | <span class='neutral'></span>
  31 | *r  | <span class='executed'>contract CalldataTest {</span>
  32 | *   | <span class='executed'>    CalldataTestWrapper public wrapper;</span>
  33 |     | <span class='unexecuted'>    uint256 constant HOOK_DATA_PLACEMENT = _endOfStaticParams_ + 32;</span>
  34 | *   | <span class='executed'>    uint256 constant MAX_HOOK_SIZE = 256;</span>
  35 |     | <span class='neutral'>    </span>
  36 | *   | <span class='executed'>    constructor() { wrapper = new CalldataTestWrapper(); }</span>
  37 |     | <span class='neutral'>    </span>
  38 | *   | <span class='executed'>    function testFuzzed(uint256 seed, uint16 hookOffset, uint16 rawHookSize) public {</span>
  39 | *   | <span class='executed'>        hookOffset = hookOffset % 256;</span>
  40 | *   | <span class='executed'>        uint16 hookSize = uint16((rawHookSize % MAX_HOOK_SIZE) + 1);</span>
  41 |     | <span class='neutral'>        </span>
  42 | *   | <span class='executed'>        uint256 totalSize = 260 + hookOffset + hookSize;</span>
  43 | *   | <span class='executed'>        bytes memory cd = new bytes(totalSize);</span>
  44 |     | <span class='neutral'>        </span>
  45 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; totalSize; i++) {</span>
  46 | *   | <span class='executed'>            cd[i] = bytes1(uint8(seed &gt;&gt; (8 * (i % 32))));</span>
  47 |     | <span class='neutral'>        }</span>
  48 |     | <span class='neutral'>        </span>
  49 |     | <span class='neutral'>        // Pool ID at bytes 0-31 (with hook flag set)</span>
  50 | *   | <span class='executed'>        uint256 pid = uint256(keccak256(abi.encode(seed)));</span>
  51 | *   | <span class='executed'>        pid = (pid &amp; ~(uint256(0xFF) &lt;&lt; 180)) | (uint256(100) &lt;&lt; 180);</span>
  52 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; 32; i++) { cd[i] = bytes1(uint8(pid &gt;&gt; (8 * (31 - i)))); }</span>
  53 |     | <span class='neutral'>        </span>
  54 |     | <span class='neutral'>        // Token0 data at bytes 32-63</span>
  55 | *   | <span class='executed'>        cd[32] = 0xFF; cd[63] = 0x01;</span>
  56 |     | <span class='neutral'>        // Token1 data at bytes 64-95</span>
  57 | *   | <span class='executed'>        cd[64] = 0xFF; cd[95] = 0x02;</span>
  58 |     | <span class='neutral'>        // Pool tick spacing at byte 96</span>
  59 | *   | <span class='executed'>        cd[96] = 0x01;</span>
  60 |     | <span class='neutral'>        </span>
  61 |     | <span class='neutral'>        // Hook data pointer at bytes 128-159</span>
  62 | *   | <span class='executed'>        uint256 hookPtr = 160 + hookOffset;</span>
  63 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; 32; i++) { cd[128 + i] = bytes1(uint8(hookPtr &gt;&gt; (8 * (31 - i)))); }</span>
  64 |     | <span class='neutral'>        </span>
  65 |     | <span class='neutral'>        // Hook data size at hookPtr</span>
  66 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; 32; i++) { cd[hookPtr + i] = bytes1(uint8(hookSize &gt;&gt; (8 * (31 - i)))); }</span>
  67 |     | <span class='neutral'>        </span>
  68 |     | <span class='neutral'>        // Hook data content</span>
  69 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; hookSize; i++) { cd[hookPtr + 32 + i] = bytes1(uint8(seed &gt;&gt; (8 * ((i + 7) % 32)))); }</span>
  70 |     | <span class='neutral'>        </span>
  71 |     | <span class='neutral'>        // Call with raw calldata</span>
  72 | *   | <span class='executed'>        (bool ok, ) = address(wrapper).call(cd);</span>
  73 |     | <span class='neutral'>        </span>
  74 | *   | <span class='executed'>        if (ok) {</span>
  75 |     | <span class='unexecuted'>            uint256 fmp = getFreeMemoryPointer();</span>
  76 |     | <span class='unexecuted'>            assert(fmp == HOOK_DATA_PLACEMENT + hookSize);</span>
  77 |     | <span class='neutral'>        }</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'>    </span>
  80 | *   | <span class='executed'>    function testVaryingHookSize(uint256 seed, uint16 rawSize) public {</span>
  81 | *   | <span class='executed'>        uint16 size = uint16((rawSize % MAX_HOOK_SIZE) + 1);</span>
  82 |     | <span class='neutral'>        </span>
  83 | *   | <span class='executed'>        bytes memory cd = new bytes(260 + size);</span>
  84 |     | <span class='neutral'>        </span>
  85 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; cd.length; i++) {</span>
  86 | *   | <span class='executed'>            cd[i] = bytes1(uint8(seed &gt;&gt; (8 * (i % 32))));</span>
  87 |     | <span class='neutral'>        }</span>
  88 |     | <span class='neutral'>        </span>
  89 | *   | <span class='executed'>        uint256 pid = uint256(keccak256(abi.encode(seed)));</span>
  90 | *   | <span class='executed'>        pid = (pid &amp; ~(uint256(0xFF) &lt;&lt; 180)) | (uint256(100) &lt;&lt; 180);</span>
  91 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; 32; i++) { cd[i] = bytes1(uint8(pid &gt;&gt; (8 * (31 - i)))); }</span>
  92 |     | <span class='neutral'>        </span>
  93 | *   | <span class='executed'>        cd[32] = 0xFF; cd[63] = 0x01;</span>
  94 | *   | <span class='executed'>        cd[64] = 0xFF; cd[95] = 0x02;</span>
  95 | *   | <span class='executed'>        cd[96] = 0x01;</span>
  96 |     | <span class='neutral'>        </span>
  97 |     | <span class='neutral'>        // Hook pointer at 160</span>
  98 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; 32; i++) { cd[128 + i] = bytes1(uint8(160 &gt;&gt; (8 * (31 - i)))); }</span>
  99 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; 32; i++) { cd[160 + i] = bytes1(uint8(size &gt;&gt; (8 * (31 - i)))); }</span>
 100 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; size; i++) { cd[192 + i] = bytes1(uint8(seed &gt;&gt; (8 * ((i + 11) % 32)))); }</span>
 101 |     | <span class='neutral'>        </span>
 102 | *   | <span class='executed'>        (bool ok, ) = address(wrapper).call(cd);</span>
 103 |     | <span class='neutral'>        </span>
 104 | *   | <span class='executed'>        if (ok) {</span>
 105 |     | <span class='unexecuted'>            uint256 fmp = getFreeMemoryPointer();</span>
 106 |     | <span class='unexecuted'>            assert(fmp == HOOK_DATA_PLACEMENT + size);</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'>    </span>
 110 | *   | <span class='executed'>    function testArbitraryHookPosition(uint256 seed, uint16 position) public {</span>
 111 | *   | <span class='executed'>        position = position % 512;</span>
 112 |     | <span class='neutral'>        </span>
 113 | *   | <span class='executed'>        uint256 hookPtr = 160 + position;</span>
 114 | *   | <span class='executed'>        bytes memory cd = new bytes(260 + position + 256);</span>
 115 |     | <span class='neutral'>        </span>
 116 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; cd.length; i++) {</span>
 117 | *   | <span class='executed'>            cd[i] = bytes1(uint8(seed &gt;&gt; (8 * (i % 32))));</span>
 118 |     | <span class='neutral'>        }</span>
 119 |     | <span class='neutral'>        </span>
 120 | *   | <span class='executed'>        uint256 pid = uint256(keccak256(abi.encode(seed)));</span>
 121 | *   | <span class='executed'>        pid = (pid &amp; ~(uint256(0xFF) &lt;&lt; 180)) | (uint256(100) &lt;&lt; 180);</span>
 122 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; 32; i++) { cd[i] = bytes1(uint8(pid &gt;&gt; (8 * (31 - i)))); }</span>
 123 |     | <span class='neutral'>        </span>
 124 | *   | <span class='executed'>        cd[32] = 0xFF; cd[63] = 0x01;</span>
 125 | *   | <span class='executed'>        cd[64] = 0xFF; cd[95] = 0x02;</span>
 126 | *   | <span class='executed'>        cd[96] = 0x01;</span>
 127 |     | <span class='neutral'>        </span>
 128 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; 32; i++) { cd[128 + i] = bytes1(uint8(hookPtr &gt;&gt; (8 * (31 - i)))); }</span>
 129 |     | <span class='neutral'>        </span>
 130 | *   | <span class='executed'>        uint16 hLen = 64;</span>
 131 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; 32; i++) { cd[hookPtr + i] = bytes1(uint8(hLen &gt;&gt; (8 * (31 - i)))); }</span>
 132 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; hLen; i++) { cd[hookPtr + 32 + i] = bytes1(uint8(seed &gt;&gt; (8 * ((i + 3) % 32)))); }</span>
 133 |     | <span class='neutral'>        </span>
 134 | *   | <span class='executed'>        (bool ok, ) = address(wrapper).call(cd);</span>
 135 |     | <span class='neutral'>        </span>
 136 | *   | <span class='executed'>        if (ok) {</span>
 137 |     | <span class='unexecuted'>            uint256 fmp = getFreeMemoryPointer();</span>
 138 |     | <span class='unexecuted'>            assert(fmp == HOOK_DATA_PLACEMENT + hLen);</span>
 139 |     | <span class='neutral'>        }</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'>}</span>
 142 |     | <span class='neutral'></span>

</code>
<br />


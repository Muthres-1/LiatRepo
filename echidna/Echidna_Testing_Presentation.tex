\documentclass[12pt, aspectratio=169]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usetheme{Madrid}

% Define custom colors FIRST
\definecolor{pass}{rgb}{0.2, 0.7, 0.2}
\definecolor{fail}{rgb}{0.8, 0.2, 0.2}
\definecolor{warn}{rgb}{0.8, 0.6, 0.0}
\definecolor{codebg}{rgb}{0.95, 0.95, 0.95}
\definecolor{keyword}{rgb}{0.13, 0.55, 0.13}
\definecolor{comment}{rgb}{0.4, 0.4, 0.4}
\definecolor{string}{rgb}{0.58, 0, 0.82}

% Define YAML language for listings
\lstdefinelanguage{yaml}{
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{codebg},
    frame=single,
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    tabsize=2,
    breaklines=true,
    keywords={true,false,null,y,yes,n,no},
    keywordstyle=\color{blue},
    stringstyle=\color{string},
    commentstyle=\color{comment},
    moredelim=[l]{:},
    moredelim=[l]{-},
    sensitive=false,
    showstringspaces=false,
}

% Define Solidity language for listings
\lstdefinelanguage{solidity}{
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{codebg},
    frame=single,
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    tabsize=2,
    breaklines=true,
    keywords={pragma,contract,function,public,private,internal,external,view,pure,constant,returns,using,for,import,library,using,enum,struct,event,modifier,assert,require,revert,throw,if,else,while,for,do,case,break,continue,return,sizeof,typeof,true,false,null,this,super,new,delete},
    keywordstyle=\color{keyword}\bfseries,
    commentstyle=\color{comment}\textit,
    stringstyle=\color{string},
    moredelim=[l][\color{string}]{\"},
    moredelim=[l][\color{string}]{'},
    sensitive=true,
    showstringspaces=false,
}

\title{Echidna Smart Contract Fuzzing}
\subtitle{PriceTest and CalldataTest Analysis}
\author{Muthres Gurjar}
\institute{IIT JAMMU}
\date{February 2025}

\begin{document}

\begin{frame}
    \titlepage
\end{frame}

\begin{frame}{Table of Contents}
    \tableofcontents
\end{frame}

%=================================================================================
% SECTION 1: INTRODUCTION
%=================================================================================
\section{Introduction}

\begin{frame}{What is Echidna?}
    \begin{itemize}
        \item \textbf{Echidna} is a property-based fuzzing framework for Ethereum smart contracts
        \item Developed by Trail of Bits
        \item Generates random inputs to test contract properties
        \item Uses assertion-based testing to find vulnerabilities
        \item Current version: \textbf{Echidna 2.2.7}
    \end{itemize}
    
    \begin{block}{Key Features}
        \begin{itemize}
            \item Automated test generation
            \item Coverage-guided fuzzing
            \item Assertion testing mode
            \item Corpus collection and minimization
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Testing Objectives}
    \begin{columns}
        \column{0.5\textwidth}
        \begin{block}{PriceTest}
            \begin{itemize}
                \item Test Price.sol library functions
                \item Verify price storage operations
                \item Check memory integrity
                \item Validate pointer operations
            \end{itemize}
        \end{block}
        
        \column{0.5\textwidth}
        \begin{block}{CalldataTest}
            \begin{itemize}
                \item Test Calldata.sol utilities
                \item Verify hook data handling
                \item Check memory pointer management
                \item Test random offsets and sizes
            \end{itemize}
        \end{block}
    \end{columns}
\end{frame}

%=================================================================================
% SECTION 1B: PRICE LIBRARY FUNCTION DESCRIPTIONS
%=================================================================================
\section{PriceLibrary Function Descriptions}

\begin{frame}{PriceLibrary - Core Functions Overview}
    \begin{center}
        \begin{tabular}{|l|p{0.6\textwidth}|}
            \hline
            \textbf{Function} & \textbf{Description} \\
            \hline
            \texttt{storePrice(pointer, log, sqrt, sqrtInv)} & Stores price with 4 components (log, sqrt, sqrtInv) at memory location \\
            \hline
            \texttt{storePrice(pointer, log)} & Calculates sqrt/sqrtInv from log, then stores price \\
            \hline
            \texttt{storePrice(pointer, height, log, sqrt, sqrtInv)} & Stores price with additional height field (64 bytes total) \\
            \hline
            \texttt{height(pointer)} & Extracts 16-bit height value from price at pointer-2 \\
            \hline
            \texttt{log(pointer)} & Extracts 64-bit logarithm value from price at pointer \\
            \hline
            \texttt{sqrt(pointer, inverse)} & Extracts 216-bit sqrt or sqrtInverse at pointer+8 or pointer+35 \\
            \hline
            \texttt{copyPrice(ptr0, ptr1)} & Copies 62 bytes from src to dst pointer \\
            \hline
            \texttt{copyPriceWithHeight(ptr0, ptr1)} & Copies 64 bytes including height field \\
            \hline
            \texttt{segment(pointer)} & Extracts b0, b1, c0, c1 from consecutive prices \\
            \hline
        \end{tabular}
    \end{center}
\end{frame}

\begin{frame}{storePrice Functions - Detailed}
    \begin{block}{storePrice(pointer, logPrice, sqrtPrice, sqrtInversePrice)}
        \textbf{Purpose:} Stores all price components at given memory pointer with 62-byte layout.
        \begin{itemize}
            \item Reads preceding slot at \texttt{pointer-32} for restoration
            \item Stores \texttt{sqrtInversePrice} at \texttt{pointer+30} (216 bits)
            \item Stores \texttt{sqrtPrice} at \texttt{pointer+3} (216 bits)
            \item Stores \texttt{logPrice} at \texttt{pointer-24} (64 bits)
            \item Restores preceding slot to prevent memory corruption
        \end{itemize}
        \textbf{Memory Layout:}
        \begin{center}
            \texttt{[8 bytes: logPrice][27 bytes: sqrtPrice][27 bytes: sqrtInversePrice]}
        \end{center}
    \end{block}
    
    \begin{block}{storePrice(pointer, logPrice) - Overload 2}
        \textbf{Purpose:} Single-parameter version that calculates sqrt values internally.
        \begin{itemize}
            \item Calls \texttt{logPrice.exp()} to compute sqrt and sqrtInverse
            \item Delegates to 4-parameter storePrice
            \item Requires: $0 < logPrice < 2^{64}$
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{storePrice with Height - Detailed}
    \begin{block}{storePrice(pointer, heightPrice, logPrice, sqrtPrice, sqrtInversePrice)}
        \textbf{Purpose:} Extended storage for prices with height metadata (64 bytes total).
        \begin{itemize}
            \item Backs up slot at \texttt{pointer-34} (2 bytes before height location)
            \item Stores \texttt{heightPrice} at \texttt{pointer-32} (16 bits in MSB position)
            \item Stores \texttt{sqrtInversePrice} at \texttt{pointer+30}
            \item Stores \texttt{sqrtPrice} at \texttt{pointer+3}
            \item Stores \texttt{logPrice} at \texttt{pointer-24}
            \item Restores preceding slot at \texttt{pointer-34}
        \end{itemize}
        \textbf{Memory Layout:}
        \begin{center}
            \texttt{[2 bytes: height][8 bytes: log][27 bytes: sqrt][27 bytes: sqrtInv]}
        \end{center}
    \end{block}
    
    \begin{alertblock}{Memory Safety Issue Discovered}
        This function has a bug: writes 32 bytes at \texttt{pointer-32} but only backs up from \texttt{pointer-34}. Last 2 bytes never restored.
    \end{alertblock}
\end{frame}

\begin{frame}{Reader Functions - Detailed}
    \begin{block}{height(pointer)}
        \textbf{Purpose:} Extracts 16-bit height from price memory.
        \begin{itemize}
            \item Reads from \texttt{sub(pointer, 2)} - slot containing height
            \item Shifts right by 240 bits to extract MSB 16 bits
            \item Returns \texttt{X15} type
        \end{itemize}
    \end{block}
    
    \begin{block}{log(pointer)}
        \textbf{Purpose:} Extracts 64-bit logarithm from price memory.
        \begin{itemize}
            \item Reads from \texttt{pointer} - slot containing logPrice
            \item Shifts right by 192 bits to extract MSB 64 bits
            \item Returns \texttt{X59} type
        \end{itemize}
    \end{block}
    
    \begin{block}{sqrt(pointer, inverse)}
        \textbf{Purpose:} Extracts 216-bit sqrt or sqrtInverse from price memory.
        \begin{itemize}
            \item If \texttt{inverse=true}: reads at \texttt{pointer+35}, shifts right 40 bits
            \item If \texttt{inverse=false}: reads at \texttt{pointer+8}, shifts right 40 bits
            \item Returns \texttt{X216} type
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Copy and Segment Functions - Detailed}
    \begin{block}{copyPrice(pointer0, pointer1)}
        \textbf{Purpose:} Copies price (62 bytes) from source to destination.
        \begin{itemize}
            \item Uses \texttt{mcopy(pointer0, pointer1, 62)}
            \item Copies: logPrice (8) + sqrtPrice (27) + sqrtInversePrice (27)
        \end{itemize}
    \end{block}
    
    \begin{block}{copyPriceWithHeight(pointer0, pointer1)}
        \textbf{Purpose:} Copies price with height (64 bytes) from source to destination.
        \begin{itemize}
            \item Uses \texttt{mcopy(pointer0-2, pointer1-2, 64)}
            \item Copies: height (2) + logPrice (8) + sqrtPrice (27) + sqrtInversePrice (27)
        \end{itemize}
    \end{block}
    
    \begin{block}{segment(pointer)}
        \textbf{Purpose:} Extracts pair of prices with heights for curve interpolation.
        \begin{itemize}
            \item Reads first price at \texttt{pointer}: \texttt{c0=height}, \texttt{b0=log}
            \item Advances 64 bytes to second price
            \item Reads second price: \texttt{c1=height}, \texttt{b1=log}
            \item Returns: \texttt{(b0, b1, c0, c1)}
        \end{itemize}
    \end{block}
\end{frame}

%=================================================================================
% SECTION 1C: PRICETEST FUNCTION DESCRIPTIONS
%=================================================================================
\section{PriceTest Function Descriptions}

\begin{frame}{PriceTest - Test Functions Overview}
    \begin{center}
        \begin{tabular}{|l|p{0.6\textwidth}|}
            \hline
            \textbf{Test Function} & \textbf{Description} \\
            \hline
            \texttt{test\_storePrice0(seed)} & Tests 2-parameter storePrice with computed sqrt values \\
            \hline
            \texttt{test\_storePrice1(seedLog, seedSqrt, seedSqrtInv)} & Tests 4-parameter storePrice with explicit values \\
            \hline
            \texttt{test\_storePrice2(seedHeight, seedLog, seedSqrt, seedSqrtInv)} & Tests storePrice with height (5 parameters) \\
            \hline
            \texttt{test\_height(seed)} & Tests height extraction from pointer-2 location \\
            \hline
            \texttt{test\_log(seed)} & Tests log extraction from pointer location \\
            \hline
            \texttt{test\_sqrt(seed, inverse)} & Tests sqrt/sqrtInverse extraction \\
            \hline
            \texttt{test\_copyPrice(seedLog, seedSqrt, seedSqrtInv)} & Tests 62-byte copy between pointers \\
            \hline
            \texttt{test\_copyPriceWithHeight(...)} & Tests 64-byte copy with height field \\
            \hline
            \texttt{test\_segment(seedC0, seedC1, seedB0, seedB1)} & Tests segment extraction of price pairs \\
            \hline
            \texttt{test\_memory\_not\_corrupted(...)} & Tests surrounding memory is not corrupted \\
            \hline
            \texttt{test\_random\_pointer\_location(...)} & Tests with random pointer alignments \\
            \hline
        \end{tabular}
    \end{center}
\end{frame}

\begin{frame}{PriceTest - Store Price Tests Detail}
    \begin{block}{test\_storePrice0(seed)}
        \textbf{Purpose:} Tests storePrice with auto-computed sqrt values.
        \begin{itemize}
            \item Generates random logPrice (64-bit, range 1 to $2^{64}-1$)
            \item Calls \texttt{storePrice(logPrice)} - computes sqrt internally
            \item Verifies round-trip: read back log, sqrt, sqrtInverse
            \item Asserts: logResult == logPrice, sqrt > 0, sqrt < 1
        \end{itemize}
    \end{block}
    
    \begin{block}{test\_storePrice1(seedLog, seedSqrt, seedSqrtInv)}
        \textbf{Purpose:} Tests explicit price storage with given values.
        \begin{itemize}
            \item Generates random logPrice, sqrtPrice, sqrtInversePrice
            \item Ensures sqrt values are within valid range (< oneX216)
            \item Calls \texttt{storePrice(log, sqrt, sqrtInv)}
            \item Verifies all values match after storage
        \end{itemize}
    \end{block}
    
    \begin{block}{test\_storePrice2(seedHeight, ...)}
        \textbf{Purpose:} Tests extended price storage with height.
        \begin{itemize}
            \item Generates random height (16-bit, 0 to oneX15)
            \item Generates log, sqrt, sqrtInverse
            \item Calls \texttt{storePrice(height, log, sqrt, sqrtInv)}
            \item Verifies height is stored correctly at pointer-2
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{PriceTest - Reader Tests Detail}
    \begin{block}{test\_height(seed)}
        \textbf{Purpose:} Tests height extraction from memory.
        \begin{itemize}
            \item Generates random 16-bit height value
            \item Writes to \texttt{pointer-32} with SHL(240, height)
            \item Reads via \texttt{height()} from \texttt{pointer-2}
            \item Asserts: extracted height == original height
        \end{itemize}
    \end{block}
    
    \begin{block}{test\_log(seed)}
        \textbf{Purpose:} Tests log extraction from memory.
        \begin{itemize}
            \item Generates random 64-bit logPrice
            \item Writes to \texttt{pointer} with SHL(192, logPrice)
            \item Reads via \texttt{log()}
            \item Asserts: extracted log == original logPrice
        \end{itemize}
    \end{block}
    
    \begin{block}{test\_sqrt(seed, inverse)}
        \textbf{Purpose:} Tests sqrt/sqrtInverse extraction from memory.
        \begin{itemize}
            \item Generates random 216-bit sqrt value
            \item Writes to appropriate offset (pointer+8 or pointer+35)
            \item Reads via \texttt{sqrt(inverse)}
            \item Asserts: extracted sqrt matches original
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{PriceTest - Copy and Segment Tests Detail}
    \begin{block}{test\_copyPrice(seedLog, seedSqrt, seedSqrtInv)}
        \textbf{Purpose:} Tests copying price between memory locations.
        \begin{itemize}
            \item Creates source pointer (pointer1) with price data
            \item Creates destination pointer (pointer0)
            \item Calls \texttt{copyPrice(pointer0, pointer1)}
            \item Verifies all values copied correctly
        \end{itemize}
    \end{block}
    
    \begin{block}{test\_copyPriceWithHeight(seedHeight, ...)}
        \textbf{Purpose:} Tests copying price with height metadata.
        \begin{itemize}
            \item Stores height at source pointer
            \item Stores full price at source
            \item Copies with \texttt{copyPriceWithHeight()}
            \item Verifies height + price copied correctly
        \end{itemize}
    \end{block}
    
    \begin{block}{test\_segment(seedC0, seedC1, seedB0, seedB1)}
        \textbf{Purpose:} Tests extracting consecutive prices from curve segment.
        \begin{itemize}
            \item Stores first price (c0, b0) at segmentPointer
            \item Stores second price (c1, b1) at segmentPointer+64
            \item Calls \texttt{segment()} to extract all 4 values
            \item Asserts: b0, b1, c0, c1 all match originals
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{PriceTest - Memory Tests Detail}
    \begin{block}{test\_memory\_not\_corrupted(seedLog, seedSqrt, seedSqrtInv)}
        \textbf{Purpose:} Verifies storePrice doesn't corrupt surrounding memory.
        \begin{itemize}
            \item Fills memory before/after pointer with known patterns
            \item Stores price at pointer
            \item Checks patterns are unchanged
            \item Asserts: no memory corruption detected
        \end{itemize}
    \end{block}
    
    \begin{block}{test\_random\_pointer\_location(seed)}
        \textbf{Purpose:} Tests with various pointer alignments.
        \begin{itemize}
            \item Generates random pointer values
            \item Tests storePrice at different memory offsets
            \item Verifies behavior is consistent
            \item Checks edge cases (boundary alignments)
        \end{itemize}
    \end{block}
    
    \begin{block}{test\_memory\_not\_corrupted\_with\_height(seedHeight, ...)}
        \textbf{Purpose:} Tests memory safety with height variant.
        \begin{itemize}
            \item Same as memory test but with height variant
            \item THIS TEST FAILED - discovered real bug
            \item Bug: height storage corrupts preceding memory
        \end{itemize}
    \end{block}
\end{frame}

%=================================================================================
% SECTION 1D: PRICETESTWITHBUG FUNCTION DESCRIPTIONS
%=================================================================================
\section{PriceTestWithBug Function Descriptions}

\begin{frame}{PriceTestWithBug - Overview}
    \begin{alertblock}{Purpose}
        Contains deliberately injected bugs to verify Echidna fuzzing effectiveness.
    \end{alertblock}
    
    \begin{center}
        \begin{tabular}{|l|p{0.6\textwidth}|}
            \hline
            \textbf{Test Function} & \textbf{Description} \\
            \hline
            \texttt{test\_bug\_injected\_wrong\_offset(...)} & Wrong offset in storePrice (pointer+31 vs pointer+30) \\
            \hline
            \texttt{test\_bug\_injected\_height\_corruption(...)} & Height stored at wrong memory location \\
            \hline
            \texttt{test\_bug\_injected\_memory\_corruption(...)} & Surrounding memory not properly preserved \\
            \hline
            \texttt{test\_bug\_injected\_copy\_corruption(...)} & Copy operation corrupts source/destination memory \\
            \hline
        \end{tabular}
    \end{center}
\end{frame}

\begin{frame}{PriceTestWithBug - Detailed Descriptions}
    \begin{block}{test\_bug\_injected\_wrong\_offset(seedLog, seedSqrt, seedSqrtInv)}
        \textbf{Purpose:} Tests for offset errors in sqrtInversePrice storage.
        \begin{itemize}
            \item Stores price with correct values
            \item Reads back and compares
            \item Bug location: \texttt{pointer+31} instead of \texttt{pointer+30}
            \item Echidna should detect mismatch in sqrtInverse readback
        \end{itemize}
    \end{block}
    
    \begin{block}{test\_bug\_injected\_height\_corruption(seedHeight, ...)}
        \textbf{Purpose:} Tests for height storage corruption.
        \begin{itemize}
            \item Stores price with height
            \item Reads back height via \texttt{height()}
            \item Bug: height written at wrong offset
            \item Should fail: extracted height != stored height
        \end{itemize}
    \end{block}
    
    \begin{block}{test\_bug\_injected\_memory\_corruption(seedLog, seedSqrt, seedSqrtInv)}
        \textbf{Purpose:} Tests memory safety around storePrice.
        \begin{itemize}
            \item Fills surrounding memory with \texttt{0xDEADBEEF...}
            \item Calls storePrice
            \item Checks patterns unchanged after call
            \item Bug: writes may corrupt adjacent slots
        \end{itemize}
    \end{block}
    
    \begin{block}{test\_bug\_injected\_copy\_corruption(seedLog, seedSqrt, seedSqrtInv)}
        \textbf{Purpose:} Tests copyPrice for memory corruption.
        \begin{itemize}
            \item Stores price at source
            \item Fills memory around both pointers
            \item Copies to destination
            \item Bug: copy corrupts source or destination memory
        \end{itemize}
    \end{block}
\end{frame}

%=================================================================================
% SECTION 2: SETUP ENVIRONMENT
%=================================================================================
\section{Setup Environment}

\begin{frame}{Prerequisites - Windows + WSL}
    \begin{alertblock}{Step 1: Install WSL}
        Open PowerShell as Administrator and run:
        \begin{center}
            \texttt{wsl --install}
        \end{center}
        This installs Ubuntu Linux subsystem on Windows.
    \end{alertblock}
    
    \begin{block}{Step 2: Install Docker Desktop}
        \begin{itemize}
            \item Download from: \url{https://www.docker.com/products/docker-desktop/}
            \item Install and restart computer
            \item Enable WSL integration: Docker Desktop Settings Resources WSL Integration
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Docker Container Setup}
    \begin{block}{Pull and Run Container}
        \begin{enumerate}
            \item Navigate to project in WSL terminal:
                \begin{center}
                    \texttt{cd /mnt/e/VsCode/BlockChain/Assessments/Liat/q1/core}
                \end{center}
            \item Open Docker Desktop first
            \item Pull the eth-security-toolbox:
                \begin{center}
                    \texttt{docker pull trailofbits/eth-security-toolbox}
                \end{center}
            \item Run container with volume mounting:
                \begin{center}
                    \texttt{docker run -it -v "\$(pwd)":/home/training trailofbits/eth-security-toolbox}
                \end{center}
        \end{enumerate}
    \end{block}
\end{frame}

\begin{frame}{Solidity Compiler Setup}
    \begin{block}{Install Solidity 0.8.28}
        \begin{center}
            \begin{tabular}{l}
                \texttt{cd /tmp} \\[2mm]
                \texttt{wget https://github.com/ethereum/solidity/releases/download/v0.8.28/solc-static-linux} \\[2mm]
                \texttt{chmod +x solc-static-linux} \\[2mm]
                \texttt{cp solc-static-linux /root/.crytic/bin/solc} \\[2mm]
                \texttt{/root/.crytic/bin/solc --version}
            \end{tabular}
        \end{center}
    \end{block}
    
    \begin{alertblock}{Why 0.8.28?}
        Contracts require Pragma solidity \^{}0.8.28. Solc-select had network issues.
    \end{alertblock}
\end{frame}

%=================================================================================
% SECTION 3: PRICE LIBRARY AND TESTING
%=================================================================================
\section{Price Library Testing}

\begin{frame}{Price.sol - Source Code}
    \begin{block}{Source File}
        \url{https://github.com/Muthres-1/LiatRepo/contracts/utilities/Price.sol}
    \end{block}
    
    \begin{block}{Key Functions}
        \begin{itemize}
            \item storePrice (3 overloads)
            \item height
            \item log
            \item sqrt
            \item copyPrice
            \item copyPriceWithHeight
        \end{itemize}
    \end{block}
PriceLibrary - Low-level memory price operations
\end{frame}

\begin{frame}{PriceTest.sol - Test Contract}
    \begin{block}{Source File}
        \url{https://github.com/Muthres-1/LiatRepo/echidna/PriceTest.sol}
    \end{block}
    
    \begin{block}{Purpose}
    \begin{itemize}
        \item Echidna tests for Price.sol library with randomized inputs
        \item \textbf{Test Functions}
           \begin{itemize}
            \item test\_storePrice0, test\_storePrice1, test\_storePrice2
            \item test\_height, test\_log, test\_sqrt
            \item test\_copyPrice, test\_copyPriceWithHeight
            \item test\_segment
            \item test\_memory\_not\_corrupted
            \item test\_random\_pointer\_location
\end{itemize}
    \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{PriceTestWithBug.sol - Bug Injection Tests}
    \begin{block}{Source File}
        \url{https://github.com/Muthres-1/LiatRepo/echidna/PriceTestWithBug.sol}
    \end{block}
    
    \begin{block}{Purpose}
        Test contract with intentionally injected bugs to verify fuzz harness
    \end{block}
    
    \begin{block}{Injected Bug Tests}
        \begin{itemize}
            \item test\_bug\_injected\_memory\_corruption
            \item test\_bug\_injected\_height\_corruption
            \item test\_bug\_injected\_wrong\_offset
            \item test\_bug\_injected\_copy\_corruption
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{PriceTest Configuration}
    \lstset{
        language=yaml,
        backgroundcolor=\color{codebg},
        basicstyle=\ttfamily\small,
        keywordstyle=\color{blue},
        commentstyle=\color{comment},
        stringstyle=\color{string},
        frame=single,
        numbers=left,
        numberstyle=\tiny,
        numbersep=5pt,
        tabsize=2,
        breaklines=true,
        caption={echidna.config.Price.yml},
        captionpos=b
    }
    \begin{center}
        \begin{tabular}{p{0.9\textwidth}}
            corpusDir: './corpus/' \\
            testMode: assertion \\
            coverage: true \\
            solcArgs: '--base-path . --include-path lib --evm-version cancun --optimize-runs 200' \\
            testLimit: 100000 \\
            shrinkLimit: 10000 \\
        \end{tabular}
    \end{center}
\end{frame}

%=================================================================================
% SECTION 4: PRICE TEST RESULTS
%=================================================================================
\section{PriceTest Results}

\begin{frame}{PriceTest Execution Summary}
    \begin{block}{Command}
        \begin{center}
            \texttt{/usr/local/bin/echidna echidna/PriceTest.sol --contract PriceTest --config echidna/echidna.config.Price.yml}
        \end{center}
    \end{block}
    
    \begin{columns}
        \column{0.5\textwidth}
        \begin{block}{Statistics}
            \begin{itemize}
                \item Compilation: 1.2s
                \item Slither: 3.28s (warning)
                \item Unique instructions: 3957
                \item Corpus size: 11
                \item Total calls: 100151
                \item Seed: 4114429109246547947
            \end{itemize}
        \end{block}
        
        \column{0.5\textwidth}
        \begin{block}{Test Results}
            \begin{itemize}
                \item test\_storePrice0: PASSING
                \item test\_segment: PASSING
                \item test\_copyPrice: PASSING
                \item test\_memory\_not\_corrupted\_with
                \_height: FAILED
                \item test\_height: FAILED
                \item test\_storePrice2: PASSING
            \end{itemize}
        \end{block}
    \end{columns}
\end{frame}

\begin{frame}{PriceTest Results (All Tests)}
    \begin{center}
        \begin{tabular}{|l|l|}
            \hline
            Test Name & Status \\
            \hline
            test\_storePrice0 & PASSING \\
            \hline
            test\_segment & PASSING \\
            \hline
            test\_copyPrice & PASSING \\
            \hline
            test\_copyPriceWithHeight & PASSING \\
            \hline
            test\_log & PASSING \\
            \hline
            test\_sqrt & PASSING \\
            \hline
            test\_random\_pointer\_location & PASSING \\
            \hline
            test\_storePrice1 & PASSING \\
            \hline
            AssertionFailed(..) & PASSING \\
            \hline
        \end{tabular}
    \end{center}
    
    \begin{alertblock}{Result Summary}
        9 tests passing, 2 tests failed (one test bug, one real memory safety issue).
    \end{alertblock}
\end{frame}

\begin{frame}{Failure 1: test\_height(1)}
    \begin{alertblock}{Test Failed}
        test\_height(uint16): failed!
    \end{alertblock}
    
    \begin{block}{Root Cause: Test Bug, Not Library Bug}
        \begin{columns}
            \column{0.5\textwidth}
            \begin{block}{What Test Does}
            From PriceTest.sol what test\_height() function do : \\
                mstore(sub(pointer, 32), shl(240, height))
            \end{block}
            
            \column{0.5\textwidth}
            \begin{block}{What height() Reads}
                From Price.sol: \\
                value := shr(240, mload(sub(pointer, 2)))
            \end{block}
        \end{columns}
    \end{block}
\end{frame}

\begin{frame}{Failure 1: Fix}
    
    \begin{alertblock}{Mismatch}
        Test writes at: pointer - 32 \\
        Library reads from: pointer - 2 \\
        That's a 30-byte difference! \\
        In test\_height() function it stores data from ptr - 32 to ptr, so those height bytes are stored in top 16 bits while  
        height() function in Price.sol returns from pointer - 2 to ptr only these bottom 16 bits 
    \end{alertblock}
    \begin{block}{Solution: Correct the Test}
        \lstset{
            language=solidity,
            backgroundcolor=\color{codebg},
            basicstyle=\ttfamily\small,
            frame=single,
            numbers=left,
            numberstyle=\tiny,
            numbersep=5pt,
            tabsize=2,
            breaklines=true
        }
        \begin{center}
            \begin{tabular}{p{0.9\textwidth}}
                assembly \{ \\
                // take data from ptr - 34 to ptr - 2 \\
                \ \ \ \ mstore(sub(pointer, 2), shl(240, height)) \\
                // save that data at same ptr - 34 to ptr - 2
                \} \\
            \end{tabular}
        \end{center}
    \end{block}

\end{frame}

\begin{frame}{Failure 2: Memory Corruption Issue}
    \begin{alertblock}{Test Failed}
        test\_memory\_not\_corrupted\_with\_height(0,0,0,0): failed!
    \end{alertblock}
    
    \begin{alertblock}{Root Cause: Real Memory Safety Issue}
        This is NOT a test bug - it is a real memory corruption issue in Price.sol.
    \end{alertblock}
    
    \begin{block}{Why This Happens}
        \begin{itemize}
            \item storePrice(...height...) writes 32 bytes
            \item But height is only 2 bytes
            \item Memory overlap causes corruption
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Failure 2: Memory Corruption Details}
    \begin{block}{The Bug - Line 273 in Price.sol}
        \begin{center}
            mstore(sub(pointer, 32), heightPrice)
        \end{center}
    \end{block}
    
    \begin{block}{The Problem}
        \begin{columns}
            \column{0.5\textwidth}
            \begin{block}{Without Height}
                Pointer saved and restored correctly.
            \end{block}
            
            \column{0.5\textwidth}
            \begin{block}{With Height}
                Writes at pointer - 32 \\
                But only backs up from pointer - 34 \\
                Last 2 bytes never backed up, never restored.
            \end{block}
        \end{columns}
    \end{block}
    
    \begin{alertblock}{Why (0,0,0,0) Triggers It}
        Zero values maximize memory overlap and edge alignment.
    \end{alertblock}
\end{frame}

\begin{frame}{Failure 2: How to Fix}
    \begin{block}{Option 1: Masked Write (Recommended)}
        \lstset{
            language=solidity,
            backgroundcolor=\color{codebg},
            basicstyle=\ttfamily\small,
            frame=single,
            numbers=left,
            numberstyle=\tiny,
            numbersep=5pt,
            tabsize=2,
            breaklines=true
        }
        \begin{center}
            \begin{tabular}{p{0.9\textwidth}}
                let slot := mload(sub(pointer, 32)) \\
                slot := and(slot, not(shl(240, 0xFFFF))) \\
                slot := or(slot, shl(240, heightPrice)) \\
                mstore(sub(pointer, 32), slot) \\
            \end{tabular}
        \end{center}
    \end{block}
    
    \begin{block}{Why This Works}
        \begin{itemize}
            \item Only writes 2 bytes, not 32
            \item Preserves surrounding memory
        \end{itemize}
    \end{block}
\end{frame}

%=================================================================================
% SECTION 5: PRICE TEST WITH BUG RESULTS
%=================================================================================
\section{PriceTestWithBug Results}

\begin{frame}{PriceTestWithBug Execution}
    \begin{block}{Source File}
        \url{https://github.com/Muthres-1/LiatRepo/echidna/PriceTestWithBug.sol}
    \end{block}
    
    \begin{block}{Command}
        \begin{center}
            \texttt{/usr/local/bin/echidna echidna/PriceTestWithBug.sol --contract PriceTestWithBug --config echidna/echidna.simple.yaml}
        \end{center}
    \end{block}
    
    \begin{alertblock}{Expected Behavior}
        At least one injected bug should FAIL, proving the harness works.
    \end{alertblock}
\end{frame}

\begin{frame}{PriceTestWithBug Test Results}
    \begin{center}
        \begin{tabular}{|l|c|l|}
            \hline
            Test Name & Status & Meaning \\
            \hline
            test\_bug\_injected\_memory\_corruption & PASSING & Not triggered yet \\
            \hline
            test\_bug\_injected\_height\_corruption & PASSING & Not triggered yet \\
            \hline
            test\_bug\_injected\_wrong\_offset & PASSING & Not triggered yet \\
            \hline
            test\_bug\_injected\_copy\_corruption & FAILED & Real violation found \\
            \hline
            AssertionFailed(..) & PASSING & Framework assertion \\
            \hline
        \end{tabular}
    \end{center}
    
    \begin{alertblock}{Result Analysis}
        Only 1 of 4 injected bugs was triggered - this is expected in fuzz testing.
    \end{alertblock}
\end{frame}

\begin{frame}{Main Failure: test\_bug\_injected\_copy\_corruption(0,0,0)}
    \begin{alertblock}{Test Failed}
        test\_bug\_injected\_copy\_corruption(0,0,0): FAILED
    \end{alertblock}
    
    \begin{block}{What This Means}
        \begin{itemize}
            \item Inputs: log=0, sqrt=0, sqrtInverse=0
            \item Copy routine corrupts memory
            \item This is exactly what the injected bug was meant to test
        \end{itemize}
    \end{block}
    
    \begin{alertblock}{Significance}
        \begin{itemize}
            \item Corruption invariant is correctly written
            \item Echidna found the breaking sequence
            \item Fuzz harness is working correctly
        \end{itemize}
    \end{alertblock}
\end{frame}

\begin{frame}{Why Other Injected Bugs Passed}
    \begin{block}{Important Fuzzing Principle}
        Passing does NOT mean bug absent. Failing ALWAYS means bug exists.
    \end{block}
    
    \begin{block}{Reasons Other Bugs Were Not Triggered}
        \begin{itemize}
            \item Triggering condition may require rare alignment
            \item Property condition may be weak
            \item Corpus not yet evolved toward that state
            \item Invariant may be logically hard to violate
        \end{itemize}
    \end{block}
    
    \begin{alertblock}{Key Insight}
        Fuzzers almost always discover boundary values (0, 1, max) first.
    \end{alertblock}
\end{frame}

\begin{frame}{PriceTestWithBug Interpretation}
    \begin{block}{Professional Fuzzing Mindset}
        \begin{columns}
            \column{0.5\textwidth}
            \begin{block}{Normal Tests}
                All invariants should PASS
            \end{block}
            
            \column{0.5\textwidth}
            \begin{block}{Injected-Bug Tests}
                At least one invariants (assert conditions) must FAIL
            \end{block}
        \end{columns}
    \end{block}
    
    \begin{alertblock}{Result Summary}
        1 failed $\rightarrow$ fuzz harness confirmed working
    \end{alertblock}
\end{frame}

%=================================================================================
% SECTION 6: CALLDATA LIBRARY AND TESTING
%=================================================================================
\section{Calldata Library Testing}

\begin{frame}{Calldata.sol - Source Code}
    \begin{block}{Source File}
        \url{https://github.com/Muthres-1/LiatRepo/contracts/utilities/Calldata.sol}
    \end{block}
    
    \begin{block}{Purpose}
        Utilities for calldata manipulation and hook data handling
    \end{block}
    
    \begin{block}{Key Functions}
        \begin{itemize}
            \item Helper functions for calldata parsing
            \item Hook data extraction
            \item Memory pointer management
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{CalldataTest.sol - Test Contract}
    \begin{block}{Source File}
        \url{https://github.com/Muthres-1/LiatRepoe/echidna/CalldataTest.sol}
    \end{block}
    
    \begin{block}{Purpose}
        Echidna tests for Calldata.sol utilities
    \end{block}
    
    \begin{block}{Test Functions}
        \begin{itemize}
            \item testFuzzed - Random calldata generation
            \item testRandomHookOffset - Variable offset testing
            \item testRandomHookSize - Variable size testing
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{CalldataTestWithBug.sol - Bug Injection Tests}
    \begin{block}{Source File}
        \url{https://github.com/Muthres-1/LiatRepo/echidna/CalldataTestWithBug.sol}
    \end{block}
    
    \begin{block}{Purpose}
        Test contract with intentionally injected calldata bugs
    \end{block}
    
    \begin{block}{Injected Bug Tests}
        \begin{itemize}
            \item testFuzzedWithBug - Wrong hook size constant
            \item testWithWrongPoolId - Incorrect pool ID
            \item testWithWrongHookPointer - Incorrect hook pointer
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{CalldataTest Configuration}
    \lstset{
        language=yaml,
        backgroundcolor=\color{codebg},
        basicstyle=\ttfamily\small,
        keywordstyle=\color{blue},
        commentstyle=\color{comment},
        stringstyle=\color{string},
        frame=single,
        numbers=left,
        numberstyle=\tiny,
        numbersep=5pt,
        tabsize=2,
        breaklines=true,
        caption={echidna.config.Calldata.yml},
        captionpos=b
    }
    \begin{center}
        \begin{tabular}{p{0.9\textwidth}}
            corpusDir: './corpus/' \\
            testMode: 'assertion' \\
            coverage: true \\
            solcArgs: '--evm-version cancun --optimize-runs 200 --via-ir' \\
            testLimit: 10000 \\
            shrinkLimit: 10000 \\
            propMaxGas: 0xffffffffffffffff \\
            testMaxGas: 0xffffffffffffffff \\
            codeSize: 0x60000000 \\
            seqLen: 100 \\
            timeout: 300000 \\
        \end{tabular}
    \end{center}
\end{frame}

%=================================================================================
% SECTION 7: CALLDATA TEST RESULTS
%=================================================================================
\section{CalldataTest Results}

\begin{frame}{CalldataTest Execution - 10,000 Tests}
    \begin{block}{Command}
        \begin{center}
            \texttt{/usr/local/bin/echidna echidna/CalldataTest.sol --contract CalldataTest --config echidna/echidna.config.Calldata.yml}
        \end{center}
    \end{block}
    
    \begin{columns}
        \column{0.5\textwidth}
        \begin{block}{Statistics}
            \begin{itemize}
                \item Compilation: 5.08s
                \item Slither: 8.73s
                \item Unique instructions: 4326
                \item Corpus size: 10
                \item Total calls: 10185
                \item Seed: 5382792802901770041
            \end{itemize}
        \end{block}
        
        \column{0.5\textwidth}
        \begin{block}{Test Results - All Passing}
            \begin{itemize}
                \item testArbitraryHookPosition: PASSING
                \item testVaryingHookSize: PASSING
                \item testFuzzed: PASSING
                \item wrapper(): PASSING
                \item AssertionFailed(..): PASSING
            \end{itemize}
        \end{block}
    \end{columns}
\textbf{5/5 tests passing. No failures detected.}
\end{frame}

\begin{frame}{CalldataTest Execution - 100,000 Tests}
    \begin{block}{Command}
        \begin{center}
            \texttt{/usr/local/bin/echidna echidna/CalldataTest.sol --contract CalldataTest --config echidna/echidna.config.Calldata.yml}
        \end{center}
    \end{block}
    
    \begin{columns}
        \column{0.5\textwidth}
        \begin{block}{Statistics}
            \begin{itemize}
                \item Compilation: 1.70s
                \item Slither: 2.91s
                \item Unique instructions: 4329
                \item Corpus size: 9
                \item Total calls: 100137
                \item Seed: 4830870414803781280
            \end{itemize}
        \end{block}
        
        \column{0.5\textwidth}
        \begin{block}{Test Results - All Passing}
            \begin{itemize}
                \item testArbitraryHookPosition: PASSING
                \item testVaryingHookSize: PASSING
                \item testFuzzed: PASSING
                \item wrapper(): PASSING
                \item AssertionFailed(..): PASSING
            \end{itemize}
        \end{block}
    \end{columns}
\textbf{5/5 tests passing. Complete coverage achieved with 100K tests.}
\end{frame}

\begin{frame}{CalldataTest Warnings Analysis}
    \begin{alertblock}{Warnings - Assertions Never Reached}
        \begin{itemize}
            \item Line 111: Assertion never reached
            \item Line 46: Assertion never reached
            \item Line 77: Assertion never reached
        \end{itemize}
    \end{alertblock}
    
    \begin{block}{Interpretation}
        \begin{itemize}
            \item These assertions are inside successful call branches
            \item Echidna may not explore all paths that reach these assertions
            \item This is normal for complex calldata patterns
            \item Does not indicate bugs - just code paths not exercised
        \end{itemize}
    \end{block}
\textbf{Warning assertions are expected when some code paths are not exercised during fuzzing.}
\end{frame}

%=================================================================================
% SECTION 8: CALLDATA TEST WITH BUG RESULTS
%=================================================================================
\section{CalldataTestWithBug Results}

\begin{frame}{CalldataTestWithBug Execution - 3,858 Tests}
    \begin{block}{Command}
        \begin{center}
            \texttt{/usr/local/bin/echidna echidna/CalldataTestWithBug.sol --contract CalldataTestWithBug --config echidna/echidna.config.Calldata.yml}
        \end{center}
    \end{block}
    
    \begin{columns}
        \column{0.5\textwidth}
        \begin{block}{Statistics}
            \begin{itemize}
                \item Compilation: 2.50s
                \item Slither: 4.31s
                \item Unique instructions: 401
                \item Corpus size: 5
                \item Total calls: 3858
                \item Seed: 5386183585703962023
            \end{itemize}
        \end{block}
        
        \column{0.5\textwidth}
        \begin{block}{Test Results - All Passing}
            \begin{itemize}
                \item testFuzzedWithBug: PASSING
                \item testWithWrongHookPointer: PASSING
                \item testWithWrongPoolId: PASSING
                \item wrapper(): PASSING
                \item AssertionFailed(..): PASSING
            \end{itemize}
        \end{block}
    \end{columns}
\textbf{5/5 tests passing. No injected bugs triggered in this run.}
\end{frame}

\begin{frame}{CalldataTestWithBug Warnings Analysis}
    \begin{alertblock}{Warnings - Assertions Never Reached}
        \begin{itemize}
            \item Line 52: testFuzzedWithBug assertion never reached
            \item Line 132: testWithWrongHookPointer assertion never reached
            \item Line 90: testWithWrongPoolId assertion never reached
        \end{itemize}
    \end{alertblock}
    
    \begin{block}{Why Bugs Were Not Triggered}
        \begin{itemize}
            \item Injected bugs may require specific input combinations
            \item Hook size, pool ID, and pointer bugs need precise values
            \item Fuzzing may not have generated triggering inputs yet
            \item More test iterations may be needed
        \end{itemize}
    \end{block}
\textbf{Passing does NOT mean bug absent. Failing ALWAYS means bug exists.}
\end{frame}

\begin{frame}{CalldataTestWithBug Interpretation}
    \begin{block}{Professional Fuzzing Mindset}
        \begin{columns}
            \column{0.5\textwidth}
            \begin{block}{Normal Tests}
                All invariants should PASS
            \end{block}
            
            \column{0.5\textwidth}
            \begin{block}{Injected-Bug Tests}
                At least one invariant should FAIL
            \end{block}
        \end{columns}
    \end{block}
    
    \begin{block}{This Run Results}
        \begin{itemize}
            \item No bugs triggered in 3,858 tests
            \item This is expected - bugs need specific conditions
            \item Fuzzing campaigns often require many iterations
            \item Consider increasing test limit or modifying properties
        \end{itemize}
    \end{block}
    
    \begin{alertblock}{Recommendation}
        Run more iterations or adjust test parameters to potentially trigger injected bugs.
    \end{alertblock}
\end{frame}

%=================================================================================
% SECTION 8B: CALLDATA LIBRARY FUNCTION DESCRIPTIONS
%=================================================================================
\section{CalldataLibrary Function Descriptions}

\begin{frame}{Calldata.sol - Reader Functions Overview}
    \begin{center}
        \begin{tabular}{|l|p{0.6\textwidth}|}
            \hline
            \textbf{Function} & \textbf{Description} \\
            \hline
            \texttt{readInitializeInput()} & Reads initialize() calldata: poolId, tags, growth, kernel, curve, hookData \\
            \hline
            \texttt{readModifyPositionInput()} & Reads modifyPosition() calldata: poolId, logPriceMin/Max, shares, hookData \\
            \hline
            \texttt{readDonateInput()} & Reads donate() calldata: poolId, shares, hookData \\
            \hline
            \texttt{readModifyKernelInput()} & Reads modifyKernel() calldata: poolId, kernelCompact, hookData \\
            \hline
            \texttt{readModifyPoolGrowthPortionInput()} & Reads modifyPoolGrowthPortion() calldata: poolId, growthPortion \\
            \hline
            \texttt{readUpdateGrowthPortionsInput()} & Reads updateGrowthPortions() calldata: poolId \\
            \hline
            \texttt{readSwapInput()} & Reads swap() calldata: poolId, amount, priceLimit, zeroForOne, hookData \\
            \hline
            \texttt{readCollectInput()} & Reads collectPool/collectProtocol() calldata: poolId \\
            \hline
        \end{tabular}
    \end{center}
\end{frame}

\begin{frame}{readInitializeInput() - Detailed}
    \begin{block}{Purpose:} Reads initialize() function calldata and places in memory.
    \begin{itemize}
        \item Sets msg.sender for hook callbacks
        \item Reads unsaltedPoolId, derives poolId (at offset 0x04)
        \item Reads tag0 (offset 0x24), tag1 (offset 0x44)
        \item Reads poolGrowthPortion (offset 0x64)
        \item Reads kernelCompact from calldata pointer (offset 0x84)
        \item Reads curve from calldata pointer (offset 0xA4)
        \item Reads hookData from calldata pointer (offset 0xC4)
        \item Copies all dynamic data to memory
        \item Sets free memory pointer to end of hookData
    \end{itemize}
    \textbf{Validation:} poolId != 0, pool doesn't exist, tags in order, growth <= 1
\end{frame}

\begin{frame}{readModifyPositionInput() - Detailed}
    \begin{block}{Purpose:} Reads modifyPosition() calldata for liquidity operations.
    \begin{itemize}
        \item Sets msg.sender for hook callbacks
        \item Reads poolId (offset 0x04)
        \item Calculates log offset from poolId
        \item Reads logPriceMin (offset 0x24), applies shift, validates range
        \item Reads logPriceMax (offset 0x44), applies shift, validates range
        \item Reads shares (offset 0x64), validates int128 range, non-zero
        \item Reads hookData pointer (offset 0x84)
        \item Copies curve and hookData to memory
        \item Sets hookInputByteCount for hook execution
    \end{itemize}
    \textbf{Validation:} logPriceMin < logPriceMax, both in valid range, shares != 0
\end{frame}

\begin{frame}{readDonateInput() - Detailed}
    \begin{block}{Purpose:} Reads donate() calldata for liquidity donation.
    \begin{itemize}
        \item Sets msg.sender for hook callbacks
        \item Reads poolId (offset 0x04)
        \item Reads shares (offset 0x24), validates positive and <= int128 max
        \item Reads hookData pointer (offset 0x44)
        \item Copies hookData to memory
        \item Sets hookInputByteCount
    \end{itemize}
    \textbf{Validation:} shares > 0, shares <= int128 max
\end{frame}

\begin{frame}{readModifyKernelInput() - Detailed}
    \begin{block}{Purpose:} Reads modifyKernel() calldata for kernel updates.
    \begin{itemize}
        \item Sets msg.sender for hook callbacks
        \item Reads poolId (offset 0x04)
        \item Reads kernelCompact pointer (offset 0x24)
        \item Reads hookData pointer (offset 0x44)
        \item Copies kernelCompact from calldata to memory
        \item Expands kernelCompact to full kernel (80-bit to 512-bit breakpoints)
        \item Copies hookData to memory
        \item Sets all memory pointers
    \end{itemize}
    \textbf{Calculation:} kernel = kernelCompact  (512/80) for expansion
\end{frame}

\begin{frame}{readSwapInput() - Detailed}
    \begin{block}{Purpose:} Reads swap() calldata for token swaps.
    \begin{itemize}
        \item Sets msg.sender for hook callbacks
        \item Reads poolId (offset 0x04)
        \item Reads amountSpecified (offset 0x24), converts to X127 fixed-point
        \item Reads logPriceLimit (offset 0x44)
        \item Reads crossThreshold (upper 128 bits at offset 0x64)
        \item Reads zeroForOne (upper 128 bits at offset 0x84), capped to 0,1,2
        \item Reads hookData pointer (offset 0xA4)
        \item Copies hookData then kernel to memory
        \item Sets hookInputByteCount for preSwap hook
    \end{itemize}
    \textbf{X127 Conversion:} amount  2^127 for fixed-point precision
\end{frame}

\begin{frame}{readCollectInput() - Detailed}
    \begin{block}{Purpose:} Reads collectPool() and collectProtocol() calldata.
    \begin{itemize}
        \item Reads function selector (offset 0x00)
        \item Reads poolId (offset 0x04)
        \item Sets free memory pointer to \_swapInput\_ location
    \end{itemize}
    \textbf{Purpose:} Minimal calldata for fee collection operations.
\end{frame}

%=================================================================================
% SECTION 8C: CALLDATATEST FUNCTION DESCRIPTIONS
%=================================================================================
\section{CalldataTest Function Descriptions}

\begin{frame}{CalldataTest - Test Functions Overview}
    \begin{center}
        \begin{tabular}{|l|p{0.6\textwidth}|}
            \hline
            \textbf{Test Function} & \textbf{Description} \\
            \hline
            \texttt{testFuzzed(seed, hookOffset, hookSize)} & Full fuzz test with random seed, offset, size \\
            \hline
            \texttt{testVaryingHookSize(seed, size)} & Tests different hook data sizes (1-256 bytes) \\
            \hline
            \texttt{testArbitraryHookPosition(seed, position)} & Tests hook data at arbitrary memory positions \\
            \hline
        \end{tabular}
    \end{center}
\end{frame}

\begin{frame}{CalldataTest - testFuzzed() Detailed}
    \begin{block}{Purpose:} Comprehensive fuzz test for modifyPosition-style calldata.
    \begin{itemize}
        \item Generates random seed for reproducibility
        \item Creates hookOffset (0-255) and hookSize (1-256)
        \item Builds complete calldata with:
            \begin{itemize}
                \item Selector: 0xc24b9ea0 (modifyPosition)
                \item PoolId: keccak(seed) with bits 180+ = 100
                \item logPriceMin: seed shifted to upper 64 bits
                \item logPriceMax: logPriceMin + 1
                \item shares: random positive int128
                \item hookPtr: 136 + hookOffset
                \item hookSize: at hookPtr
                \item hookData: random bytes of hookSize length
            \end{itemize}
        \item Calls CalldataWrapper with constructed calldata
        \item Asserts: freeMemoryPointer == HOOK\_DATA\_PLACEMENT + hookSize
    \end{itemize}
\end{frame}

\begin{frame}{CalldataTest - testVaryingHookSize() Detailed}
    \begin{block}{Purpose:} Tests memory handling across different hook sizes.
    \begin{itemize}
        \item Generates size (1-256 bytes)
        \item Creates calldata with fixed hook offset (168)
        \item Builds modifyPosition-style calldata:
            \begin{itemize}
                \item Static params: selector, poolId, logPriceMin/Max, shares
                \item hookPtr: 168 (points to size slot)
                \item hookSize: at offset 168
                \item hookData: at offset 200, length = size
            \end{itemize}
        \item Calls CalldataWrapper
        \item Asserts: freeMemoryPointer updates correctly with size
    \end{itemize}
    \textbf{Edge Cases Tested:} size=1, size=256, size=32, size=128
\end{frame}

\begin{frame}{CalldataTest - testArbitraryHookPosition() Detailed}
    \begin{block}{Purpose:} Tests hook data placement at arbitrary positions.
    \begin{itemize}
        \item Generates position (0-512)
        \item Creates hookPtr = 136 + position
        \item Builds calldata with variable hook location:
            \begin{itemize}
                \item Static params occupy first 136 bytes
                \item hookPtr stored at offset 132
                \item hookSize: 64 bytes at hookPtr
                \item hookData: 64 bytes at hookPtr+32
            \end{itemize}
        \item Calls CalldataWrapper
        \item Asserts: freeMemoryPointer reflects actual hook placement
    \end{itemize}
    \textbf{Tests:} Boundary positions, alignment, overflow handling
\end{frame}

%=================================================================================
% SECTION 8D: CALLDATATESTWITHBUG FUNCTION DESCRIPTIONS
%=================================================================================
\section{CalldataTestWithBug Function Descriptions}

\begin{frame}{CalldataTestWithBug - Overview}
    \begin{alertblock}{Purpose}
        Contains deliberately injected bugs to verify Echidna effectiveness.
    \end{alertblock}
    
    \begin{center}
        \begin{tabular}{|l|p{0.6\textwidth}|}
            \hline
            \textbf{Test Function} & \textbf{Description} \\
            \hline
            \texttt{testFuzzedWithBug(seed, hookOffset, hookSize)} & Wrong constant in assertion (+1 instead of +hookSize) \\
            \hline
            \texttt{testWithWrongPoolId(seed, hookSize)} & Pool ID uses 99 instead of 100 at bits 180+ \\
            \hline
            \texttt{testWithWrongHookPointer(seed, hookOffset, size)} & Hook pointer is off by 1 byte (+1 error) \\
            \hline
        \end{tabular}
    \end{center}
\end{frame}

\begin{frame}{CalldataTestWithBug - Detailed Descriptions}
    \begin{block}{testFuzzedWithBug(seed, hookOffset, hookSize)}
        \textbf{Purpose:} Tests assertion with incorrect expected value.
        \begin{itemize}
            \item Builds valid modifyPosition calldata
            \item Calls CalldataWrapper
            \item Bug: Asserts \texttt{fmp == HOOK\_DATA\_PLACEMENT + 1} instead of \texttt{+ hookSize}
            \item Should fail when hookSize > 1
        \end{itemize}
    \end{block}
    
    \begin{block}{testWithWrongPoolId(seed, hookSize)}
        \textbf{Purpose:} Tests pool ID validation.
        \begin{itemize}
            \item Builds calldata with wrong poolId (99 at bits 180+)
            \item Calls CalldataWrapper
            \item Bug: Pool ID validation may not catch this specific value
            \item Expected: Validation should fail or wrapper handles it
        \end{itemize}
    \end{block}
    
    \begin{block}{testWithWrongHookPointer(seed, hookOffset, rawHookSize)}
        \textbf{Purpose:} Tests hook pointer arithmetic.
        \begin{itemize}
            \item Creates hookPtr = 137 + hookOffset (off by 1)
            \item Stores wrongHookPtr at offset 132
            \item Writes size and data at wrong location
            \item Bug: CalldataWrapper reads from wrong location
            \item Should cause memory corruption or assertion failure
        \end{itemize}
    \end{block}
\end{frame}

%=================================================================================
% SECTION 9: CODE FIXES
%=================================================================================
\section{Code Fixes Summary}

\begin{frame}{Issue 1: Command Execution}
    \begin{alertblock}{Initial Command That Did Not Work}
        echidna-test --config echidna/echidna.config.Calldata.yml --contract CalldataTest echidna/CalldataTest.sol --corpus-dir ./corpus
    \end{alertblock}
    
    \begin{block}{Root Causes}
        \begin{itemize}
            \item echidna-test is not in PATH
            \item Need to use full path: /usr/local/bin/echidna
            \item Wrong command name: should be echidna
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Issue 2: Shadowed Type Definitions}
    \begin{columns}
        \column{0.5\textwidth}
        \begin{block}{Before}
            uint256 epsilon = ...;
        \end{block}
        
        \column{0.5\textwidth}
        \begin{block}{After}
            epsilonX216 from X216.sol
        \end{block}
    \end{columns}
    
    \begin{alertblock}{Solution}
        Removed shadowed constants and used library-defined epsilonX216.
    \end{alertblock}
\end{frame}

\begin{frame}{Issue 3: Type Conversion Fixes}
    \begin{block}{Fix Applied}
        \begin{center}
            \begin{tabular}{p{0.9\textwidth}}
                int256 maxValue = X216.unwrap(oneX216) - X216.unwrap(epsilonX216); \\
                X216.wrap(int256(uint256(seedSqrt) \% uint256(maxValue))); \\
            \end{tabular}
        \end{center}
    \end{block}
\end{frame}

\begin{frame}{Issue 4: Hex Literals Fix}
    \begin{columns}
        \column{0.5\textwidth}
        \begin{block}{Before (Invalid)}
            uint256 beforePattern = 0xAAAAAAAAAAAAAAAA...;
        \end{block}
        
        \column{0.5\textwidth}
        \begin{block}{After (Fixed)}
            uint256 beforePattern = 0xABABABABABABABABABABABABABABABAB;
        \end{block}
    \end{columns}
    
    \begin{alertblock}{Solution}
        Reduced hex literals to fit within uint256 range.
    \end{alertblock}
\end{frame}

\begin{frame}{Issue 5: assert(iszero()) Syntax Fix}
    \begin{columns}
        \column{0.5\textwidth}
        \begin{block}{Before (Invalid)}
            assert(iszero(corrupted));
        \end{block}
        
        \column{0.5\textwidth}
        \begin{block}{After (Fixed)}
            assert(!corrupted);
        \end{block}
    \end{columns}
    
    \begin{alertblock}{Reason}
        Solidity 0.8.x requires proper boolean expressions in assertions.
    \end{alertblock}
\end{frame}

%=================================================================================
% SECTION 10: QUICK REFERENCE
%=================================================================================
\section{Quick Reference}

\begin{frame}{Essential Commands}
    \begin{center}
        \begin{tabular}{|l|l|}
            \hline
            Command & Description \\
            \hline
            /root/.crytic/bin/solc --version & Check solc version \\
            \hline
            /usr/local/bin/echidna --version & Check echidna version \\
            \hline
            cd /home/training & Go to project root \\
            \hline
            echidna PriceTest.sol --contract PriceTest --config echidna/echidna.config.Price.yml & Run Price tests \\
            \hline
            echidna PriceTestWithBug.sol --contract PriceTestWithBug --config echidna/echidna.simple.yaml & Run tests with bugs \\
            \hline
            echidna CalldataTest.sol --contract CalldataTest --config echidna/echidna.config.Calldata.yml & Run Calldata tests \\
            \hline
        \end{tabular}
    \end{center}
\end{frame}

\begin{frame}{Common Issues and Fixes}
    \begin{center}
        \begin{tabular}{|p{0.4\textwidth}|p{0.5\textwidth}|}
            \hline
            Error & Fix \\
            \hline
            echidna-test not found & Use /usr/local/bin/echidna \\
            \hline
            solc-select 403 Forbidden & Install solc manually with wget \\
            \hline
            pragma solidity \^{}0.8.28 required & Install solc 0.8.28 \\
            \hline
            Source not found & Run from /home/training \\
            \hline
            ABI is empty & Specify --contract ContractName \\
            \hline
        \end{tabular}
    \end{center}
\end{frame}

%=================================================================================
% SECTION 11: CONCLUSION
%=================================================================================
\section{Conclusion}

\begin{frame}{Summary of All Test Results}
    \begin{columns}
        \column{0.5\textwidth}
        \begin{block}{PriceTest}
            \begin{itemize}
                \item 100,151 tests executed
                \item 9 passing, 2 failed
                \item 1 test bug discovered
                \item 1 real vulnerability found
            \end{itemize}
        \end{block}
        
        \column{0.5\textwidth}
        \begin{block}{PriceTestWithBug}
            \begin{itemize}
                \item 1 bug successfully triggered
                \item Fuzz harness verified working
            \end{itemize}
        \end{block}
    \end{columns}
    
    \begin{columns}
        \column{0.5\textwidth}
        \begin{block}{CalldataTest}
            \begin{itemize}
                \item 100,137 tests executed
                \item 5/5 tests passing
                \item Complete coverage achieved
            \end{itemize}
        \end{block}
        
        \column{0.5\textwidth}
        \begin{block}{CalldataTestWithBug}
            \begin{itemize}
                \item 3,858 tests executed
                \item 5/5 tests passing
                \item No bugs triggered (expected)
            \end{itemize}
        \end{block}
    \end{columns}
\end{frame}

\begin{frame}{Key Achievements}
    \begin{alertblock}{What We Accomplished}
        \begin{itemize}
            \item Discovered real memory safety issue in Price.sol
            \item Verified fuzz harness correctness
            \item Identified and fixed test bugs
            \item 200,000+ total fuzz tests executed
            \item Complete coverage analysis for Calldata
        \end{itemize}
    \end{alertblock}
    
    \begin{block}{Important Insights}
        \begin{itemize}
            \item Passing fuzz tests does NOT mean bug-free
            \item Failing tests ALWAYS indicate issues
            \item Boundary values (0, 1, max) trigger most bugs
            \item Warning assertions indicate unexplored code paths
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Future Work}
    \begin{block}{Recommended Next Steps}
        \begin{itemize}
            \item Fix memory corruption in Price.sol storePrice with height
            \item Implement masked write for height storage
            \item Increase test limits for CalldataTestWithBug
            \item Add more property-based tests
            \item Explore unreached assertion paths
        \end{itemize}
    \end{block}
    
    \begin{center}
        \textbf{Thank You!}
        
        \vspace{5mm}
        \url{https://github.com/Muthres-1/LiatRepo}
        
        \vspace{5mm}
        Echidna 2.2.7 | Solidity 0.8.28
    \end{center}
\end{frame}

\end{document}
